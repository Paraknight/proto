{"version":3,"sources":["webpack:///proto.min.js","webpack:///webpack/bootstrap 6e07bdf12b4c2ae4d8f6","webpack:///./proto.ls","webpack:////home/amar/misc/Dropbox/projects/home/proto/src/core/game.ls","webpack:////home/amar/misc/Dropbox/projects/home/proto/src/core/scene.ls","webpack:////home/amar/misc/Dropbox/projects/home/proto/src/gfx/renderer.ls","webpack:////home/amar/misc/Dropbox/projects/home/proto/src/gfx/style/clear.styl?8f33","webpack:////home/amar/misc/Dropbox/projects/home/proto/src/gfx/style/clear.styl","webpack:////home/amar/misc/Dropbox/projects/home/proto/~/css-loader/lib/css-base.js","webpack:////home/amar/misc/Dropbox/projects/home/proto/~/style-loader/addStyles.js","webpack:////home/amar/misc/Dropbox/projects/home/proto/src/gfx/style/standard.styl?14cd","webpack:////home/amar/misc/Dropbox/projects/home/proto/src/gfx/style/standard.styl","webpack:////home/amar/misc/Dropbox/projects/home/proto/~/three/three.js","webpack:////home/amar/misc/Dropbox/projects/home/proto/src/core/entity.ls","webpack:///(webpack)/~/node-libs-browser/~/events/events.js"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","id","loaded","call","m","c","p","Game","Renderer","game","renderer","Scene","out$","this","config","scene","console","log","displayName","prototype","extend$","sub","sup","fun","superclass","constructor","extended","import$","obj","src","own","hasOwnProperty","key","Entity","addChild","it","apply","arguments","emit","removeChild","clear","standard","three","x$","self","y$","render","threeRenderer","WebGLRenderer","antialias","setSize","window","innerWidth","innerHeight","shadowMapEnabled","shadowMapSoft","sortObjects","addEventListener","camera","aspect","updateProjectionMatrix","PerspectiveCamera","position","z","geometry","BoxGeometry","material","MeshBasicMaterial","color","wireframe","mesh","Mesh","add","domElement","document","body","appendChild","requestAnimationFrame","rotation","x","y","content","locals","push","list","toString","result","i","length","item","join","mediaQuery","alreadyImportedModules","addStylesToDom","styles","options","domStyle","stylesInDom","refs","j","parts","addStyle","listToStyles","newStyles","css","media","sourceMap","part","createStyleElement","styleElement","createElement","head","getHeadElement","type","createLinkElement","linkElement","rel","update","remove","singleton","styleIndex","singletonCounter","singletonElement","applyToSingletonTag","bind","URL","createObjectURL","revokeObjectURL","Blob","btoa","updateLink","parentNode","href","applyToTag","newObj","index","styleSheet","cssText","replaceText","cssNode","createTextNode","childNodes","insertBefore","setAttribute","firstChild","unescape","encodeURIComponent","JSON","stringify","blob","oldSrc","memoize","fn","memo","isOldIE","test","navigator","userAgent","toLowerCase","getElementsByTagName","Error","newList","mayRemove","textStore","replacement","filter","Boolean","THREE","REVISION","undefined","Math","sign","warn","error","MOUSE","LEFT","MIDDLE","RIGHT","CullFaceNone","CullFaceBack","CullFaceFront","CullFaceFrontBack","FrontFaceDirectionCW","FrontFaceDirectionCCW","BasicShadowMap","PCFShadowMap","PCFSoftShadowMap","FrontSide","BackSide","DoubleSide","NoShading","FlatShading","SmoothShading","NoColors","FaceColors","VertexColors","NoBlending","NormalBlending","AdditiveBlending","SubtractiveBlending","MultiplyBlending","CustomBlending","AddEquation","SubtractEquation","ReverseSubtractEquation","MinEquation","MaxEquation","ZeroFactor","OneFactor","SrcColorFactor","OneMinusSrcColorFactor","SrcAlphaFactor","OneMinusSrcAlphaFactor","DstAlphaFactor","OneMinusDstAlphaFactor","DstColorFactor","OneMinusDstColorFactor","SrcAlphaSaturateFactor","MultiplyOperation","MixOperation","AddOperation","UVMapping","CubeReflectionMapping","CubeRefractionMapping","EquirectangularReflectionMapping","EquirectangularRefractionMapping","SphericalReflectionMapping","RepeatWrapping","ClampToEdgeWrapping","MirroredRepeatWrapping","NearestFilter","NearestMipMapNearestFilter","NearestMipMapLinearFilter","LinearFilter","LinearMipMapNearestFilter","LinearMipMapLinearFilter","UnsignedByteType","ByteType","ShortType","UnsignedShortType","IntType","UnsignedIntType","FloatType","HalfFloatType","UnsignedShort4444Type","UnsignedShort5551Type","UnsignedShort565Type","AlphaFormat","RGBFormat","RGBAFormat","LuminanceFormat","LuminanceAlphaFormat","RGBEFormat","RGB_S3TC_DXT1_Format","RGBA_S3TC_DXT1_Format","RGBA_S3TC_DXT3_Format","RGBA_S3TC_DXT5_Format","RGB_PVRTC_4BPPV1_Format","RGB_PVRTC_2BPPV1_Format","RGBA_PVRTC_4BPPV1_Format","RGBA_PVRTC_2BPPV1_Format","Projector","projectVector","vector","project","unprojectVector","unproject","pickingRay","CanvasRenderer","setClearColor","Color","setRGB","set","r","g","b","value","copy","setHex","setStyle","hex","floor","setHSL","h","s","l","hue2rgb","q","t","style","exec","min","parseInt","ColorKeywords","copyGammaToLinear","gammaFactor","pow","copyLinearToGamma","safeInverse","convertGammaToLinear","convertLinearToGamma","sqrt","getHex","getHexString","slice","getHSL","optionalTarget","hue","saturation","hsl","max","lightness","delta","getStyle","offsetHSL","addColors","color1","color2","addScalar","multiply","multiplyScalar","lerp","alpha","equals","fromArray","array","toArray","offset","clone","aliceblue","antiquewhite","aqua","aquamarine","azure","beige","bisque","black","blanchedalmond","blue","blueviolet","brown","burlywood","cadetblue","chartreuse","chocolate","coral","cornflowerblue","cornsilk","crimson","cyan","darkblue","darkcyan","darkgoldenrod","darkgray","darkgreen","darkgrey","darkkhaki","darkmagenta","darkolivegreen","darkorange","darkorchid","darkred","darksalmon","darkseagreen","darkslateblue","darkslategray","darkslategrey","darkturquoise","darkviolet","deeppink","deepskyblue","dimgray","dimgrey","dodgerblue","firebrick","floralwhite","forestgreen","fuchsia","gainsboro","ghostwhite","gold","goldenrod","gray","green","greenyellow","grey","honeydew","hotpink","indianred","indigo","ivory","khaki","lavender","lavenderblush","lawngreen","lemonchiffon","lightblue","lightcoral","lightcyan","lightgoldenrodyellow","lightgray","lightgreen","lightgrey","lightpink","lightsalmon","lightseagreen","lightskyblue","lightslategray","lightslategrey","lightsteelblue","lightyellow","lime","limegreen","linen","magenta","maroon","mediumaquamarine","mediumblue","mediumorchid","mediumpurple","mediumseagreen","mediumslateblue","mediumspringgreen","mediumturquoise","mediumvioletred","midnightblue","mintcream","mistyrose","moccasin","navajowhite","navy","oldlace","olive","olivedrab","orange","orangered","orchid","palegoldenrod","palegreen","paleturquoise","palevioletred","papayawhip","peachpuff","peru","pink","plum","powderblue","purple","red","rosybrown","royalblue","saddlebrown","salmon","sandybrown","seagreen","seashell","sienna","silver","skyblue","slateblue","slategray","slategrey","snow","springgreen","steelblue","tan","teal","thistle","tomato","turquoise","violet","wheat","white","whitesmoke","yellow","yellowgreen","Quaternion","w","_x","_y","_z","_w",{"end":{"file":"proto.min.js","comments_before":[],"nlb":false,"endpos":33339,"endcol":7,"endline":1221,"pos":33338,"col":6,"line":1221,"value":"x","type":"name","_comments_dumped":true},"start":{"file":"proto.min.js","comments_before":[],"nlb":false,"endpos":33339,"endcol":7,"endline":1221,"pos":33338,"col":6,"line":1221,"value":"x","type":"name","_comments_dumped":true},"name":"x"},"onChangeCallback","quaternion","setFromEuler","euler","Euler","c1","cos","c2","c3","s1","sin","s2","s3","order","setFromAxisAngle","axis","angle","halfAngle","setFromRotationMatrix","te","elements","m11","m12","m13","m21","m22","m23","m31","m32","m33","trace","setFromUnitVectors","v1","EPS","vFrom","vTo","Vector3","dot","abs","crossVectors","normalize","inverse","conjugate","v","lengthSq","multiplyQuaternions","a","qax","qay","qaz","qaw","qbx","qby","qbz","qbw","multiplyVector3","applyQuaternion","slerp","qb","cosHalfTheta","halfTheta","acos","sinHalfTheta","ratioA","ratioB","onChange","callback","qa","qm","Vector2","setX","setY","setComponent","getComponent","addVectors","subVectors","subScalar","divide","divideScalar","scalar","invScalar","clamp","clampScalar","minVal","maxVal","ceil","round","roundToZero","negate","distanceTo","distanceToSquared","dx","dy","setLength","oldLength","lerpVectors","v2","fromAttribute","attribute","itemSize","setZ","multiplyVectors","applyEuler","applyAxisAngle","applyMatrix3","e","applyMatrix4","applyProjection","d","qx","qy","qz","qw","ix","iy","iz","iw","matrix","Matrix4","multiplyMatrices","projectionMatrix","getInverse","matrixWorld","transformDirection","lengthManhattan","cross","ax","ay","az","bx","by","bz","projectOnVector","projectOnPlane","planeNormal","reflect","normal","angleTo","theta","dz","setEulerFromRotationMatrix","setEulerFromQuaternion","getPositionFromMatrix","setFromMatrixPosition","getScaleFromMatrix","setFromMatrixScale","getColumnFromMatrix","setFromMatrixColumn","sx","sy","sz","me","Vector4","setW","setAxisAngleFromQuaternion","setAxisAngleFromRotationMatrix","epsilon","epsilon2","PI","xx","yy","zz","xy","xz","yz","_order","DefaultOrder","RotationOrders","asin","atan2","setFromQuaternion","makeRotationFromQuaternion","setFromVector3","reorder","newOrder","toVector3","optionalResult","Line3","start","end","line","center","distanceSq","distance","at","closestPointToPointParameter","startP","startEnd","point","clampToLine","startEnd2","startEnd_startP","closestPointToPoint","Box2","Infinity","setFromPoints","points","makeEmpty","il","expandByPoint","setFromCenterAndSize","size","halfSize","box","empty","expandByVector","expandByScalar","containsPoint","containsBox","getParameter","isIntersectionBox","clampPoint","distanceToPoint","clampedPoint","intersect","union","translate","Box3","setFromObject","object","scope","updateMatrixWorld","traverse","node","Geometry","vertices","BufferGeometry","attributes","positions","getBoundingSphere","Sphere","radius","Matrix3","Float32Array","n11","n12","n13","n21","n22","n23","n31","n32","n33","identity","multiplyVector3Array","applyToVector3Array","determinant","f","throwOnInvertible","det","msg","transpose","tmp","flattenToArrayOffset","getNormalMatrix","transposeIntoArray","n14","n24","n34","n41","n42","n43","n44","extractPosition","copyPosition","extractBasis","xAxis","yAxis","zAxis","makeBasis","extractRotation","scaleX","scaleY","scaleZ","makeRotationFromEuler","ae","af","be","bf","ce","cf","de","df","ac","ad","bc","bd","setRotationFromQuaternion","x2","y2","z2","wx","wy","wz","lookAt","eye","target","up","n","a11","a12","a13","a14","a21","a22","a23","a24","a31","a32","a33","a34","a41","a42","a43","a44","b11","b12","b13","b14","b21","b22","b23","b24","b31","b32","b33","b34","b41","b42","b43","b44","multiplyToArray","multiplyVector4","rotateAxis","crossVector","getPosition","setPosition","rotateX","rotateY","rotateZ","rotateByAxis","scale","getMaxScaleOnAxis","scaleXSq","scaleYSq","scaleZSq","makeTranslation","makeRotationX","makeRotationY","makeRotationZ","makeRotationAxis","tx","ty","makeScale","compose","decompose","invSX","invSY","invSZ","makeFrustum","left","right","bottom","top","near","far","makePerspective","fov","ymax","degToRad","ymin","xmin","xmax","makeOrthographic","Ray","origin","direction","ray","recast","directionDistance","distanceSqToSegment","segCenter","segDir","diff","v0","optionalPointOnRay","optionalPointOnSegment","s0","sqrDist","extDet","segExtent","a01","b0","b1","invDet","isIntersectionSphere","sphere","intersectSphere","tca","d2","radius2","thc","t0","t1","isIntersectionPlane","plane","distToPoint","denominator","distanceToPlane","constant","intersectPlane","intersectBox","tmin","tmax","tymin","tymax","tzmin","tzmax","invdirx","invdiry","invdirz","intersectTriangle","edge1","edge2","backfaceCulling","DdN","DdQxE2","DdE1xQ","QdN","matrix4","optionalCenter","maxRadiusSq","intersectsSphere","radiusSum","deltaLengthSq","getBoundingBox","Frustum","p0","p1","p2","p3","p4","p5","planes","Plane","frustum","setFromMatrix","me0","me1","me2","me3","me4","me5","me6","me7","me8","me9","me10","me11","me12","me13","me14","me15","setComponents","intersectsObject","boundingSphere","computeBoundingSphere","negRadius","intersectsBox","d1","setFromNormalAndCoplanarPoint","setFromCoplanarPoints","inverseNormalLength","distanceToSphere","projectPoint","orthoPoint","perpendicularMagnitude","isIntersectionLine","startSign","endSign","intersectLine","coplanarPoint","m1","optionalNormalMatrix","normalMatrix","newNormal","newCoplanarPoint","generateUUID","chars","split","uuid","Array","rnd","random","clampBottom","mapLinear","a1","a2","b2","smoothstep","smootherstep","random16","randInt","low","high","randFloat","randFloatSpread","range","degreeToRadiansFactor","degrees","radToDeg","radianToDegreesFactor","radians","isPowerOfTwo","nextPowerOfTwo","Spline","interpolate","t2","t3","intPoint","weight","w2","w3","pa","pb","pc","pd","v3","initFromArray","getPoint","k","getControlPointsArray","coords","getLength","nSubDivisions","nSamples","oldIntPoint","oldPosition","tmpVec","chunkLengths","totalLength","chunks","total","reparametrizeByArcLength","samplingCoef","indexCurrent","indexNext","realDistance","sampling","newpoints","sl","Triangle","resultLengthSq","barycoordFromPoint","dot00","dot01","dot02","dot11","dot12","denom","invDenom","u","setFromPointsAndIndices","i0","i1","i2","triangle","area","midpoint","Clock","autoStart","startTime","oldTime","elapsedTime","running","performance","now","Date","stop","getElapsedTime","getDelta","newTime","EventDispatcher","hasEventListener","removeEventListener","dispatchEvent","listener","_listeners","listeners","indexOf","listenerArray","splice","event","Raycaster","params","Sprite","PointCloud","threshold","LOD","Line","descSort","intersectObject","raycaster","intersects","recursive","raycast","children","precision","linePrecision","setFromCamera","OrthographicCamera","sort","intersectObjects","objects","Object3D","Object","defineProperty","Object3DIdCount","name","parent","DefaultUp","onRotationChange","onQuaternionChange","defineProperties","enumerable","rotationAutoUpdate","matrixAutoUpdate","matrixWorldNeedsUpdate","visible","castShadow","receiveShadow","frustumCulled","renderOrder","userData","eulerOrder","useQuaternion","applyMatrix","setRotationFromAxisAngle","setRotationFromEuler","setRotationFromMatrix","rotateOnAxis","q1","translateOnAxis","translateX","translateY","translateZ","localToWorld","worldToLocal","getChildByName","getObjectByName","getObjectById","getObjectByProperty","child","getWorldPosition","getWorldQuaternion","getWorldRotation","getWorldScale","getWorldDirection","traverseVisible","traverseAncestors","updateMatrix","force","toJSON","output","metadata","version","generator","geometries","parseGeometry","json","materials","parseMaterial","parseObject","data","AmbientLight","DirectionalLight","intensity","PointLight","decay","SpotLight","exponent","HemisphereLight","groundColor","mode","parse","Face3","materialIndex","vertexNormals","vertexColors","vertexTangents","face","Face4","BufferAttribute","needsUpdate","copyAt","index1","index2","setXY","setXYZ","setXYZW","Int8Attribute","Uint8Attribute","Uint8ClampedAttribute","Int16Attribute","Uint16Attribute","Int32Attribute","Uint32Attribute","Float32Attribute","Float64Attribute","DynamicBufferAttribute","updateRange","count","create","GeometryIdCount","attributesKeys","drawcalls","offsets","boundingBox","addAttribute","keys","getAttribute","addDrawCall","indexOffset","computeBoundingBox","fromGeometry","settings","faces","faceVertexUvs","hasFaceVertexUv","hasFaceVertexNormals","normals","colors","uvs","i3","na","nb","nc","fc","vca","vcb","vcc","uva","uvb","uvc","bb","isNaN","computeFaceNormals","computeVertexNormals","vA","vB","vC","pA","pB","pC","cb","ab","indices","jl","normalizeNormals","computeTangents","handleTriangle","uvA","uvB","uvC","x1","y1","z1","sdir","tdir","tan1","tan2","handleVertex","n2","tmp2","tangents","uv","nVertices","tangent","iA","iB","iC","computeOffsets","facesCount","sortedIndices","Uint16Array","indexPtr","vertexPtr","duplicatedVertices","newVerticeMaps","faceVertices","Int32Array","vertexMap","revVertexMap","findex","vo","vid","faceMax","new_offset","new_vid","reorderBuffers","merge","attribute1","attributeArray1","attribute2","attributeArray2","attributeSize","indexBuffer","indexMap","vertexCount","sortedAttributes","attr","sourceArray","attrArray","attrSize","sortedAttr","numItems","sourceAttr","dispose","morphTargets","morphColors","morphNormals","skinWeights","skinIndices","lineDistances","hasTangents","dynamic","verticesNeedUpdate","elementsNeedUpdate","uvsNeedUpdate","normalsNeedUpdate","tangentsNeedUpdate","colorsNeedUpdate","lineDistancesNeedUpdate","groupsNeedUpdate","vertex","fromBufferGeometry","tempNormals","tempUVs","addFace","drawcall","fl","areaWeighted","vl","computeMorphNormals","__originalFaceNormal","__originalVertexNormals","tmpGeo","faceNormals","faceNormal","dstNormalsFace","dstNormalsVertex","context","ua","ub","uc","vertexIndex","faceIndex","computeLineDistances","materialIndexOffset","vertexOffset","vertices1","vertices2","faces1","faces2","uvs1","uvs2","vertexCopy","faceCopy","faceVertexNormals","faceVertexColors","uvCopy","mergeMesh","mergeVertices","verticesMap","unique","changes","precisionPoints","faceIndicesToRemove","dupIndex","idx","setBit","enabled","getNormalIndex","hash","normalsHash","getColorIndex","colorsHash","getUvIndex","uvsHash","parameters","hasMaterial","hasFaceUv","hasFaceNormal","hasFaceVertexNormal","hasFaceColor","hasFaceVertexColor","faceType","uvsCopy","kl","Camera","matrixWorldInverse","CubeCamera","cubeResolution","cameraPX","cameraNX","cameraPY","cameraNY","cameraPZ","cameraNZ","renderTarget","WebGLRenderTargetCube","format","magFilter","minFilter","updateCubeMap","generateMipmaps","activeCubeFace","zoom","cx","cy","setLens","focalLength","frameHeight","atan","setViewOffset","fullWidth","fullHeight","width","height","Light","light","AreaLight","constantAttenuation","linearAttenuation","quadraticAttenuation","onlyShadow","shadowCameraNear","shadowCameraFar","shadowCameraLeft","shadowCameraRight","shadowCameraTop","shadowCameraBottom","shadowCameraVisible","shadowBias","shadowDarkness","shadowMapWidth","shadowMapHeight","shadowCascade","shadowCascadeOffset","shadowCascadeCount","shadowCascadeBias","shadowCascadeWidth","shadowCascadeHeight","shadowCascadeNearZ","shadowCascadeFarZ","shadowCascadeArray","shadowMap","shadowMapSize","shadowCamera","shadowMatrix","skyColor","shadowCameraFov","Cache","files","file","get","Loader","showStatus","statusDomElement","addStatusElement","imageLoader","ImageLoader","onLoadStart","onLoadProgress","onLoadComplete","crossOrigin","fontSize","textAlign","background","padding","zIndex","innerHTML","updateProgress","progress","message","toFixed","extractUrlBase","url","pop","initMaterials","texturePath","createMaterial","needsTangents","ShaderMaterial","nearest_pow2","LN2","create_texture","where","sourceFile","repeat","wrap","anisotropy","texture","fullPath","loader","Handlers","load","Texture","image","canvas","getContext","drawImage","wrapS","wrapT","wrapMap","mirror","rgb2hex","rgb","mtype","mpars","opacity","map","lightMap","normalMap","bumpMap","shading","blending","transparent","depthTest","depthWrite","flipSided","side","doubleSided","colorDiffuse","DbgColor","colorSpecular","specular","colorEmissive","emissive","transparency","specularCoef","shininess","mapDiffuse","mapDiffuseRepeat","mapDiffuseOffset","mapDiffuseWrap","mapDiffuseAnisotropy","mapLight","mapLightRepeat","mapLightOffset","mapLightWrap","mapLightAnisotropy","mapBump","mapBumpRepeat","mapBumpOffset","mapBumpWrap","mapBumpAnisotropy","mapNormal","mapNormalRepeat","mapNormalOffset","mapNormalWrap","mapNormalAnisotropy","mapSpecular","mapSpecularRepeat","mapSpecularOffset","mapSpecularWrap","mapSpecularAnisotropy","mapAlpha","mapAlphaRepeat","mapAlphaOffset","mapAlphaWrap","mapAlphaAnisotropy","mapBumpScale","bumpScale","mapNormalFactor","normalScale","DbgName","handlers","regex","XHRLoader","manager","DefaultLoadingManager","onLoad","onProgress","onError","cached","request","XMLHttpRequest","open","response","itemEnd","responseType","send","itemStart","setResponseType","setCrossOrigin","JSONLoader","withCredentials","loadAjaxJSON","callbackProgress","xhr","onreadystatechange","readyState","DONE","status","responseText","LOADING","getResponseHeader","HEADERS_RECEIVED","parseModel","isBitSet","fi","zLength","colorIndex","normalIndex","uvIndex","isQuad","faceA","faceB","uvLayer","nUvLayers","parseSkin","influencesPerVertex","bones","animation","animations","parseMorphing","dstVertices","srcVertices","cl","dstColors","srcColors","LoadingManager","BufferGeometryLoader","text","typedArray","MaterialLoader","uniforms","vertexShader","fragmentShader","sizeAttenuation","ObjectLoader","substring","lastIndexOf","setTexturePath","parseGeometries","images","parseImages","textures","parseTextures","parseMaterials","geometryLoader","bufferGeometryLoader","widthSegments","heightSegments","depth","depthSegments","CircleGeometry","segments","CylinderGeometry","radiusTop","radiusBottom","radialSegments","openEnded","SphereGeometry","phiStart","phiLength","thetaStart","thetaLength","IcosahedronGeometry","detail","TorusGeometry","tube","tubularSegments","arc","TorusKnotGeometry","heightScale","getTexture","alphaMap","envMap","specularMap","loadImage","path","getGeometry","getMaterial","Group","TextureLoader","DataTextureLoader","BinaryTextureLoader","_parser","DataTexture","buffer","texData","mipmaps","mipmapCount","CompressedTextureLoader","CompressedTexture","loadTexture","texDatas","isCubemap","Material","MaterialIdCount","blendSrc","blendDst","blendEquation","blendSrcAlpha","blendDstAlpha","blendEquationAlpha","colorWrite","polygonOffset","polygonOffsetFactor","polygonOffsetUnits","alphaTest","overdraw","_needsUpdate","setValues","values","newValue","currentValue","Number","MeshLambertMaterial","MeshPhongMaterial","MeshNormalMaterial","MeshDepthMaterial","PointCloudMaterial","SpriteMaterial","LineBasicMaterial","linewidth","linecap","linejoin","fog","LineDashedMaterial","dashSize","gapSize","combine","reflectivity","refractionRatio","wireframeLinewidth","wireframeLinecap","wireframeLinejoin","skinning","wrapAround","wrapRGB","metal","MeshFaceMaterial","ParticleBasicMaterial","ParticleSystemMaterial","defines","lights","defaultAttributeValues","uv2","index0AttributeName","UniformsUtils","RawShaderMaterial","mapping","TextureIdCount","DEFAULT_IMAGE","DEFAULT_MAPPING","premultiplyAlpha","flipY","unpackAlignment","onUpdate","CubeTexture","VideoTexture","video","HAVE_ENOUGH_DATA","inverseMatrix","localThreshold","testPoint","rayPointDistance","intersectPoint","distanceToRay","oi","ol","pointCount","ParticleSystem","LineStrip","LinePieces","precisionSq","vStart","vEnd","interSegment","interRay","step","distSq","offsetIndex","nbVertices","updateMorphTargets","morphTargetBase","morphTargetForcedOrder","morphTargetInfluences","morphTargetDictionary","ml","getMorphTargetIndexByName","intersectionPoint","isFaceMaterial","objectMaterials","morphInfluences","tl","influence","targets","Bone","skin","Skeleton","boneInverses","useVertexTexture","identityMatrix","boneTextureWidth","boneTextureHeight","boneMatrices","boneTexture","calculateInverses","bl","pose","bone","offsetMatrix","SkinnedMesh","bindMode","bindMatrix","bindMatrixInverse","gbone","pos","rotq","scl","normalizeSkinWeights","skeleton","sw","MorphAnimMesh","duration","mirroredLoop","time","lastKeyframe","currentKeyframe","directionBackwards","setFrameRange","startKeyframe","endKeyframe","setDirectionForward","setDirectionBackward","parseAnimations","firstAnimation","pattern","morph","match","label","setAnimationLabel","playAnimation","fps","updateAnimation","frameTime","keyframe","mix","interpolateTargets","influences","addLevel","getObjectForDistance","matrixPosition","Particle","LensFlare","lensFlares","positionScreen","customUpdateCallback","updateLensFlares","flare","vecX","vecY","wantedRotation","overrideMaterial","autoUpdate","Fog","FogExp2","density","ShaderChunk","merged","uniforms_src","uniforms_dst","parameter_src","UniformsLib","common","diffuse","offsetRepeat","flipEnvMap","bump","normalmap","fogDensity","fogNear","fogFar","fogColor","ambientLightColor","directionalLightDirection","directionalLightColor","hemisphereLightDirection","hemisphereLightSkyColor","hemisphereLightGroundColor","pointLightColor","pointLightPosition","pointLightDistance","pointLightDecay","spotLightColor","spotLightPosition","spotLightDirection","spotLightDistance","spotLightAngleCos","spotLightExponent","spotLightDecay","particle","psColor","shadowmap","ShaderLib","basic","lambert","phong","particle_basic","dashed","totalSize","mNear","mFar","cube","tCube","tFlip","equirect","tEquirect","depthRGBA","createParticleBuffers","__webglVertexBuffer","_gl","createBuffer","__webglColorBuffer","_this","info","memory","createLineBuffers","__webglLineDistanceBuffer","createMeshBuffers","geometryGroup","__webglNormalBuffer","__webglTangentBuffer","__webglUVBuffer","__webglUV2Buffer","__webglSkinIndicesBuffer","__webglSkinWeightsBuffer","__webglFaceBuffer","__webglLineBuffer","numMorphTargets","__webglMorphTargetsBuffers","numMorphNormals","__webglMorphNormalsBuffers","initCustomAttributes","nvertices","__webglCustomAttributesList","__webglInitialized","createUniqueBuffers","belongsToAttribute","initParticleBuffers","__vertexArray","__colorArray","__webglParticleCount","initLineBuffers","__lineDistanceArray","__webglLineCount","initMeshBuffers","faces3","ntris","nlines","getBufferMaterial","__normalArray","__uvArray","__uv2Array","__tangentArray","__skinIndexArray","__skinWeightArray","UintArray","extensions","Uint32Array","__typeArray","__faceArray","__lineArray","__morphTargetsArrays","__morphNormalsArrays","__webglFaceCount","originalAttribute","property","__original","__inittedArrays","materialNeedsFaceNormals","setParticleBuffers","hint","ca","cal","customAttribute","vertexArray","colorArray","dirtyVertices","dirtyColors","customAttributes","bindBuffer","ARRAY_BUFFER","bufferData","boundTo","setLineBuffers","dl","lineDistanceArray","dirtyLineDistances","setMeshBuffers","faceColor","n1","n3","sw1","sw2","sw3","si1","si2","si3","vn","uvi","uv2i","vk","vkl","vka","nka","chf","needsFaceNormals","offset_uv","offset_uv2","offset_face","offset_normal","offset_tangent","offset_line","offset_color","offset_skin","offset_morphTarget","offset_custom","uvArray","uv2Array","normalArray","tangentArray","skinIndexArray","skinWeightArray","morphTargetsArrays","morphNormalsArrays","faceArray","lineArray","dirtyElements","dirtyUvs","dirtyNormals","dirtyTangents","dirtyMorphTargets","morphTargetsNeedUpdate","chunk_faces3","obj_faces","obj_uvs","obj_uvs2","obj_skinIndices","obj_skinWeights","ELEMENT_ARRAY_BUFFER","pp","setupVertexAttributes","program","startIndex","geometryAttributes","programAttributes","programAttributesKeys","programAttribute","geometryAttribute","state","enableAttribute","vertexAttribPointer","FLOAT","vertexAttrib2fv","vertexAttrib3fv","disableUnusedAttributes","setupMorphTargets","numSupportedMorphTargets","__webglMorphTargetInfluences","activeInfluenceIndices","numericalSort","numSupportedMorphNormals","influenceIndex","uniform1fv","painterSortStable","reversePainterSortStable","projectObject","initObject","sprites","webglObjects","_webglObjects","_frustum","webglObject","unrollBufferMaterial","_vector3","_projScreenMatrix","renderObjects","renderList","setupMatrices","setMaterial","setMaterialFaces","renderBufferDirect","renderBuffer","renderObjectsImmediate","materialType","renderImmediateObject","unrollImmediateBufferMaterial","globject","opaque","transparentObjects","opaqueObjects","__webglInit","_modelViewMatrix","_normalMatrix","onObjectRemoved","onGeometryDispose","initGeometryGroups","__webglActive","addBuffer","geometryGroupsList","geometryGroups","ImmediateRenderObject","immediateRenderCallback","addBufferImmediate","_webglObjectsImmediate","makeGroups","usesFaceMaterial","groupHash","group","maxVerticesInGroup","hash_map","groups","groupsList","counter","geometryGroupCounter","addBuffers","objlist","updateObject","bufferType","DYNAMIC_DRAW","STATIC_DRAW","bufferSubData","BYTES_PER_ELEMENT","subarray","customAttributesDirty","areCustomAttributesDirty","clearCustomAttributes","removeObject","removeInstances","o","initMaterial","onMaterialDispose","shaderID","shaderIDs","shader","__webglShader","maxLightCount","allocateLights","maxShadows","allocateShadows","maxBones","allocateBones","_precision","supportsVertexTextures","_supportsVertexTextures","envMapMode","useFog","fogExp","flatShading","logarithmicDepthBuffer","_logarithmicDepthBuffer","_supportsBoneTextures","maxMorphTargets","maxMorphNormals","maxDirLights","directional","maxPointLights","maxSpotLights","spot","maxHemiLights","hemi","shadowMapType","shadowMapDebug","shadowMapCascade","code","pl","_programs","programInfo","usedTimes","WebGLProgram","programs","base","uniformsList","location","setBlending","setDepthTest","setDepthWrite","setColorWrite","setPolygonOffset","setProgram","_usedTextureUnits","deallocateMaterial","refreshProgram","refreshMaterial","refreshLights","p_uniforms","m_uniforms","_currentProgram","useProgram","_currentMaterialId","_currentCamera","uniformMatrix4fv","uniform1f","logDepthBufFC","cameraPosition","uniform3f","viewMatrix","textureUnit","getTextureUnit","uniform1i","setTexture","boneGlobalMatrices","refreshUniformsFog","_lightsNeedUpdate","setupLights","refreshUniformsLights","_lights","markUniformsLightsNeedsUpdate","refreshUniformsCommon","refreshUniformsLine","refreshUniformsDash","refreshUniformsParticle","refreshUniformsPhong","refreshUniformsLambert","_shadowPass","refreshUniformsShadow","loadUniformsGeneric","loadUniformsMatrices","modelMatrix","uvScaleMap","_canvas","ambient","distances","decays","directions","anglesCos","exponents","skyColors","groundColors","modelViewMatrix","uniformMatrix3fv","_maxTextures","uniform","uniform2f","uniform4f","uniform1iv","uniform3iv","uniform2fv","uniform3fv","uniform4fv","_array","setCubeTexture","setCubeTextureDynamic","setColorLinear","ll","zlights","dirColors","dirPositions","pointColors","pointPositions","pointDistances","pointDecays","spotColors","spotPositions","spotDistances","spotDirections","spotAnglesCos","spotExponents","spotDecays","hemiSkyColors","hemiGroundColors","hemiPositions","dirLength","pointLength","spotLength","hemiLength","dirCount","spotCount","hemiCount","dirOffset","pointOffset","spotOffset","hemiOffset","_direction","setTextureParameters","textureType","isImagePowerOfTwo","extension","texParameteri","TEXTURE_WRAP_S","paramThreeToGL","TEXTURE_WRAP_T","TEXTURE_MAG_FILTER","TEXTURE_MIN_FILTER","CLAMP_TO_EDGE","filterFallback","__currentAnisotropy","texParameterf","TEXTURE_MAX_ANISOTROPY_EXT","getMaxAnisotropy","clampToMaxSize","maxSize","slot","__webglTextureCube","onTextureDispose","createTexture","activeTexture","TEXTURE0","bindTexture","TEXTURE_CUBE_MAP","pixelStorei","UNPACK_FLIP_Y_WEBGL","isCompressed","isDataTexture","cubeImage","autoScaleCubemaps","_maxCubemapSize","glFormat","glType","mipmap","getCompressedTextureFormats","compressedTexImage2D","TEXTURE_CUBE_MAP_POSITIVE_X","texImage2D","generateMipmap","__webglTexture","setupFrameBuffer","framebuffer","textureTarget","bindFramebuffer","FRAMEBUFFER","framebufferTexture2D","COLOR_ATTACHMENT0","setupRenderBuffer","renderbuffer","bindRenderbuffer","RENDERBUFFER","depthBuffer","stencilBuffer","renderbufferStorage","DEPTH_COMPONENT16","framebufferRenderbuffer","DEPTH_ATTACHMENT","DEPTH_STENCIL","DEPTH_STENCIL_ATTACHMENT","RGBA4","updateRenderTargetMipmap","TEXTURE_2D","NEAREST","LINEAR","REPEAT","MIRRORED_REPEAT","NEAREST_MIPMAP_NEAREST","NEAREST_MIPMAP_LINEAR","LINEAR_MIPMAP_NEAREST","LINEAR_MIPMAP_LINEAR","UNSIGNED_BYTE","UNSIGNED_SHORT_4_4_4_4","UNSIGNED_SHORT_5_5_5_1","UNSIGNED_SHORT_5_6_5","BYTE","SHORT","UNSIGNED_SHORT","INT","UNSIGNED_INT","HALF_FLOAT_OES","ALPHA","RGB","RGBA","LUMINANCE","LUMINANCE_ALPHA","FUNC_ADD","FUNC_SUBTRACT","FUNC_REVERSE_SUBTRACT","ZERO","ONE","SRC_COLOR","ONE_MINUS_SRC_COLOR","SRC_ALPHA","ONE_MINUS_SRC_ALPHA","DST_ALPHA","ONE_MINUS_DST_ALPHA","DST_COLOR","ONE_MINUS_DST_COLOR","SRC_ALPHA_SATURATE","COMPRESSED_RGB_S3TC_DXT1_EXT","COMPRESSED_RGBA_S3TC_DXT1_EXT","COMPRESSED_RGBA_S3TC_DXT3_EXT","COMPRESSED_RGBA_S3TC_DXT5_EXT","COMPRESSED_RGB_PVRTC_4BPPV1_IMG","COMPRESSED_RGB_PVRTC_2BPPV1_IMG","COMPRESSED_RGBA_PVRTC_4BPPV1_IMG","COMPRESSED_RGBA_PVRTC_2BPPV1_IMG","MIN_EXT","MAX_EXT","nVertexUniforms","MAX_VERTEX_UNIFORM_VECTORS","nVertexMatrices","dirLights","pointLights","spotLights","hemiLights","_context","pixelRatio","_alpha","_depth","_stencil","stencil","_antialias","_premultipliedAlpha","premultipliedAlpha","_preserveDrawingBuffer","preserveDrawingBuffer","_clearColor","_clearAlpha","autoClear","autoClearColor","autoClearDepth","autoClearStencil","gammaInput","gammaOutput","shadowMapCullFace","calls","_currentFramebuffer","_currentGeometryProgram","_viewportX","_viewportY","_viewportWidth","_viewportHeight","_currentWidth","_currentHeight","preventDefault","resetGLState","setDefaultGLState","WebGLState","getShaderPrecisionFormat","rangeMin","rangeMax","WebGLExtensions","glClearColor","clearColor","clearDepth","clearStencil","enable","DEPTH_TEST","depthFunc","LEQUAL","frontFace","CCW","cullFace","BACK","CULL_FACE","BLEND","blendFunc","viewport","reset","MAX_TEXTURE_IMAGE_UNITS","_maxVertexTextures","MAX_VERTEX_TEXTURE_IMAGE_UNITS","_maxTextureSize","MAX_TEXTURE_SIZE","MAX_CUBE_MAP_TEXTURE_SIZE","_vertexShaderPrecisionHighpFloat","VERTEX_SHADER","HIGH_FLOAT","_vertexShaderPrecisionMediumpFloat","MEDIUM_FLOAT","_fragmentShaderPrecisionHighpFloat","FRAGMENT_SHADER","_fragmentShaderPrecisionMediumpFloat","formats","COMPRESSED_TEXTURE_FORMATS","highpAvailable","mediumpAvailable","shadowMapPlugin","ShadowMapPlugin","spritePlugin","SpritePlugin","lensFlarePlugin","LensFlarePlugin","forceContextLoss","loseContext","supportsFloatTextures","supportsHalfFloatTextures","supportsStandardDerivatives","supportsCompressedTextureS3TC","supportsCompressedTexturePVRTC","supportsBlendMinMax","MAX_TEXTURE_MAX_ANISOTROPY_EXT","getPrecision","getPixelRatio","setPixelRatio","updateStyle","setViewport","setScissor","scissor","enableScissorTest","SCISSOR_TEST","disable","getClearColor","getClearAlpha","setClearAlpha","bits","COLOR_BUFFER_BIT","DEPTH_BUFFER_BIT","STENCIL_BUFFER_BIT","clearTarget","setRenderTarget","deallocateGeometry","deallocateTexture","onRenderTargetDispose","deallocateRenderTarget","deleteBuffers","buffers","deleteBuffer","deleteTexture","deleteFramebuffer","__webglFramebuffer","deleteRenderbuffer","__webglRenderbuffer","deleteProgram","newPrograms","renderBufferImmediate","initAttributes","hasPositions","hasNormals","hasUvs","__webglUvBuffer","hasColors","positionArray","nx","ny","nz","nax","nbx","ncx","nay","nby","ncy","naz","nbz","ncz","drawArrays","TRIANGLES","updateBuffers","wireframeBit","geometryProgram","LINES","drawElements","POINTS","LINE_STRIP","setLineWidth","skinIndex","skinWeight","lineDistance","forceClear","setFaceCulling","frontFaceDirection","CW","FRONT","FRONT_AND_BACK","setDoubleSided","setFlipSided","uploadTexture","UNPACK_PREMULTIPLY_ALPHA_WEBGL","UNPACK_ALIGNMENT","isCube","isTargetPowerOfTwo","createFramebuffer","createRenderbuffer","shareDepthFrom","vx","vy","readRenderTargetPixels","WebGLRenderTarget","restore","checkFramebufferStatus","FRAMEBUFFER_COMPLETE","readPixels","addPrePlugin","addPostPlugin","updateShadowMap","gl","getExtension","programIdCount","generateDefines","chunk","cacheUniformLocations","identifiers","getUniformLocation","cacheAttributeLocations","getAttribLocation","shadowMapTypeDefine","envMapTypeDefine","envMapModeDefine","envMapBlendingDefine","prefix_vertex","prefix_fragment","gammaFactorDefine","customDefines","createProgram","glVertexShader","WebGLShader","glFragmentShader","attachShader","bindAttribLocation","linkProgram","programLogInfo","getProgramInfoLog","getProgramParameter","LINK_STATUS","getError","VALIDATE_STATUS","deleteShader","addLineNumbers","string","lines","createShader","shaderSource","compileShader","getShaderParameter","COMPILE_STATUS","getShaderInfoLog","newAttributes","Uint8Array","enabledAttributes","currentBlending","currentBlendEquation","currentBlendSrc","currentBlendDst","currentBlendEquationAlpha","currentBlendSrcAlpha","currentBlendDstAlpha","currentDepthTest","currentDepthWrite","currentColorWrite","currentDoubleSided","currentFlipSided","currentLineWidth","currentPolygonOffset","currentPolygonOffsetFactor","currentPolygonOffsetUnits","enableVertexAttribArray","disableVertexAttribArray","blendEquationSeparate","blendFuncSeparate","depthMask","colorMask","lineWidth","polygonoffset","factor","units","POLYGON_OFFSET_FILL","flares","prefix","vertexBuffer","elementBuffer","hasVertexTexture","tempTexture","occlusionTexture","init","renderType","occlusionMap","screenPosition","viewportWidth","viewportHeight","tempPosition","invAspect","halfViewportWidth","halfViewportHeight","screenPositionPixels","TEXTURE1","copyTexImage2D","sprite","_renderer","_renderList","createVirtualLight","cascade","virtualLight","isVirtual","pointsWorld","pointsFrustum","nearZ","farZ","updateVirtualLight","updateShadowCamera","_min","_max","getObjectMaterial","_depthMaterial","_depthMaterialMorph","_depthMaterialSkin","_depthMaterialMorphSkin","_matrixPosition","depthShader","depthUniforms","originalCamera","gyro","Gyroscope","shadowFilter","pars","cameraHelper","CameraHelper","objectMaterial","useMorphing","useSkinning","customDepthMaterial","clearAlpha","spritePosition","spriteRotation","spriteScale","uvOffset","uvScale","fogType","fillStyle","fillRect","oldFogType","sceneFogType","GeometryUtils","geometry1","geometry2","ImageUtils","loadTextureCube","loadCompressedTexture","loadCompressedTextureCube","getNormalMap","subtract","getImageData","imageData","createImageData","ly","uy","lx","ux","num_points","putImageData","generateDataTexture","SceneUtils","createMultiMaterialObject","detach","attach","FontUtils","divisions","getFace","loadFace","family","familyName","ThreeFont","cssFontWeight","cssFontStyle","drawText","resolution","String","fontPaths","Path","ret","extractGlyphPoints","paths","outline","action","cpx","cpy","cpx0","cpy0","cpx1","cpy1","cpx2","cpy2","laste","pts","glyph","glyphs","_cachedOutline","moveTo","lineTo","quadraticCurveTo","Shape","Utils","bezierCurveTo","b3","ha","generateShapes","curveSegments","font","shapes","toShapes","namespace","EPSILON","process","contour","verts","vertIndices","nv","snip","px","py","aX","aY","bX","bY","cX","cY","apx","apy","bpx","bpy","cCROSSap","bCROSScp","aCROSSbp","Triangulate","_typeface_js","typeface_js","Audio","source","createBufferSource","onended","onEnded","gain","createGain","connect","destination","panner","createPanner","autoplay","isPlaying","onload","decodeAudioData","play","loop","pause","currentTime","setLoop","setRefDistance","refDistance","setRolloffFactor","rolloffFactor","setVolume","AudioListener","AudioContext","webkitAudioContext","orientation","velocity","positionPrev","setOrientation","setVelocity","Curve","getPointAt","getUtoTmapping","getPoints","getSpacedPoints","lengths","getLengths","cacheArcLengths","current","cache","last","sum","updateArcLengths","targetArcLength","arcLengths","comparison","lengthBefore","lengthAfter","segmentLength","segmentFraction","getTangent","pt1","pt2","vec","getTangentAt","tangentQuadraticBezier","tangentCubicBezier","tangentSpline","h00","h10","h01","h11","getPointFunc","CurvePath","curves","bends","autoClose","curve","checkConnection","closePath","startPoint","endPoint","LineCurve","curveLengths","getCurveLengths","lens","cacheLengths","sums","maxX","maxY","maxZ","minX","minY","minZ","NEGATIVE_INFINITY","POSITIVE_INFINITY","createPointsGeometry","createGeometry","createSpacedPointsGeometry","addWrapPath","bendpath","getTransformedPoints","oldPts","getWrapPoints","getTransformedSpacedPoints","oldX","oldY","xNorm","bounds","pathPt","translationObject","quaternionObject","scaleObject","translationWorld","quaternionWorld","scaleWorld","actions","fromPoints","PathActions","MOVE_TO","LINE_TO","QUADRATIC_CURVE_TO","BEZIER_CURVE_TO","CSPLINE_THRU","ARC","ELLIPSE","vectors","vlen","args","lastargs","x0","y0","aCPx","aCPy","QuadraticBezierCurve","aCP1x","aCP1y","aCP2x","aCP2y","CubicBezierCurve","splineThru","npts","SplineCurve","aRadius","aStartAngle","aEndAngle","aClockwise","absarc","absellipse","ellipse","xRadius","yRadius","EllipseCurve","lastPoint","closedPath","useSpacedPoints","spts","concat","spline","deltaAngle","tdivisions","isCCW","noHoles","extractSubpaths","inActions","subPaths","lastPath","toShapesNoHoles","inSubpaths","tmpPath","tmpShape","isPointInsidePolygon","inPt","inPolygon","polyLen","inside","edgeLowPt","edgeHighPt","edgeDx","edgeDy","perpEdge","solid","holesFirst","isClockWise","tmpPoints","betterShapeHoles","newShapes","newShapeHoles","mainIdx","ambigious","toChange","sIdx","sLen","sho","hIdx","ho","hole_unassigned","s2Idx","froms","tos","hole","tmpHoles","holes","extrude","extruded","ExtrudeGeometry","makeGeometry","ShapeGeometry","getPointsHoles","holesPts","getSpacedPointsHoles","extractAllPoints","shape","extractPoints","extractAllSpacedPoints","triangulateShape","point_in_segment_2D_colin","inSegPt1","inSegPt2","inOtherPt","intersect_segments_2D","inSeg1Pt1","inSeg1Pt2","inSeg2Pt1","inSeg2Pt2","inExcludeAdjacentSegs","seg1dx","seg1dy","seg2dx","seg2dy","seg1seg2dx","seg1seg2dy","limit","perpSeg1","perpSeg2","factorSeg1","seg1Pt","seg2Pt","seg1min","seg1max","seg1minVal","seg1maxVal","seg2min","seg2max","seg2minVal","seg2maxVal","isPointInsideAngle","inVertex","inLegFromPt","inLegToPt","legFromPtX","legFromPtY","legToPtX","legToPtY","otherPtX","otherPtY","from2toAngle","from2otherAngle","other2toAngle","removeHoles","isCutLineInsideAngles","inShapeIdx","inHoleIdx","lastShapeIdx","prevShapeIdx","nextShapeIdx","insideAngle","lastHoleIdx","prevHoleIdx","nextHoleIdx","intersectsShapeEdge","inShapePt","inHolePt","nextIdx","intersection","intersectsHoleEdge","ihIdx","chkHole","indepHoles","holeIndex","shapeIndex","shapePt","holePt","holeIdx","cutKey","tmpShape1","tmpShape2","tmpHole1","tmpHole2","failedCuts","hl","minShapeIndex","h2","allPointsMap","allpoints","shapeWithoutHoles","triangles","b2p0","b2p1","b2p2","b3p0","b3p1","b3p2","b3p3","point0","point1","point2","point3","ArcCurve","LineCurve3","QuadraticBezierCurve3","CubicBezierCurve3","SplineCurve3","ClosedSplineCurve3","AnimationHandler","CATMULLROM","CATMULLROM_FORWARD","initialized","hierarchy","rot","quat","usedMorphTargets","morphTargetName","morphTargetsInfluences","root","parseRecurseHierarchy","deltaTimeMS","resetBlendWeights","Animation","timeScale","interpolationType","keyTypes","animationCache","positionWeight","quaternionWeight","scaleWeight","prevKey","nextKey","originalMatrix","getNextKeyWith","newVector","newQuat","interpolateCatmullRom","prevXYZ","nextXYZ","proportionalWeight","getPrevKeyWith","currentPoint","forwardPoint","KeyFrameAnimation","isPaused","sids","sid","next","endTime","original","hasTarget","MorphAnimation","frames","lastFrame","currentFrame","interpolation","frame","buildPlane","udir","vdir","gridX","gridY","width_half","height_half","gridX1","gridY1","segment_width","segment_height","uvd","depth_half","centerUV","segment","CubeGeometry","heightHalf","verticesRow","uvsRow","tanTheta","v4","n4","uv1","uv3","uv4","addShapeList","addShape","scalePt2","pt","getBevelVec","inPrev","inNext","v_trans_x","v_trans_y","shrink_by","v_prev_x","v_prev_y","v_next_x","v_next_y","v_prev_lensq","colinear0","v_prev_len","v_next_len","ptPrevShift_x","ptPrevShift_y","ptNextShift_x","ptNextShift_y","sf","v_trans_lensq","direction_eq","buildLidFaces","bevelEnabled","layer","flen","f3","steps","bevelSegments","buildSideFaces","layeroffset","sidewalls","ahole","slen1","slen2","f4","shapesOffset","uvgen","generateTopUV","wallContour","stepIndex","stepsLength","contourIndex1","contourIndex2","extrudeMaterial","generateSideWallUV","extrudePts","splineTube","binormal","position2","amount","bevelThickness","bevelSize","extrudePath","extrudeByPath","UVGenerator","WorldUVGenerator","TubeGeometry","FrenetFrames","shapePoints","reverse","bs","vert","contourMovements","oneHoleMovements","holesMovements","verticesMovements","binormals","indexA","indexB","indexC","indexD","LatheGeometry","inversePointLength","inverseSegments","phi","np","u0","u1","PlaneGeometry","PlaneBufferGeometry","offset2","RingGeometry","innerRadius","outerRadius","thetaSegments","phiSegments","radiusStep","thetaSegment","TextGeometry","textShapes","getPos","in_q","in_p","cu","su","quOverP","cs","tz","grid","tang","bitan","ip","jp","closed","taper","NoTaper","numpoints","pos2","SinusoidalTaper","initialNormal3","smallest","MAX_VALUE","mat","PolyhedronGeometry","prepare","that","azimuth","inclination","make","centroid","azi","correctUV","subdivide","cols","aj","bj","rows","DodecahedronGeometry","OctahedronGeometry","TetrahedronGeometry","ParametricGeometry","func","slices","stacks","sliceCount","AxisHelper","ArrowHelper","lineGeometry","coneGeometry","dir","headLength","headWidth","cone","setDirection","setColor","BoxHelper","BoundingBoxHelper","addLine","addPoint","pointMap","hexFrustum","hexCone","hexUp","hexTarget","hexCross","setPoint","DirectionalLightHelper","lightPlane","targetLine","EdgesHelper","thresholdAngle","thresholdDot","edge","sortFunction","numEdges","vert1","vert2","face1","face2","FaceNormalsHelper","objectVertices","objectFaces","objectWorldMatrix","GridHelper","setColors","colorCenterLine","colorGrid","HemisphereLightHelper","sphereSize","lightSphere","PointLightHelper","SkeletonHelper","getBoneList","boneList","matrixWorldInv","boneMatrix","SpotLightHelper","vector2","coneLength","coneWidth","VertexNormalsHelper","worldMatrix","vertexId","VertexTangentsHelper","WireframeHelper","edges","numTris","renderCallback","MorphBlendMesh","animationsMap","animationsList","numFrames","startFrame","endFrame","createAnimation","setAnimationWeight","active","autoCreateAnimations","frameRanges","setAnimationDirectionForward","setAnimationDirectionBackward","setAnimationFPS","setAnimationDuration","setAnimationTime","getAnimationTime","getAnimationDuration","stopAnimation","EventEmitter","i$","ref$","len$","_events","_maxListeners","isFunction","arg","isNumber","isObject","isUndefined","defaultMaxListeners","setMaxListeners","TypeError","er","handler","len","addListener","newListener","warned","on","once","removeListener","fired","removeAllListeners","listenerCount","emitter"],"mappings":"CAAS,SAAUA,SCInB,QAAAC,qBAAAC,UAGA,GAAAC,iBAAAD,UACA,MAAAC,kBAAAD,UAAAE,OAGA,IAAAC,QAAAF,iBAAAD,WACAE,WACAE,GAAAJ,SACAK,QAAA,EAUA,OANAP,SAAAE,UAAAM,KAAAH,OAAAD,QAAAC,cAAAD,QAAAH,qBAGAI,OAAAE,QAAA,EAGAF,OAAAD,QAvBA,GAAAD,oBAqCA,OATAF,qBAAAQ,EAAAT,QAGAC,oBAAAS,EAAAP,iBAGAF,oBAAAU,EAAA,GAGAV,oBAAA,KDMM,SAASI,OAAQD,QAASH,qBAE/B,GAAIW,MAAMC,SAAUC,KAAMC,QE7CIH,MAALX,oBAAA,GAAKW,KACGC,SAALZ,oBAAA,GAAKY,SAGlCC,KAAK,GAAMF,MAEXG,SAAS,GAAMF,UAASC,OFiDlB,SAAST,OAAQD,QAASH,qBAE/B,GAAIe,OAAOJ,KAAMK,KAAyB,mBAAXb,UAA0BA,SAAWc,IGzDnDF,OAAhBf,oBAAA,GAAgBe,MH2DjBC,KAAKL,KGxDOA,KAAN,WACL,QAAAA,MAAAO,QH2DG,GAAIC,MG3DN,OAAAD,oBAECC,MAAM,GAAMJ,OAEZK,QAAQC,IAAI,QHoDbV,KAAKW,YAAc,MACHX,MAAKY,SAOrB,OAAOZ,UAOJ,SAASP,OAAQD,QAASH,qBAyB/B,QAASwB,SAAQC,IAAKC,KACpB,QAASC,QAGT,MAHiBA,KAAIJ,WAAaE,IAAIG,WAAaF,KAAKH,WACvDE,IAAIF,UAAY,GAAII,MAAKE,YAAcJ,IACb,kBAAhBC,KAAII,UAAwBJ,IAAII,SAASL,KAC7CA,IAET,QAASM,SAAQC,IAAKC,KACpB,GAAIC,QAASC,cACb,KAAK,GAAIC,OAAOH,KAASC,IAAI3B,KAAK0B,IAAKG,OAAMJ,IAAII,KAAOH,IAAIG,KAC5D,OAAOJ,KAhCT,GAAIK,QAAQtB,MAAOC,KAAyB,mBAAXb,UAA0BA,SAAWc,II7EpDoB,QAAjBrC,oBAAA,IAAiBqC,OJ+ElBrB,KAAKD,MI5EOA,MAAN,SAAAa,YACL,QAAAb,SACEA,MAAAa,WAAArB,KAAAU,KAAM,MJ2EP,GAAIM,WAAYC,SAASO,QAAQhB,MAAOa,YAAYN,YAAc,QAASP,OAAQa,YAAYL,SAkB/F,OAdAA,WI7EDe,SAAW,SAAAC,IJkFR,MIjFDA,IAAKX,WAAAL,UADPe,SAAAE,MAAAvB,KAAAwB,WAEK,MAAAF,IAAStB,KAACyB,KAAK,gBAAeH,IACjCA,IJiFDhB,UI/EDoB,YAAc,SAAAJ,IJoFX,MInFDA,IAAKX,WAAAL,UADPoB,YAAAH,MAAAvB,KAAAwB,WAEK,MAAAF,IAAStB,KAACyB,KAAK,kBAAiBH,IACnCA,IJmFMxB,OI/FSsB,SJiHb,SAASjC,OAAQD,QAASH,qBAE/B,GAAI4C,OAAOC,SAAUC,MAAOlC,SAAUI,KAAyB,mBAAXb,UAA0BA,SAAWc,IKtHxF2B,OAAA5C,oBAAA,GACA6C,SAAA7C,oBAAA,GAGO8C,MAAA9C,oBAAA,ILsHRgB,KAAKJ,SKpHOA,SAAN,WACL,QAAAA,UAAAM,QLuHG,GAAI6B,IAAIC,KAAMC,GAAIC,MKvHpB,OAAAhC,oBLyHE6B,GKvHD9B,KAACkC,cAAe,GAAML,OAAMM,eAAcC,WAAW,IACnDN,GAAEO,QAASC,OAAOC,WAAaD,OAAOE,aACtCV,GAAEW,kBAAqB,EACvBX,GAAEY,eAAqB,EACvBZ,GAAEa,aAAqB,EAEzBZ,KAAO/B,KAEPsC,OAAOM,iBAAmB,SAAQ,WAC7Bb,KAAKc,SACNd,KAAKc,OAAOC,OAASR,OAAOC,WAAcD,OAAOE,YACjDT,KAAKc,OAAOE,0BACdhB,KAAKG,cAAeG,QAASC,OAAOC,WAAaD,OAAOE,eAG1DxC,KAACE,MAAM,GAAM2B,OAAM/B,MAEnBE,KAAC6C,OAAO,GAAMhB,OAAMmB,kBAAkB,GAAIV,OAAOC,WAAcD,OAAOE,YAAc,EAAG,KACvFxC,KAAC6C,OAAOI,SAASC,EAAI,IAErBlD,KAACmD,SAAS,GAAMtB,OAAMuB,YAAY,IAAK,IAAK,KAC5CpD,KAACqD,SAAS,GAAMxB,OAAMyB,mBAAkBC,MAAO,SAASC,WAAW,IAEnExD,KAACyD,KAAK,GAAM5B,OAAM6B,KAAK1D,KAACmD,SAAUnD,KAACqD,UACnCrD,KAACE,MAAMyD,IAAI3D,KAACyD,MLwHXzB,GKtHDhC,KAACkC,cAAe0B,WACd5B,GAAE5C,GAAK,aACDyE,SAASC,KAAKC,YAApB/B,IAEFM,OAAO0B,sBAAwB/B,OAAS,WACtCK,OAAO0B,sBAAwB/B,QAC/BF,KAAKE,WLkFRtC,SAASU,YAAc,UACvB,IAAIC,WAAYX,SAASW,SA2CzB,OALAA,WKvHD2B,OAAQ,WACNjC,KAACyD,KAAKQ,SAASC,GAAK,IACpBlE,KAACyD,KAAKQ,SAASE,GAAK,IAEpBnE,KAACkC,cAAeD,OAAOjC,KAACE,MAAOF,KAAC6C,SLwH1BlD,aAOJ,SAASR,OAAQD,QAASH,qBM5KhC,GAAAqF,SAAArF,oBAAA,EACA,iBAAAqF,qBAAAjF,OAAAC,GAAAgF,QAAA,KAEArF,qBAAA,GAAAqF,WACAA,SAAAC,SAAAlF,OAAAD,QAAAkF,QAAAC,SNkMM,SAASlF,OAAQD,QAASH,qBOzMhCG,QAAAC,OAAAD,QAAAH,oBAAA,KAKAG,QAAAoF,MAAAnF,OAAAC,GAAA,oCAA2D,MPkNrD,SAASD,OAAQD,SQlNvBC,OAAAD,QAAA,WACA,GAAAqF,QA0CA,OAvCAA,MAAAC,SAAA,WAEA,OADAC,WACAC,EAAA,EAAgBA,EAAA1E,KAAA2E,OAAiBD,IAAA,CACjC,GAAAE,MAAA5E,KAAA0E,EACAE,MAAA,GACAH,OAAAH,KAAA,UAAAM,KAAA,OAAwCA,KAAA,QAExCH,OAAAH,KAAAM,KAAA,IAGA,MAAAH,QAAAI,KAAA,KAIAN,KAAAG,EAAA,SAAA5F,QAAAgG,YACA,gBAAAhG,WACAA,UAAA,KAAAA,QAAA,KAEA,QADAiG,2BACAL,EAAA,EAAgBA,EAAA1E,KAAA2E,OAAiBD,IAAA,CACjC,GAAAtF,IAAAY,KAAA0E,GAAA,EACA,iBAAAtF,MACA2F,uBAAA3F,KAAA,GAEA,IAAAsF,EAAA,EAAYA,EAAA5F,QAAA6F,OAAoBD,IAAA,CAChC,GAAAE,MAAA9F,QAAA4F,EAKA,iBAAAE,MAAA,IAAAG,uBAAAH,KAAA,MACAE,aAAAF,KAAA,GACAA,KAAA,GAAAE,WACKA,aACLF,KAAA,OAAAA,KAAA,aAAAE,WAAA,KAEAP,KAAAD,KAAAM,SAIAL,OR+NM,SAASpF,OAAQD,QAASH,qBStNhC,QAAAiG,gBAAAC,OAAAC,SACA,OAAAR,GAAA,EAAeA,EAAAO,OAAAN,OAAmBD,IAAA,CAClC,GAAAE,MAAAK,OAAAP,GACAS,SAAAC,YAAAR,KAAAxF,GACA,IAAA+F,SAAA,CACAA,SAAAE,MACA,QAAAC,GAAA,EAAiBA,EAAAH,SAAAI,MAAAZ,OAA2BW,IAC5CH,SAAAI,MAAAD,GAAAV,KAAAW,MAAAD,GAEA,MAAQA,EAAAV,KAAAW,MAAAZ,OAAuBW,IAC/BH,SAAAI,MAAAjB,KAAAkB,SAAAZ,KAAAW,MAAAD,GAAAJ,cAEG,CAEH,OADAK,UACAD,EAAA,EAAiBA,EAAAV,KAAAW,MAAAZ,OAAuBW,IACxCC,MAAAjB,KAAAkB,SAAAZ,KAAAW,MAAAD,GAAAJ,SAEAE,aAAAR,KAAAxF,KAA2BA,GAAAwF,KAAAxF,GAAAiG,KAAA,EAAAE,eAK3B,QAAAE,cAAAlB,MAGA,OAFAU,WACAS,aACAhB,EAAA,EAAeA,EAAAH,KAAAI,OAAiBD,IAAA,CAChC,GAAAE,MAAAL,KAAAG,GACAtF,GAAAwF,KAAA,GACAe,IAAAf,KAAA,GACAgB,MAAAhB,KAAA,GACAiB,UAAAjB,KAAA,GACAkB,MAAcH,QAAAC,YAAAC,oBACdH,WAAAtG,IAGAsG,UAAAtG,IAAAmG,MAAAjB,KAAAwB,MAFAb,OAAAX,KAAAoB,UAAAtG,KAAgCA,MAAAmG,OAAAO,QAIhC,MAAAb,QAGA,QAAAc,sBACA,GAAAC,cAAAnC,SAAAoC,cAAA,SACAC,KAAAC,gBAGA,OAFAH,cAAAI,KAAA,WACAF,KAAAnC,YAAAiC,cACAA,aAGA,QAAAK,qBACA,GAAAC,aAAAzC,SAAAoC,cAAA,QACAC,KAAAC,gBAGA,OAFAG,aAAAC,IAAA,aACAL,KAAAnC,YAAAuC,aACAA,YAGA,QAAAd,UAAAzE,IAAAmE,SACA,GAAAc,cAAAQ,OAAAC,MAEA,IAAAvB,QAAAwB,UAAA,CACA,GAAAC,YAAAC,kBACAZ,cAAAa,oCAAAd,sBACAS,OAAAM,oBAAAC,KAAA,KAAAf,aAAAW,YAAA,GACAF,OAAAK,oBAAAC,KAAA,KAAAf,aAAAW,YAAA,OACE5F,KAAA8E,WACF,kBAAAmB,MACA,kBAAAA,KAAAC,iBACA,kBAAAD,KAAAE,iBACA,kBAAAC,OACA,kBAAAC,OACApB,aAAAK,oBACAG,OAAAa,WAAAN,KAAA,KAAAf,cACAS,OAAA,WACAT,aAAAsB,WAAA5F,YAAAsE,cACAA,aAAAuB,MACAP,IAAAE,gBAAAlB,aAAAuB,SAGAvB,aAAAD,qBACAS,OAAAgB,WAAAT,KAAA,KAAAf,cACAS,OAAA,WACAT,aAAAsB,WAAA5F,YAAAsE,eAMA,OAFAQ,QAAAzF,KAEA,SAAA0G,QACA,GAAAA,OAAA,CACA,GAAAA,OAAA9B,MAAA5E,IAAA4E,KAAA8B,OAAA7B,QAAA7E,IAAA6E,OAAA6B,OAAA5B,YAAA9E,IAAA8E,UACA,MACAW,QAAAzF,IAAA0G,YAEAhB,WAcA,QAAAK,qBAAAd,aAAA0B,MAAAjB,OAAA1F,KACA,GAAA4E,KAAAc,OAAA,GAAA1F,IAAA4E,GAEA,IAAAK,aAAA2B,WACA3B,aAAA2B,WAAAC,QAAAC,YAAAH,MAAA/B,SACE,CACF,GAAAmC,SAAAjE,SAAAkE,eAAApC,KACAqC,WAAAhC,aAAAgC,UACAA,YAAAN,QAAA1B,aAAAtE,YAAAsG,WAAAN,QACAM,WAAArD,OACAqB,aAAAiC,aAAAH,QAAAE,WAAAN,QAEA1B,aAAAjC,YAAA+D,UAKA,QAAAN,YAAAxB,aAAAjF,KACA,GAAA4E,KAAA5E,IAAA4E,IACAC,MAAA7E,IAAA6E,KACA7E,KAAA8E,SAMA,IAJAD,OACAI,aAAAkC,aAAA,QAAAtC,OAGAI,aAAA2B,WACA3B,aAAA2B,WAAAC,QAAAjC,QACE,CACF,KAAAK,aAAAmC,YACAnC,aAAAtE,YAAAsE,aAAAmC,WAEAnC,cAAAjC,YAAAF,SAAAkE,eAAApC,OAIA,QAAA0B,YAAAf,YAAAvF,KACA,GAAA4E,KAAA5E,IAAA4E,IAEAE,WADA9E,IAAA6E,MACA7E,IAAA8E,UAEAA,aAEAF,KAAA,uDAAuDyB,KAAAgB,SAAAC,mBAAAC,KAAAC,UAAA1C,cAAA,MAGvD,IAAA2C,MAAA,GAAArB,OAAAxB,MAA6BS,KAAA,aAE7BqC,OAAAnC,YAAAiB,IAEAjB,aAAAiB,KAAAP,IAAAC,gBAAAuB,MAEAC,QACAzB,IAAAE,gBAAAuB,QArNA,GAAArD,gBACAsD,QAAA,SAAAC,IACA,GAAAC,KACA,mBAEA,MADA,mBAAAA,aAAAD,GAAApH,MAAAvB,KAAAwB,YACAoH,OAGAC,QAAAH,QAAA,WACA,qBAAAI,KAAAxG,OAAAyG,UAAAC,UAAAC,iBAEA9C,eAAAuC,QAAA,WACA,MAAA7E,UAAAqC,MAAArC,SAAAqF,qBAAA,aAEArC,iBAAA,KACAD,iBAAA,CAEAzH,QAAAD,QAAA,SAAAqF,KAAAW,SAEA,mBAAArB,UAAA,SAAAsF,OAAA,+DAGAjE,qBAGA,mBAAAA,SAAAwB,YAAAxB,QAAAwB,UAAAmC,UAEA,IAAA5D,QAAAQ,aAAAlB,KAGA,OAFAS,gBAAAC,OAAAC,SAEA,SAAAkE,SAEA,OADAC,cACA3E,EAAA,EAAgBA,EAAAO,OAAAN,OAAmBD,IAAA,CACnC,GAAAE,MAAAK,OAAAP,GACAS,SAAAC,YAAAR,KAAAxF,GACA+F,UAAAE,OACAgE,UAAA/E,KAAAa,UAEA,GAAAiE,QAAA,CACA,GAAA1D,WAAAD,aAAA2D,QACApE,gBAAAU,UAAAR,SAEA,OAAAR,GAAA,EAAgBA,EAAA2E,UAAA1E,OAAsBD,IAAA,CACtC,GAAAS,UAAAkE,UAAA3E,EACA,QAAAS,SAAAE,KAAA,CACA,OAAAC,GAAA,EAAkBA,EAAAH,SAAAI,MAAAZ,OAA2BW,IAC7CH,SAAAI,MAAAD,WACAF,aAAAD,SAAA/F,OAwGA,IAAAyI,aAAA,WACA,GAAAyB,aAEA,iBAAA5B,MAAA6B,aAEA,MADAD,WAAA5B,OAAA6B,YACAD,UAAAE,OAAAC,SAAA5E,KAAA,WTgVM,SAAS1F,OAAQD,QAASH,qBU7ehC,GAAAqF,SAAArF,oBAAA,EACA,iBAAAqF,qBAAAjF,OAAAC,GAAAgF,QAAA,KAEArF,qBAAA,GAAAqF,WACAA,SAAAC,SAAAlF,OAAAD,QAAAkF,QAAAC,SVmgBM,SAASlF,OAAQD,QAASH,qBW1gBhCG,QAAAC,OAAAD,QAAAH,oBAAA,KAKAG,QAAAoF,MAAAnF,OAAAC,GAAA,SXmhBM,SAASD,OAAQD,QAASH,qBYxhBhC,GAAAgD,eAMA2H,OAAaC,SAAA,KAMbxK,QAAAD,QAAAwK,MAMAE,SAAAC,KAAAC,OAIAD,KAAAC,KAAA,SAAA5F,GAEA,SAAAA,EAAA,GAAAA,EAAA,KAAAA,IAQAwF,MAAAtJ,IAAA,WAAwBD,QAAAC,IAAAmB,MAAApB,QAAAqB,YACxBkI,MAAAK,KAAA,WAAyB5J,QAAA4J,KAAAxI,MAAApB,QAAAqB,YACzBkI,MAAAM,MAAA,WAA0B7J,QAAA6J,MAAAzI,MAAApB,QAAAqB,YAK1BkI,MAAAO,OAAeC,KAAA,EAAAC,OAAA,EAAAC,MAAA,GAIfV,MAAAW,aAAA,EACAX,MAAAY,aAAA,EACAZ,MAAAa,cAAA,EACAb,MAAAc,kBAAA,EAEAd,MAAAe,qBAAA,EACAf,MAAAgB,sBAAA,EAIAhB,MAAAiB,eAAA,EACAjB,MAAAkB,aAAA,EACAlB,MAAAmB,iBAAA,EAMAnB,MAAAoB,UAAA,EACApB,MAAAqB,SAAA,EACArB,MAAAsB,WAAA,EAIAtB,MAAAuB,UAAA,EACAvB,MAAAwB,YAAA,EACAxB,MAAAyB,cAAA,EAIAzB,MAAA0B,SAAA,EACA1B,MAAA2B,WAAA,EACA3B,MAAA4B,aAAA,EAIA5B,MAAA6B,WAAA,EACA7B,MAAA8B,eAAA,EACA9B,MAAA+B,iBAAA,EACA/B,MAAAgC,oBAAA,EACAhC,MAAAiC,iBAAA,EACAjC,MAAAkC,eAAA,EAMAlC,MAAAmC,YAAA,IACAnC,MAAAoC,iBAAA,IACApC,MAAAqC,wBAAA,IACArC,MAAAsC,YAAA,IACAtC,MAAAuC,YAAA,IAIAvC,MAAAwC,WAAA,IACAxC,MAAAyC,UAAA,IACAzC,MAAA0C,eAAA,IACA1C,MAAA2C,uBAAA,IACA3C,MAAA4C,eAAA,IACA5C,MAAA6C,uBAAA,IACA7C,MAAA8C,eAAA,IACA9C,MAAA+C,uBAAA,IAUA/C,MAAAgD,eAAA,IACAhD,MAAAiD,uBAAA,IACAjD,MAAAkD,uBAAA,IAKAlD,MAAAmD,kBAAA,EACAnD,MAAAoD,aAAA,EACApD,MAAAqD,aAAA,EAIArD,MAAAsD,UAAA,IAEAtD,MAAAuD,sBAAA,IACAvD,MAAAwD,sBAAA,IAEAxD,MAAAyD,iCAAA,IACAzD,MAAA0D,iCAAA,IAEA1D,MAAA2D,2BAAA,IAIA3D,MAAA4D,eAAA,IACA5D,MAAA6D,oBAAA,KACA7D,MAAA8D,uBAAA,KAIA9D,MAAA+D,cAAA,KACA/D,MAAAgE,2BAAA,KACAhE,MAAAiE,0BAAA,KACAjE,MAAAkE,aAAA,KACAlE,MAAAmE,0BAAA,KACAnE,MAAAoE,yBAAA,KAIApE,MAAAqE,iBAAA,KACArE,MAAAsE,SAAA,KACAtE,MAAAuE,UAAA,KACAvE,MAAAwE,kBAAA,KACAxE,MAAAyE,QAAA,KACAzE,MAAA0E,gBAAA,KACA1E,MAAA2E,UAAA,KACA3E,MAAA4E,cAAA,KAKA5E,MAAA6E,sBAAA,KACA7E,MAAA8E,sBAAA,KACA9E,MAAA+E,qBAAA,KAIA/E,MAAAgF,YAAA,KACAhF,MAAAiF,UAAA,KACAjF,MAAAkF,WAAA,KACAlF,MAAAmF,gBAAA,KACAnF,MAAAoF,qBAAA,KAEApF,MAAAqF,WAAArF,MAAAkF,WAIAlF,MAAAsF,qBAAA,KACAtF,MAAAuF,sBAAA,KACAvF,MAAAwF,sBAAA,KACAxF,MAAAyF,sBAAA,KAKAzF,MAAA0F,wBAAA,KACA1F,MAAA2F,wBAAA,KACA3F,MAAA4F,yBAAA,KACA5F,MAAA6F,yBAAA,KAKA7F,MAAA8F,UAAA,WAEA9F,MAAAM,MAAA,0EAEAhK,KAAAyP,cAAA,SAAAC,OAAA7M,QAEA6G,MAAAK,KAAA,8DACA2F,OAAAC,QAAA9M,SAIA7C,KAAA4P,gBAAA,SAAAF,OAAA7M,QAEA6G,MAAAK,KAAA,kEACA2F,OAAAG,UAAAhN,SAIA7C,KAAA8P,WAAA,SAAAJ,OAAA7M,QAEA6G,MAAAM,MAAA,sEAMAN,MAAAqG,eAAA,WAEArG,MAAAM,MAAA,mFAEAhK,KAAA4D,WAAAC,SAAAoC,cAAA,UACAjG,KAAA2B,MAAA,aACA3B,KAAAiC,OAAA,aACAjC,KAAAgQ,cAAA,aACAhQ,KAAAqC,QAAA,cAUAqH,MAAAuG,MAAA,SAAA1M,OAEA,WAAA/B,UAAAmD,OAEA3E,KAAAkQ,OAAA1O,UAAA,GAAAA,UAAA,GAAAA,UAAA,IAIAxB,KAAAmQ,IAAA5M,QAIAmG,MAAAuG,MAAA3P,WAEAM,YAAA8I,MAAAuG,MAEAG,EAAA,EAAAC,EAAA,EAAAC,EAAA,EAEAH,IAAA,SAAAI,OAgBA,MAdAA,iBAAA7G,OAAAuG,MAEAjQ,KAAAwQ,KAAAD,OAEG,gBAAAA,OAEHvQ,KAAAyQ,OAAAF,OAEG,gBAAAA,QAEHvQ,KAAA0Q,SAAAH,OAIAvQ,MAIAyQ,OAAA,SAAAE,KAQA,MANAA,KAAA9G,KAAA+G,MAAAD,KAEA3Q,KAAAoQ,GAAAO,KAAA,YACA3Q,KAAAqQ,GAAAM,KAAA,WACA3Q,KAAAsQ,GAAA,IAAAK,KAAA,IAEA3Q,MAIAkQ,OAAA,SAAAE,EAAAC,EAAAC,GAMA,MAJAtQ,MAAAoQ,IACApQ,KAAAqQ,IACArQ,KAAAsQ,IAEAtQ,MAIA6Q,OAAA,SAAAC,EAAAC,EAAAC,GAIA,OAAAD,EAEA/Q,KAAAoQ,EAAApQ,KAAAqQ,EAAArQ,KAAAsQ,EAAAU,MAEG,CAEH,GAAAC,SAAA,SAAAxR,EAAAyR,EAAAC,GAIA,MAFA,GAAAA,OAAA,GACAA,EAAA,IAAAA,GAAA,GACA,IAAAA,EAAA1R,EAAA,GAAAyR,EAAAzR,GAAA0R,EACA,GAAAA,EAAAD,EACA,IAAAC,EAAA1R,EAAA,GAAAyR,EAAAzR,IAAA,IAAA0R,GACA1R,GAIAA,EAAA,IAAAuR,KAAA,EAAAD,GAAAC,EAAAD,EAAAC,EAAAD,EACAG,EAAA,EAAAF,EAAAvR,CAEAO,MAAAoQ,EAAAa,QAAAC,EAAAzR,EAAAqR,EAAA,KACA9Q,KAAAqQ,EAAAY,QAAAC,EAAAzR,EAAAqR,GACA9Q,KAAAsQ,EAAAW,QAAAC,EAAAzR,EAAAqR,EAAA,KAIA,MAAA9Q,OAIA0Q,SAAA,SAAAU,OAIA,qCAAAtI,KAAAsI,OAAA,CAEA,GAAA7N,OAAA,kCAAA8N,KAAAD,MAMA,OAJApR,MAAAoQ,EAAAvG,KAAAyH,IAAA,IAAAC,SAAAhO,MAAA,YACAvD,KAAAqQ,EAAAxG,KAAAyH,IAAA,IAAAC,SAAAhO,MAAA,YACAvD,KAAAsQ,EAAAzG,KAAAyH,IAAA,IAAAC,SAAAhO,MAAA,YAEAvD,KAMA,2CAAA8I,KAAAsI,OAAA,CAEA,GAAA7N,OAAA,wCAAA8N,KAAAD,MAMA,OAJApR,MAAAoQ,EAAAvG,KAAAyH,IAAA,IAAAC,SAAAhO,MAAA,YACAvD,KAAAqQ,EAAAxG,KAAAyH,IAAA,IAAAC,SAAAhO,MAAA,YACAvD,KAAAsQ,EAAAzG,KAAAyH,IAAA,IAAAC,SAAAhO,MAAA,YAEAvD,KAMA,wBAAuB8I,KAAAsI,OAAA,CAEvB,GAAA7N,OAAA,qBAA+B8N,KAAAD,MAI/B,OAFApR,MAAAyQ,OAAAc,SAAAhO,MAAA,QAEAvD,KAMA,yCAAA8I,KAAAsI,OAAA,CAEA,GAAA7N,OAAA,sCAAA8N,KAAAD,MAIA,OAFApR,MAAAyQ,OAAAc,SAAAhO,MAAA,GAAAA,MAAA,GAAAA,MAAA,GAAAA,MAAA,GAAAA,MAAA,GAAAA,MAAA,QAEAvD,KAMA,iBAAA8I,KAAAsI,QAEApR,KAAAyQ,OAAA/G,MAAA8H,cAAAJ,QAEApR,MAJA,QAWAwQ,KAAA,SAAAjN,OAMA,MAJAvD,MAAAoQ,EAAA7M,MAAA6M,EACApQ,KAAAqQ,EAAA9M,MAAA8M,EACArQ,KAAAsQ,EAAA/M,MAAA+M,EAEAtQ,MAIAyR,kBAAA,SAAAlO,MAAAmO,aAQA,MANA9H,UAAA8H,0BAAA,GAEA1R,KAAAoQ,EAAAvG,KAAA8H,IAAApO,MAAA6M,EAAAsB,aACA1R,KAAAqQ,EAAAxG,KAAA8H,IAAApO,MAAA8M,EAAAqB,aACA1R,KAAAsQ,EAAAzG,KAAA8H,IAAApO,MAAA+M,EAAAoB,aAEA1R,MAIA4R,kBAAA,SAAArO,MAAAmO,aAEA9H,SAAA8H,0BAAA,EAEA,IAAAG,aAAAH,YAAA,IAAAA,YAAA,CAMA,OAJA1R,MAAAoQ,EAAAvG,KAAA8H,IAAApO,MAAA6M,EAAAyB,aACA7R,KAAAqQ,EAAAxG,KAAA8H,IAAApO,MAAA8M,EAAAwB,aACA7R,KAAAsQ,EAAAzG,KAAA8H,IAAApO,MAAA+M,EAAAuB,aAEA7R,MAIA8R,qBAAA,WAEA,GAAA1B,GAAApQ,KAAAoQ,EAAAC,EAAArQ,KAAAqQ,EAAAC,EAAAtQ,KAAAsQ,CAMA,OAJAtQ,MAAAoQ,MACApQ,KAAAqQ,MACArQ,KAAAsQ,MAEAtQ,MAIA+R,qBAAA,WAMA,MAJA/R,MAAAoQ,EAAAvG,KAAAmI,KAAAhS,KAAAoQ,GACApQ,KAAAqQ,EAAAxG,KAAAmI,KAAAhS,KAAAqQ,GACArQ,KAAAsQ,EAAAzG,KAAAmI,KAAAhS,KAAAsQ,GAEAtQ,MAIAiS,OAAA,WAEA,WAAAjS,KAAAoQ,GAAA,OAAApQ,KAAAqQ,GAAA,MAAArQ,KAAAsQ,GAAA,GAIA4B,aAAA,WAEA,gBAAAlS,KAAAiS,SAAAzN,SAAA,KAAA2N,MAAA,KAIAC,OAAA,SAAAC,gBAIA,GAOAC,KAAAC,WAPAC,IAAAH,iBAA+BvB,EAAA,EAAAC,EAAA,EAAAC,EAAA,GAE/BZ,EAAApQ,KAAAoQ,EAAAC,EAAArQ,KAAAqQ,EAAAC,EAAAtQ,KAAAsQ,EAEAmC,IAAA5I,KAAA4I,IAAArC,EAAAC,EAAAC,GACAgB,IAAAzH,KAAAyH,IAAAlB,EAAAC,EAAAC,GAGAoC,WAAApB,IAAAmB,KAAA,CAEA,IAAAnB,MAAAmB,IAEAH,IAAA,EACAC,WAAA,MAEG,CAEH,GAAAI,OAAAF,IAAAnB,GAIA,QAFAiB,WAAA,IAAAG,UAAAC,OAAAF,IAAAnB,KAAAqB,OAAA,EAAAF,IAAAnB,KAEAmB,KAEA,IAAArC,GAAAkC,KAAAjC,EAAAC,GAAAqC,OAAArC,EAAAD,EAAA,IAAwD,MACxD,KAAAA,GAAAiC,KAAAhC,EAAAF,GAAAuC,MAAA,CAAwC,MACxC,KAAArC,GAAAgC,KAAAlC,EAAAC,GAAAsC,MAAA,EAIAL,KAAA,EAQA,MAJAE,KAAA1B,EAAAwB,IACAE,IAAAzB,EAAAwB,WACAC,IAAAxB,EAAA0B,UAEAF,KAIAI,SAAA,WAEA,kBAAA5S,KAAAoQ,EAAA,YAAApQ,KAAAqQ,EAAA,YAAArQ,KAAAsQ,EAAA,QAIAuC,UAAA,SAAA/B,EAAAC,EAAAC,GAEA,GAAAwB,KAAAxS,KAAAoS,QAMA,OAJAI,KAAA1B,KAAa0B,IAAAzB,KAAYyB,IAAAxB,KAEzBhR,KAAA6Q,OAAA2B,IAAA1B,EAAA0B,IAAAzB,EAAAyB,IAAAxB,GAEAhR,MAIA2D,IAAA,SAAAJ,OAMA,MAJAvD,MAAAoQ,GAAA7M,MAAA6M,EACApQ,KAAAqQ,GAAA9M,MAAA8M,EACArQ,KAAAsQ,GAAA/M,MAAA+M,EAEAtQ,MAIA8S,UAAA,SAAAC,OAAAC,QAMA,MAJAhT,MAAAoQ,EAAA2C,OAAA3C,EAAA4C,OAAA5C,EACApQ,KAAAqQ,EAAA0C,OAAA1C,EAAA2C,OAAA3C,EACArQ,KAAAsQ,EAAAyC,OAAAzC,EAAA0C,OAAA1C,EAEAtQ,MAIAiT,UAAA,SAAAlC,GAMA,MAJA/Q,MAAAoQ,GAAAW,EACA/Q,KAAAqQ,GAAAU,EACA/Q,KAAAsQ,GAAAS,EAEA/Q,MAIAkT,SAAA,SAAA3P,OAMA,MAJAvD,MAAAoQ,GAAA7M,MAAA6M,EACApQ,KAAAqQ,GAAA9M,MAAA8M,EACArQ,KAAAsQ,GAAA/M,MAAA+M,EAEAtQ,MAIAmT,eAAA,SAAApC,GAMA,MAJA/Q,MAAAoQ,GAAAW,EACA/Q,KAAAqQ,GAAAU,EACA/Q,KAAAsQ,GAAAS,EAEA/Q,MAIAoT,KAAA,SAAA7P,MAAA8P,OAMA,MAJArT,MAAAoQ,IAAA7M,MAAA6M,EAAApQ,KAAAoQ,GAAAiD,MACArT,KAAAqQ,IAAA9M,MAAA8M,EAAArQ,KAAAqQ,GAAAgD,MACArT,KAAAsQ,IAAA/M,MAAA+M,EAAAtQ,KAAAsQ,GAAA+C,MAEArT,MAIAsT,OAAA,SAAA9T,GAEA,MAAAA,GAAA4Q,IAAApQ,KAAAoQ,GAAA5Q,EAAA6Q,IAAArQ,KAAAqQ,GAAA7Q,EAAA8Q,IAAAtQ,KAAAsQ,GAIAiD,UAAA,SAAAC,OAMA,MAJAxT,MAAAoQ,EAAAoD,MAAA,GACAxT,KAAAqQ,EAAAmD,MAAA,GACAxT,KAAAsQ,EAAAkD,MAAA,GAEAxT,MAIAyT,QAAA,SAAAD,MAAAE,QASA,MAPA9J,UAAA4J,kBACA5J,SAAA8J,gBAAA,GAEAF,MAAAE,QAAA1T,KAAAoQ,EACAoD,MAAAE,OAAA,GAAA1T,KAAAqQ,EACAmD,MAAAE,OAAA,GAAA1T,KAAAsQ,EAEAkD,OAGAG,MAAA,WAEA,UAAAjK,OAAAuG,OAAAC,OAAAlQ,KAAAoQ,EAAApQ,KAAAqQ,EAAArQ,KAAAsQ,KAMA5G,MAAA8H,eAAuBoC,UAAA,SAAAC,aAAA,SAAAC,KAAA,MAAAC,WAAA,QAAAC,MAAA,SACvBC,MAAA,SAAAC,OAAA,SAAAC,MAAA,EAAAC,eAAA,SAAAC,KAAA,IAAAC,WAAA,QACAC,MAAA,SAAAC,UAAA,SAAAC,UAAA,QAAAC,WAAA,QAAAC,UAAA,SAAAC,MAAA,SACAC,eAAA,QAAAC,SAAA,SAAAC,QAAA,SAAAC,KAAA,MAAAC,SAAA,IAAAC,SAAA,MACAC,cAAA,SAAAC,SAAA,SAAAC,UAAA,MAAAC,SAAA,SAAAC,UAAA,SAAAC,YAAA,QACAC,eAAA,QAAAC,WAAA,SAAAC,WAAA,SAAAC,QAAA,QAAAC,WAAA,SAAAC,aAAA,QACAC,cAAA,QAAAC,cAAA,QAAAC,cAAA,QAAAC,cAAA,MAAAC,WAAA,QACAC,SAAA,SAAAC,YAAA,MAAAC,QAAA,QAAAC,QAAA,QAAAC,WAAA,QAAAC,UAAA,SACAC,YAAA,SAAAC,YAAA,QAAAC,QAAA,SAAAC,UAAA,SAAAC,WAAA,SAAAC,KAAA,SACAC,UAAA,SAAAC,KAAA,QAAAC,MAAA,MAAAC,YAAA,SAAAC,KAAA,QAAAC,SAAA,SAAAC,QAAA,SACAC,UAAA,SAAAC,OAAA,QAAAC,MAAA,SAAAC,MAAA,SAAAC,SAAA,SAAAC,cAAA,SAAAC,UAAA,QACAC,aAAA,SAAAC,UAAA,SAAAC,WAAA,SAAAC,UAAA,SAAAC,qBAAA,SAAAC,UAAA,SACAC,WAAA,QAAAC,UAAA,SAAAC,UAAA,SAAAC,YAAA,SAAAC,cAAA,QAAAC,aAAA,QACAC,eAAA,QAAAC,eAAA,QAAAC,eAAA,SAAAC,YAAA,SAAAC,KAAA,MAAAC,UAAA,QACAC,MAAA,SAAAC,QAAA,SAAAC,OAAA,QAAAC,iBAAA,QAAAC,WAAA,IAAAC,aAAA,SACAC,aAAA,QAAAC,eAAA,QAAAC,gBAAA,QAAAC,kBAAA,MAAAC,gBAAA,QACAC,gBAAA,SAAAC,aAAA,QAAAC,UAAA,SAAAC,UAAA,SAAAC,SAAA,SAAAC,YAAA,SACAC,KAAA,IAAAC,QAAA,SAAAC,MAAA,QAAAC,UAAA,QAAAC,OAAA,SAAAC,UAAA,SAAAC,OAAA,SACAC,cAAA,SAAAC,UAAA,SAAAC,cAAA,SAAAC,cAAA,SAAAC,WAAA,SAAAC,UAAA,SACAC,KAAA,SAAAC,KAAA,SAAAC,KAAA,SAAAC,WAAA,SAAAC,OAAA,QAAAC,IAAA,SAAAC,UAAA,SACAC,UAAA,QAAAC,YAAA,QAAAC,OAAA,SAAAC,WAAA,SAAAC,SAAA,QAAAC,SAAA,SACAC,OAAA,SAAAC,OAAA,SAAAC,QAAA,QAAAC,UAAA,QAAAC,UAAA,QAAAC,UAAA,QAAAC,KAAA,SACAC,YAAA,MAAAC,UAAA,QAAAC,IAAA,SAAAC,KAAA,MAAAC,QAAA,SAAAC,OAAA,SAAAC,UAAA,QACAC,OAAA,SAAAC,MAAA,SAAAC,MAAA,SAAAC,WAAA,SAAAC,OAAA,SAAAC,YAAA,UAWApT,MAAAqT,WAAA,SAAA7Y,EAAAC,EAAAjB,EAAA8Z,GAEAhd,KAAAid,GAAA/Y,GAAA,EACAlE,KAAAkd,GAAA/Y,GAAA,EACAnE,KAAAmd,GAAAja,GAAA,EACAlD,KAAAod,GAAAxT,SAAAoT,IAAA,GAIAtT,MAAAqT,WAAAzc,WAEAM,YAAA8I,MAAAqT,WAEAE,GAAA,EAAAC,GAAA,EAAAC,GAAA,EAAAC,GAAA,EAEAC,GAAAnZ,KAEA,MAAAlE,MAAAid,IAIAI,GAAAnZ,GAAAqM,OAEAvQ,KAAAid,GAAA1M,MACAvQ,KAAAsd,oBAIAD,GAAAlZ,KAEA,MAAAnE,MAAAkd,IAIAG,GAAAlZ,GAAAoM,OAEAvQ,KAAAkd,GAAA3M,MACAvQ,KAAAsd,oBAIAD,GAAAna,KAEA,MAAAlD,MAAAmd,IAIAE,GAAAna,GAAAqN,OAEAvQ,KAAAmd,GAAA5M,MACAvQ,KAAAsd,oBAIAD,GAAAL,KAEA,MAAAhd,MAAAod,IAIAC,GAAAL,GAAAzM,OAEAvQ,KAAAod,GAAA7M,MACAvQ,KAAAsd,oBAIAnN,IAAA,SAAAjM,EAAAC,EAAAjB,EAAA8Z,GASA,MAPAhd,MAAAid,GAAA/Y,EACAlE,KAAAkd,GAAA/Y,EACAnE,KAAAmd,GAAAja,EACAlD,KAAAod,GAAAJ,EAEAhd,KAAAsd,mBAEAtd,MAIAwQ,KAAA,SAAA+M,YASA,MAPAvd,MAAAid,GAAAM,WAAArZ,EACAlE,KAAAkd,GAAAK,WAAApZ,EACAnE,KAAAmd,GAAAI,WAAAra,EACAlD,KAAAod,GAAAG,WAAAP,EAEAhd,KAAAsd,mBAEAtd,MAIAwd,aAAA,SAAAC,MAAAjX,QAEA,GAAAiX,gBAAA/T,OAAAgU,QAAA,EAEA,SAAAvU,OAAA,kGAOA,IAAAwU,IAAA9T,KAAA+T,IAAAH,MAAAR,GAAA,GACAY,GAAAhU,KAAA+T,IAAAH,MAAAP,GAAA,GACAY,GAAAjU,KAAA+T,IAAAH,MAAAN,GAAA,GACAY,GAAAlU,KAAAmU,IAAAP,MAAAR,GAAA,GACAgB,GAAApU,KAAAmU,IAAAP,MAAAP,GAAA,GACAgB,GAAArU,KAAAmU,IAAAP,MAAAN,GAAA,EAgDA,OA9CA,QAAAM,MAAAU,OAEAne,KAAAid,GAAAc,GAAAF,GAAAC,GAAAH,GAAAM,GAAAC,GACAle,KAAAkd,GAAAS,GAAAM,GAAAH,GAAAC,GAAAF,GAAAK,GACAle,KAAAmd,GAAAQ,GAAAE,GAAAK,GAAAH,GAAAE,GAAAH,GACA9d,KAAAod,GAAAO,GAAAE,GAAAC,GAAAC,GAAAE,GAAAC,IAEG,QAAAT,MAAAU,OAEHne,KAAAid,GAAAc,GAAAF,GAAAC,GAAAH,GAAAM,GAAAC,GACAle,KAAAkd,GAAAS,GAAAM,GAAAH,GAAAC,GAAAF,GAAAK,GACAle,KAAAmd,GAAAQ,GAAAE,GAAAK,GAAAH,GAAAE,GAAAH,GACA9d,KAAAod,GAAAO,GAAAE,GAAAC,GAAAC,GAAAE,GAAAC,IAEG,QAAAT,MAAAU,OAEHne,KAAAid,GAAAc,GAAAF,GAAAC,GAAAH,GAAAM,GAAAC,GACAle,KAAAkd,GAAAS,GAAAM,GAAAH,GAAAC,GAAAF,GAAAK,GACAle,KAAAmd,GAAAQ,GAAAE,GAAAK,GAAAH,GAAAE,GAAAH,GACA9d,KAAAod,GAAAO,GAAAE,GAAAC,GAAAC,GAAAE,GAAAC,IAEG,QAAAT,MAAAU,OAEHne,KAAAid,GAAAc,GAAAF,GAAAC,GAAAH,GAAAM,GAAAC,GACAle,KAAAkd,GAAAS,GAAAM,GAAAH,GAAAC,GAAAF,GAAAK,GACAle,KAAAmd,GAAAQ,GAAAE,GAAAK,GAAAH,GAAAE,GAAAH,GACA9d,KAAAod,GAAAO,GAAAE,GAAAC,GAAAC,GAAAE,GAAAC,IAEG,QAAAT,MAAAU,OAEHne,KAAAid,GAAAc,GAAAF,GAAAC,GAAAH,GAAAM,GAAAC,GACAle,KAAAkd,GAAAS,GAAAM,GAAAH,GAAAC,GAAAF,GAAAK,GACAle,KAAAmd,GAAAQ,GAAAE,GAAAK,GAAAH,GAAAE,GAAAH,GACA9d,KAAAod,GAAAO,GAAAE,GAAAC,GAAAC,GAAAE,GAAAC,IAEG,QAAAT,MAAAU,QAEHne,KAAAid,GAAAc,GAAAF,GAAAC,GAAAH,GAAAM,GAAAC,GACAle,KAAAkd,GAAAS,GAAAM,GAAAH,GAAAC,GAAAF,GAAAK,GACAle,KAAAmd,GAAAQ,GAAAE,GAAAK,GAAAH,GAAAE,GAAAH,GACA9d,KAAAod,GAAAO,GAAAE,GAAAC,GAAAC,GAAAE,GAAAC,IAIA1X,UAAA,GAAAxG,KAAAsd,mBAEAtd,MAIAoe,iBAAA,SAAAC,KAAAC,OAMA,GAAAC,WAAAD,MAAA,EAAAvN,EAAAlH,KAAAmU,IAAAO,UASA,OAPAve,MAAAid,GAAAoB,KAAAna,EAAA6M,EACA/Q,KAAAkd,GAAAmB,KAAAla,EAAA4M,EACA/Q,KAAAmd,GAAAkB,KAAAnb,EAAA6N,EACA/Q,KAAAod,GAAAvT,KAAA+T,IAAAW,WAEAve,KAAAsd,mBAEAtd,MAIAwe,sBAAA,SAAAjf,GAMA,GAOAwR,GAPA0N,GAAAlf,EAAAmf,SAEAC,IAAAF,GAAA,GAAAG,IAAAH,GAAA,GAAAI,IAAAJ,GAAA,GACAK,IAAAL,GAAA,GAAAM,IAAAN,GAAA,GAAAO,IAAAP,GAAA,GACAQ,IAAAR,GAAA,GAAAS,IAAAT,GAAA,GAAAU,IAAAV,GAAA,IAEAW,MAAAT,IAAAI,IAAAI,GA2CA,OAxCAC,OAAA,GAEArO,EAAA,GAAAlH,KAAAmI,KAAAoN,MAAA,GAEApf,KAAAod,GAAA,IAAArM,EACA/Q,KAAAid,IAAAiC,IAAAF,KAAAjO,EACA/Q,KAAAkd,IAAA2B,IAAAI,KAAAlO,EACA/Q,KAAAmd,IAAA2B,IAAAF,KAAA7N,GAEG4N,IAAAI,KAAAJ,IAAAQ,KAEHpO,EAAA,EAAAlH,KAAAmI,KAAA,EAAA2M,IAAAI,IAAAI,KAEAnf,KAAAod,IAAA8B,IAAAF,KAAAjO,EACA/Q,KAAAid,GAAA,IAAAlM,EACA/Q,KAAAkd,IAAA0B,IAAAE,KAAA/N,EACA/Q,KAAAmd,IAAA0B,IAAAI,KAAAlO,GAEGgO,IAAAI,KAEHpO,EAAA,EAAAlH,KAAAmI,KAAA,EAAA+M,IAAAJ,IAAAQ,KAEAnf,KAAAod,IAAAyB,IAAAI,KAAAlO,EACA/Q,KAAAid,IAAA2B,IAAAE,KAAA/N,EACA/Q,KAAAkd,GAAA,IAAAnM,EACA/Q,KAAAmd,IAAA6B,IAAAE,KAAAnO,IAIAA,EAAA,EAAAlH,KAAAmI,KAAA,EAAAmN,IAAAR,IAAAI,KAEA/e,KAAAod,IAAA0B,IAAAF,KAAA7N,EACA/Q,KAAAid,IAAA4B,IAAAI,KAAAlO,EACA/Q,KAAAkd,IAAA8B,IAAAE,KAAAnO,EACA/Q,KAAAmd,GAAA,IAAApM,GAIA/Q,KAAAsd,mBAEAtd,MAIAqf,mBAAA,WAMA,GAAAC,IAAAlP,EAEAmP,IAAA,IAEA,iBAAAC,MAAAC,KAiCA,MA/BA7V,UAAA0V,QAAA,GAAA5V,OAAAgW,SAEAtP,EAAAoP,MAAAG,IAAAF,KAAA,EAEAF,IAAAnP,GAEAA,EAAA,EAEAvG,KAAA+V,IAAAJ,MAAAtb,GAAA2F,KAAA+V,IAAAJ,MAAAtc,GAEAoc,GAAAnP,KAAAqP,MAAArb,EAAAqb,MAAAtb,EAAA,GAIAob,GAAAnP,IAAA,GAAAqP,MAAAtc,EAAAsc,MAAArb,IAMAmb,GAAAO,aAAAL,MAAAC,KAIAzf,KAAAid,GAAAqC,GAAApb,EACAlE,KAAAkd,GAAAoC,GAAAnb,EACAnE,KAAAmd,GAAAmC,GAAApc,EACAlD,KAAAod,GAAAhN,EAEApQ,KAAA8f,YAEA9f,SAMA+f,QAAA,WAIA,MAFA/f,MAAAggB,YAAAF,YAEA9f,MAIAggB,UAAA,WAQA,MANAhgB,MAAAid,IAAA,GACAjd,KAAAkd,IAAA,GACAld,KAAAmd,IAAA,GAEAnd,KAAAsd,mBAEAtd,MAIA2f,IAAA,SAAAM,GAEA,MAAAjgB,MAAAid,GAAAgD,EAAAhD,GAAAjd,KAAAkd,GAAA+C,EAAA/C,GAAAld,KAAAmd,GAAA8C,EAAA9C,GAAAnd,KAAAod,GAAA6C,EAAA7C,IAIA8C,SAAA,WAEA,MAAAlgB,MAAAid,GAAAjd,KAAAid,GAAAjd,KAAAkd,GAAAld,KAAAkd,GAAAld,KAAAmd,GAAAnd,KAAAmd,GAAAnd,KAAAod,GAAApd,KAAAod,IAIAzY,OAAA,WAEA,MAAAkF,MAAAmI,KAAAhS,KAAAid,GAAAjd,KAAAid,GAAAjd,KAAAkd,GAAAld,KAAAkd,GAAAld,KAAAmd,GAAAnd,KAAAmd,GAAAnd,KAAAod,GAAApd,KAAAod,KAIA0C,UAAA,WAEA,GAAA9O,GAAAhR,KAAA2E,QAsBA,OApBA,KAAAqM,GAEAhR,KAAAid,GAAA,EACAjd,KAAAkd,GAAA,EACAld,KAAAmd,GAAA,EACAnd,KAAAod,GAAA,IAIApM,EAAA,EAAAA,EAEAhR,KAAAid,GAAAjd,KAAAid,GAAAjM,EACAhR,KAAAkd,GAAAld,KAAAkd,GAAAlM,EACAhR,KAAAmd,GAAAnd,KAAAmd,GAAAnM,EACAhR,KAAAod,GAAApd,KAAAod,GAAApM,GAIAhR,KAAAsd,mBAEAtd,MAIAkT,SAAA,SAAAhC,EAAAzR,GAEA,MAAAmK,UAAAnK,GAEAiK,MAAAK,KAAA,0GACA/J,KAAAmgB,oBAAAjP,EAAAzR,IAIAO,KAAAmgB,oBAAAngB,KAAAkR,IAIAiP,oBAAA,SAAAC,EAAA9P,GAIA,GAAA+P,KAAAD,EAAAnD,GAAAqD,IAAAF,EAAAlD,GAAAqD,IAAAH,EAAAjD,GAAAqD,IAAAJ,EAAAhD,GACAqD,IAAAnQ,EAAA2M,GAAAyD,IAAApQ,EAAA4M,GAAAyD,IAAArQ,EAAA6M,GAAAyD,IAAAtQ,EAAA8M,EASA,OAPApd,MAAAid,GAAAoD,IAAAO,IAAAJ,IAAAC,IAAAH,IAAAK,IAAAJ,IAAAG,IACA1gB,KAAAkd,GAAAoD,IAAAM,IAAAJ,IAAAE,IAAAH,IAAAE,IAAAJ,IAAAM,IACA3gB,KAAAmd,GAAAoD,IAAAK,IAAAJ,IAAAG,IAAAN,IAAAK,IAAAJ,IAAAG,IACAzgB,KAAAod,GAAAoD,IAAAI,IAAAP,IAAAI,IAAAH,IAAAI,IAAAH,IAAAI,IAEA3gB,KAAAsd,mBAEAtd,MAIA6gB,gBAAA,SAAAnR,QAGA,MADAhG,OAAAK,KAAA,mHACA2F,OAAAoR,gBAAA9gB,OAIA+gB,MAAA,SAAAC,GAAA7P,GAEA,OAAAA,EAAA,MAAAnR,KACA,QAAAmR,EAAA,MAAAnR,MAAAwQ,KAAAwQ,GAEA,IAAA9c,GAAAlE,KAAAid,GAAA9Y,EAAAnE,KAAAkd,GAAAha,EAAAlD,KAAAmd,GAAAH,EAAAhd,KAAAod,GAIA6D,aAAAjE,EAAAgE,GAAA5D,GAAAlZ,EAAA8c,GAAA/D,GAAA9Y,EAAA6c,GAAA9D,GAAAha,EAAA8d,GAAA7D,EAiBA,IAfA,EAAA8D,cAEAjhB,KAAAod,IAAA4D,GAAA5D,GACApd,KAAAid,IAAA+D,GAAA/D,GACAjd,KAAAkd,IAAA8D,GAAA9D,GACAld,KAAAmd,IAAA6D,GAAA7D,GAEA8D,4BAIAjhB,KAAAwQ,KAAAwQ,IAIAC,cAAA,EAOA,MALAjhB,MAAAod,GAAAJ,EACAhd,KAAAid,GAAA/Y,EACAlE,KAAAkd,GAAA/Y,EACAnE,KAAAmd,GAAAja,EAEAlD,IAIA,IAAAkhB,WAAArX,KAAAsX,KAAAF,cACAG,aAAAvX,KAAAmI,KAAA,EAAAiP,0BAEA,IAAApX,KAAA+V,IAAAwB,cAAA,KAOA,MALAphB,MAAAod,GAAA,IAAAJ,EAAAhd,KAAAod,IACApd,KAAAid,GAAA,IAAA/Y,EAAAlE,KAAAid,IACAjd,KAAAkd,GAAA,IAAA/Y,EAAAnE,KAAAkd,IACAld,KAAAmd,GAAA,IAAAja,EAAAlD,KAAAmd,IAEAnd,IAIA,IAAAqhB,QAAAxX,KAAAmU,KAAA,EAAA7M,GAAA+P,WAAAE,aACAE,OAAAzX,KAAAmU,IAAA7M,EAAA+P,WAAAE,YASA,OAPAphB,MAAAod,GAAAJ,EAAAqE,OAAArhB,KAAAod,GAAAkE,OACAthB,KAAAid,GAAA/Y,EAAAmd,OAAArhB,KAAAid,GAAAqE,OACAthB,KAAAkd,GAAA/Y,EAAAkd,OAAArhB,KAAAkd,GAAAoE,OACAthB,KAAAmd,GAAAja,EAAAme,OAAArhB,KAAAmd,GAAAmE,OAEAthB,KAAAsd,mBAEAtd,MAIAsT,OAAA,SAAAiK,YAEA,MAAAA,YAAAN,KAAAjd,KAAAid,IAAAM,WAAAL,KAAAld,KAAAkd,IAAAK,WAAAJ,KAAAnd,KAAAmd,IAAAI,WAAAH,KAAApd,KAAAod,IAIA7J,UAAA,SAAAC,MAAAE,QAWA,MATA9J,UAAA8J,gBAAA,GAEA1T,KAAAid,GAAAzJ,MAAAE,QACA1T,KAAAkd,GAAA1J,MAAAE,OAAA,GACA1T,KAAAmd,GAAA3J,MAAAE,OAAA,GACA1T,KAAAod,GAAA5J,MAAAE,OAAA,GAEA1T,KAAAsd,mBAEAtd,MAIAyT,QAAA,SAAAD,MAAAE,QAUA,MARA9J,UAAA4J,kBACA5J,SAAA8J,gBAAA,GAEAF,MAAAE,QAAA1T,KAAAid,GACAzJ,MAAAE,OAAA,GAAA1T,KAAAkd,GACA1J,MAAAE,OAAA,GAAA1T,KAAAmd,GACA3J,MAAAE,OAAA,GAAA1T,KAAAod,GAEA5J,OAIA+N,SAAA,SAAAC,UAIA,MAFAxhB,MAAAsd,iBAAAkE,SAEAxhB,MAIAsd,iBAAA,aAEA3J,MAAA,WAEA,UAAAjK,OAAAqT,WAAA/c,KAAAid,GAAAjd,KAAAkd,GAAAld,KAAAmd,GAAAnd,KAAAod,MAMA1T,MAAAqT,WAAAgE,MAAA,SAAAU,GAAAT,GAAAU,GAAAvQ,GAEA,MAAAuQ,IAAAlR,KAAAiR,IAAAV,MAAAC,GAAA7P,IAaAzH,MAAAiY,QAAA,SAAAzd,EAAAC,GAEAnE,KAAAkE,KAAA,EACAlE,KAAAmE,KAAA,GAIAuF,MAAAiY,QAAArhB,WAEAM,YAAA8I,MAAAiY,QAEAxR,IAAA,SAAAjM,EAAAC,GAKA,MAHAnE,MAAAkE,IACAlE,KAAAmE,IAEAnE,MAIA4hB,KAAA,SAAA1d,GAIA,MAFAlE,MAAAkE,IAEAlE,MAIA6hB,KAAA,SAAA1d,GAIA,MAFAnE,MAAAmE,IAEAnE,MAIA8hB,aAAA,SAAApa,MAAA6I,OAEA,OAAA7I,OAEA,OAAA1H,KAAAkE,EAAAqM,KAA0B,MAC1B,QAAAvQ,KAAAmE,EAAAoM,KAA0B,MAC1B,kBAAApH,OAAA,0BAAAzB,SAMAqa,aAAA,SAAAra,OAEA,OAAAA,OAEA,aAAA1H,MAAAkE,CACA,cAAAlE,MAAAmE,CACA,kBAAAgF,OAAA,0BAAAzB,SAMA8I,KAAA,SAAAyP,GAKA,MAHAjgB,MAAAkE,EAAA+b,EAAA/b,EACAlE,KAAAmE,EAAA8b,EAAA9b,EAEAnE,MAIA2D,IAAA,SAAAsc,EAAAjD,GAEA,MAAApT,UAAAoT,GAEAtT,MAAAK,KAAA,yFACA/J,KAAAgiB,WAAA/B,EAAAjD,KAIAhd,KAAAkE,GAAA+b,EAAA/b,EACAlE,KAAAmE,GAAA8b,EAAA9b,EAEAnE,OAIAiT,UAAA,SAAAlC,GAKA,MAHA/Q,MAAAkE,GAAA6M,EACA/Q,KAAAmE,GAAA4M,EAEA/Q,MAIAgiB,WAAA,SAAA5B,EAAA9P,GAKA,MAHAtQ,MAAAkE,EAAAkc,EAAAlc,EAAAoM,EAAApM,EACAlE,KAAAmE,EAAAic,EAAAjc,EAAAmM,EAAAnM,EAEAnE,MAIAQ,IAAA,SAAAyf,EAAAjD,GAEA,MAAApT,UAAAoT,GAEAtT,MAAAK,KAAA,yFACA/J,KAAAiiB,WAAAhC,EAAAjD,KAIAhd,KAAAkE,GAAA+b,EAAA/b,EACAlE,KAAAmE,GAAA8b,EAAA9b,EAEAnE,OAIAkiB,UAAA,SAAAnR,GAKA,MAHA/Q,MAAAkE,GAAA6M,EACA/Q,KAAAmE,GAAA4M,EAEA/Q,MAIAiiB,WAAA,SAAA7B,EAAA9P,GAKA,MAHAtQ,MAAAkE,EAAAkc,EAAAlc,EAAAoM,EAAApM,EACAlE,KAAAmE,EAAAic,EAAAjc,EAAAmM,EAAAnM,EAEAnE,MAIAkT,SAAA,SAAA+M,GAKA,MAHAjgB,MAAAkE,GAAA+b,EAAA/b,EACAlE,KAAAmE,GAAA8b,EAAA9b,EAEAnE,MAIAmT,eAAA,SAAApC,GAKA,MAHA/Q,MAAAkE,GAAA6M,EACA/Q,KAAAmE,GAAA4M,EAEA/Q,MAIAmiB,OAAA,SAAAlC,GAKA,MAHAjgB,MAAAkE,GAAA+b,EAAA/b,EACAlE,KAAAmE,GAAA8b,EAAA9b,EAEAnE,MAIAoiB,aAAA,SAAAC,QAEA,OAAAA,OAAA,CAEA,GAAAC,WAAA,EAAAD,MAEAriB,MAAAkE,GAAAoe,UACAtiB,KAAAmE,GAAAme,cAIAtiB,MAAAkE,EAAA,EACAlE,KAAAmE,EAAA,CAIA,OAAAnE,OAIAsR,IAAA,SAAA2O,GAcA,MAZAjgB,MAAAkE,EAAA+b,EAAA/b,IAEAlE,KAAAkE,EAAA+b,EAAA/b,GAIAlE,KAAAmE,EAAA8b,EAAA9b,IAEAnE,KAAAmE,EAAA8b,EAAA9b,GAIAnE,MAIAyS,IAAA,SAAAwN,GAcA,MAZAjgB,MAAAkE,EAAA+b,EAAA/b,IAEAlE,KAAAkE,EAAA+b,EAAA/b,GAIAlE,KAAAmE,EAAA8b,EAAA9b,IAEAnE,KAAAmE,EAAA8b,EAAA9b,GAIAnE,MAIAuiB,MAAA,SAAAjR,IAAAmB,KAwBA,MApBAzS,MAAAkE,EAAAoN,IAAApN,EAEAlE,KAAAkE,EAAAoN,IAAApN,EAEGlE,KAAAkE,EAAAuO,IAAAvO,IAEHlE,KAAAkE,EAAAuO,IAAAvO,GAIAlE,KAAAmE,EAAAmN,IAAAnN,EAEAnE,KAAAmE,EAAAmN,IAAAnN,EAEGnE,KAAAmE,EAAAsO,IAAAtO,IAEHnE,KAAAmE,EAAAsO,IAAAtO,GAIAnE,MAGAwiB,YAAA,WAEA,GAAAlR,KAAAmB,GAEA,iBAAAgQ,OAAAC,QAYA,MAVA9Y,UAAA0H,MAEAA,IAAA,GAAA5H,OAAAiY,QACAlP,IAAA,GAAA/I,OAAAiY,SAIArQ,IAAAnB,IAAAsS,eACAhQ,IAAAtC,IAAAuS,eAEA1iB,KAAAuiB,MAAAjR,IAAAmB,SAMA7B,MAAA,WAKA,MAHA5Q,MAAAkE,EAAA2F,KAAA+G,MAAA5Q,KAAAkE,GACAlE,KAAAmE,EAAA0F,KAAA+G,MAAA5Q,KAAAmE,GAEAnE,MAIA2iB,KAAA,WAKA,MAHA3iB,MAAAkE,EAAA2F,KAAA8Y,KAAA3iB,KAAAkE,GACAlE,KAAAmE,EAAA0F,KAAA8Y,KAAA3iB,KAAAmE,GAEAnE,MAIA4iB,MAAA,WAKA,MAHA5iB,MAAAkE,EAAA2F,KAAA+Y,MAAA5iB,KAAAkE,GACAlE,KAAAmE,EAAA0F,KAAA+Y,MAAA5iB,KAAAmE,GAEAnE,MAIA6iB,YAAA,WAKA,MAHA7iB,MAAAkE,EAAAlE,KAAAkE,EAAA,EAAA2F,KAAA8Y,KAAA3iB,KAAAkE,GAAA2F,KAAA+G,MAAA5Q,KAAAkE,GACAlE,KAAAmE,EAAAnE,KAAAmE,EAAA,EAAA0F,KAAA8Y,KAAA3iB,KAAAmE,GAAA0F,KAAA+G,MAAA5Q,KAAAmE,GAEAnE,MAIA8iB,OAAA,WAKA,MAHA9iB,MAAAkE,GAAAlE,KAAAkE,EACAlE,KAAAmE,GAAAnE,KAAAmE,EAEAnE,MAIA2f,IAAA,SAAAM,GAEA,MAAAjgB,MAAAkE,EAAA+b,EAAA/b,EAAAlE,KAAAmE,EAAA8b,EAAA9b,GAIA+b,SAAA,WAEA,MAAAlgB,MAAAkE,EAAAlE,KAAAkE,EAAAlE,KAAAmE,EAAAnE,KAAAmE,GAIAQ,OAAA,WAEA,MAAAkF,MAAAmI,KAAAhS,KAAAkE,EAAAlE,KAAAkE,EAAAlE,KAAAmE,EAAAnE,KAAAmE,IAIA2b,UAAA,WAEA,MAAA9f,MAAAoiB,aAAApiB,KAAA2E,WAIAoe,WAAA,SAAA9C,GAEA,MAAApW,MAAAmI,KAAAhS,KAAAgjB,kBAAA/C,KAIA+C,kBAAA,SAAA/C,GAEA,GAAAgD,IAAAjjB,KAAAkE,EAAA+b,EAAA/b,EAAAgf,GAAAljB,KAAAmE,EAAA8b,EAAA9b,CACA,OAAA8e,OAAAC,OAIAC,UAAA,SAAAnS,GAEA,GAAAoS,WAAApjB,KAAA2E,QAOA,OALA,KAAAye,WAAApS,IAAAoS,WAEApjB,KAAAmT,eAAAnC,EAAAoS,WAGApjB,MAIAoT,KAAA,SAAA6M,EAAA5M,OAKA,MAHArT,MAAAkE,IAAA+b,EAAA/b,EAAAlE,KAAAkE,GAAAmP,MACArT,KAAAmE,IAAA8b,EAAA9b,EAAAnE,KAAAmE,GAAAkP,MAEArT,MAIAqjB,YAAA,SAAA/D,GAAAgE,GAAAjQ,OAIA,MAFArT,MAAAiiB,WAAAqB,GAAAhE,IAAAnM,eAAAE,OAAA1P,IAAA2b,IAEAtf,MAIAsT,OAAA,SAAA2M,GAEA,MAAAA,GAAA/b,IAAAlE,KAAAkE,GAAA+b,EAAA9b,IAAAnE,KAAAmE,GAIAoP,UAAA,SAAAC,MAAAE,QAOA,MALA9J,UAAA8J,gBAAA,GAEA1T,KAAAkE,EAAAsP,MAAAE,QACA1T,KAAAmE,EAAAqP,MAAAE,OAAA,GAEA1T,MAIAyT,QAAA,SAAAD,MAAAE,QAQA,MANA9J,UAAA4J,kBACA5J,SAAA8J,gBAAA,GAEAF,MAAAE,QAAA1T,KAAAkE,EACAsP,MAAAE,OAAA,GAAA1T,KAAAmE,EAEAqP,OAIA+P,cAAA,SAAAC,UAAA9b,MAAAgM,QASA,MAPA9J,UAAA8J,gBAAA,GAEAhM,YAAA8b,UAAAC,SAAA/P,OAEA1T,KAAAkE,EAAAsf,UAAAhQ,MAAA9L,OACA1H,KAAAmE,EAAAqf,UAAAhQ,MAAA9L,MAAA,GAEA1H,MAIA2T,MAAA,WAEA,UAAAjK,OAAAiY,QAAA3hB,KAAAkE,EAAAlE,KAAAmE,KAiBAuF,MAAAgW,QAAA,SAAAxb,EAAAC,EAAAjB,GAEAlD,KAAAkE,KAAA,EACAlE,KAAAmE,KAAA,EACAnE,KAAAkD,KAAA,GAIAwG,MAAAgW,QAAApf,WAEAM,YAAA8I,MAAAgW,QAEAvP,IAAA,SAAAjM,EAAAC,EAAAjB,GAMA,MAJAlD,MAAAkE,IACAlE,KAAAmE,IACAnE,KAAAkD,IAEAlD,MAIA4hB,KAAA,SAAA1d,GAIA,MAFAlE,MAAAkE,IAEAlE,MAIA6hB,KAAA,SAAA1d,GAIA,MAFAnE,MAAAmE,IAEAnE,MAIA0jB,KAAA,SAAAxgB,GAIA,MAFAlD,MAAAkD,IAEAlD,MAIA8hB,aAAA,SAAApa,MAAA6I,OAEA,OAAA7I,OAEA,OAAA1H,KAAAkE,EAAAqM,KAA0B,MAC1B,QAAAvQ,KAAAmE,EAAAoM,KAA0B,MAC1B,QAAAvQ,KAAAkD,EAAAqN,KAA0B,MAC1B,kBAAApH,OAAA,0BAAAzB,SAMAqa,aAAA,SAAAra,OAEA,OAAAA,OAEA,aAAA1H,MAAAkE,CACA,cAAAlE,MAAAmE,CACA,cAAAnE,MAAAkD,CACA,kBAAAiG,OAAA,0BAAAzB,SAMA8I,KAAA,SAAAyP,GAMA,MAJAjgB,MAAAkE,EAAA+b,EAAA/b,EACAlE,KAAAmE,EAAA8b,EAAA9b,EACAnE,KAAAkD,EAAA+c,EAAA/c,EAEAlD,MAIA2D,IAAA,SAAAsc,EAAAjD,GAEA,MAAApT,UAAAoT,GAEAtT,MAAAK,KAAA,yFACA/J,KAAAgiB,WAAA/B,EAAAjD,KAIAhd,KAAAkE,GAAA+b,EAAA/b,EACAlE,KAAAmE,GAAA8b,EAAA9b,EACAnE,KAAAkD,GAAA+c,EAAA/c,EAEAlD,OAIAiT,UAAA,SAAAlC,GAMA,MAJA/Q,MAAAkE,GAAA6M,EACA/Q,KAAAmE,GAAA4M,EACA/Q,KAAAkD,GAAA6N,EAEA/Q,MAIAgiB,WAAA,SAAA5B,EAAA9P,GAMA,MAJAtQ,MAAAkE,EAAAkc,EAAAlc,EAAAoM,EAAApM,EACAlE,KAAAmE,EAAAic,EAAAjc,EAAAmM,EAAAnM,EACAnE,KAAAkD,EAAAkd,EAAAld,EAAAoN,EAAApN,EAEAlD,MAIAQ,IAAA,SAAAyf,EAAAjD,GAEA,MAAApT,UAAAoT,GAEAtT,MAAAK,KAAA,yFACA/J,KAAAiiB,WAAAhC,EAAAjD,KAIAhd,KAAAkE,GAAA+b,EAAA/b,EACAlE,KAAAmE,GAAA8b,EAAA9b,EACAnE,KAAAkD,GAAA+c,EAAA/c,EAEAlD,OAIAkiB,UAAA,SAAAnR,GAMA,MAJA/Q,MAAAkE,GAAA6M,EACA/Q,KAAAmE,GAAA4M,EACA/Q,KAAAkD,GAAA6N,EAEA/Q,MAIAiiB,WAAA,SAAA7B,EAAA9P,GAMA,MAJAtQ,MAAAkE,EAAAkc,EAAAlc,EAAAoM,EAAApM,EACAlE,KAAAmE,EAAAic,EAAAjc,EAAAmM,EAAAnM,EACAnE,KAAAkD,EAAAkd,EAAAld,EAAAoN,EAAApN,EAEAlD,MAIAkT,SAAA,SAAA+M,EAAAjD,GAEA,MAAApT,UAAAoT,GAEAtT,MAAAK,KAAA,mGACA/J,KAAA2jB,gBAAA1D,EAAAjD,KAIAhd,KAAAkE,GAAA+b,EAAA/b,EACAlE,KAAAmE,GAAA8b,EAAA9b,EACAnE,KAAAkD,GAAA+c,EAAA/c,EAEAlD,OAIAmT,eAAA,SAAAkP,QAMA,MAJAriB,MAAAkE,GAAAme,OACAriB,KAAAmE,GAAAke,OACAriB,KAAAkD,GAAAmf,OAEAriB,MAIA2jB,gBAAA,SAAAvD,EAAA9P,GAMA,MAJAtQ,MAAAkE,EAAAkc,EAAAlc,EAAAoM,EAAApM,EACAlE,KAAAmE,EAAAic,EAAAjc,EAAAmM,EAAAnM,EACAnE,KAAAkD,EAAAkd,EAAAld,EAAAoN,EAAApN,EAEAlD,MAIA4jB,WAAA,WAEA,GAAArG,WAEA,iBAAAE,OAYA,MAVAA,iBAAA/T,OAAAgU,QAAA,GAEAhU,MAAAM,MAAA,8FAIAJ,SAAA2T,wBAAA,GAAA7T,OAAAqT,YAEA/c,KAAA8gB,gBAAAvD,WAAAC,aAAAC,QAEAzd,SAMA6jB,eAAA,WAEA,GAAAtG,WAEA,iBAAAc,KAAAC,OAMA,MAJA1U,UAAA2T,wBAAA,GAAA7T,OAAAqT,YAEA/c,KAAA8gB,gBAAAvD,WAAAa,iBAAAC,KAAAC,QAEAte,SAMA8jB,aAAA,SAAAvkB;AAEA,GAAA2E,GAAAlE,KAAAkE,EACAC,EAAAnE,KAAAmE,EACAjB,EAAAlD,KAAAkD,EAEA6gB,EAAAxkB,EAAAmf,QAMA,OAJA1e,MAAAkE,EAAA6f,EAAA,GAAA7f,EAAA6f,EAAA,GAAA5f,EAAA4f,EAAA,GAAA7gB,EACAlD,KAAAmE,EAAA4f,EAAA,GAAA7f,EAAA6f,EAAA,GAAA5f,EAAA4f,EAAA,GAAA7gB,EACAlD,KAAAkD,EAAA6gB,EAAA,GAAA7f,EAAA6f,EAAA,GAAA5f,EAAA4f,EAAA,GAAA7gB,EAEAlD,MAIAgkB,aAAA,SAAAzkB,GAIA,GAAA2E,GAAAlE,KAAAkE,EAAAC,EAAAnE,KAAAmE,EAAAjB,EAAAlD,KAAAkD,EAEA6gB,EAAAxkB,EAAAmf,QAMA,OAJA1e,MAAAkE,EAAA6f,EAAA,GAAA7f,EAAA6f,EAAA,GAAA5f,EAAA4f,EAAA,GAAA7gB,EAAA6gB,EAAA,IACA/jB,KAAAmE,EAAA4f,EAAA,GAAA7f,EAAA6f,EAAA,GAAA5f,EAAA4f,EAAA,GAAA7gB,EAAA6gB,EAAA,IACA/jB,KAAAkD,EAAA6gB,EAAA,GAAA7f,EAAA6f,EAAA,GAAA5f,EAAA4f,EAAA,IAAA7gB,EAAA6gB,EAAA,IAEA/jB,MAIAikB,gBAAA,SAAA1kB,GAIA,GAAA2E,GAAAlE,KAAAkE,EAAAC,EAAAnE,KAAAmE,EAAAjB,EAAAlD,KAAAkD,EAEA6gB,EAAAxkB,EAAAmf,SACAwF,EAAA,GAAAH,EAAA,GAAA7f,EAAA6f,EAAA,GAAA5f,EAAA4f,EAAA,IAAA7gB,EAAA6gB,EAAA,IAMA,OAJA/jB,MAAAkE,GAAA6f,EAAA,GAAA7f,EAAA6f,EAAA,GAAA5f,EAAA4f,EAAA,GAAA7gB,EAAA6gB,EAAA,KAAAG,EACAlkB,KAAAmE,GAAA4f,EAAA,GAAA7f,EAAA6f,EAAA,GAAA5f,EAAA4f,EAAA,GAAA7gB,EAAA6gB,EAAA,KAAAG,EACAlkB,KAAAkD,GAAA6gB,EAAA,GAAA7f,EAAA6f,EAAA,GAAA5f,EAAA4f,EAAA,IAAA7gB,EAAA6gB,EAAA,KAAAG,EAEAlkB,MAIA8gB,gBAAA,SAAA5P,GAEA,GAAAhN,GAAAlE,KAAAkE,EACAC,EAAAnE,KAAAmE,EACAjB,EAAAlD,KAAAkD,EAEAihB,GAAAjT,EAAAhN,EACAkgB,GAAAlT,EAAA/M,EACAkgB,GAAAnT,EAAAhO,EACAohB,GAAApT,EAAA8L,EAIAuH,GAAAD,GAAApgB,EAAAkgB,GAAAlhB,EAAAmhB,GAAAlgB,EACAqgB,GAAAF,GAAAngB,EAAAkgB,GAAAngB,EAAAigB,GAAAjhB,EACAuhB,GAAAH,GAAAphB,EAAAihB,GAAAhgB,EAAAigB,GAAAlgB,EACAwgB,IAAAP,GAAAjgB,EAAAkgB,GAAAjgB,EAAAkgB,GAAAnhB,CAQA,OAJAlD,MAAAkE,EAAAqgB,GAAAD,GAAAI,IAAAP,GAAAK,IAAAH,GAAAI,IAAAL,GACApkB,KAAAmE,EAAAqgB,GAAAF,GAAAI,IAAAN,GAAAK,IAAAN,GAAAI,IAAAF,GACArkB,KAAAkD,EAAAuhB,GAAAH,GAAAI,IAAAL,GAAAE,IAAAH,GAAAI,IAAAL,GAEAnkB,MAIA2P,QAAA,WAEA,GAAAgV,OAEA,iBAAA9hB,QAKA,MAHA+G,UAAA+a,gBAAA,GAAAjb,OAAAkb,SAEAD,OAAAE,iBAAAhiB,OAAAiiB,iBAAAH,OAAAI,WAAAliB,OAAAmiB,cACAhlB,KAAAikB,gBAAAU,YAMA9U,UAAA,WAEA,GAAA8U,OAEA,iBAAA9hB,QAKA,MAHA+G,UAAA+a,gBAAA,GAAAjb,OAAAkb,SAEAD,OAAAE,iBAAAhiB,OAAAmiB,YAAAL,OAAAI,WAAAliB,OAAAiiB,mBACA9kB,KAAAikB,gBAAAU,YAMAM,mBAAA,SAAA1lB,GAKA,GAAA2E,GAAAlE,KAAAkE,EAAAC,EAAAnE,KAAAmE,EAAAjB,EAAAlD,KAAAkD,EAEA6gB,EAAAxkB,EAAAmf,QAQA,OANA1e,MAAAkE,EAAA6f,EAAA,GAAA7f,EAAA6f,EAAA,GAAA5f,EAAA4f,EAAA,GAAA7gB,EACAlD,KAAAmE,EAAA4f,EAAA,GAAA7f,EAAA6f,EAAA,GAAA5f,EAAA4f,EAAA,GAAA7gB,EACAlD,KAAAkD,EAAA6gB,EAAA,GAAA7f,EAAA6f,EAAA,GAAA5f,EAAA4f,EAAA,IAAA7gB,EAEAlD,KAAA8f,YAEA9f,MAIAmiB,OAAA,SAAAlC,GAMA,MAJAjgB,MAAAkE,GAAA+b,EAAA/b,EACAlE,KAAAmE,GAAA8b,EAAA9b,EACAnE,KAAAkD,GAAA+c,EAAA/c,EAEAlD,MAIAoiB,aAAA,SAAAC,QAEA,OAAAA,OAAA,CAEA,GAAAC,WAAA,EAAAD,MAEAriB,MAAAkE,GAAAoe,UACAtiB,KAAAmE,GAAAme,UACAtiB,KAAAkD,GAAAof,cAIAtiB,MAAAkE,EAAA,EACAlE,KAAAmE,EAAA,EACAnE,KAAAkD,EAAA,CAIA,OAAAlD,OAIAsR,IAAA,SAAA2O,GAoBA,MAlBAjgB,MAAAkE,EAAA+b,EAAA/b,IAEAlE,KAAAkE,EAAA+b,EAAA/b,GAIAlE,KAAAmE,EAAA8b,EAAA9b,IAEAnE,KAAAmE,EAAA8b,EAAA9b,GAIAnE,KAAAkD,EAAA+c,EAAA/c,IAEAlD,KAAAkD,EAAA+c,EAAA/c,GAIAlD,MAIAyS,IAAA,SAAAwN,GAoBA,MAlBAjgB,MAAAkE,EAAA+b,EAAA/b,IAEAlE,KAAAkE,EAAA+b,EAAA/b,GAIAlE,KAAAmE,EAAA8b,EAAA9b,IAEAnE,KAAAmE,EAAA8b,EAAA9b,GAIAnE,KAAAkD,EAAA+c,EAAA/c,IAEAlD,KAAAkD,EAAA+c,EAAA/c,GAIAlD,MAIAuiB,MAAA,SAAAjR,IAAAmB,KAkCA,MA9BAzS,MAAAkE,EAAAoN,IAAApN,EAEAlE,KAAAkE,EAAAoN,IAAApN,EAEGlE,KAAAkE,EAAAuO,IAAAvO,IAEHlE,KAAAkE,EAAAuO,IAAAvO,GAIAlE,KAAAmE,EAAAmN,IAAAnN,EAEAnE,KAAAmE,EAAAmN,IAAAnN,EAEGnE,KAAAmE,EAAAsO,IAAAtO,IAEHnE,KAAAmE,EAAAsO,IAAAtO,GAIAnE,KAAAkD,EAAAoO,IAAApO,EAEAlD,KAAAkD,EAAAoO,IAAApO,EAEGlD,KAAAkD,EAAAuP,IAAAvP,IAEHlD,KAAAkD,EAAAuP,IAAAvP,GAIAlD,MAIAwiB,YAAA,WAEA,GAAAlR,KAAAmB,GAEA,iBAAAgQ,OAAAC,QAYA,MAVA9Y,UAAA0H,MAEAA,IAAA,GAAA5H,OAAAgW,QACAjN,IAAA,GAAA/I,OAAAgW,SAIApO,IAAAnB,IAAAsS,sBACAhQ,IAAAtC,IAAAuS,sBAEA1iB,KAAAuiB,MAAAjR,IAAAmB,SAMA7B,MAAA,WAMA,MAJA5Q,MAAAkE,EAAA2F,KAAA+G,MAAA5Q,KAAAkE,GACAlE,KAAAmE,EAAA0F,KAAA+G,MAAA5Q,KAAAmE,GACAnE,KAAAkD,EAAA2G,KAAA+G,MAAA5Q,KAAAkD,GAEAlD,MAIA2iB,KAAA,WAMA,MAJA3iB,MAAAkE,EAAA2F,KAAA8Y,KAAA3iB,KAAAkE,GACAlE,KAAAmE,EAAA0F,KAAA8Y,KAAA3iB,KAAAmE,GACAnE,KAAAkD,EAAA2G,KAAA8Y,KAAA3iB,KAAAkD,GAEAlD,MAIA4iB,MAAA,WAMA,MAJA5iB,MAAAkE,EAAA2F,KAAA+Y,MAAA5iB,KAAAkE,GACAlE,KAAAmE,EAAA0F,KAAA+Y,MAAA5iB,KAAAmE,GACAnE,KAAAkD,EAAA2G,KAAA+Y,MAAA5iB,KAAAkD,GAEAlD,MAIA6iB,YAAA,WAMA,MAJA7iB,MAAAkE,EAAAlE,KAAAkE,EAAA,EAAA2F,KAAA8Y,KAAA3iB,KAAAkE,GAAA2F,KAAA+G,MAAA5Q,KAAAkE,GACAlE,KAAAmE,EAAAnE,KAAAmE,EAAA,EAAA0F,KAAA8Y,KAAA3iB,KAAAmE,GAAA0F,KAAA+G,MAAA5Q,KAAAmE,GACAnE,KAAAkD,EAAAlD,KAAAkD,EAAA,EAAA2G,KAAA8Y,KAAA3iB,KAAAkD,GAAA2G,KAAA+G,MAAA5Q,KAAAkD,GAEAlD,MAIA8iB,OAAA,WAMA,MAJA9iB,MAAAkE,GAAAlE,KAAAkE,EACAlE,KAAAmE,GAAAnE,KAAAmE,EACAnE,KAAAkD,GAAAlD,KAAAkD,EAEAlD,MAIA2f,IAAA,SAAAM,GAEA,MAAAjgB,MAAAkE,EAAA+b,EAAA/b,EAAAlE,KAAAmE,EAAA8b,EAAA9b,EAAAnE,KAAAkD,EAAA+c,EAAA/c,GAIAgd,SAAA,WAEA,MAAAlgB,MAAAkE,EAAAlE,KAAAkE,EAAAlE,KAAAmE,EAAAnE,KAAAmE,EAAAnE,KAAAkD,EAAAlD,KAAAkD,GAIAyB,OAAA,WAEA,MAAAkF,MAAAmI,KAAAhS,KAAAkE,EAAAlE,KAAAkE,EAAAlE,KAAAmE,EAAAnE,KAAAmE,EAAAnE,KAAAkD,EAAAlD,KAAAkD,IAIAgiB,gBAAA,WAEA,MAAArb,MAAA+V,IAAA5f,KAAAkE,GAAA2F,KAAA+V,IAAA5f,KAAAmE,GAAA0F,KAAA+V,IAAA5f,KAAAkD,IAIA4c,UAAA,WAEA,MAAA9f,MAAAoiB,aAAApiB,KAAA2E,WAIAwe,UAAA,SAAAnS,GAEA,GAAAoS,WAAApjB,KAAA2E,QAOA,OALA,KAAAye,WAAApS,IAAAoS,WAEApjB,KAAAmT,eAAAnC,EAAAoS,WAGApjB,MAIAoT,KAAA,SAAA6M,EAAA5M,OAMA,MAJArT,MAAAkE,IAAA+b,EAAA/b,EAAAlE,KAAAkE,GAAAmP,MACArT,KAAAmE,IAAA8b,EAAA9b,EAAAnE,KAAAmE,GAAAkP,MACArT,KAAAkD,IAAA+c,EAAA/c,EAAAlD,KAAAkD,GAAAmQ,MAEArT,MAIAqjB,YAAA,SAAA/D,GAAAgE,GAAAjQ,OAIA,MAFArT,MAAAiiB,WAAAqB,GAAAhE,IAAAnM,eAAAE,OAAA1P,IAAA2b,IAEAtf,MAIAmlB,MAAA,SAAAlF,EAAAjD,GAEA,GAAApT,SAAAoT,EAGA,MADAtT,OAAAK,KAAA,6FACA/J,KAAA6f,aAAAI,EAAAjD,EAIA,IAAA9Y,GAAAlE,KAAAkE,EAAAC,EAAAnE,KAAAmE,EAAAjB,EAAAlD,KAAAkD,CAMA,OAJAlD,MAAAkE,EAAAC,EAAA8b,EAAA/c,IAAA+c,EAAA9b,EACAnE,KAAAmE,EAAAjB,EAAA+c,EAAA/b,IAAA+b,EAAA/c,EACAlD,KAAAkD,EAAAgB,EAAA+b,EAAA9b,IAAA8b,EAAA/b,EAEAlE,MAIA6f,aAAA,SAAAO,EAAA9P,GAEA,GAAA8U,IAAAhF,EAAAlc,EAAAmhB,GAAAjF,EAAAjc,EAAAmhB,GAAAlF,EAAAld,EACAqiB,GAAAjV,EAAApM,EAAAshB,GAAAlV,EAAAnM,EAAAshB,GAAAnV,EAAApN,CAMA,OAJAlD,MAAAkE,EAAAmhB,GAAAI,GAAAH,GAAAE,GACAxlB,KAAAmE,EAAAmhB,GAAAC,GAAAH,GAAAK,GACAzlB,KAAAkD,EAAAkiB,GAAAI,GAAAH,GAAAE,GAEAvlB,MAIA0lB,gBAAA,WAEA,GAAApG,IAAAK,GAEA,iBAAAjQ,QAQA,MANA9F,UAAA0V,QAAA,GAAA5V,OAAAgW,SAEAJ,GAAA9O,KAAAd,QAAAoQ,YAEAH,IAAA3f,KAAA2f,IAAAL,IAEAtf,KAAAwQ,KAAA8O,IAAAnM,eAAAwM,SAMAgG,eAAA,WAEA,GAAArG,GAEA,iBAAAsG,aAMA,MAJAhc,UAAA0V,QAAA,GAAA5V,OAAAgW,SAEAJ,GAAA9O,KAAAxQ,MAAA0lB,gBAAAE,aAEA5lB,KAAAQ,IAAA8e,QAMAuG,QAAA,WAKA,GAAAvG,GAEA,iBAAAwG,QAIA,MAFAlc,UAAA0V,QAAA,GAAA5V,OAAAgW,SAEA1f,KAAAQ,IAAA8e,GAAA9O,KAAAsV,QAAA3S,eAAA,EAAAnT,KAAA2f,IAAAmG,cAMAC,QAAA,SAAA9F,GAEA,GAAA+F,OAAAhmB,KAAA2f,IAAAM,IAAAjgB,KAAA2E,SAAAsb,EAAAtb,SAIA,OAAAkF,MAAAsX,KAAAzX,MAAAG,KAAA0Y,MAAAyD,MAAA,QAIAjD,WAAA,SAAA9C,GAEA,MAAApW,MAAAmI,KAAAhS,KAAAgjB,kBAAA/C,KAIA+C,kBAAA,SAAA/C,GAEA,GAAAgD,IAAAjjB,KAAAkE,EAAA+b,EAAA/b,EACAgf,GAAAljB,KAAAmE,EAAA8b,EAAA9b,EACA8hB,GAAAjmB,KAAAkD,EAAA+c,EAAA/c,CAEA,OAAA+f,OAAAC,MAAA+C,OAIAC,2BAAA,SAAA3mB,EAAA4e,OAEAzU,MAAAM,MAAA,8GAIAmc,uBAAA,SAAAjV,EAAAiN,OAEAzU,MAAAM,MAAA,sGAIAoc,sBAAA,SAAA7mB,GAIA,MAFAmK,OAAAK,KAAA,yFAEA/J,KAAAqmB,sBAAA9mB,IAIA+mB,mBAAA,SAAA/mB,GAIA,MAFAmK,OAAAK,KAAA,mFAEA/J,KAAAumB,mBAAAhnB,IAGAinB,oBAAA,SAAA9e,MAAAid,QAIA,MAFAjb,OAAAK,KAAA,qFAEA/J,KAAAymB,oBAAA/e,MAAAid,SAIA0B,sBAAA,SAAA9mB,GAMA,MAJAS,MAAAkE,EAAA3E,EAAAmf,SAAA,IACA1e,KAAAmE,EAAA5E,EAAAmf,SAAA,IACA1e,KAAAkD,EAAA3D,EAAAmf,SAAA,IAEA1e,MAIAumB,mBAAA,SAAAhnB,GAEA,GAAAmnB,IAAA1mB,KAAAmQ,IAAA5Q,EAAAmf,SAAA,GAAAnf,EAAAmf,SAAA,GAAAnf,EAAAmf,SAAA,IAAA/Z,SACAgiB,GAAA3mB,KAAAmQ,IAAA5Q,EAAAmf,SAAA,GAAAnf,EAAAmf,SAAA,GAAAnf,EAAAmf,SAAA,IAAA/Z,SACAiiB,GAAA5mB,KAAAmQ,IAAA5Q,EAAAmf,SAAA,GAAAnf,EAAAmf,SAAA,GAAAnf,EAAAmf,SAAA,KAAA/Z,QAMA,OAJA3E,MAAAkE,EAAAwiB,GACA1mB,KAAAmE,EAAAwiB,GACA3mB,KAAAkD,EAAA0jB,GAEA5mB,MAGAymB,oBAAA,SAAA/e,MAAAid,QAEA,GAAAjR,QAAA,EAAAhM,MAEAmf,GAAAlC,OAAAjG,QAMA,OAJA1e,MAAAkE,EAAA2iB,GAAAnT,QACA1T,KAAAmE,EAAA0iB,GAAAnT,OAAA,GACA1T,KAAAkD,EAAA2jB,GAAAnT,OAAA,GAEA1T,MAIAsT,OAAA,SAAA2M,GAEA,MAAAA,GAAA/b,IAAAlE,KAAAkE,GAAA+b,EAAA9b,IAAAnE,KAAAmE,GAAA8b,EAAA/c,IAAAlD,KAAAkD,GAIAqQ,UAAA,SAAAC,MAAAE,QAQA,MANA9J,UAAA8J,gBAAA,GAEA1T,KAAAkE,EAAAsP,MAAAE,QACA1T,KAAAmE,EAAAqP,MAAAE,OAAA,GACA1T,KAAAkD,EAAAsQ,MAAAE,OAAA,GAEA1T,MAIAyT,QAAA,SAAAD,MAAAE,QASA,MAPA9J,UAAA4J,kBACA5J,SAAA8J,gBAAA,GAEAF,MAAAE,QAAA1T,KAAAkE,EACAsP,MAAAE,OAAA,GAAA1T,KAAAmE,EACAqP,MAAAE,OAAA,GAAA1T,KAAAkD,EAEAsQ,OAIA+P,cAAA,SAAAC,UAAA9b,MAAAgM,QAUA,MARA9J,UAAA8J,gBAAA,GAEAhM,YAAA8b,UAAAC,SAAA/P,OAEA1T,KAAAkE,EAAAsf,UAAAhQ,MAAA9L,OACA1H,KAAAmE,EAAAqf,UAAAhQ,MAAA9L,MAAA,GACA1H,KAAAkD,EAAAsgB,UAAAhQ,MAAA9L,MAAA,GAEA1H,MAIA2T,MAAA,WAEA,UAAAjK,OAAAgW,QAAA1f,KAAAkE,EAAAlE,KAAAmE,EAAAnE,KAAAkD,KAgBAwG,MAAAod,QAAA,SAAA5iB,EAAAC,EAAAjB,EAAA8Z,GAEAhd,KAAAkE,KAAA,EACAlE,KAAAmE,KAAA,EACAnE,KAAAkD,KAAA,EACAlD,KAAAgd,EAAApT,SAAAoT,IAAA,GAIAtT,MAAAod,QAAAxmB,WAEAM,YAAA8I,MAAAod,QAEA3W,IAAA,SAAAjM,EAAAC,EAAAjB,EAAA8Z,GAOA,MALAhd,MAAAkE,IACAlE,KAAAmE,IACAnE,KAAAkD,IACAlD,KAAAgd,IAEAhd,MAIA4hB,KAAA,SAAA1d,GAIA,MAFAlE,MAAAkE,IAEAlE,MAIA6hB,KAAA,SAAA1d,GAIA,MAFAnE,MAAAmE,IAEAnE,MAIA0jB,KAAA,SAAAxgB,GAIA,MAFAlD,MAAAkD,IAEAlD,MAIA+mB,KAAA,SAAA/J,GAIA,MAFAhd,MAAAgd,IAEAhd,MAIA8hB,aAAA,SAAApa,MAAA6I,OAEA,OAAA7I,OAEA,OAAA1H,KAAAkE,EAAAqM,KAA0B,MAC1B,QAAAvQ,KAAAmE,EAAAoM,KAA0B,MAC1B,QAAAvQ,KAAAkD,EAAAqN,KAA0B,MAC1B,QAAAvQ,KAAAgd,EAAAzM,KAA0B,MAC1B,kBAAApH,OAAA,0BAAAzB,SAMAqa,aAAA,SAAAra,OAEA,OAAAA,OAEA,aAAA1H,MAAAkE,CACA,cAAAlE,MAAAmE,CACA,cAAAnE,MAAAkD,CACA,cAAAlD,MAAAgd,CACA,kBAAA7T,OAAA,0BAAAzB,SAMA8I,KAAA,SAAAyP,GAOA,MALAjgB,MAAAkE,EAAA+b,EAAA/b,EACAlE,KAAAmE,EAAA8b,EAAA9b,EACAnE,KAAAkD,EAAA+c,EAAA/c,EACAlD,KAAAgd,EAAApT,SAAAqW,EAAAjD,EAAAiD,EAAAjD,EAAA,EAEAhd,MAIA2D,IAAA,SAAAsc,EAAAjD,GAEA,MAAApT,UAAAoT,GAEAtT,MAAAK,KAAA,yFACA/J,KAAAgiB,WAAA/B,EAAAjD,KAIAhd,KAAAkE,GAAA+b,EAAA/b,EACAlE,KAAAmE,GAAA8b,EAAA9b,EACAnE,KAAAkD,GAAA+c,EAAA/c,EACAlD,KAAAgd,GAAAiD,EAAAjD,EAEAhd,OAIAiT,UAAA,SAAAlC,GAOA,MALA/Q,MAAAkE,GAAA6M,EACA/Q,KAAAmE,GAAA4M,EACA/Q,KAAAkD,GAAA6N,EACA/Q,KAAAgd,GAAAjM,EAEA/Q,MAIAgiB,WAAA,SAAA5B,EAAA9P,GAOA,MALAtQ,MAAAkE,EAAAkc,EAAAlc,EAAAoM,EAAApM,EACAlE,KAAAmE,EAAAic,EAAAjc,EAAAmM,EAAAnM,EACAnE,KAAAkD,EAAAkd,EAAAld,EAAAoN,EAAApN,EACAlD,KAAAgd,EAAAoD,EAAApD,EAAA1M,EAAA0M,EAEAhd,MAIAQ,IAAA,SAAAyf,EAAAjD,GAEA,MAAApT,UAAAoT,GAEAtT,MAAAK,KAAA,yFACA/J,KAAAiiB,WAAAhC,EAAAjD,KAIAhd,KAAAkE,GAAA+b,EAAA/b,EACAlE,KAAAmE,GAAA8b,EAAA9b,EACAnE,KAAAkD,GAAA+c,EAAA/c,EACAlD,KAAAgd,GAAAiD,EAAAjD,EAEAhd,OAIAkiB,UAAA,SAAAnR,GAOA,MALA/Q,MAAAkE,GAAA6M,EACA/Q,KAAAmE,GAAA4M,EACA/Q,KAAAkD,GAAA6N,EACA/Q,KAAAgd,GAAAjM,EAEA/Q,MAIAiiB,WAAA,SAAA7B,EAAA9P,GAOA,MALAtQ,MAAAkE,EAAAkc,EAAAlc,EAAAoM,EAAApM,EACAlE,KAAAmE,EAAAic,EAAAjc,EAAAmM,EAAAnM,EACAnE,KAAAkD,EAAAkd,EAAAld,EAAAoN,EAAApN,EACAlD,KAAAgd,EAAAoD,EAAApD,EAAA1M,EAAA0M,EAEAhd,MAIAmT,eAAA,SAAAkP,QAOA,MALAriB,MAAAkE,GAAAme,OACAriB,KAAAmE,GAAAke,OACAriB,KAAAkD,GAAAmf,OACAriB,KAAAgd,GAAAqF,OAEAriB,MAIAgkB,aAAA,SAAAzkB,GAEA,GAAA2E,GAAAlE,KAAAkE,EACAC,EAAAnE,KAAAmE,EACAjB,EAAAlD,KAAAkD,EACA8Z,EAAAhd,KAAAgd,EAEA+G,EAAAxkB,EAAAmf,QAOA,OALA1e,MAAAkE,EAAA6f,EAAA,GAAA7f,EAAA6f,EAAA,GAAA5f,EAAA4f,EAAA,GAAA7gB,EAAA6gB,EAAA,IAAA/G,EACAhd,KAAAmE,EAAA4f,EAAA,GAAA7f,EAAA6f,EAAA,GAAA5f,EAAA4f,EAAA,GAAA7gB,EAAA6gB,EAAA,IAAA/G,EACAhd,KAAAkD,EAAA6gB,EAAA,GAAA7f,EAAA6f,EAAA,GAAA5f,EAAA4f,EAAA,IAAA7gB,EAAA6gB,EAAA,IAAA/G,EACAhd,KAAAgd,EAAA+G,EAAA,GAAA7f,EAAA6f,EAAA,GAAA5f,EAAA4f,EAAA,IAAA7gB,EAAA6gB,EAAA,IAAA/G,EAEAhd,MAIAoiB,aAAA,SAAAC,QAEA,OAAAA,OAAA,CAEA,GAAAC,WAAA,EAAAD,MAEAriB,MAAAkE,GAAAoe,UACAtiB,KAAAmE,GAAAme,UACAtiB,KAAAkD,GAAAof,UACAtiB,KAAAgd,GAAAsF,cAIAtiB,MAAAkE,EAAA,EACAlE,KAAAmE,EAAA,EACAnE,KAAAkD,EAAA,EACAlD,KAAAgd,EAAA,CAIA,OAAAhd,OAIAgnB,2BAAA,SAAA9V,GAMAlR,KAAAgd,EAAA,EAAAnT,KAAAsX,KAAAjQ,EAAA8L,EAEA,IAAAjM,GAAAlH,KAAAmI,KAAA,EAAAd,EAAA8L,EAAA9L,EAAA8L,EAgBA,OAdA,MAAAjM,GAEA/Q,KAAAkE,EAAA,EACAlE,KAAAmE,EAAA,EACAnE,KAAAkD,EAAA,IAIAlD,KAAAkE,EAAAgN,EAAAhN,EAAA6M,EACA/Q,KAAAmE,EAAA+M,EAAA/M,EAAA4M,EACA/Q,KAAAkD,EAAAgO,EAAAhO,EAAA6N,GAIA/Q,MAIAinB,+BAAA,SAAA1nB,GAMA,GAAA+e,OAAApa,EAAAC,EAAAjB,EACAgkB,QAAA,IACAC,SAAA,GAEA1I,GAAAlf,EAAAmf,SAEAC,IAAAF,GAAA,GAAAG,IAAAH,GAAA,GAAAI,IAAAJ,GAAA,GACAK,IAAAL,GAAA,GAAAM,IAAAN,GAAA,GAAAO,IAAAP,GAAA,GACAQ,IAAAR,GAAA,GAAAS,IAAAT,GAAA,GAAAU,IAAAV,GAAA,GAEA,IAAA5U,KAAA+V,IAAAhB,IAAAE,KAAAoI,SACArd,KAAA+V,IAAAf,IAAAI,KAAAiI,SACArd,KAAA+V,IAAAZ,IAAAE,KAAAgI,QAAA,CAMA,GAAArd,KAAA+V,IAAAhB,IAAAE,KAAAqI,UACAtd,KAAA+V,IAAAf,IAAAI,KAAAkI,UACAtd,KAAA+V,IAAAZ,IAAAE,KAAAiI,UACAtd,KAAA+V,IAAAjB,IAAAI,IAAAI,IAAA,GAAAgI,SAMA,MAFAnnB,MAAAmQ,IAAA,SAEAnQ,IAMAse,OAAAzU,KAAAud,EAEA,IAAAC,KAAA1I,IAAA,KACA2I,IAAAvI,IAAA,KACAwI,IAAApI,IAAA,KACAqI,IAAA5I,IAAAE,KAAA,EACA2I,IAAA5I,IAAAI,KAAA,EACAyI,IAAA1I,IAAAE,KAAA,CAsDA,OApDAmI,IAAAC,IAAAD,GAAAE,GAEAL,QAAAG,IAEAnjB,EAAA,EACAC,EAAA,WACAjB,EAAA,aAIAgB,EAAA2F,KAAAmI,KAAAqV,IACAljB,EAAAqjB,GAAAtjB,EACAhB,EAAAukB,GAAAvjB,GAIIojB,GAAAC,GAEJL,QAAAI,IAEApjB,EAAA,WACAC,EAAA,EACAjB,EAAA,aAIAiB,EAAA0F,KAAAmI,KAAAsV,IACApjB,EAAAsjB,GAAArjB,EACAjB,EAAAwkB,GAAAvjB,GAMA+iB,QAAAK,IAEArjB,EAAA,WACAC,EAAA,WACAjB,EAAA,IAIAA,EAAA2G,KAAAmI,KAAAuV,IACArjB,EAAAujB,GAAAvkB,EACAiB,EAAAujB,GAAAxkB,GAMAlD,KAAAmQ,IAAAjM,EAAAC,EAAAjB,EAAAob,OAEAte,KAMA,GAAA+Q,GAAAlH,KAAAmI,MAAAkN,IAAAF,MAAAE,IAAAF,MACAH,IAAAI,MAAAJ,IAAAI,MACAH,IAAAF,MAAAE,IAAAF,KAYA,OAVA/U,MAAA+V,IAAA7O,GAAA,OAAAA,EAAA,GAKA/Q,KAAAkE,GAAAgb,IAAAF,KAAAjO,EACA/Q,KAAAmE,GAAA0a,IAAAI,KAAAlO,EACA/Q,KAAAkD,GAAA4b,IAAAF,KAAA7N,EACA/Q,KAAAgd,EAAAnT,KAAAsX,MAAAxC,IAAAI,IAAAI,IAAA,MAEAnf,MAIAsR,IAAA,SAAA2O,GA0BA,MAxBAjgB,MAAAkE,EAAA+b,EAAA/b,IAEAlE,KAAAkE,EAAA+b,EAAA/b,GAIAlE,KAAAmE,EAAA8b,EAAA9b,IAEAnE,KAAAmE,EAAA8b,EAAA9b,GAIAnE,KAAAkD,EAAA+c,EAAA/c,IAEAlD,KAAAkD,EAAA+c,EAAA/c,GAIAlD,KAAAgd,EAAAiD,EAAAjD,IAEAhd,KAAAgd,EAAAiD,EAAAjD,GAIAhd,MAIAyS,IAAA,SAAAwN,GA0BA,MAxBAjgB,MAAAkE,EAAA+b,EAAA/b,IAEAlE,KAAAkE,EAAA+b,EAAA/b,GAIAlE,KAAAmE,EAAA8b,EAAA9b,IAEAnE,KAAAmE,EAAA8b,EAAA9b,GAIAnE,KAAAkD,EAAA+c,EAAA/c,IAEAlD,KAAAkD,EAAA+c,EAAA/c,GAIAlD,KAAAgd,EAAAiD,EAAAjD,IAEAhd,KAAAgd,EAAAiD,EAAAjD,GAIAhd,MAIAuiB,MAAA,SAAAjR,IAAAmB,KA4CA,MAxCAzS,MAAAkE,EAAAoN,IAAApN,EAEAlE,KAAAkE,EAAAoN,IAAApN,EAEGlE,KAAAkE,EAAAuO,IAAAvO,IAEHlE,KAAAkE,EAAAuO,IAAAvO,GAIAlE,KAAAmE,EAAAmN,IAAAnN,EAEAnE,KAAAmE,EAAAmN,IAAAnN,EAEGnE,KAAAmE,EAAAsO,IAAAtO,IAEHnE,KAAAmE,EAAAsO,IAAAtO,GAIAnE,KAAAkD,EAAAoO,IAAApO,EAEAlD,KAAAkD,EAAAoO,IAAApO,EAEGlD,KAAAkD,EAAAuP,IAAAvP,IAEHlD,KAAAkD,EAAAuP,IAAAvP,GAIAlD,KAAAgd,EAAA1L,IAAA0L,EAEAhd,KAAAgd,EAAA1L,IAAA0L,EAEGhd,KAAAgd,EAAAvK,IAAAuK,IAEHhd,KAAAgd,EAAAvK,IAAAuK,GAIAhd,MAIAwiB,YAAA,WAEA,GAAAlR,KAAAmB,GAEA,iBAAAgQ,OAAAC,QAYA,MAVA9Y,UAAA0H,MAEAA,IAAA,GAAA5H,OAAAod,QACArU,IAAA,GAAA/I,OAAAod,SAIAxV,IAAAnB,IAAAsS,6BACAhQ,IAAAtC,IAAAuS,6BAEA1iB,KAAAuiB,MAAAjR,IAAAmB,SAMA7B,MAAA,WAOA,MALA5Q,MAAAkE,EAAA2F,KAAA+G,MAAA5Q,KAAAkE,GACAlE,KAAAmE,EAAA0F,KAAA+G,MAAA5Q,KAAAmE,GACAnE,KAAAkD,EAAA2G,KAAA+G,MAAA5Q,KAAAkD,GACAlD,KAAAgd,EAAAnT,KAAA+G,MAAA5Q,KAAAgd,GAEAhd,MAIA2iB,KAAA,WAOA,MALA3iB,MAAAkE,EAAA2F,KAAA8Y,KAAA3iB,KAAAkE,GACAlE,KAAAmE,EAAA0F,KAAA8Y,KAAA3iB,KAAAmE,GACAnE,KAAAkD,EAAA2G,KAAA8Y,KAAA3iB,KAAAkD,GACAlD,KAAAgd,EAAAnT,KAAA8Y,KAAA3iB,KAAAgd,GAEAhd,MAIA4iB,MAAA,WAOA,MALA5iB,MAAAkE,EAAA2F,KAAA+Y,MAAA5iB,KAAAkE,GACAlE,KAAAmE,EAAA0F,KAAA+Y,MAAA5iB,KAAAmE,GACAnE,KAAAkD,EAAA2G,KAAA+Y,MAAA5iB,KAAAkD,GACAlD,KAAAgd,EAAAnT,KAAA+Y,MAAA5iB,KAAAgd,GAEAhd,MAIA6iB,YAAA,WAOA,MALA7iB,MAAAkE,EAAAlE,KAAAkE,EAAA,EAAA2F,KAAA8Y,KAAA3iB,KAAAkE,GAAA2F,KAAA+G,MAAA5Q,KAAAkE,GACAlE,KAAAmE,EAAAnE,KAAAmE,EAAA,EAAA0F,KAAA8Y,KAAA3iB,KAAAmE,GAAA0F,KAAA+G,MAAA5Q,KAAAmE,GACAnE,KAAAkD,EAAAlD,KAAAkD,EAAA,EAAA2G,KAAA8Y,KAAA3iB,KAAAkD,GAAA2G,KAAA+G,MAAA5Q,KAAAkD,GACAlD,KAAAgd,EAAAhd,KAAAgd,EAAA,EAAAnT,KAAA8Y,KAAA3iB,KAAAgd,GAAAnT,KAAA+G,MAAA5Q,KAAAgd,GAEAhd,MAIA8iB,OAAA,WAOA,MALA9iB,MAAAkE,GAAAlE,KAAAkE,EACAlE,KAAAmE,GAAAnE,KAAAmE,EACAnE,KAAAkD,GAAAlD,KAAAkD,EACAlD,KAAAgd,GAAAhd,KAAAgd,EAEAhd,MAIA2f,IAAA,SAAAM,GAEA,MAAAjgB,MAAAkE,EAAA+b,EAAA/b,EAAAlE,KAAAmE,EAAA8b,EAAA9b,EAAAnE,KAAAkD,EAAA+c,EAAA/c,EAAAlD,KAAAgd,EAAAiD,EAAAjD,GAIAkD,SAAA,WAEA,MAAAlgB,MAAAkE,EAAAlE,KAAAkE,EAAAlE,KAAAmE,EAAAnE,KAAAmE,EAAAnE,KAAAkD,EAAAlD,KAAAkD,EAAAlD,KAAAgd,EAAAhd,KAAAgd,GAIArY,OAAA,WAEA,MAAAkF,MAAAmI,KAAAhS,KAAAkE,EAAAlE,KAAAkE,EAAAlE,KAAAmE,EAAAnE,KAAAmE,EAAAnE,KAAAkD,EAAAlD,KAAAkD,EAAAlD,KAAAgd,EAAAhd,KAAAgd,IAIAkI,gBAAA,WAEA,MAAArb,MAAA+V,IAAA5f,KAAAkE,GAAA2F,KAAA+V,IAAA5f,KAAAmE,GAAA0F,KAAA+V,IAAA5f,KAAAkD,GAAA2G,KAAA+V,IAAA5f,KAAAgd,IAIA8C,UAAA,WAEA,MAAA9f,MAAAoiB,aAAApiB,KAAA2E,WAIAwe,UAAA,SAAAnS,GAEA,GAAAoS,WAAApjB,KAAA2E,QAQA,OANA,KAAAye,WAAApS,IAAAoS,WAEApjB,KAAAmT,eAAAnC,EAAAoS,WAIApjB,MAIAoT,KAAA,SAAA6M,EAAA5M,OAOA,MALArT,MAAAkE,IAAA+b,EAAA/b,EAAAlE,KAAAkE,GAAAmP,MACArT,KAAAmE,IAAA8b,EAAA9b,EAAAnE,KAAAmE,GAAAkP,MACArT,KAAAkD,IAAA+c,EAAA/c,EAAAlD,KAAAkD,GAAAmQ,MACArT,KAAAgd,IAAAiD,EAAAjD,EAAAhd,KAAAgd,GAAA3J,MAEArT,MAIAqjB,YAAA,SAAA/D,GAAAgE,GAAAjQ,OAIA,MAFArT,MAAAiiB,WAAAqB,GAAAhE,IAAAnM,eAAAE,OAAA1P,IAAA2b,IAEAtf,MAIAsT,OAAA,SAAA2M,GAEA,MAAAA,GAAA/b,IAAAlE,KAAAkE,GAAA+b,EAAA9b,IAAAnE,KAAAmE,GAAA8b,EAAA/c,IAAAlD,KAAAkD,GAAA+c,EAAAjD,IAAAhd,KAAAgd,GAIAzJ,UAAA,SAAAC,MAAAE,QASA,MAPA9J,UAAA8J,gBAAA,GAEA1T,KAAAkE,EAAAsP,MAAAE,QACA1T,KAAAmE,EAAAqP,MAAAE,OAAA,GACA1T,KAAAkD,EAAAsQ,MAAAE,OAAA,GACA1T,KAAAgd,EAAAxJ,MAAAE,OAAA,GAEA1T,MAIAyT,QAAA,SAAAD,MAAAE,QAUA,MARA9J,UAAA4J,kBACA5J,SAAA8J,gBAAA,GAEAF,MAAAE,QAAA1T,KAAAkE,EACAsP,MAAAE,OAAA,GAAA1T,KAAAmE,EACAqP,MAAAE,OAAA,GAAA1T,KAAAkD,EACAsQ,MAAAE,OAAA,GAAA1T,KAAAgd,EAEAxJ,OAIA+P,cAAA,SAAAC,UAAA9b,MAAAgM,QAWA,MATA9J,UAAA8J,gBAAA,GAEAhM,YAAA8b,UAAAC,SAAA/P,OAEA1T,KAAAkE,EAAAsf,UAAAhQ,MAAA9L,OACA1H,KAAAmE,EAAAqf,UAAAhQ,MAAA9L,MAAA,GACA1H,KAAAkD,EAAAsgB,UAAAhQ,MAAA9L,MAAA,GACA1H,KAAAgd,EAAAwG,UAAAhQ,MAAA9L,MAAA,GAEA1H,MAIA2T,MAAA,WAEA,UAAAjK,OAAAod,QAAA9mB,KAAAkE,EAAAlE,KAAAmE,EAAAnE,KAAAkD,EAAAlD,KAAAgd,KAcAtT,MAAAgU,MAAA,SAAAxZ,EAAAC,EAAAjB,EAAAib,OAEAne,KAAAid,GAAA/Y,GAAA,EACAlE,KAAAkd,GAAA/Y,GAAA,EACAnE,KAAAmd,GAAAja,GAAA,EACAlD,KAAA2nB,OAAAxJ,OAAAzU,MAAAgU,MAAAkK,cAIAle,MAAAgU,MAAAmK,gBAAA,qCAEAne,MAAAgU,MAAAkK,aAAA,MAEAle,MAAAgU,MAAApd,WAEAM,YAAA8I,MAAAgU,MAEAT,GAAA,EAAAC,GAAA,EAAAC,GAAA,EAAAwK,OAAAje,MAAAgU,MAAAkK,aAEAvK,GAAAnZ,KAEA,MAAAlE,MAAAid,IAIAI,GAAAnZ,GAAAqM,OAEAvQ,KAAAid,GAAA1M,MACAvQ,KAAAsd,oBAIAD,GAAAlZ,KAEA,MAAAnE,MAAAkd,IAIAG,GAAAlZ,GAAAoM,OAEAvQ,KAAAkd,GAAA3M,MACAvQ,KAAAsd,oBAIAD,GAAAna,KAEA,MAAAlD,MAAAmd,IAIAE,GAAAna,GAAAqN,OAEAvQ,KAAAmd,GAAA5M,MACAvQ,KAAAsd,oBAIAD,GAAAc,SAEA,MAAAne,MAAA2nB,QAIAtK,GAAAc,OAAA5N,OAEAvQ,KAAA2nB,OAAApX,MACAvQ,KAAAsd,oBAIAnN,IAAA,SAAAjM,EAAAC,EAAAjB,EAAAib,OASA,MAPAne,MAAAid,GAAA/Y,EACAlE,KAAAkd,GAAA/Y,EACAnE,KAAAmd,GAAAja,EACAlD,KAAA2nB,OAAAxJ,OAAAne,KAAA2nB,OAEA3nB,KAAAsd,mBAEAtd,MAIAwQ,KAAA,SAAAiN,OASA,MAPAzd,MAAAid,GAAAQ,MAAAR,GACAjd,KAAAkd,GAAAO,MAAAP,GACAld,KAAAmd,GAAAM,MAAAN,GACAnd,KAAA2nB,OAAAlK,MAAAkK,OAEA3nB,KAAAsd,mBAEAtd,MAIAwe,sBAAA,SAAAjf,EAAA4e,MAAA3X,QAEA,GAAA+b,OAAA7Y,MAAAG,KAAA0Y,MAIA9D,GAAAlf,EAAAmf,SACAC,IAAAF,GAAA,GAAAG,IAAAH,GAAA,GAAAI,IAAAJ,GAAA,GACAK,IAAAL,GAAA,GAAAM,IAAAN,GAAA,GAAAO,IAAAP,GAAA,GACAQ,IAAAR,GAAA,GAAAS,IAAAT,GAAA,GAAAU,IAAAV,GAAA,GA8GA,OA5GAN,cAAAne,KAAA2nB,OAEA,QAAAxJ,OAEAne,KAAAkd,GAAArT,KAAAie,KAAAvF,MAAA1D,IAAA,OAEAhV,KAAA+V,IAAAf,KAAA,QAEA7e,KAAAid,GAAApT,KAAAke,OAAA/I,IAAAG,KACAnf,KAAAmd,GAAAtT,KAAAke,OAAAnJ,IAAAD,OAIA3e,KAAAid,GAAApT,KAAAke,MAAA7I,IAAAH,KACA/e,KAAAmd,GAAA,IAIG,QAAAgB,OAEHne,KAAAid,GAAApT,KAAAie,MAAAvF,MAAAvD,IAAA,OAEAnV,KAAA+V,IAAAZ,KAAA,QAEAhf,KAAAkd,GAAArT,KAAAke,MAAAlJ,IAAAM,KACAnf,KAAAmd,GAAAtT,KAAAke,MAAAjJ,IAAAC,OAIA/e,KAAAkd,GAAArT,KAAAke,OAAA9I,IAAAN,KACA3e,KAAAmd,GAAA,IAIG,QAAAgB,OAEHne,KAAAid,GAAApT,KAAAie,KAAAvF,MAAArD,IAAA,OAEArV,KAAA+V,IAAAV,KAAA,QAEAlf,KAAAkd,GAAArT,KAAAke,OAAA9I,IAAAE,KACAnf,KAAAmd,GAAAtT,KAAAke,OAAAnJ,IAAAG,OAIA/e,KAAAkd,GAAA,EACAld,KAAAmd,GAAAtT,KAAAke,MAAAjJ,IAAAH,OAIG,QAAAR,OAEHne,KAAAkd,GAAArT,KAAAie,MAAAvF,MAAAtD,IAAA,OAEApV,KAAA+V,IAAAX,KAAA,QAEAjf,KAAAid,GAAApT,KAAAke,MAAA7I,IAAAC,KACAnf,KAAAmd,GAAAtT,KAAAke,MAAAjJ,IAAAH,OAIA3e,KAAAid,GAAA,EACAjd,KAAAmd,GAAAtT,KAAAke,OAAAnJ,IAAAG,OAIG,QAAAZ,OAEHne,KAAAmd,GAAAtT,KAAAie,KAAAvF,MAAAzD,IAAA,OAEAjV,KAAA+V,IAAAd,KAAA,QAEA9e,KAAAid,GAAApT,KAAAke,OAAA/I,IAAAD,KACA/e,KAAAkd,GAAArT,KAAAke,OAAA9I,IAAAN,OAIA3e,KAAAid,GAAA,EACAjd,KAAAkd,GAAArT,KAAAke,MAAAlJ,IAAAM,OAIG,QAAAhB,OAEHne,KAAAmd,GAAAtT,KAAAie,MAAAvF,MAAA3D,IAAA,OAEA/U,KAAA+V,IAAAhB,KAAA,QAEA5e,KAAAid,GAAApT,KAAAke,MAAA7I,IAAAH,KACA/e,KAAAkd,GAAArT,KAAAke,MAAAlJ,IAAAF,OAIA3e,KAAAid,GAAApT,KAAAke,OAAA/I,IAAAG,KACAnf,KAAAkd,GAAA,IAMAxT,MAAAK,KAAA,kEAAAoU,OAIAne,KAAA2nB,OAAAxJ,MAEA3X,UAAA,GAAAxG,KAAAsd,mBAEAtd,MAIAgoB,kBAAA,WAEA,GAAArD,OAEA,iBAAAzT,EAAAiN,MAAA3X,QAMA,MAJAoD,UAAA+a,gBAAA,GAAAjb,OAAAkb,SACAD,OAAAsD,2BAAA/W,GACAlR,KAAAwe,sBAAAmG,OAAAxG,MAAA3X,QAEAxG,SAMAkoB,eAAA,SAAAjI,EAAA9B,OAEA,MAAAne,MAAAmQ,IAAA8P,EAAA/b,EAAA+b,EAAA9b,EAAA8b,EAAA/c,EAAAib,OAAAne,KAAA2nB,SAIAQ,QAAA,WAIA,GAAAjX,GAAA,GAAAxH,OAAAqT,UAEA,iBAAAqL,UAEAlX,EAAAsM,aAAAxd,MACAA,KAAAgoB,kBAAA9W,EAAAkX,cAMA9U,OAAA,SAAAmK,OAEA,MAAAA,OAAAR,KAAAjd,KAAAid,IAAAQ,MAAAP,KAAAld,KAAAkd,IAAAO,MAAAN,KAAAnd,KAAAmd,IAAAM,MAAAkK,SAAA3nB,KAAA2nB,QAIApU,UAAA,SAAAC,OASA,MAPAxT,MAAAid,GAAAzJ,MAAA,GACAxT,KAAAkd,GAAA1J,MAAA,GACAxT,KAAAmd,GAAA3J,MAAA,GACA5J,SAAA4J,MAAA,KAAAxT,KAAA2nB,OAAAnU,MAAA,IAEAxT,KAAAsd,mBAEAtd,MAIAyT,QAAA,SAAAD,MAAAE,QAUA,MARA9J,UAAA4J,kBACA5J,SAAA8J,gBAAA,GAEAF,MAAAE,QAAA1T,KAAAid,GACAzJ,MAAAE,OAAA,GAAA1T,KAAAkd,GACA1J,MAAAE,OAAA,GAAA1T,KAAAmd,GACA3J,MAAAE,OAAA,GAAA1T,KAAA2nB,OAEAnU,OAGA6U,UAAA,SAAAC,gBAEA,MAAAA,gBAEAA,eAAAnY,IAAAnQ,KAAAid,GAAAjd,KAAAkd,GAAAld,KAAAmd,IAIA,GAAAzT,OAAAgW,QAAA1f,KAAAid,GAAAjd,KAAAkd,GAAAld,KAAAmd,KAMAoE,SAAA,SAAAC,UAIA,MAFAxhB,MAAAsd,iBAAAkE,SAEAxhB,MAIAsd,iBAAA,aAEA3J,MAAA,WAEA,UAAAjK,OAAAgU,MAAA1d,KAAAid,GAAAjd,KAAAkd,GAAAld,KAAAmd,GAAAnd,KAAA2nB,UAYAje,MAAA6e,MAAA,SAAAC,MAAAC,KAEAzoB,KAAAwoB,MAAA5e,SAAA4e,YAAA,GAAA9e,OAAAgW,QACA1f,KAAAyoB,IAAA7e,SAAA6e,QAAA,GAAA/e,OAAAgW,SAIAhW,MAAA6e,MAAAjoB,WAEAM,YAAA8I,MAAA6e,MAEApY,IAAA,SAAAqY,MAAAC,KAKA,MAHAzoB,MAAAwoB,MAAAhY,KAAAgY,OACAxoB,KAAAyoB,IAAAjY,KAAAiY,KAEAzoB,MAIAwQ,KAAA,SAAAkY,MAKA,MAHA1oB,MAAAwoB,MAAAhY,KAAAkY,KAAAF,OACAxoB,KAAAyoB,IAAAjY,KAAAkY,KAAAD,KAEAzoB,MAIA2oB,OAAA,SAAAtW,gBAEA,GAAA5N,QAAA4N,gBAAA,GAAA3I,OAAAgW,OACA,OAAAjb,QAAAud,WAAAhiB,KAAAwoB,MAAAxoB,KAAAyoB,KAAAtV,eAAA,KAIAR,MAAA,SAAAN,gBAEA,GAAA5N,QAAA4N,gBAAA,GAAA3I,OAAAgW,OACA,OAAAjb,QAAAwd,WAAAjiB,KAAAyoB,IAAAzoB,KAAAwoB,QAIAI,WAAA,WAEA,MAAA5oB,MAAAwoB,MAAAxF,kBAAAhjB,KAAAyoB,MAIAI,SAAA,WAEA,MAAA7oB,MAAAwoB,MAAAzF,WAAA/iB,KAAAyoB,MAIAK,GAAA,SAAA3X,EAAAkB,gBAEA,GAAA5N,QAAA4N,gBAAA,GAAA3I,OAAAgW,OAEA,OAAA1f,MAAA2S,MAAAlO,QAAA0O,eAAAhC,GAAAxN,IAAA3D,KAAAwoB,QAIAO,6BAAA,WAEA,GAAAC,QAAA,GAAAtf,OAAAgW,QACAuJ,SAAA,GAAAvf,OAAAgW,OAEA,iBAAAwJ,MAAAC,aAEAH,OAAA/G,WAAAiH,MAAAlpB,KAAAwoB,OACAS,SAAAhH,WAAAjiB,KAAAyoB,IAAAzoB,KAAAwoB,MAEA,IAAAY,WAAAH,SAAAtJ,IAAAsJ,UACAI,gBAAAJ,SAAAtJ,IAAAqJ,QAEA7X,EAAAkY,gBAAAD,SAQA,OANAD,eAEAhY,EAAAzH,MAAAG,KAAA0Y,MAAApR,EAAA,MAIAA,MAMAmY,oBAAA,SAAAJ,MAAAC,YAAA9W,gBAEA,GAAAlB,GAAAnR,KAAA+oB,6BAAAG,MAAAC,aAEA1kB,OAAA4N,gBAAA,GAAA3I,OAAAgW,OAEA,OAAA1f,MAAA2S,MAAAlO,QAAA0O,eAAAhC,GAAAxN,IAAA3D,KAAAwoB,QAIAxE,aAAA,SAAAW,QAKA,MAHA3kB,MAAAwoB,MAAAxE,aAAAW,QACA3kB,KAAAyoB,IAAAzE,aAAAW,QAEA3kB,MAIAsT,OAAA,SAAAoV,MAEA,MAAAA,MAAAF,MAAAlV,OAAAtT,KAAAwoB,QAAAE,KAAAD,IAAAnV,OAAAtT,KAAAyoB,MAIA9U,MAAA,WAEA,UAAAjK,OAAA6e,OAAA/X,KAAAxQ,QAYA0J,MAAA6f,KAAA,SAAAjY,IAAAmB,KAEAzS,KAAAsR,IAAA1H,SAAA0H,QAAA,GAAA5H,OAAAiY,QAAA6H,SACAxpB,KAAAyS,IAAA7I,SAAA6I,QAAA,GAAA/I,OAAAiY,UAAA6H,cAIA9f,MAAA6f,KAAAjpB,WAEAM,YAAA8I,MAAA6f,KAEApZ,IAAA,SAAAmB,IAAAmB,KAKA,MAHAzS,MAAAsR,IAAAd,KAAAc,KACAtR,KAAAyS,IAAAjC,KAAAiC,KAEAzS,MAIAypB,cAAA,SAAAC,QAEA1pB,KAAA2pB,WAEA,QAAAjlB,GAAA,EAAAklB,GAAAF,OAAA/kB,OAAsCilB,GAAAllB,EAAQA,IAE9C1E,KAAA6pB,cAAAH,OAAAhlB,GAIA,OAAA1E,OAIA8pB,qBAAA,WAEA,GAAAxK,IAAA,GAAA5V,OAAAiY,OAEA,iBAAAgH,OAAAoB,MAEA,GAAAC,UAAA1K,GAAA9O,KAAAuZ,MAAA5W,eAAA,GAIA,OAHAnT,MAAAsR,IAAAd,KAAAmY,QAAAnoB,IAAAwpB,UACAhqB,KAAAyS,IAAAjC,KAAAmY,QAAAhlB,IAAAqmB,UAEAhqB,SAMAwQ,KAAA,SAAAyZ,KAKA,MAHAjqB,MAAAsR,IAAAd,KAAAyZ,IAAA3Y,KACAtR,KAAAyS,IAAAjC,KAAAyZ,IAAAxX,KAEAzS,MAIA2pB,UAAA,WAKA,MAHA3pB,MAAAsR,IAAApN,EAAAlE,KAAAsR,IAAAnN,EAAAqlB,IACAxpB,KAAAyS,IAAAvO,EAAAlE,KAAAyS,IAAAtO,IAAAqlB,KAEAxpB,MAIAkqB,MAAA,WAIA,MAAAlqB,MAAAyS,IAAAvO,EAAAlE,KAAAsR,IAAApN,GAAAlE,KAAAyS,IAAAtO,EAAAnE,KAAAsR,IAAAnN,GAIAwkB,OAAA,SAAAtW,gBAEA,GAAA5N,QAAA4N,gBAAA,GAAA3I,OAAAiY,OACA,OAAAld,QAAAud,WAAAhiB,KAAAsR,IAAAtR,KAAAyS,KAAAU,eAAA,KAIA4W,KAAA,SAAA1X,gBAEA,GAAA5N,QAAA4N,gBAAA,GAAA3I,OAAAiY,OACA,OAAAld,QAAAwd,WAAAjiB,KAAAyS,IAAAzS,KAAAsR,MAIAuY,cAAA,SAAAX,OAKA,MAHAlpB,MAAAsR,QAAA4X,OACAlpB,KAAAyS,QAAAyW,OAEAlpB,MAGAmqB,eAAA,SAAAza,QAKA,MAHA1P,MAAAsR,IAAA9Q,IAAAkP,QACA1P,KAAAyS,IAAA9O,IAAA+L,QAEA1P,MAGAoqB,eAAA,SAAA/H,QAKA,MAHAriB,MAAAsR,IAAA2B,WAAAoP,QACAriB,KAAAyS,IAAAQ,UAAAoP,QAEAriB,MAGAqqB,cAAA,SAAAnB,OAEA,MAAAA,OAAAhlB,EAAAlE,KAAAsR,IAAApN,GAAAglB,MAAAhlB,EAAAlE,KAAAyS,IAAAvO,GACAglB,MAAA/kB,EAAAnE,KAAAsR,IAAAnN,GAAA+kB,MAAA/kB,EAAAnE,KAAAyS,IAAAtO,GAEA,GAIA,GAIAmmB,YAAA,SAAAL,KAEA,MAAAjqB,MAAAsR,IAAApN,GAAA+lB,IAAA3Y,IAAApN,GAAA+lB,IAAAxX,IAAAvO,GAAAlE,KAAAyS,IAAAvO,GACAlE,KAAAsR,IAAAnN,GAAA8lB,IAAA3Y,IAAAnN,GAAA8lB,IAAAxX,IAAAtO,GAAAnE,KAAAyS,IAAAtO,GAEA,GAIA,GAIAomB,aAAA,SAAArB,MAAA7W,gBAKA,GAAA5N,QAAA4N,gBAAA,GAAA3I,OAAAiY,OAEA,OAAAld,QAAA0L,KACA+Y,MAAAhlB,EAAAlE,KAAAsR,IAAApN,IAAAlE,KAAAyS,IAAAvO,EAAAlE,KAAAsR,IAAApN,IACAglB,MAAA/kB,EAAAnE,KAAAsR,IAAAnN,IAAAnE,KAAAyS,IAAAtO,EAAAnE,KAAAsR,IAAAnN,KAKAqmB,kBAAA,SAAAP,KAIA,MAAAA,KAAAxX,IAAAvO,EAAAlE,KAAAsR,IAAApN,GAAA+lB,IAAA3Y,IAAApN,EAAAlE,KAAAyS,IAAAvO,GACA+lB,IAAAxX,IAAAtO,EAAAnE,KAAAsR,IAAAnN,GAAA8lB,IAAA3Y,IAAAnN,EAAAnE,KAAAyS,IAAAtO,GAEA,GAIA,GAIAsmB,WAAA,SAAAvB,MAAA7W,gBAEA,GAAA5N,QAAA4N,gBAAA,GAAA3I,OAAAiY,OACA,OAAAld,QAAA+L,KAAA0Y,OAAA3G,MAAAviB,KAAAsR,IAAAtR,KAAAyS,MAIAiY,gBAAA,WAEA,GAAApL,IAAA,GAAA5V,OAAAiY,OAEA,iBAAAuH,OAEA,GAAAyB,cAAArL,GAAA9O,KAAA0Y,OAAA3G,MAAAviB,KAAAsR,IAAAtR,KAAAyS,IACA,OAAAkY,cAAAnqB,IAAA0oB,OAAAvkB,aAMAimB,UAAA,SAAAX,KAKA,MAHAjqB,MAAAsR,IAAAmB,IAAAwX,IAAA3Y,KACAtR,KAAAyS,IAAAnB,IAAA2Y,IAAAxX,KAEAzS,MAIA6qB,MAAA,SAAAZ,KAKA,MAHAjqB,MAAAsR,QAAA2Y,IAAA3Y,KACAtR,KAAAyS,QAAAwX,IAAAxX,KAEAzS,MAIA8qB,UAAA,SAAApX,QAKA,MAHA1T,MAAAsR,IAAA3N,IAAA+P,QACA1T,KAAAyS,IAAA9O,IAAA+P,QAEA1T,MAIAsT,OAAA,SAAA2W,KAEA,MAAAA,KAAA3Y,IAAAgC,OAAAtT,KAAAsR,MAAA2Y,IAAAxX,IAAAa,OAAAtT,KAAAyS,MAIAkB,MAAA,WAEA,UAAAjK,OAAA6f,MAAA/Y,KAAAxQ,QAaA0J,MAAAqhB,KAAA,SAAAzZ,IAAAmB,KAEAzS,KAAAsR,IAAA1H,SAAA0H,QAAA,GAAA5H,OAAAgW,QAAA8J,aACAxpB,KAAAyS,IAAA7I,SAAA6I,QAAA,GAAA/I,OAAAgW,UAAA8J,qBAIA9f,MAAAqhB,KAAAzqB,WAEAM,YAAA8I,MAAAqhB,KAEA5a,IAAA,SAAAmB,IAAAmB,KAKA,MAHAzS,MAAAsR,IAAAd,KAAAc,KACAtR,KAAAyS,IAAAjC,KAAAiC,KAEAzS,MAIAypB,cAAA,SAAAC,QAEA1pB,KAAA2pB,WAEA,QAAAjlB,GAAA,EAAAklB,GAAAF,OAAA/kB,OAAsCilB,GAAAllB,EAAQA,IAE9C1E,KAAA6pB,cAAAH,OAAAhlB,GAIA,OAAA1E,OAIA8pB,qBAAA,WAEA,GAAAxK,IAAA,GAAA5V,OAAAgW,OAEA,iBAAAiJ,OAAAoB,MAEA,GAAAC,UAAA1K,GAAA9O,KAAAuZ,MAAA5W,eAAA,GAKA,OAHAnT,MAAAsR,IAAAd,KAAAmY,QAAAnoB,IAAAwpB,UACAhqB,KAAAyS,IAAAjC,KAAAmY,QAAAhlB,IAAAqmB,UAEAhqB,SAMAgrB,cAAA,WAKA,GAAA1L,IAAA,GAAA5V,OAAAgW,OAEA,iBAAAuL,QAEA,GAAAC,OAAAlrB,IA8CA,OA5CAirB,QAAAE,mBAAA,GAEAnrB,KAAA2pB,YAEAsB,OAAAG,SAAA,SAAAC,MAEA,GAAAloB,UAAAkoB,KAAAloB,QAEA,IAAAyG,SAAAzG,SAEA,GAAAA,mBAAAuG,OAAA4hB,SAIA,OAFAC,UAAApoB,SAAAooB,SAEA7mB,EAAA,EAAAklB,GAAA2B,SAAA5mB,OAA4CilB,GAAAllB,EAAQA,IAEpD4a,GAAA9O,KAAA+a,SAAA7mB,IAEA4a,GAAA0E,aAAAqH,KAAArG,aAEAkG,MAAArB,cAAAvK,QAIM,IAAAnc,mBAAAuG,OAAA8hB,gBAAA5hB,SAAAzG,SAAAsoB,WAAA,SAIN,OAFAC,WAAAvoB,SAAAsoB,WAAA,SAAAjY,MAEA9O,EAAA,EAAAklB,GAAA8B,UAAA/mB,OAA6CilB,GAAAllB,EAAQA,GAAA,EAErD4a,GAAAnP,IAAAub,UAAAhnB,GAAAgnB,UAAAhnB,EAAA,GAAAgnB,UAAAhnB,EAAA,IAEA4a,GAAA0E,aAAAqH,KAAArG,aAEAkG,MAAArB,cAAAvK,MAUAtf,SAMAwQ,KAAA,SAAAyZ,KAKA,MAHAjqB,MAAAsR,IAAAd,KAAAyZ,IAAA3Y,KACAtR,KAAAyS,IAAAjC,KAAAyZ,IAAAxX,KAEAzS,MAIA2pB,UAAA,WAKA,MAHA3pB,MAAAsR,IAAApN,EAAAlE,KAAAsR,IAAAnN,EAAAnE,KAAAsR,IAAApO,EAAAsmB,IACAxpB,KAAAyS,IAAAvO,EAAAlE,KAAAyS,IAAAtO,EAAAnE,KAAAyS,IAAAvP,IAAAsmB,KAEAxpB,MAIAkqB,MAAA,WAIA,MAAAlqB,MAAAyS,IAAAvO,EAAAlE,KAAAsR,IAAApN,GAAAlE,KAAAyS,IAAAtO,EAAAnE,KAAAsR,IAAAnN,GAAAnE,KAAAyS,IAAAvP,EAAAlD,KAAAsR,IAAApO,GAIAylB,OAAA,SAAAtW,gBAEA,GAAA5N,QAAA4N,gBAAA,GAAA3I,OAAAgW,OACA,OAAAjb,QAAAud,WAAAhiB,KAAAsR,IAAAtR,KAAAyS,KAAAU,eAAA,KAIA4W,KAAA,SAAA1X,gBAEA,GAAA5N,QAAA4N,gBAAA,GAAA3I,OAAAgW,OACA,OAAAjb,QAAAwd,WAAAjiB,KAAAyS,IAAAzS,KAAAsR,MAIAuY,cAAA,SAAAX,OAKA,MAHAlpB,MAAAsR,QAAA4X,OACAlpB,KAAAyS,QAAAyW,OAEAlpB,MAIAmqB,eAAA,SAAAza,QAKA,MAHA1P,MAAAsR,IAAA9Q,IAAAkP,QACA1P,KAAAyS,IAAA9O,IAAA+L,QAEA1P,MAIAoqB,eAAA,SAAA/H,QAKA,MAHAriB,MAAAsR,IAAA2B,WAAAoP,QACAriB,KAAAyS,IAAAQ,UAAAoP,QAEAriB,MAIAqqB,cAAA,SAAAnB,OAEA,MAAAA,OAAAhlB,EAAAlE,KAAAsR,IAAApN,GAAAglB,MAAAhlB,EAAAlE,KAAAyS,IAAAvO,GACAglB,MAAA/kB,EAAAnE,KAAAsR,IAAAnN,GAAA+kB,MAAA/kB,EAAAnE,KAAAyS,IAAAtO,GACA+kB,MAAAhmB,EAAAlD,KAAAsR,IAAApO,GAAAgmB,MAAAhmB,EAAAlD,KAAAyS,IAAAvP,GAEA,GAIA,GAIAonB,YAAA,SAAAL,KAEA,MAAAjqB,MAAAsR,IAAApN,GAAA+lB,IAAA3Y,IAAApN,GAAA+lB,IAAAxX,IAAAvO,GAAAlE,KAAAyS,IAAAvO,GACAlE,KAAAsR,IAAAnN,GAAA8lB,IAAA3Y,IAAAnN,GAAA8lB,IAAAxX,IAAAtO,GAAAnE,KAAAyS,IAAAtO,GACAnE,KAAAsR,IAAApO,GAAA+mB,IAAA3Y,IAAApO,GAAA+mB,IAAAxX,IAAAvP,GAAAlD,KAAAyS,IAAAvP,GAEA,GAIA,GAIAqnB,aAAA,SAAArB,MAAA7W,gBAKA,GAAA5N,QAAA4N,gBAAA,GAAA3I,OAAAgW,OAEA,OAAAjb,QAAA0L,KACA+Y,MAAAhlB,EAAAlE,KAAAsR,IAAApN,IAAAlE,KAAAyS,IAAAvO,EAAAlE,KAAAsR,IAAApN,IACAglB,MAAA/kB,EAAAnE,KAAAsR,IAAAnN,IAAAnE,KAAAyS,IAAAtO,EAAAnE,KAAAsR,IAAAnN,IACA+kB,MAAAhmB,EAAAlD,KAAAsR,IAAApO,IAAAlD,KAAAyS,IAAAvP,EAAAlD,KAAAsR,IAAApO,KAKAsnB,kBAAA,SAAAP,KAIA,MAAAA,KAAAxX,IAAAvO,EAAAlE,KAAAsR,IAAApN,GAAA+lB,IAAA3Y,IAAApN,EAAAlE,KAAAyS,IAAAvO,GACA+lB,IAAAxX,IAAAtO,EAAAnE,KAAAsR,IAAAnN,GAAA8lB,IAAA3Y,IAAAnN,EAAAnE,KAAAyS,IAAAtO,GACA8lB,IAAAxX,IAAAvP,EAAAlD,KAAAsR,IAAApO,GAAA+mB,IAAA3Y,IAAApO,EAAAlD,KAAAyS,IAAAvP,GAEA,GAIA,GAIAunB,WAAA,SAAAvB,MAAA7W,gBAEA,GAAA5N,QAAA4N,gBAAA,GAAA3I,OAAAgW,OACA,OAAAjb,QAAA+L,KAAA0Y,OAAA3G,MAAAviB,KAAAsR,IAAAtR,KAAAyS,MAIAiY,gBAAA,WAEA,GAAApL,IAAA,GAAA5V,OAAAgW,OAEA,iBAAAwJ,OAEA,GAAAyB,cAAArL,GAAA9O,KAAA0Y,OAAA3G,MAAAviB,KAAAsR,IAAAtR,KAAAyS,IACA,OAAAkY,cAAAnqB,IAAA0oB,OAAAvkB,aAMAgnB,kBAAA,WAEA,GAAArM,IAAA,GAAA5V,OAAAgW,OAEA,iBAAArN,gBAEA,GAAA5N,QAAA4N,gBAAA,GAAA3I,OAAAkiB,MAKA,OAHAnnB,QAAAkkB,OAAA3oB,KAAA2oB,SACAlkB,OAAAonB,OAAA,GAAA7rB,KAAA+pB,KAAAzK,IAAA3a,SAEAF,WAMAmmB,UAAA,SAAAX,KAKA,MAHAjqB,MAAAsR,IAAAmB,IAAAwX,IAAA3Y,KACAtR,KAAAyS,IAAAnB,IAAA2Y,IAAAxX,KAEAzS,MAIA6qB,MAAA,SAAAZ,KAKA,MAHAjqB,MAAAsR,QAAA2Y,IAAA3Y,KACAtR,KAAAyS,QAAAwX,IAAAxX,KAEAzS,MAIAgkB,aAAA,WAEA,GAAA0F,SACA,GAAAhgB,OAAAgW,QACA,GAAAhW,OAAAgW,QACA,GAAAhW,OAAAgW,QACA,GAAAhW,OAAAgW,QACA,GAAAhW,OAAAgW,QACA,GAAAhW,OAAAgW,QACA,GAAAhW,OAAAgW,QACA,GAAAhW,OAAAgW,QAGA,iBAAAiF,QAeA,MAZA+E,QAAA,GAAAvZ,IAAAnQ,KAAAsR,IAAApN,EAAAlE,KAAAsR,IAAAnN,EAAAnE,KAAAsR,IAAApO,GAAA8gB,aAAAW,QACA+E,OAAA,GAAAvZ,IAAAnQ,KAAAsR,IAAApN,EAAAlE,KAAAsR,IAAAnN,EAAAnE,KAAAyS,IAAAvP,GAAA8gB,aAAAW,QACA+E,OAAA,GAAAvZ,IAAAnQ,KAAAsR,IAAApN,EAAAlE,KAAAyS,IAAAtO,EAAAnE,KAAAsR,IAAApO,GAAA8gB,aAAAW,QACA+E,OAAA,GAAAvZ,IAAAnQ,KAAAsR,IAAApN,EAAAlE,KAAAyS,IAAAtO,EAAAnE,KAAAyS,IAAAvP,GAAA8gB,aAAAW,QACA+E,OAAA,GAAAvZ,IAAAnQ,KAAAyS,IAAAvO,EAAAlE,KAAAsR,IAAAnN,EAAAnE,KAAAsR,IAAApO,GAAA8gB,aAAAW,QACA+E,OAAA,GAAAvZ,IAAAnQ,KAAAyS,IAAAvO,EAAAlE,KAAAsR,IAAAnN,EAAAnE,KAAAyS,IAAAvP,GAAA8gB,aAAAW,QACA+E,OAAA,GAAAvZ,IAAAnQ,KAAAyS,IAAAvO,EAAAlE,KAAAyS,IAAAtO,EAAAnE,KAAAsR,IAAApO,GAAA8gB,aAAAW,QACA+E,OAAA,GAAAvZ,IAAAnQ,KAAAyS,IAAAvO,EAAAlE,KAAAyS,IAAAtO,EAAAnE,KAAAyS,IAAAvP,GAAA8gB,aAAAW,QAEA3kB,KAAA2pB,YACA3pB,KAAAypB,cAAAC,QAEA1pB,SAMA8qB,UAAA,SAAApX,QAKA,MAHA1T,MAAAsR,IAAA3N,IAAA+P,QACA1T,KAAAyS,IAAA9O,IAAA+P,QAEA1T,MAIAsT,OAAA,SAAA2W,KAEA,MAAAA,KAAA3Y,IAAAgC,OAAAtT,KAAAsR,MAAA2Y,IAAAxX,IAAAa,OAAAtT,KAAAyS,MAIAkB,MAAA,WAEA,UAAAjK,OAAAqhB,MAAAva,KAAAxQ,QAcA0J,MAAAoiB,QAAA,WAEA9rB,KAAA0e,SAAA,GAAAqN,eAEA,MACA,MACA,QAIAvqB,UAAAmD,OAAA,GAEA+E,MAAAM,MAAA,kFAMAN,MAAAoiB,QAAAxrB,WAEAM,YAAA8I,MAAAoiB,QAEA3b,IAAA,SAAA6b,IAAAC,IAAAC,IAAAC,IAAAC,IAAAC,IAAAC,IAAAC,IAAAC,KAEA,GAAA/N,IAAAze,KAAA0e,QAMA,OAJAD,IAAA,GAAAuN,IAAgBvN,GAAA,GAAAwN,IAAexN,GAAA,GAAAyN,IAC/BzN,GAAA,GAAA0N,IAAgB1N,GAAA,GAAA2N,IAAe3N,GAAA,GAAA4N,IAC/B5N,GAAA,GAAA6N,IAAgB7N,GAAA,GAAA8N,IAAe9N,GAAA,GAAA+N,IAE/BxsB,MAIAysB,SAAA,WAUA,MARAzsB,MAAAmQ,IAEA,MACA,MACA,OAIAnQ,MAIAwQ,KAAA,SAAAjR,GAEA,GAAAsnB,IAAAtnB,EAAAmf,QAUA,OARA1e,MAAAmQ,IAEA0W,GAAA,GAAAA,GAAA,GAAAA,GAAA,GACAA,GAAA,GAAAA,GAAA,GAAAA,GAAA,GACAA,GAAA,GAAAA,GAAA,GAAAA,GAAA,IAIA7mB,MAIA6gB,gBAAA,SAAAnR,QAGA,MADAhG,OAAAK,KAAA,kGACA2F,OAAAoU,aAAA9jB,OAIA0sB,qBAAA,SAAAtM,GAGA,MADA1W,OAAAK,KAAA,6GACA/J,KAAA2sB,oBAAAvM,IAIAuM,oBAAA,WAEA,GAAArN,IAAA,GAAA5V,OAAAgW,OAEA,iBAAAlM,MAAAE,OAAA/O,QAEAiF,SAAA8J,gBAAA,GACA9J,SAAAjF,gBAAA6O,MAAA7O,OAEA,QAAAD,GAAA,EAAAY,EAAAoO,OAA+B/O,OAAAD,EAAYA,GAAA,EAAAY,GAAA,EAE3Cga,GAAApb,EAAAsP,MAAAlO,GACAga,GAAAnb,EAAAqP,MAAAlO,EAAA,GACAga,GAAApc,EAAAsQ,MAAAlO,EAAA,GAEAga,GAAAwE,aAAA9jB,MAEAwT,MAAAlO,GAAAga,GAAApb,EACAsP,MAAAlO,EAAA,GAAAga,GAAAnb,EACAqP,MAAAlO,EAAA,GAAAga,GAAApc,CAIA,OAAAsQ,WAMAL,eAAA,SAAApC,GAEA,GAAA0N,IAAAze,KAAA0e,QAMA,OAJAD,IAAA,IAAA1N,EAAe0N,GAAA,IAAA1N,EAAc0N,GAAA,IAAA1N,EAC7B0N,GAAA,IAAA1N,EAAe0N,GAAA,IAAA1N,EAAc0N,GAAA,IAAA1N,EAC7B0N,GAAA,IAAA1N,EAAe0N,GAAA,IAAA1N,EAAc0N,GAAA,IAAA1N,EAE7B/Q,MAIA4sB,YAAA,WAEA,GAAAnO,IAAAze,KAAA0e,SAEA0B,EAAA3B,GAAA,GAAAnO,EAAAmO,GAAA,GAAAjf,EAAAif,GAAA,GACAyF,EAAAzF,GAAA,GAAAsF,EAAAtF,GAAA,GAAAoO,EAAApO,GAAA,GACApO,EAAAoO,GAAA,GAAA3N,EAAA2N,GAAA,GAAA/Z,EAAA+Z,GAAA,EAEA,OAAA2B,GAAA2D,EAAArf,EAAA0b,EAAAyM,EAAA/b,EAAAR,EAAA4T,EAAAxf,EAAA4L,EAAAuc,EAAAxc,EAAA7Q,EAAA0kB,EAAApT,EAAAtR,EAAAukB,EAAA1T,GAIA0U,WAAA,SAAAJ,OAAAmI,mBAKA,GAAAjG,IAAAlC,OAAAjG,SACAD,GAAAze,KAAA0e,QAEAD,IAAA,GAAAoI,GAAA,IAAAA,GAAA,GAAAA,GAAA,GAAAA,GAAA,GACApI,GAAA,IAAAoI,GAAA,IAAAA,GAAA,GAAAA,GAAA,GAAAA,GAAA,GACApI,GAAA,GAAAoI,GAAA,GAAAA,GAAA,GAAAA,GAAA,GAAAA,GAAA,GACApI,GAAA,IAAAoI,GAAA,IAAAA,GAAA,GAAAA,GAAA,GAAAA,GAAA,GACApI,GAAA,GAAAoI,GAAA,IAAAA,GAAA,GAAAA,GAAA,GAAAA,GAAA,GACApI,GAAA,IAAAoI,GAAA,GAAAA,GAAA,GAAAA,GAAA,GAAAA,GAAA,GACApI,GAAA,GAAAoI,GAAA,GAAAA,GAAA,GAAAA,GAAA,GAAAA,GAAA,GACApI,GAAA,IAAAoI,GAAA,GAAAA,GAAA,GAAAA,GAAA,GAAAA,GAAA,GACApI,GAAA,GAAAoI,GAAA,GAAAA,GAAA,GAAAA,GAAA,GAAAA,GAAA,EAEA,IAAAkG,KAAAlG,GAAA,GAAApI,GAAA,GAAAoI,GAAA,GAAApI,GAAA,GAAAoI,GAAA,GAAApI,GAAA,EAIA,QAAAsO,IAAA,CAEA,GAAAC,KAAA,6DAEA,IAAAF,kBAEA,SAAA3jB,OAAA6jB,IAUA,OANAtjB,OAAAK,KAAAijB,KAIAhtB,KAAAysB,WAEAzsB,KAMA,MAFAA,MAAAmT,eAAA,EAAA4Z,KAEA/sB,MAIAitB,UAAA,WAEA,GAAAC,KAAA3tB,EAAAS,KAAA0e,QAMA,OAJAwO,KAAA3tB,EAAA,GAAeA,EAAA,GAAAA,EAAA,GAAiBA,EAAA,GAAA2tB,IAChCA,IAAA3tB,EAAA,GAAeA,EAAA,GAAAA,EAAA,GAAiBA,EAAA,GAAA2tB,IAChCA,IAAA3tB,EAAA,GAAeA,EAAA,GAAAA,EAAA,GAAiBA,EAAA,GAAA2tB,IAEhCltB,MAIAmtB,qBAAA,SAAA3Z,MAAAE,QAEA,GAAA+K,IAAAze,KAAA0e,QAcA,OAZAlL,OAAAE,QAAA+K,GAAA,GACAjL,MAAAE,OAAA,GAAA+K,GAAA,GACAjL,MAAAE,OAAA,GAAA+K,GAAA,GAEAjL,MAAAE,OAAA,GAAA+K,GAAA,GACAjL,MAAAE,OAAA,GAAA+K,GAAA,GACAjL,MAAAE,OAAA,GAAA+K,GAAA,GAEAjL,MAAAE,OAAA,GAAA+K,GAAA,GACAjL,MAAAE,OAAA,GAAA+K,GAAA,GACAjL,MAAAE,OAAA,GAAA+K,GAAA,GAEAjL,OAIA4Z,gBAAA,SAAA7tB,GAMA,MAFAS,MAAA+kB,WAAAxlB,GAAA0tB,YAEAjtB,MAIAqtB,mBAAA,SAAAjd,GAEA,GAAA7Q,GAAAS,KAAA0e,QAYA,OAVAtO,GAAA,GAAA7Q,EAAA,GACA6Q,EAAA,GAAA7Q,EAAA,GACA6Q,EAAA,GAAA7Q,EAAA,GACA6Q,EAAA,GAAA7Q,EAAA,GACA6Q,EAAA,GAAA7Q,EAAA,GACA6Q,EAAA,GAAA7Q,EAAA,GACA6Q,EAAA,GAAA7Q,EAAA,GACA6Q,EAAA,GAAA7Q,EAAA,GACA6Q,EAAA,GAAA7Q,EAAA,GAEAS,MAIAuT,UAAA,SAAAC,OAIA,MAFAxT,MAAA0e,SAAAvO,IAAAqD,OAEAxT,MAIAyT,QAAA,WAEA,GAAAgL,IAAAze,KAAA0e,QAEA,QACAD,GAAA,GAAAA,GAAA,GAAAA,GAAA,GACAA,GAAA,GAAAA,GAAA,GAAAA,GAAA,GACAA,GAAA,GAAAA,GAAA,GAAAA,GAAA,KAKA9K,MAAA,WAEA,UAAAjK,OAAAoiB,SAAAvY,UAAAvT,KAAA0e,YAqBAhV,MAAAkb,QAAA,WAEA5kB,KAAA0e,SAAA,GAAAqN,eAEA,QACA,QACA,QACA,UAIAvqB,UAAAmD,OAAA,GAEA+E,MAAAM,MAAA,kFAMAN,MAAAkb,QAAAtkB,WAEAM,YAAA8I,MAAAkb,QAEAzU,IAAA,SAAA6b,IAAAC,IAAAC,IAAAoB,IAAAnB,IAAAC,IAAAC,IAAAkB,IAAAjB,IAAAC,IAAAC,IAAAgB,IAAAC,IAAAC,IAAAC,IAAAC,KAEA,GAAAnP,IAAAze,KAAA0e,QAOA,OALAD,IAAA,GAAAuN,IAAgBvN,GAAA,GAAAwN,IAAexN,GAAA,GAAAyN,IAAezN,GAAA,IAAA6O,IAC9C7O,GAAA,GAAA0N,IAAgB1N,GAAA,GAAA2N,IAAe3N,GAAA,GAAA4N,IAAe5N,GAAA,IAAA8O,IAC9C9O,GAAA,GAAA6N,IAAgB7N,GAAA,GAAA8N,IAAe9N,GAAA,IAAA+N,IAAgB/N,GAAA,IAAA+O,IAC/C/O,GAAA,GAAAgP,IAAgBhP,GAAA,GAAAiP,IAAejP,GAAA,IAAAkP,IAAgBlP,GAAA,IAAAmP,IAE/C5tB,MAIAysB,SAAA,WAWA,MATAzsB,MAAAmQ,IAEA,QACA,QACA,QACA,SAIAnQ,MAIAwQ,KAAA,SAAAjR,GAIA,MAFAS,MAAA0e,SAAAvO,IAAA5Q,EAAAmf,UAEA1e,MAIA6tB,gBAAA,SAAAtuB,GAGA,MADAmK,OAAAK,KAAA,0EACA/J,KAAA8tB,aAAAvuB,IAIAuuB,aAAA,SAAAvuB,GAEA,GAAAkf,IAAAze,KAAA0e,SACAmI,GAAAtnB,EAAAmf,QAMA,OAJAD,IAAA,IAAAoI,GAAA,IACApI,GAAA,IAAAoI,GAAA,IACApI,GAAA,IAAAoI,GAAA,IAEA7mB,MAIA+tB,aAAA,SAAAC,MAAAC,MAAAC,OAEA,GAAAzP,IAAAze,KAAA0e,QAMA,OAJAsP,OAAA7d,IAAAsO,GAAA,GAAAA,GAAA,GAAAA,GAAA,IACAwP,MAAA9d,IAAAsO,GAAA,GAAAA,GAAA,GAAAA,GAAA,IACAyP,MAAA/d,IAAAsO,GAAA,GAAAA,GAAA,GAAAA,GAAA,KAEAze,MAIAmuB,UAAA,SAAAH,MAAAC,MAAAC,OASA,MAPAluB,MAAAmQ,IACA6d,MAAA9pB,EAAA+pB,MAAA/pB,EAAAgqB,MAAAhqB,EAAA,EACA8pB,MAAA7pB,EAAA8pB,MAAA9pB,EAAA+pB,MAAA/pB,EAAA,EACA6pB,MAAA9qB,EAAA+qB,MAAA/qB,EAAAgrB,MAAAhrB,EAAA,EACA,SAGAlD,MAIAouB,gBAAA,WAEA,GAAA9O,IAAA,GAAA5V,OAAAgW,OAEA,iBAAAngB,GAEA,GAAAkf,IAAAze,KAAA0e,SACAmI,GAAAtnB,EAAAmf,SAEA2P,OAAA,EAAA/O,GAAAnP,IAAA0W,GAAA,GAAAA,GAAA,GAAAA,GAAA,IAAAliB,SACA2pB,OAAA,EAAAhP,GAAAnP,IAAA0W,GAAA,GAAAA,GAAA,GAAAA,GAAA,IAAAliB,SACA4pB,OAAA,EAAAjP,GAAAnP,IAAA0W,GAAA,GAAAA,GAAA,GAAAA,GAAA,KAAAliB,QAcA,OAZA8Z,IAAA,GAAAoI,GAAA,GAAAwH,OACA5P,GAAA,GAAAoI,GAAA,GAAAwH,OACA5P,GAAA,GAAAoI,GAAA,GAAAwH,OAEA5P,GAAA,GAAAoI,GAAA,GAAAyH,OACA7P,GAAA,GAAAoI,GAAA,GAAAyH,OACA7P,GAAA,GAAAoI,GAAA,GAAAyH,OAEA7P,GAAA,GAAAoI,GAAA,GAAA0H,OACA9P,GAAA,GAAAoI,GAAA,GAAA0H,OACA9P,GAAA,IAAAoI,GAAA,IAAA0H,OAEAvuB,SAMAwuB,sBAAA,SAAA/Q,OAEAA,gBAAA/T,OAAAgU,QAAA,GAEAhU,MAAAM,MAAA,uGAIA,IAAAyU,IAAAze,KAAA0e,SAEAxa,EAAAuZ,MAAAvZ,EAAAC,EAAAsZ,MAAAtZ,EAAAjB,EAAAua,MAAAva,EACAkd,EAAAvW,KAAA+T,IAAA1Z,GAAAoM,EAAAzG,KAAAmU,IAAA9Z,GACA1E,EAAAqK,KAAA+T,IAAAzZ,GAAA+f,EAAAra,KAAAmU,IAAA7Z,GACA4f,EAAAla,KAAA+T,IAAA1a,GAAA2pB,EAAAhjB,KAAAmU,IAAA9a,EAEA,YAAAua,MAAAU,MAAA,CAEA,GAAAsQ,IAAArO,EAAA2D,EAAA2K,GAAAtO,EAAAyM,EAAA8B,GAAAre,EAAAyT,EAAA6K,GAAAte,EAAAuc,CAEApO,IAAA,GAAAjf,EAAAukB,EACAtF,GAAA,IAAAjf,EAAAqtB,EACApO,GAAA,GAAAyF,EAEAzF,GAAA,GAAAiQ,GAAAC,GAAAzK,EACAzF,GAAA,GAAAgQ,GAAAG,GAAA1K,EACAzF,GAAA,IAAAnO,EAAA9Q,EAEAif,GAAA,GAAAmQ,GAAAH,GAAAvK,EACAzF,GAAA,GAAAkQ,GAAAD,GAAAxK,EACAzF,GAAA,IAAA2B,EAAA5gB,MAEG,YAAAie,MAAAU,MAAA,CAEH,GAAA0Q,IAAArvB,EAAAukB,EAAA+K,GAAAtvB,EAAAqtB,EAAAkC,GAAA7K,EAAAH,EAAAiL,GAAA9K,EAAA2I,CAEApO,IAAA,GAAAoQ,GAAAG,GAAA1e,EACAmO,GAAA,GAAAsQ,GAAAze,EAAAwe,GACArQ,GAAA,GAAA2B,EAAA8D,EAEAzF,GAAA,GAAA2B,EAAAyM,EACApO,GAAA,GAAA2B,EAAA2D,EACAtF,GAAA,IAAAnO,EAEAmO,GAAA,GAAAqQ,GAAAxe,EAAAye,GACAtQ,GAAA,GAAAuQ,GAAAH,GAAAve,EACAmO,GAAA,IAAA2B,EAAA5gB,MAEG,YAAAie,MAAAU,MAAA,CAEH,GAAA0Q,IAAArvB,EAAAukB,EAAA+K,GAAAtvB,EAAAqtB,EAAAkC,GAAA7K,EAAAH,EAAAiL,GAAA9K,EAAA2I,CAEApO,IAAA,GAAAoQ,GAAAG,GAAA1e,EACAmO,GAAA,IAAA2B,EAAAyM,EACApO,GAAA,GAAAsQ,GAAAD,GAAAxe,EAEAmO,GAAA,GAAAqQ,GAAAC,GAAAze,EACAmO,GAAA,GAAA2B,EAAA2D,EACAtF,GAAA,GAAAuQ,GAAAH,GAAAve,EAEAmO,GAAA,IAAA2B,EAAA8D,EACAzF,GAAA,GAAAnO,EACAmO,GAAA,IAAA2B,EAAA5gB,MAEG,YAAAie,MAAAU,MAAA,CAEH,GAAAsQ,IAAArO,EAAA2D,EAAA2K,GAAAtO,EAAAyM,EAAA8B,GAAAre,EAAAyT,EAAA6K,GAAAte,EAAAuc,CAEApO,IAAA,GAAAjf,EAAAukB,EACAtF,GAAA,GAAAkQ,GAAAzK,EAAAwK,GACAjQ,GAAA,GAAAgQ,GAAAvK,EAAA0K,GAEAnQ,GAAA,GAAAjf,EAAAqtB,EACApO,GAAA,GAAAmQ,GAAA1K,EAAAuK,GACAhQ,GAAA,GAAAiQ,GAAAxK,EAAAyK,GAEAlQ,GAAA,IAAAyF,EACAzF,GAAA,GAAAnO,EAAA9Q,EACAif,GAAA,IAAA2B,EAAA5gB,MAEG,YAAAie,MAAAU,MAAA,CAEH,GAAA8Q,IAAA7O,EAAA5gB,EAAA0vB,GAAA9O,EAAA8D,EAAAiL,GAAA7e,EAAA9Q,EAAA4vB,GAAA9e,EAAA4T,CAEAzF,IAAA,GAAAjf,EAAAukB,EACAtF,GAAA,GAAA2Q,GAAAH,GAAApC,EACApO,GAAA,GAAA0Q,GAAAtC,EAAAqC,GAEAzQ,GAAA,GAAAoO,EACApO,GAAA,GAAA2B,EAAA2D,EACAtF,GAAA,IAAAnO,EAAAyT,EAEAtF,GAAA,IAAAyF,EAAAH,EACAtF,GAAA,GAAAyQ,GAAArC,EAAAsC,GACA1Q,GAAA,IAAAwQ,GAAAG,GAAAvC,MAEG,YAAApP,MAAAU,MAAA,CAEH,GAAA8Q,IAAA7O,EAAA5gB,EAAA0vB,GAAA9O,EAAA8D,EAAAiL,GAAA7e,EAAA9Q,EAAA4vB,GAAA9e,EAAA4T,CAEAzF,IAAA,GAAAjf,EAAAukB,EACAtF,GAAA,IAAAoO,EACApO,GAAA,GAAAyF,EAAAH,EAEAtF,GAAA,GAAAwQ,GAAApC,EAAAuC,GACA3Q,GAAA,GAAA2B,EAAA2D,EACAtF,GAAA,GAAAyQ,GAAArC,EAAAsC,GAEA1Q,GAAA,GAAA0Q,GAAAtC,EAAAqC,GACAzQ,GAAA,GAAAnO,EAAAyT,EACAtF,GAAA,IAAA2Q,GAAAvC,EAAAoC,GAeA,MAVAxQ,IAAA,KACAA,GAAA,KACAA,GAAA,MAGAA,GAAA,MACAA,GAAA,MACAA,GAAA,MACAA,GAAA,MAEAze,MAIAqvB,0BAAA,SAAAne,GAIA,MAFAxH,OAAAK,KAAA;AAEA/J,KAAAioB,2BAAA/W,IAIA+W,2BAAA,SAAA/W,GAEA,GAAAuN,IAAAze,KAAA0e,SAEAxa,EAAAgN,EAAAhN,EAAAC,EAAA+M,EAAA/M,EAAAjB,EAAAgO,EAAAhO,EAAA8Z,EAAA9L,EAAA8L,EACAsS,GAAAprB,IAAAqrB,GAAAprB,IAAAqrB,GAAAtsB,IACAmkB,GAAAnjB,EAAAorB,GAAA9H,GAAAtjB,EAAAqrB,GAAA9H,GAAAvjB,EAAAsrB,GACAlI,GAAAnjB,EAAAorB,GAAA7H,GAAAvjB,EAAAqrB,GAAAjI,GAAArkB,EAAAssB,GACAC,GAAAzS,EAAAsS,GAAAI,GAAA1S,EAAAuS,GAAAI,GAAA3S,EAAAwS,EAyBA,OAvBA/Q,IAAA,MAAA6I,GAAAC,IACA9I,GAAA,GAAA+I,GAAAmI,GACAlR,GAAA,GAAAgJ,GAAAiI,GAEAjR,GAAA,GAAA+I,GAAAmI,GACAlR,GAAA,MAAA4I,GAAAE,IACA9I,GAAA,GAAAiJ,GAAA+H,GAEAhR,GAAA,GAAAgJ,GAAAiI,GACAjR,GAAA,GAAAiJ,GAAA+H,GACAhR,GAAA,OAAA4I,GAAAC,IAGA7I,GAAA,KACAA,GAAA,KACAA,GAAA,MAGAA,GAAA,MACAA,GAAA,MACAA,GAAA,MACAA,GAAA,MAEAze,MAIA4vB,OAAA,WAEA,GAAA1rB,GAAA,GAAAwF,OAAAgW,QACAvb,EAAA,GAAAuF,OAAAgW,QACAxc,EAAA,GAAAwG,OAAAgW,OAEA,iBAAAmQ,IAAAC,OAAAC,IAEA,GAAAtR,IAAAze,KAAA0e,QA0BA,OAxBAxb,GAAA+e,WAAA4N,IAAAC,QAAAhQ,YAEA,IAAA5c,EAAAyB,WAEAzB,IAAA,GAIAgB,EAAA2b,aAAAkQ,GAAA7sB,GAAA4c,YAEA,IAAA5b,EAAAS,WAEAzB,EAAAgB,GAAA,KACAA,EAAA2b,aAAAkQ,GAAA7sB,GAAA4c,aAIA3b,EAAA0b,aAAA3c,EAAAgB,GAGAua,GAAA,GAAAva,IAAiBua,GAAA,GAAAta,EAAAD,EAAeua,GAAA,GAAAvb,EAAAgB,EAChCua,GAAA,GAAAva,EAAAC,EAAiBsa,GAAA,GAAAta,IAAesa,GAAA,GAAAvb,EAAAiB,EAChCsa,GAAA,GAAAva,EAAAhB,EAAiBub,GAAA,GAAAta,EAAAjB,EAAeub,GAAA,IAAAvb,IAEhClD,SAMAkT,SAAA,SAAA3T,EAAAywB,GAEA,MAAApmB,UAAAomB,GAEAtmB,MAAAK,KAAA,oGACA/J,KAAA6kB,iBAAAtlB,EAAAywB,IAIAhwB,KAAA6kB,iBAAA7kB,KAAAT,IAIAslB,iBAAA,SAAAzE,EAAA9P,GAEA,GAAAme,IAAArO,EAAA1B,SACAiQ,GAAAre,EAAAoO,SACAD,GAAAze,KAAA0e,SAEAuR,IAAAxB,GAAA,GAAAyB,IAAAzB,GAAA,GAAA0B,IAAA1B,GAAA,GAAA2B,IAAA3B,GAAA,IACA4B,IAAA5B,GAAA,GAAA6B,IAAA7B,GAAA,GAAA8B,IAAA9B,GAAA,GAAA+B,IAAA/B,GAAA,IACAgC,IAAAhC,GAAA,GAAAiC,IAAAjC,GAAA,GAAAkC,IAAAlC,GAAA,IAAAmC,IAAAnC,GAAA,IACAoC,IAAApC,GAAA,GAAAqC,IAAArC,GAAA,GAAAsC,IAAAtC,GAAA,IAAAuC,IAAAvC,GAAA,IAEAwC,IAAAtC,GAAA,GAAAuC,IAAAvC,GAAA,GAAAwC,IAAAxC,GAAA,GAAAyC,IAAAzC,GAAA,IACA0C,IAAA1C,GAAA,GAAA2C,IAAA3C,GAAA,GAAA4C,IAAA5C,GAAA,GAAA6C,IAAA7C,GAAA,IACA8C,IAAA9C,GAAA,GAAA+C,IAAA/C,GAAA,GAAAgD,IAAAhD,GAAA,IAAAiD,IAAAjD,GAAA,IACAkD,IAAAlD,GAAA,GAAAmD,IAAAnD,GAAA,GAAAoD,IAAApD,GAAA,IAAAqD,IAAArD,GAAA,GAsBA,OApBAlQ,IAAA,GAAAwR,IAAAgB,IAAAf,IAAAmB,IAAAlB,IAAAsB,IAAArB,IAAAyB,IACApT,GAAA,GAAAwR,IAAAiB,IAAAhB,IAAAoB,IAAAnB,IAAAuB,IAAAtB,IAAA0B,IACArT,GAAA,GAAAwR,IAAAkB,IAAAjB,IAAAqB,IAAApB,IAAAwB,IAAAvB,IAAA2B,IACAtT,GAAA,IAAAwR,IAAAmB,IAAAlB,IAAAsB,IAAArB,IAAAyB,IAAAxB,IAAA4B,IAEAvT,GAAA,GAAA4R,IAAAY,IAAAX,IAAAe,IAAAd,IAAAkB,IAAAjB,IAAAqB,IACApT,GAAA,GAAA4R,IAAAa,IAAAZ,IAAAgB,IAAAf,IAAAmB,IAAAlB,IAAAsB,IACArT,GAAA,GAAA4R,IAAAc,IAAAb,IAAAiB,IAAAhB,IAAAoB,IAAAnB,IAAAuB,IACAtT,GAAA,IAAA4R,IAAAe,IAAAd,IAAAkB,IAAAjB,IAAAqB,IAAApB,IAAAwB,IAEAvT,GAAA,GAAAgS,IAAAQ,IAAAP,IAAAW,IAAAV,IAAAc,IAAAb,IAAAiB,IACApT,GAAA,GAAAgS,IAAAS,IAAAR,IAAAY,IAAAX,IAAAe,IAAAd,IAAAkB,IACArT,GAAA,IAAAgS,IAAAU,IAAAT,IAAAa,IAAAZ,IAAAgB,IAAAf,IAAAmB,IACAtT,GAAA,IAAAgS,IAAAW,IAAAV,IAAAc,IAAAb,IAAAiB,IAAAhB,IAAAoB,IAEAvT,GAAA,GAAAoS,IAAAI,IAAAH,IAAAO,IAAAN,IAAAU,IAAAT,IAAAa,IACApT,GAAA,GAAAoS,IAAAK,IAAAJ,IAAAQ,IAAAP,IAAAW,IAAAV,IAAAc,IACArT,GAAA,IAAAoS,IAAAM,IAAAL,IAAAS,IAAAR,IAAAY,IAAAX,IAAAe,IACAtT,GAAA,IAAAoS,IAAAO,IAAAN,IAAAU,IAAAT,IAAAa,IAAAZ,IAAAgB,IAEAhyB,MAIAiyB,gBAAA,SAAA7R,EAAA9P,EAAAF,GAEA,GAAAqO,IAAAze,KAAA0e,QASA,OAPA1e,MAAA6kB,iBAAAzE,EAAA9P,GAEAF,EAAA,GAAAqO,GAAA,GAAmBrO,EAAA,GAAAqO,GAAA,GAAkBrO,EAAA,GAAAqO,GAAA,GAAkBrO,EAAA,GAAAqO,GAAA,GACvDrO,EAAA,GAAAqO,GAAA,GAAmBrO,EAAA,GAAAqO,GAAA,GAAkBrO,EAAA,GAAAqO,GAAA,GAAkBrO,EAAA,GAAAqO,GAAA,GACvDrO,EAAA,GAAAqO,GAAA,GAAoBrO,EAAA,GAAAqO,GAAA,GAAmBrO,EAAA,IAAAqO,GAAA,IAAoBrO,EAAA,IAAAqO,GAAA,IAC3DrO,EAAA,IAAAqO,GAAA,IAAqBrO,EAAA,IAAAqO,GAAA,IAAoBrO,EAAA,IAAAqO,GAAA,IAAoBrO,EAAA,IAAAqO,GAAA,IAE7Dze,MAIAmT,eAAA,SAAApC,GAEA,GAAA0N,IAAAze,KAAA0e,QAOA,OALAD,IAAA,IAAA1N,EAAe0N,GAAA,IAAA1N,EAAc0N,GAAA,IAAA1N,EAAc0N,GAAA,KAAA1N,EAC3C0N,GAAA,IAAA1N,EAAe0N,GAAA,IAAA1N,EAAc0N,GAAA,IAAA1N,EAAc0N,GAAA,KAAA1N,EAC3C0N,GAAA,IAAA1N,EAAe0N,GAAA,IAAA1N,EAAc0N,GAAA,KAAA1N,EAAe0N,GAAA,KAAA1N,EAC5C0N,GAAA,IAAA1N,EAAe0N,GAAA,IAAA1N,EAAc0N,GAAA,KAAA1N,EAAe0N,GAAA,KAAA1N,EAE5C/Q,MAIA6gB,gBAAA,SAAAnR,QAGA,MADAhG,OAAAK,KAAA,sIACA2F,OAAAuU,gBAAAjkB,OAIAkyB,gBAAA,SAAAxiB,QAGA,MADAhG,OAAAK,KAAA,kGACA2F,OAAAsU,aAAAhkB,OAIA0sB,qBAAA,SAAAtM,GAGA,MADA1W,OAAAK,KAAA,6GACA/J,KAAA2sB,oBAAAvM,IAIAuM,oBAAA,WAEA,GAAArN,IAAA,GAAA5V,OAAAgW,OAEA,iBAAAlM,MAAAE,OAAA/O,QAEAiF,SAAA8J,gBAAA,GACA9J,SAAAjF,gBAAA6O,MAAA7O,OAEA,QAAAD,GAAA,EAAAY,EAAAoO,OAA+B/O,OAAAD,EAAYA,GAAA,EAAAY,GAAA,EAE3Cga,GAAApb,EAAAsP,MAAAlO,GACAga,GAAAnb,EAAAqP,MAAAlO,EAAA,GACAga,GAAApc,EAAAsQ,MAAAlO,EAAA,GAEAga,GAAA0E,aAAAhkB,MAEAwT,MAAAlO,GAAAga,GAAApb,EACAsP,MAAAlO,EAAA,GAAAga,GAAAnb,EACAqP,MAAAlO,EAAA,GAAAga,GAAApc,CAIA,OAAAsQ,WAMA2e,WAAA,SAAAlS,GAEAvW,MAAAK,KAAA,oGAEAkW,EAAAgF,mBAAAjlB,OAIAoyB,YAAA,SAAA1iB,QAGA,MADAhG,OAAAK,KAAA,8FACA2F,OAAAsU,aAAAhkB,OAIA4sB,YAAA,WAEA,GAAAnO,IAAAze,KAAA0e,SAEAsN,IAAAvN,GAAA,GAAAwN,IAAAxN,GAAA,GAAAyN,IAAAzN,GAAA,GAAA6O,IAAA7O,GAAA,IACA0N,IAAA1N,GAAA,GAAA2N,IAAA3N,GAAA,GAAA4N,IAAA5N,GAAA,GAAA8O,IAAA9O,GAAA,IACA6N,IAAA7N,GAAA,GAAA8N,IAAA9N,GAAA,GAAA+N,IAAA/N,GAAA,IAAA+O,IAAA/O,GAAA,IACAgP,IAAAhP,GAAA,GAAAiP,IAAAjP,GAAA,GAAAkP,IAAAlP,GAAA,IAAAmP,IAAAnP,GAAA,GAKA,OACAgP,OACAH,IAAAjB,IAAAE,IACAL,IAAAqB,IAAAhB,IACAe,IAAAlB,IAAAI,IACAP,IAAAsB,IAAAf,IACAN,IAAAE,IAAAoB,IACAvB,IAAAI,IAAAmB,KAEAE,MACA1B,IAAAK,IAAAmB,IACAxB,IAAAuB,IAAAf,IACAc,IAAAnB,IAAAK,IACAN,IAAAC,IAAAqB,IACAtB,IAAAqB,IAAAjB,IACAgB,IAAAjB,IAAAC,KAEAqB,MACA3B,IAAAuB,IAAAhB,IACAP,IAAAI,IAAAoB,IACAF,IAAAnB,IAAAI,IACAN,IAAAE,IAAAqB,IACAF,IAAAlB,IAAAE,IACAL,IAAAsB,IAAAjB,KAEAsB,MACA1B,IAAAE,IAAAE,IACAN,IAAAK,IAAAE,IACAP,IAAAI,IAAAI,IACAN,IAAAC,IAAAI,IACAN,IAAAE,IAAAK,IACAP,IAAAI,IAAAC,MAOAW,UAAA,WAEA,GACAC,KADAzO,GAAAze,KAAA0e,QAWA,OARAwO,KAAAzO,GAAA,GAAgBA,GAAA,GAAAA,GAAA,GAAmBA,GAAA,GAAAyO,IACnCA,IAAAzO,GAAA,GAAgBA,GAAA,GAAAA,GAAA,GAAmBA,GAAA,GAAAyO,IACnCA,IAAAzO,GAAA,GAAgBA,GAAA,GAAAA,GAAA,GAAmBA,GAAA,GAAAyO,IAEnCA,IAAAzO,GAAA,GAAgBA,GAAA,GAAAA,GAAA,IAAoBA,GAAA,IAAAyO,IACpCA,IAAAzO,GAAA,GAAgBA,GAAA,GAAAA,GAAA,IAAoBA,GAAA,IAAAyO,IACpCA,IAAAzO,GAAA,IAAiBA,GAAA,IAAAA,GAAA,IAAqBA,GAAA,IAAAyO,IAEtCltB,MAIAmtB,qBAAA,SAAA3Z,MAAAE,QAEA,GAAA+K,IAAAze,KAAA0e,QAsBA,OApBAlL,OAAAE,QAAA+K,GAAA,GACAjL,MAAAE,OAAA,GAAA+K,GAAA,GACAjL,MAAAE,OAAA,GAAA+K,GAAA,GACAjL,MAAAE,OAAA,GAAA+K,GAAA,GAEAjL,MAAAE,OAAA,GAAA+K,GAAA,GACAjL,MAAAE,OAAA,GAAA+K,GAAA,GACAjL,MAAAE,OAAA,GAAA+K,GAAA,GACAjL,MAAAE,OAAA,GAAA+K,GAAA,GAEAjL,MAAAE,OAAA,GAAA+K,GAAA,GACAjL,MAAAE,OAAA,GAAA+K,GAAA,GACAjL,MAAAE,OAAA,IAAA+K,GAAA,IACAjL,MAAAE,OAAA,IAAA+K,GAAA,IAEAjL,MAAAE,OAAA,IAAA+K,GAAA,IACAjL,MAAAE,OAAA,IAAA+K,GAAA,IACAjL,MAAAE,OAAA,IAAA+K,GAAA,IACAjL,MAAAE,OAAA,IAAA+K,GAAA,IAEAjL,OAIA6e,YAAA,WAEA,GAAA/S,IAAA,GAAA5V,OAAAgW,OAEA,mBAEAhW,MAAAK,KAAA,uGAEA,IAAA0U,IAAAze,KAAA0e,QACA,OAAAY,IAAAnP,IAAAsO,GAAA,IAAAA,GAAA,IAAAA,GAAA,SAMA6T,YAAA,SAAArS,GAEA,GAAAxB,IAAAze,KAAA0e,QAMA,OAJAD,IAAA,IAAAwB,EAAA/b,EACAua,GAAA,IAAAwB,EAAA9b,EACAsa,GAAA,IAAAwB,EAAA/c,EAEAlD,MAIA+kB,WAAA,SAAAxlB,EAAAutB,mBAGA,GAAArO,IAAAze,KAAA0e,SACAmI,GAAAtnB,EAAAmf,SAEAsN,IAAAnF,GAAA,GAAAoF,IAAApF,GAAA,GAAAqF,IAAArF,GAAA,GAAAyG,IAAAzG,GAAA,IACAsF,IAAAtF,GAAA,GAAAuF,IAAAvF,GAAA,GAAAwF,IAAAxF,GAAA,GAAA0G,IAAA1G,GAAA,IACAyF,IAAAzF,GAAA,GAAA0F,IAAA1F,GAAA,GAAA2F,IAAA3F,GAAA,IAAA2G,IAAA3G,GAAA,IACA4G,IAAA5G,GAAA,GAAA6G,IAAA7G,GAAA,GAAA8G,IAAA9G,GAAA,IAAA+G,IAAA/G,GAAA,GAEApI,IAAA,GAAA4N,IAAAmB,IAAAE,IAAAH,IAAAf,IAAAkB,IAAAH,IAAAhB,IAAAoB,IAAAvB,IAAAoB,IAAAG,IAAAtB,IAAAE,IAAAqB,IAAAxB,IAAAI,IAAAoB,IACAnP,GAAA,GAAA6O,IAAAd,IAAAkB,IAAAxB,IAAAsB,IAAAE,IAAAJ,IAAAf,IAAAoB,IAAA1B,IAAAuB,IAAAG,IAAAzB,IAAAK,IAAAqB,IAAA3B,IAAAO,IAAAoB,IACAnP,GAAA,GAAAyN,IAAAqB,IAAAG,IAAAJ,IAAAjB,IAAAqB,IAAAJ,IAAAlB,IAAAuB,IAAA1B,IAAAsB,IAAAI,IAAAzB,IAAAE,IAAAwB,IAAA3B,IAAAI,IAAAuB,IACAnP,GAAA,IAAA6O,IAAAjB,IAAAE,IAAAL,IAAAqB,IAAAhB,IAAAe,IAAAlB,IAAAI,IAAAP,IAAAsB,IAAAf,IAAAN,IAAAE,IAAAoB,IAAAvB,IAAAI,IAAAmB,IACA/O,GAAA,GAAA8O,IAAAf,IAAAiB,IAAApB,IAAAmB,IAAAC,IAAAF,IAAAjB,IAAAqB,IAAAxB,IAAAqB,IAAAG,IAAAtB,IAAAC,IAAAsB,IAAAzB,IAAAK,IAAAoB,IACAnP,GAAA,GAAAyN,IAAAsB,IAAAC,IAAAH,IAAAd,IAAAiB,IAAAH,IAAAhB,IAAAqB,IAAA3B,IAAAwB,IAAAG,IAAAzB,IAAAI,IAAAsB,IAAA5B,IAAAQ,IAAAoB,IACAnP,GAAA,GAAA6O,IAAAjB,IAAAoB,IAAAvB,IAAAqB,IAAAE,IAAAH,IAAAnB,IAAAwB,IAAA3B,IAAAuB,IAAAI,IAAAzB,IAAAC,IAAAyB,IAAA5B,IAAAK,IAAAuB,IACAnP,GAAA,IAAAyN,IAAAqB,IAAAjB,IAAAgB,IAAAjB,IAAAC,IAAAgB,IAAAnB,IAAAK,IAAAR,IAAAuB,IAAAf,IAAAN,IAAAC,IAAAqB,IAAAxB,IAAAK,IAAAmB,IACA/O,GAAA,GAAA2N,IAAAoB,IAAAC,IAAAF,IAAAhB,IAAAkB,IAAAF,IAAAjB,IAAAoB,IAAAvB,IAAAqB,IAAAE,IAAAtB,IAAAE,IAAAsB,IAAAzB,IAAAI,IAAAqB,IACAnP,GAAA,GAAA6O,IAAAf,IAAAkB,IAAAxB,IAAAuB,IAAAC,IAAAH,IAAAhB,IAAAoB,IAAA1B,IAAAwB,IAAAE,IAAAzB,IAAAK,IAAAsB,IAAA5B,IAAAO,IAAAqB,IACAnP,GAAA,IAAAwN,IAAAsB,IAAAE,IAAAH,IAAAlB,IAAAqB,IAAAH,IAAAnB,IAAAuB,IAAA1B,IAAAuB,IAAAG,IAAAzB,IAAAE,IAAAyB,IAAA5B,IAAAI,IAAAwB,IACAnP,GAAA,IAAA6O,IAAAlB,IAAAE,IAAAL,IAAAsB,IAAAjB,IAAAgB,IAAAnB,IAAAI,IAAAP,IAAAuB,IAAAhB,IAAAN,IAAAE,IAAAqB,IAAAxB,IAAAI,IAAAoB,IACA/O,GAAA,GAAA4N,IAAAE,IAAAkB,IAAArB,IAAAI,IAAAiB,IAAApB,IAAAC,IAAAoB,IAAAvB,IAAAK,IAAAkB,IAAAtB,IAAAE,IAAAqB,IAAAxB,IAAAI,IAAAoB,IACAlP,GAAA,GAAAwN,IAAAO,IAAAiB,IAAAvB,IAAAK,IAAAkB,IAAAvB,IAAAI,IAAAoB,IAAA1B,IAAAQ,IAAAkB,IAAAzB,IAAAK,IAAAqB,IAAA3B,IAAAO,IAAAoB,IACAlP,GAAA,IAAAyN,IAAAE,IAAAqB,IAAAxB,IAAAI,IAAAoB,IAAAvB,IAAAC,IAAAuB,IAAA1B,IAAAK,IAAAqB,IAAAzB,IAAAE,IAAAwB,IAAA3B,IAAAI,IAAAuB,IACAlP,GAAA,IAAAwN,IAAAI,IAAAC,IAAAJ,IAAAE,IAAAE,IAAAJ,IAAAC,IAAAI,IAAAP,IAAAK,IAAAE,IAAAN,IAAAE,IAAAK,IAAAR,IAAAI,IAAAI,GAEA,IAAAO,KAAAf,IAAAvN,GAAA,GAAA0N,IAAA1N,GAAA,GAAA6N,IAAA7N,GAAA,GAAAgP,IAAAhP,GAAA,GAEA,OAAAsO,IAAA,CAEA,GAAAC,KAAA,mEAEA,IAAAF,kBAEA,SAAA3jB,OAAA6jB,IAUA,OANAtjB,OAAAK,KAAAijB,KAIAhtB,KAAAysB,WAEAzsB,KAKA,MAFAA,MAAAmT,eAAA,EAAA4Z,KAEA/sB,MAIA8qB,UAAA,SAAA7K,GAEAvW,MAAAM,MAAA,kDAIAuoB,QAAA,SAAAjU,OAEA5U,MAAAM,MAAA,gDAIAwoB,QAAA,SAAAlU,OAEA5U,MAAAM,MAAA,gDAIAyoB,QAAA,SAAAnU,OAEA5U,MAAAM,MAAA,gDAIA0oB,aAAA,SAAArU,KAAAC,OAEA5U,MAAAM,MAAA,qDAIA2oB,MAAA,SAAA1S,GAEA,GAAAxB,IAAAze,KAAA0e,SACAxa,EAAA+b,EAAA/b,EAAAC,EAAA8b,EAAA9b,EAAAjB,EAAA+c,EAAA/c,CAOA,OALAub,IAAA,IAAAva,EAAeua,GAAA,IAAAta,EAAcsa,GAAA,IAAAvb,EAC7Bub,GAAA,IAAAva,EAAeua,GAAA,IAAAta,EAAcsa,GAAA,IAAAvb,EAC7Bub,GAAA,IAAAva,EAAeua,GAAA,IAAAta,EAAcsa,GAAA,KAAAvb,EAC7Bub,GAAA,IAAAva,EAAeua,GAAA,IAAAta,EAAcsa,GAAA,KAAAvb,EAE7BlD,MAIA4yB,kBAAA,WAEA,GAAAnU,IAAAze,KAAA0e,SAEAmU,SAAApU,GAAA,GAAAA,GAAA,GAAAA,GAAA,GAAAA,GAAA,GAAAA,GAAA,GAAAA,GAAA,GACAqU,SAAArU,GAAA,GAAAA,GAAA,GAAAA,GAAA,GAAAA,GAAA,GAAAA,GAAA,GAAAA,GAAA,GACAsU,SAAAtU,GAAA,GAAAA,GAAA,GAAAA,GAAA,GAAAA,GAAA,GAAAA,GAAA,IAAAA,GAAA,GAEA,OAAA5U,MAAAmI,KAAAnI,KAAA4I,IAAAogB,SAAAhpB,KAAA4I,IAAAqgB,SAAAC,aAIAC,gBAAA,SAAA9uB,EAAAC,EAAAjB,GAWA,MATAlD,MAAAmQ,IAEA,MAAAjM,EACA,MAAAC,EACA,MAAAjB,EACA,SAIAlD,MAIAizB,cAAA,SAAAjN,OAEA,GAAAxmB,GAAAqK,KAAA+T,IAAAoI,OAAAjV,EAAAlH,KAAAmU,IAAAgI,MAWA,OATAhmB,MAAAmQ,IAEA,QACA,EAAA3Q,GAAAuR,EAAA,EACA,EAAAA,EAAAvR,EAAA,EACA,SAIAQ,MAIAkzB,cAAA,SAAAlN,OAEA,GAAAxmB,GAAAqK,KAAA+T,IAAAoI,OAAAjV,EAAAlH,KAAAmU,IAAAgI,MAWA,OATAhmB,MAAAmQ,IAEA3Q,EAAA,EAAAuR,EAAA,EACA,SACAA,EAAA,EAAAvR,EAAA,EACA,SAIAQ,MAIAmzB,cAAA,SAAAnN,OAEA,GAAAxmB,GAAAqK,KAAA+T,IAAAoI,OAAAjV,EAAAlH,KAAAmU,IAAAgI,MAWA,OATAhmB,MAAAmQ,IAEA3Q,GAAAuR,EAAA,IACAA,EAAAvR,EAAA,IACA,QACA,SAIAQ,MAIAozB,iBAAA,SAAA/U,KAAAC,OAIA,GAAA9e,GAAAqK,KAAA+T,IAAAU,OACAvN,EAAAlH,KAAAmU,IAAAM,OACAnN,EAAA,EAAA3R,EACA0E,EAAAma,KAAAna,EAAAC,EAAAka,KAAAla,EAAAjB,EAAAmb,KAAAnb,EACAmwB,GAAAliB,EAAAjN,EAAAovB,GAAAniB,EAAAhN,CAWA,OATAnE,MAAAmQ,IAEAkjB,GAAAnvB,EAAA1E,EAAA6zB,GAAAlvB,EAAA4M,EAAA7N,EAAAmwB,GAAAnwB,EAAA6N,EAAA5M,EAAA,EACAkvB,GAAAlvB,EAAA4M,EAAA7N,EAAAowB,GAAAnvB,EAAA3E,EAAA8zB,GAAApwB,EAAA6N,EAAA7M,EAAA,EACAmvB,GAAAnwB,EAAA6N,EAAA5M,EAAAmvB,GAAApwB,EAAA6N,EAAA7M,EAAAiN,EAAAjO,IAAA1D,EAAA,EACA,SAIAQ,MAIAuzB,UAAA,SAAArvB,EAAAC,EAAAjB,GAWA,MATAlD,MAAAmQ,IAEAjM,EAAA,MACA,EAAAC,EAAA,IACA,IAAAjB,EAAA,EACA,SAIAlD,MAIAwzB,QAAA,SAAAvwB,SAAAsa,WAAAoV,OAMA,MAJA3yB,MAAAioB,2BAAA1K,YACAvd,KAAA2yB,aACA3yB,KAAAsyB,YAAArvB,UAEAjD,MAIAyzB,UAAA,WAEA,GAAA/jB,QAAA,GAAAhG,OAAAgW,QACAiF,OAAA,GAAAjb,OAAAkb,OAEA,iBAAA3hB,SAAAsa,WAAAoV,OAEA,GAAAlU,IAAAze,KAAA0e,SAEAgI,GAAAhX,OAAAS,IAAAsO,GAAA,GAAAA,GAAA,GAAAA,GAAA,IAAA9Z,SACAgiB,GAAAjX,OAAAS,IAAAsO,GAAA,GAAAA,GAAA,GAAAA,GAAA,IAAA9Z,SACAiiB,GAAAlX,OAAAS,IAAAsO,GAAA,GAAAA,GAAA,GAAAA,GAAA,KAAA9Z,SAGAooB,IAAA/sB,KAAA4sB,aACA,GAAAG,MACArG,QAGAzjB,SAAAiB,EAAAua,GAAA,IACAxb,SAAAkB,EAAAsa,GAAA,IACAxb,SAAAC,EAAAub,GAAA,IAIAkG,OAAAjG,SAAAvO,IAAAnQ,KAAA0e,SAEA,IAAAgV,OAAA,EAAAhN,GACAiN,MAAA,EAAAhN,GACAiN,MAAA,EAAAhN,EAoBA,OAlBAjC,QAAAjG,SAAA,IAAAgV,MACA/O,OAAAjG,SAAA,IAAAgV,MACA/O,OAAAjG,SAAA,IAAAgV,MAEA/O,OAAAjG,SAAA,IAAAiV,MACAhP,OAAAjG,SAAA,IAAAiV,MACAhP,OAAAjG,SAAA,IAAAiV,MAEAhP,OAAAjG,SAAA,IAAAkV,MACAjP,OAAAjG,SAAA,IAAAkV,MACAjP,OAAAjG,SAAA,KAAAkV,MAEArW,WAAAiB,sBAAAmG,QAEAgO,MAAAzuB,EAAAwiB,GACAiM,MAAAxuB,EAAAwiB,GACAgM,MAAAzvB,EAAA0jB,GAEA5mB,SAMA6zB,YAAA,SAAAC,KAAAC,MAAAC,OAAAC,IAAAC,KAAAC,KAEA,GAAA1V,IAAAze,KAAA0e,SACAxa,EAAA,EAAAgwB,MAAAH,MAAAD,MACA3vB,EAAA,EAAA+vB,MAAAD,IAAAD,QAEA5T,GAAA2T,MAAAD,OAAAC,MAAAD,MACAxjB,GAAA2jB,IAAAD,SAAAC,IAAAD,QACAx0B,IAAA20B,IAAAD,OAAAC,IAAAD,MACAhQ,EAAA,GAAAiQ,IAAAD,MAAAC,IAAAD,KAOA,OALAzV,IAAA,GAAAva,EAAcua,GAAA,KAAaA,GAAA,GAAA2B,EAAa3B,GAAA,MACxCA,GAAA,KAAcA,GAAA,GAAAta,EAAasa,GAAA,GAAAnO,EAAamO,GAAA,MACxCA,GAAA,KAAcA,GAAA,KAAaA,GAAA,IAAAjf,EAAcif,GAAA,IAAAyF,EACzCzF,GAAA,KAAcA,GAAA,KAAaA,GAAA,OAAgBA,GAAA,MAE3Cze,MAIAo0B,gBAAA,SAAAC,IAAAvxB,OAAAoxB,KAAAC,KAEA,GAAAG,MAAAJ,KAAArqB,KAAAuS,IAAA1S,MAAAG,KAAA0qB,SAAA,GAAAF,MACAG,MAAAF,KACAG,KAAAD,KAAA1xB,OACA4xB,KAAAJ,KAAAxxB,MAEA,OAAA9C,MAAA6zB,YAAAY,KAAAC,KAAAF,KAAAF,KAAAJ,KAAAC,MAIAQ,iBAAA,SAAAb,KAAAC,MAAAE,IAAAD,OAAAE,KAAAC,KAEA,GAAA1V,IAAAze,KAAA0e,SACA1B,EAAA+W,MAAAD,KACAhjB,EAAAmjB,IAAAD,OACAv0B,EAAA00B,IAAAD,KAEAhwB,GAAA6vB,MAAAD,MAAA9W,EACA7Y,GAAA8vB,IAAAD,QAAAljB,EACA5N,GAAAixB,IAAAD,MAAAz0B,CAOA,OALAgf,IAAA,KAAAzB,EAAkByB,GAAA,KAAaA,GAAA,KAAaA,GAAA,KAAAva,EAC5Cua,GAAA,KAAcA,GAAA,KAAA3N,EAAiB2N,GAAA,KAAaA,GAAA,KAAAta,EAC5Csa,GAAA,KAAcA,GAAA,KAAaA,GAAA,OAAAhf,EAAoBgf,GAAA,KAAAvb,EAC/Cub,GAAA,KAAcA,GAAA,KAAaA,GAAA,MAAcA,GAAA,MAEzCze,MAIAuT,UAAA,SAAAC,OAIA,MAFAxT,MAAA0e,SAAAvO,IAAAqD,OAEAxT,MAIAyT,QAAA,WAEA,GAAAgL,IAAAze,KAAA0e,QAEA,QACAD,GAAA,GAAAA,GAAA,GAAAA,GAAA,GAAAA,GAAA,GACAA,GAAA,GAAAA,GAAA,GAAAA,GAAA,GAAAA,GAAA,GACAA,GAAA,GAAAA,GAAA,GAAAA,GAAA,IAAAA,GAAA,IACAA,GAAA,IAAAA,GAAA,IAAAA,GAAA,IAAAA,GAAA,MAKA9K,MAAA,WAEA,UAAAjK,OAAAkb,SAAArR,UAAAvT,KAAA0e,YAYAhV,MAAAkrB,IAAA,SAAAC,OAAAC,WAEA90B,KAAA60B,OAAAjrB,SAAAirB,cAAA,GAAAnrB,OAAAgW,QACA1f,KAAA80B,UAAAlrB,SAAAkrB,oBAAA,GAAAprB,OAAAgW,SAIAhW,MAAAkrB,IAAAt0B,WAEAM,YAAA8I,MAAAkrB,IAEAzkB,IAAA,SAAA0kB,OAAAC,WAKA,MAHA90B,MAAA60B,OAAArkB,KAAAqkB,QACA70B,KAAA80B,UAAAtkB,KAAAskB,WAEA90B,MAIAwQ,KAAA,SAAAukB,KAKA,MAHA/0B,MAAA60B,OAAArkB,KAAAukB,IAAAF,QACA70B,KAAA80B,UAAAtkB,KAAAukB,IAAAD,WAEA90B,MAIA8oB,GAAA,SAAA3X,EAAAkB,gBAEA,GAAA5N,QAAA4N,gBAAA,GAAA3I,OAAAgW,OAEA,OAAAjb,QAAA+L,KAAAxQ,KAAA80B,WAAA3hB,eAAAhC,GAAAxN,IAAA3D,KAAA60B,SAIAG,OAAA,WAEA,GAAA1V,IAAA,GAAA5V,OAAAgW,OAEA,iBAAAvO,GAIA,MAFAnR,MAAA60B,OAAArkB,KAAAxQ,KAAA8oB,GAAA3X,EAAAmO,KAEAtf,SAMAspB,oBAAA,SAAAJ,MAAA7W,gBAEA,GAAA5N,QAAA4N,gBAAA,GAAA3I,OAAAgW,OACAjb,QAAAwd,WAAAiH,MAAAlpB,KAAA60B,OACA,IAAAI,mBAAAxwB,OAAAkb,IAAA3f,KAAA80B,UAEA,UAAAG,kBAEAxwB,OAAA+L,KAAAxQ,KAAA60B,QAIApwB,OAAA+L,KAAAxQ,KAAA80B,WAAA3hB,eAAA8hB,mBAAAtxB,IAAA3D,KAAA60B,SAIAnK,gBAAA,WAEA,GAAApL,IAAA,GAAA5V,OAAAgW,OAEA,iBAAAwJ,OAEA,GAAA+L,mBAAA3V,GAAA2C,WAAAiH,MAAAlpB,KAAA60B,QAAAlV,IAAA3f,KAAA80B,UAIA,UAAAG,kBAEAj1B,KAAA60B,OAAA9R,WAAAmG,QAIA5J,GAAA9O,KAAAxQ,KAAA80B,WAAA3hB,eAAA8hB,mBAAAtxB,IAAA3D,KAAA60B,QAEAvV,GAAAyD,WAAAmG,YAMAgM,oBAAA,WAEA,GAAAC,WAAA,GAAAzrB,OAAAgW,QACA0V,OAAA,GAAA1rB,OAAAgW,QACA2V,KAAA,GAAA3rB,OAAAgW,OAEA,iBAAA4V,GAAAhW,GAAAiW,mBAAAC,wBASAL,UAAA3kB,KAAA8kB,IAAA3xB,IAAA2b,IAAAnM,eAAA,IACAiiB,OAAA5kB,KAAA8O,IAAA9e,IAAA80B,IAAAxV,YACAuV,KAAA7kB,KAAAxQ,KAAA60B,QAAAr0B,IAAA20B,UAEA,IAMAM,IAAA1X,GAAA2X,QAAAC,OANAC,UAAA,GAAAN,GAAAvS,WAAAzD,IACAuW,KAAA71B,KAAA80B,UAAAnV,IAAAyV,QACAU,GAAAT,KAAA1V,IAAA3f,KAAA80B,WACAiB,IAAAV,KAAA1V,IAAAyV,QACA51B,EAAA61B,KAAAnV,WACA6M,IAAAljB,KAAA+V,IAAA,EAAAiW,QAGA,IAAA9I,IAAA,EAQA,GAJA0I,GAAAI,IAAAE,GAAAD,GACA/X,GAAA8X,IAAAC,GAAAC,GACAJ,OAAAC,UAAA7I,IAEA0I,IAAA,EAEA,GAAA1X,KAAA4X,OAEA,GAAAA,QAAA5X,GAAA,CAKA,GAAAiY,QAAA,EAAAjJ,GACA0I,KAAAO,OACAjY,IAAAiY,OACAN,QAAAD,OAAAI,IAAA9X,GAAA,EAAA+X,IAAA/X,IAAA8X,IAAAJ,GAAA1X,GAAA,EAAAgY,IAAAv2B,MAMAue,IAAA6X,UACAH,GAAA5rB,KAAA4I,IAAA,IAAAojB,IAAA9X,GAAA+X,KACAJ,SAAAD,MAAA1X,OAAA,EAAAgY,IAAAv2B,MAQAue,KAAA6X,UACAH,GAAA5rB,KAAA4I,IAAA,IAAAojB,IAAA9X,GAAA+X,KACAJ,SAAAD,MAAA1X,OAAA,EAAAgY,IAAAv2B,OAMAm2B,QAAA5X,IAIA0X,GAAA5rB,KAAA4I,IAAA,KAAAojB,IAAAD,UAAAE,KACA/X,GAAA0X,GAAA,GAAAG,UAAA/rB,KAAAyH,IAAAzH,KAAA4I,KAAAmjB,WAAAG,IAAAH,WACAF,SAAAD,MAAA1X,OAAA,EAAAgY,IAAAv2B,GAEMm2B,QAAA5X,IAIN0X,GAAA,EACA1X,GAAAlU,KAAAyH,IAAAzH,KAAA4I,KAAAmjB,WAAAG,IAAAH,WACAF,QAAA3X,OAAA,EAAAgY,IAAAv2B,IAMAi2B,GAAA5rB,KAAA4I,IAAA,IAAAojB,IAAAD,UAAAE,KACA/X,GAAA0X,GAAA,EAAAG,UAAA/rB,KAAAyH,IAAAzH,KAAA4I,KAAAmjB,WAAAG,IAAAH,WACAF,SAAAD,MAAA1X,OAAA,EAAAgY,IAAAv2B,OAUAue,IAAA8X,IAAA,GAAAD,oBACAH,GAAA5rB,KAAA4I,IAAA,IAAAojB,IAAA9X,GAAA+X,KACAJ,SAAAD,MAAA1X,OAAA,EAAAgY,IAAAv2B,CAgBA,OAZA+1B,qBAEAA,mBAAA/kB,KAAAxQ,KAAA80B,WAAA3hB,eAAAsiB,IAAA9xB,IAAA3D,KAAA60B,QAIAW,wBAEAA,uBAAAhlB,KAAA4kB,QAAAjiB,eAAA4K,IAAApa,IAAAwxB,WAIAO,YAOAO,qBAAA,SAAAC,QAEA,MAAAl2B,MAAA0qB,gBAAAwL,OAAAvN,SAAAuN,OAAArK,QAIAsK,gBAAA,WAIA,GAAA7W,IAAA,GAAA5V,OAAAgW,OAEA,iBAAAwW,OAAA7jB,gBAEAiN,GAAA2C,WAAAiU,OAAAvN,OAAA3oB,KAAA60B,OAEA,IAAAuB,KAAA9W,GAAAK,IAAA3f,KAAA80B,WAEAuB,GAAA/W,GAAAK,IAAAL,IAAA8W,QAEAE,QAAAJ,OAAArK,OAAAqK,OAAArK,MAEA,IAAAwK,GAAAC,QAAA,WAEA,IAAAC,KAAA1sB,KAAAmI,KAAAskB,QAAAD,IAGAG,GAAAJ,IAAAG,IAGAE,GAAAL,IAAAG,GAGA,UAAAC,IAAA,EAAAC,GAAA,KAKA,EAAAD,GAAAx2B,KAAA8oB,GAAA2N,GAAApkB,gBAGArS,KAAA8oB,GAAA0N,GAAAnkB,oBAMAqkB,oBAAA,SAAAC,OAIA,GAAAC,aAAAD,MAAAjM,gBAAA1qB,KAAA60B,OAEA,QAAA+B,YAEA,QAIA,IAAAC,aAAAF,MAAA7Q,OAAAnG,IAAA3f,KAAA80B,UAEA,UAAA+B,YAAAD,aAEA,GAMA,GAIAE,gBAAA,SAAAH,OAEA,GAAAE,aAAAF,MAAA7Q,OAAAnG,IAAA3f,KAAA80B,UACA,OAAA+B,YAGA,UAAAF,MAAAjM,gBAAA1qB,KAAA60B,QAEA,EAMA,IAIA,IAAA1jB,KAAAnR,KAAA60B,OAAAlV,IAAAgX,MAAA7Q,QAAA6Q,MAAAI,UAAAF,WAIA,OAAA1lB,IAAA,EAAAA,EAAA,MAIA6lB,eAAA,SAAAL,MAAAtkB,gBAEA,GAAAlB,GAAAnR,KAAA82B,gBAAAH,MAEA,eAAAxlB,EAEA,KAGAnR,KAAA8oB,GAAA3X,EAAAkB,iBAIAmY,kBAAA,WAEA,GAAAvK,GAAA,GAAAvW,OAAAgW,OAEA,iBAAAuK,KAEA,cAAAjqB,KAAAi3B,aAAAhN,IAAAhK,OAMAgX,aAAA,SAAAhN,IAAA5X,gBAIA,GAAA6kB,MAAAC,KAAAC,MAAAC,MAAAC,MAAAC,MAEAC,QAAA,EAAAx3B,KAAA80B,UAAA5wB,EACAuzB,QAAA,EAAAz3B,KAAA80B,UAAA3wB,EACAuzB,QAAA,EAAA13B,KAAA80B,UAAA5xB,EAEA2xB,OAAA70B,KAAA60B,MAwBA,OAtBA2C,UAAA,GAEAN,MAAAjN,IAAA3Y,IAAApN,EAAA2wB,OAAA3wB,GAAAszB,QACAL,MAAAlN,IAAAxX,IAAAvO,EAAA2wB,OAAA3wB,GAAAszB,UAIAN,MAAAjN,IAAAxX,IAAAvO,EAAA2wB,OAAA3wB,GAAAszB,QACAL,MAAAlN,IAAA3Y,IAAApN,EAAA2wB,OAAA3wB,GAAAszB,SAGAC,SAAA,GAEAL,OAAAnN,IAAA3Y,IAAAnN,EAAA0wB,OAAA1wB,GAAAszB,QACAJ,OAAApN,IAAAxX,IAAAtO,EAAA0wB,OAAA1wB,GAAAszB,UAIAL,OAAAnN,IAAAxX,IAAAtO,EAAA0wB,OAAA1wB,GAAAszB,QACAJ,OAAApN,IAAA3Y,IAAAnN,EAAA0wB,OAAA1wB,GAAAszB,SAGAP,KAAAG,OAAAD,MAAAD,KAAA,OAKAC,MAAAF,0BAAAE,QAEAD,KAAAE,OAAAF,oBAAAE,OAEAK,SAAA,GAEAJ,OAAArN,IAAA3Y,IAAApO,EAAA2xB,OAAA3xB,GAAAw0B,QACAH,OAAAtN,IAAAxX,IAAAvP,EAAA2xB,OAAA3xB,GAAAw0B,UAIAJ,OAAArN,IAAAxX,IAAAvP,EAAA2xB,OAAA3xB,GAAAw0B,QACAH,OAAAtN,IAAA3Y,IAAApO,EAAA2xB,OAAA3xB,GAAAw0B,SAGAR,KAAAK,OAAAD,MAAAH,KAAA,OAEAG,MAAAJ,0BAAAI,QAEAH,KAAAI,OAAAJ,oBAAAI,OAIA,EAAAJ,KAAA,KAEAn3B,KAAA8oB,GAAAoO,MAAA,EAAAA,KAAAC,KAAA9kB,mBAIAslB,kBAAA,WAGA,GAAAtC,MAAA,GAAA3rB,OAAAgW,QACAkY,MAAA,GAAAluB,OAAAgW,QACAmY,MAAA,GAAAnuB,OAAAgW,QACAoG,OAAA,GAAApc,OAAAgW,OAEA,iBAAAU,EAAA9P,EAAA9Q,EAAAs4B,gBAAAzlB,gBAIAulB,MAAA3V,WAAA3R,EAAA8P,GACAyX,MAAA5V,WAAAziB,EAAA4gB,GACA0F,OAAAjG,aAAA+X,MAAAC,MAOA,IACA/tB,MADAiuB,IAAA/3B,KAAA80B,UAAAnV,IAAAmG,OAGA,IAAAiS,IAAA,GAEA,GAAAD,gBAAA,WACAhuB,MAAA,MAEI,QAAAiuB,KAOJ,WALAjuB,MAAA,GACAiuB,SAQA1C,KAAApT,WAAAjiB,KAAA60B,OAAAzU,EACA,IAAA4X,QAAAluB,KAAA9J,KAAA80B,UAAAnV,IAAAkY,MAAAhY,aAAAwV,KAAAwC,OAGA,MAAAG,OAEA,WAIA,IAAAC,QAAAnuB,KAAA9J,KAAA80B,UAAAnV,IAAAiY,MAAAzS,MAAAkQ,MAGA,MAAA4C,OAEA,WAKA,IAAAD,OAAAC,OAAAF,IAEA,WAKA,IAAAG,MAAApuB,KAAAurB,KAAA1V,IAAAmG,OAGA,UAAAoS,IAEA,KAKAl4B,KAAA8oB,GAAAoP,IAAAH,IAAA1lB,oBAMA2R,aAAA,SAAAmU,SAOA,MALAn4B,MAAA80B,UAAAnxB,IAAA3D,KAAA60B,QAAA7Q,aAAAmU,SACAn4B,KAAA60B,OAAA7Q,aAAAmU,SACAn4B,KAAA80B,UAAAt0B,IAAAR,KAAA60B,QACA70B,KAAA80B,UAAAhV,YAEA9f,MAGAsT,OAAA,SAAAyhB,KAEA,MAAAA,KAAAF,OAAAvhB,OAAAtT,KAAA60B,SAAAE,IAAAD,UAAAxhB,OAAAtT,KAAA80B,YAIAnhB,MAAA,WAEA,UAAAjK,OAAAkrB,KAAApkB,KAAAxQ,QAaA0J,MAAAkiB,OAAA,SAAAjD,OAAAkD,QAEA7rB,KAAA2oB,OAAA/e,SAAA+e,cAAA,GAAAjf,OAAAgW,QACA1f,KAAA6rB,OAAAjiB,SAAAiiB,cAAA,GAIAniB,MAAAkiB,OAAAtrB,WAEAM,YAAA8I,MAAAkiB,OAEAzb,IAAA,SAAAwY,OAAAkD,QAKA,MAHA7rB,MAAA2oB,OAAAnY,KAAAmY,QACA3oB,KAAA6rB,cAEA7rB,MAGAypB,cAAA,WAEA,GAAAQ,KAAA,GAAAvgB,OAAAqhB,IAEA,iBAAArB,OAAA0O,gBAEA,GAAAzP,QAAA3oB,KAAA2oB,MAEA/e,UAAAwuB,eAEAzP,OAAAnY,KAAA4nB,gBAIAnO,IAAAR,cAAAC,QAAAf,cAMA,QAFA0P,aAAA,EAEA3zB,EAAA,EAAAklB,GAAAF,OAAA/kB,OAAuCilB,GAAAllB,EAAQA,IAE/C2zB,YAAAxuB,KAAA4I,IAAA4lB,YAAA1P,OAAA3F,kBAAA0G,OAAAhlB,IAMA,OAFA1E,MAAA6rB,OAAAhiB,KAAAmI,KAAAqmB,aAEAr4B,SAMAwQ,KAAA,SAAA0lB,QAKA,MAHAl2B,MAAA2oB,OAAAnY,KAAA0lB,OAAAvN,QACA3oB,KAAA6rB,OAAAqK,OAAArK,OAEA7rB,MAIAkqB,MAAA,WAEA,MAAAlqB,MAAA6rB,QAAA,GAIAxB,cAAA,SAAAnB,OAEA,MAAAA,OAAAlG,kBAAAhjB,KAAA2oB,SAAA3oB,KAAA6rB,OAAA7rB,KAAA6rB,QAIAnB,gBAAA,SAAAxB,OAEA,MAAAA,OAAAnG,WAAA/iB,KAAA2oB,QAAA3oB,KAAA6rB,QAIAyM,iBAAA,SAAApC,QAEA,GAAAqC,WAAAv4B,KAAA6rB,OAAAqK,OAAArK,MAEA,OAAAqK,QAAAvN,OAAA3F,kBAAAhjB,KAAA2oB,SAAA4P,qBAIA9N,WAAA,SAAAvB,MAAA7W,gBAEA,GAAAmmB,eAAAx4B,KAAA2oB,OAAA3F,kBAAAkG,OAEAzkB,OAAA4N,gBAAA,GAAA3I,OAAAgW,OAUA,OATAjb,QAAA+L,KAAA0Y,OAEAsP,cAAAx4B,KAAA6rB,OAAA7rB,KAAA6rB,SAEApnB,OAAAjE,IAAAR,KAAA2oB,QAAA7I,YACArb,OAAA0O,eAAAnT,KAAA6rB,QAAAloB,IAAA3D,KAAA2oB,SAIAlkB,QAIAg0B,eAAA,SAAApmB,gBAEA,GAAA4X,KAAA5X,gBAAA,GAAA3I,OAAAqhB,IAKA,OAHAd,KAAA9Z,IAAAnQ,KAAA2oB,OAAA3oB,KAAA2oB,QACAsB,IAAAG,eAAApqB,KAAA6rB,QAEA5B,KAIAjG,aAAA,SAAAW,QAKA,MAHA3kB,MAAA2oB,OAAA3E,aAAAW,QACA3kB,KAAA6rB,OAAA7rB,KAAA6rB,OAAAlH,OAAAiO,oBAEA5yB,MAIA8qB,UAAA,SAAApX,QAIA,MAFA1T,MAAA2oB,OAAAhlB,IAAA+P,QAEA1T,MAIAsT,OAAA,SAAA4iB,QAEA,MAAAA,QAAAvN,OAAArV,OAAAtT,KAAA2oB,SAAAuN,OAAArK,SAAA7rB,KAAA6rB,QAIAlY,MAAA,WAEA,UAAAjK,OAAAkiB,QAAApb,KAAAxQ,QAcA0J,MAAAgvB,QAAA,SAAAC,GAAAC,GAAAC,GAAAC,GAAAC,GAAAC,IAEAh5B,KAAAi5B,QAEArvB,SAAA+uB,MAAA,GAAAjvB,OAAAwvB,MACAtvB,SAAAgvB,MAAA,GAAAlvB,OAAAwvB,MACAtvB,SAAAivB,MAAA,GAAAnvB,OAAAwvB,MACAtvB,SAAAkvB,MAAA,GAAApvB,OAAAwvB,MACAtvB,SAAAmvB,MAAA,GAAArvB,OAAAwvB,MACAtvB,SAAAovB,MAAA,GAAAtvB,OAAAwvB,QAMAxvB,MAAAgvB,QAAAp4B,WAEAM,YAAA8I,MAAAgvB,QAEAvoB,IAAA,SAAAwoB,GAAAC,GAAAC,GAAAC,GAAAC,GAAAC,IAEA,GAAAC,QAAAj5B,KAAAi5B,MASA,OAPAA,QAAA,GAAAzoB,KAAAmoB,IACAM,OAAA,GAAAzoB,KAAAooB,IACAK,OAAA,GAAAzoB,KAAAqoB,IACAI,OAAA,GAAAzoB,KAAAsoB,IACAG,OAAA,GAAAzoB,KAAAuoB,IACAE,OAAA,GAAAzoB,KAAAwoB,IAEAh5B,MAIAwQ,KAAA,SAAA2oB,SAIA,OAFAF,QAAAj5B,KAAAi5B,OAEAv0B,EAAA,EAAkB,EAAAA,EAAOA,IAEzBu0B,OAAAv0B,GAAA8L,KAAA2oB,QAAAF,OAAAv0B,GAIA,OAAA1E,OAIAo5B,cAAA,SAAA75B,GAEA,GAAA05B,QAAAj5B,KAAAi5B,OACApS,GAAAtnB,EAAAmf,SACA2a,IAAAxS,GAAA,GAAAyS,IAAAzS,GAAA,GAAA0S,IAAA1S,GAAA,GAAA2S,IAAA3S,GAAA,GACA4S,IAAA5S,GAAA,GAAA6S,IAAA7S,GAAA,GAAA8S,IAAA9S,GAAA,GAAA+S,IAAA/S,GAAA,GACAgT,IAAAhT,GAAA,GAAAiT,IAAAjT,GAAA,GAAAkT,KAAAlT,GAAA,IAAAmT,KAAAnT,GAAA,IACAoT,KAAApT,GAAA,IAAAqT,KAAArT,GAAA,IAAAsT,KAAAtT,GAAA,IAAAuT,KAAAvT,GAAA,GASA,OAPAoS,QAAA,GAAAoB,cAAAb,IAAAH,IAAAO,IAAAH,IAAAO,KAAAH,IAAAO,KAAAH,MAAAna,YACAmZ,OAAA,GAAAoB,cAAAb,IAAAH,IAAAO,IAAAH,IAAAO,KAAAH,IAAAO,KAAAH,MAAAna,YACAmZ,OAAA,GAAAoB,cAAAb,IAAAF,IAAAM,IAAAF,IAAAM,KAAAF,IAAAM,KAAAF,MAAApa,YACAmZ,OAAA,GAAAoB,cAAAb,IAAAF,IAAAM,IAAAF,IAAAM,KAAAF,IAAAM,KAAAF,MAAApa,YACAmZ,OAAA,GAAAoB,cAAAb,IAAAD,IAAAK,IAAAD,IAAAK,KAAAD,KAAAK,KAAAD,MAAAra,YACAmZ,OAAA,GAAAoB,cAAAb,IAAAD,IAAAK,IAAAD,IAAAK,KAAAD,KAAAK,KAAAD,MAAAra,YAEA9f,MAIAs6B,iBAAA,WAEA,GAAApE,QAAA,GAAAxsB,OAAAkiB,MAEA,iBAAAX,QAEA,GAAA9nB,UAAA8nB,OAAA9nB,QAOA,OALA,QAAAA,SAAAo3B,gBAAAp3B,SAAAq3B,wBAEAtE,OAAA1lB,KAAArN,SAAAo3B,gBACArE,OAAAlS,aAAAiH,OAAAjG,aAEAhlB,KAAAs4B,iBAAApC,YAMAoC,iBAAA,SAAApC,QAMA,OAJA+C,QAAAj5B,KAAAi5B,OACAtQ,OAAAuN,OAAAvN,OACA8R,WAAAvE,OAAArK,OAEAnnB,EAAA,EAAkB,EAAAA,EAAOA,IAAA,CAEzB,GAAAmkB,UAAAoQ,OAAAv0B,GAAAgmB,gBAAA/B,OAEA,IAAA8R,UAAA5R,SAEA,SAMA,UAIA6R,cAAA,WAEA,GAAA9B,IAAA,GAAAlvB,OAAAgW,QACAmZ,GAAA,GAAAnvB,OAAAgW,OAEA,iBAAAuK,KAIA,OAFAgP,QAAAj5B,KAAAi5B,OAEAv0B,EAAA,EAAmB,EAAAA,EAAQA,IAAA,CAE3B,GAAAiyB,OAAAsC,OAAAv0B,EAEAk0B,IAAA10B,EAAAyyB,MAAA7Q,OAAA5hB,EAAA,EAAA+lB,IAAA3Y,IAAApN,EAAA+lB,IAAAxX,IAAAvO,EACA20B,GAAA30B,EAAAyyB,MAAA7Q,OAAA5hB,EAAA,EAAA+lB,IAAAxX,IAAAvO,EAAA+lB,IAAA3Y,IAAApN,EACA00B,GAAAz0B,EAAAwyB,MAAA7Q,OAAA3hB,EAAA,EAAA8lB,IAAA3Y,IAAAnN,EAAA8lB,IAAAxX,IAAAtO,EACA00B,GAAA10B,EAAAwyB,MAAA7Q,OAAA3hB,EAAA,EAAA8lB,IAAAxX,IAAAtO,EAAA8lB,IAAA3Y,IAAAnN,EACAy0B,GAAA11B,EAAAyzB,MAAA7Q,OAAA5iB,EAAA,EAAA+mB,IAAA3Y,IAAApO,EAAA+mB,IAAAxX,IAAAvP,EACA21B,GAAA31B,EAAAyzB,MAAA7Q,OAAA5iB,EAAA,EAAA+mB,IAAAxX,IAAAvP,EAAA+mB,IAAA3Y,IAAApO,CAEA,IAAAy3B,IAAAhE,MAAAjM,gBAAAkO,IACAvC,GAAAM,MAAAjM,gBAAAmO,GAIA,MAAA8B,IAAA,EAAAtE,GAEA,SAKA,aAMAhM,cAAA,SAAAnB,OAIA,OAFA+P,QAAAj5B,KAAAi5B,OAEAv0B,EAAA,EAAkB,EAAAA,EAAOA,IAEzB,GAAAu0B,OAAAv0B,GAAAgmB,gBAAAxB,OAAA,EAEA,QAMA,WAIAvV,MAAA,WAEA,UAAAjK,OAAAgvB,SAAAloB,KAAAxQ,QAYA0J,MAAAwvB,MAAA,SAAApT,OAAAiR,UAEA/2B,KAAA8lB,OAAAlc,SAAAkc,cAAA,GAAApc,OAAAgW,QAAA,OACA1f,KAAA+2B,SAAAntB,SAAAmtB,kBAAA,GAIArtB,MAAAwvB,MAAA54B,WAEAM,YAAA8I,MAAAwvB,MAEA/oB,IAAA,SAAA2V,OAAAiR,UAKA,MAHA/2B,MAAA8lB,OAAAtV,KAAAsV,QACA9lB,KAAA+2B,kBAEA/2B,MAIAq6B,cAAA,SAAAn2B,EAAAC,EAAAjB,EAAA8Z,GAKA,MAHAhd,MAAA8lB,OAAA3V,IAAAjM,EAAAC,EAAAjB,GACAlD,KAAA+2B,SAAA/Z,EAEAhd,MAIA46B,8BAAA,SAAA9U,OAAAoD,OAKA,MAHAlpB,MAAA8lB,OAAAtV,KAAAsV,QACA9lB,KAAA+2B,UAAA7N,MAAAvJ,IAAA3f,KAAA8lB,QAEA9lB,MAIA66B,sBAAA,WAEA,GAAAvb,IAAA,GAAA5V,OAAAgW,QACA4D,GAAA,GAAA5Z,OAAAgW,OAEA,iBAAAU,EAAA9P,EAAA9Q,GAEA,GAAAsmB,QAAAxG,GAAA2C,WAAAziB,EAAA8Q,GAAA6U,MAAA7B,GAAArB,WAAA7B,EAAA9P,IAAAwP,WAMA,OAFA9f,MAAA46B,8BAAA9U,OAAA1F,GAEApgB,SAOAwQ,KAAA,SAAAmmB,OAKA,MAHA32B,MAAA8lB,OAAAtV,KAAAmmB,MAAA7Q,QACA9lB,KAAA+2B,SAAAJ,MAAAI,SAEA/2B,MAIA8f,UAAA,WAIA,GAAAgb,qBAAA,EAAA96B,KAAA8lB,OAAAnhB,QAIA,OAHA3E,MAAA8lB,OAAA3S,eAAA2nB,qBACA96B,KAAA+2B,UAAA+D,oBAEA96B,MAIA8iB,OAAA,WAKA,MAHA9iB,MAAA+2B,UAAA,GACA/2B,KAAA8lB,OAAAhD,SAEA9iB,MAIA0qB,gBAAA,SAAAxB,OAEA,MAAAlpB,MAAA8lB,OAAAnG,IAAAuJ,OAAAlpB,KAAA+2B,UAIAgE,iBAAA,SAAA7E,QAEA,MAAAl2B,MAAA0qB,gBAAAwL,OAAAvN,QAAAuN,OAAArK,QAIAmP,aAAA,SAAA9R,MAAA7W,gBAEA,MAAArS,MAAAi7B,WAAA/R,MAAA7W,gBAAA7R,IAAA0oB,OAAApG,UAIAmY,WAAA,SAAA/R,MAAA7W,gBAEA,GAAA6oB,wBAAAl7B,KAAA0qB,gBAAAxB,OAEAzkB,OAAA4N,gBAAA,GAAA3I,OAAAgW,OACA,OAAAjb,QAAA+L,KAAAxQ,KAAA8lB,QAAA3S,eAAA+nB,yBAIAC,mBAAA,SAAAzS,MAIA,GAAA0S,WAAAp7B,KAAA0qB,gBAAAhC,KAAAF,OACA6S,QAAAr7B,KAAA0qB,gBAAAhC,KAAAD,IAEA,UAAA2S,WAAAC,QAAA,KAAAA,SAAAD,UAAA,GAIAE,cAAA,WAEA,GAAAhc,IAAA,GAAA5V,OAAAgW,OAEA,iBAAAgJ,KAAArW,gBAEA,GAAA5N,QAAA4N,gBAAA,GAAA3I,OAAAgW,QAEAoV,UAAApM,KAAA/V,MAAA2M,IAEAuX,YAAA72B,KAAA8lB,OAAAnG,IAAAmV,UAEA,OAAA+B,YAGA,UAAA72B,KAAA0qB,gBAAAhC,KAAAF,OAEA/jB,OAAA+L,KAAAkY,KAAAF,OAKA5e,MAIA,IAAAuH,KAAAuX,KAAAF,MAAA7I,IAAA3f,KAAA8lB,QAAA9lB,KAAA+2B,UAAAF,WAEA,UAAA1lB,KAAA,EAEAvH,OAIAnF,OAAA+L,KAAAskB,WAAA3hB,eAAAhC,GAAAxN,IAAA+kB,KAAAF,WAOA+S,cAAA,SAAAlpB,gBAEA,GAAA5N,QAAA4N,gBAAA,GAAA3I,OAAAgW,OACA,OAAAjb,QAAA+L,KAAAxQ,KAAA8lB,QAAA3S,gBAAAnT,KAAA+2B,WAIA/S,aAAA,WAEA,GAAA1E,IAAA,GAAA5V,OAAAgW,QACA4D,GAAA,GAAA5Z,OAAAgW,QACA8b,GAAA,GAAA9xB,OAAAoiB,OAEA,iBAAAnH,OAAA8W,sBAIA,GAAAC,cAAAD,sBAAAD,GAAApO,gBAAAzI,QACAgX,UAAArc,GAAA9O,KAAAxQ,KAAA8lB,QAAAhC,aAAA4X,cAEAE,iBAAA57B,KAAAu7B,cAAAjY,GAKA,OAJAsY,kBAAA5X,aAAAW,QAEA3kB,KAAA46B,8BAAAe,UAAAC,kBAEA57B,SAMA8qB,UAAA,SAAApX,QAIA,MAFA1T,MAAA+2B,SAAA/2B,KAAA+2B,SAAArjB,OAAAiM,IAAA3f,KAAA8lB,QAEA9lB,MAIAsT,OAAA,SAAAqjB,OAEA,MAAAA,OAAA7Q,OAAAxS,OAAAtT,KAAA8lB,SAAA6Q,MAAAI,UAAA/2B,KAAA+2B,UAIApjB,MAAA,WAEA,UAAAjK,OAAAwvB,OAAA1oB,KAAAxQ,QAaA0J,MAAAG,MAEAgyB,aAAA,WAIA,GAEAzrB,GAFA0rB,MAAA,iEAAAC,MAAA,IACAC,KAAA,GAAAC,OAAA,IACAC,IAAA,CAEA,mBAEA,OAAAx3B,GAAA,EAAmB,GAAAA,EAAQA,IAE3B,GAAAA,GAAA,IAAAA,GAAA,IAAAA,GAAA,IAAAA,EAEAs3B,KAAAt3B,GAAA,IAEK,IAAAA,EAELs3B,KAAAt3B,GAAA,KAIA,GAAAw3B,UAAA,kBAAAryB,KAAAsyB,SAAA,GACA/rB,EAAA,GAAA8rB,IACAA,MAAA,EACAF,KAAAt3B,GAAAo3B,MAAA,IAAAp3B,EAAA,EAAA0L,EAAA,EAAAA,GAKA,OAAA4rB,MAAAn3B,KAAA,QAQA0d,MAAA,SAAAre,EAAAkc,EAAA9P,GAEA,MAAA8P,GAAAlc,EAAAkc,EAAAlc,EAAAoM,IAAApM,GAMAk4B,YAAA,SAAAl4B,EAAAkc,GAEA,MAAAA,GAAAlc,EAAAkc,EAAAlc,GAMAm4B,UAAA,SAAAn4B,EAAAo4B,GAAAC,GAAAxG,GAAAyG,IAEA,MAAAzG,KAAA7xB,EAAAo4B,KAAAE,GAAAzG,KAAAwG,GAAAD,KAMAG,WAAA,SAAAv4B,EAAAoN,IAAAmB,KAEA,MAAAnB,MAAApN,EAAA,EACAA,GAAAuO,IAAA,GAEAvO,KAAAoN,MAAAmB,IAAAnB,KAEApN,KAAA,IAAAA,KAIAw4B,aAAA,SAAAx4B,EAAAoN,IAAAmB,KAEA,MAAAnB,MAAApN,EAAA,EACAA,GAAAuO,IAAA,GAEAvO,KAAAoN,MAAAmB,IAAAnB,KAEApN,UAAA,EAAAA,EAAA,UAOAy4B,SAAA,WAEA,aAAA9yB,KAAAsyB,SAAA,IAAAtyB,KAAAsyB,UAAA,OAMAS,QAAA,SAAAC,IAAAC,MAEA,MAAAjzB,MAAA+G,MAAA5Q,KAAA+8B,UAAAF,IAAAC,QAMAC,UAAA,SAAAF,IAAAC,MAEA,MAAAD,KAAAhzB,KAAAsyB,UAAAW,KAAAD,MAMAG,gBAAA,SAAAC,OAEA,MAAAA,QAAA,GAAApzB,KAAAsyB,WAIA5H,SAAA,WAEA,GAAA2I,uBAAArzB,KAAAud,GAAA,GAEA,iBAAA+V,SAEA,MAAAA,SAAAD,0BAMAE,SAAA,WAEA,GAAAC,uBAAA,IAAAxzB,KAAAud,EAEA,iBAAAkW,SAEA,MAAAA,SAAAD,0BAMAE,aAAA,SAAAhtB,OAEA,YAAAA,YAAA,QAAAA,OAIAitB,eAAA,SAAAjtB,OAUA,MARAA,SACAA,cAAA,EACAA,cAAA,EACAA,cAAA,EACAA,cAAA,EACAA,cAAA,GACAA,QAEAA,QAgBA7G,MAAA+zB,OAAA,SAAA/T,QA8JA,QAAAgU,aAAA/E,GAAAC,GAAAC,GAAAC,GAAA3nB,EAAAwsB,GAAAC,IAEA,GAAAtI,IAAA,IAAAuD,GAAAF,IACArZ,GAAA,IAAAwZ,GAAAF,GAEA,WAAAA,GAAAC,IAAAvD,GAAAhW,IAAAse,IAAA,IAAAhF,GAAAC,IAAA,EAAAvD,GAAAhW,IAAAqe,GAAArI,GAAAnkB,EAAAynB,GAjKA54B,KAAA0pB,aAEA,IACAR,OAAA2U,SAAAC,OAAAC,GAAAC,GACAC,GAAAC,GAAAC,GAAAC,GAFA5+B,KAAA6+B,IAAmBn6B,EAAA,EAAAC,EAAA,EAAAjB,EAAA,EAInBlD,MAAAs+B,cAAA,SAAAle,GAEApgB,KAAA0pB,SAEA,QAAAhlB,GAAA,EAAkBA,EAAA0b,EAAAzb,OAAcD,IAEhC1E,KAAA0pB,OAAAhlB,IAAuBR,EAAAkc,EAAA1b,GAAA,GAAAP,EAAAic,EAAA1b,GAAA,GAAAxB,EAAAkd,EAAA1b,GAAA,KAMvB1E,KAAAu+B,SAAA,SAAAC,GAuBA,MArBAtV,QAAAlpB,KAAA0pB,OAAA/kB,OAAA,GAAA65B,EACAX,SAAAh0B,KAAA+G,MAAAsY,OACA4U,OAAA5U,MAAA2U,SAEAr+B,EAAA,OAAAq+B,2BAAA,EACAr+B,EAAA,GAAAq+B,SACAr+B,EAAA,GAAAq+B,SAAA79B,KAAA0pB,OAAA/kB,OAAA,EAAA3E,KAAA0pB,OAAA/kB,OAAA,EAAAk5B,SAAA,EACAr+B,EAAA,GAAAq+B,SAAA79B,KAAA0pB,OAAA/kB,OAAA,EAAA3E,KAAA0pB,OAAA/kB,OAAA,EAAAk5B,SAAA,EAEAI,GAAAj+B,KAAA0pB,OAAAlqB,EAAA,IACA0+B,GAAAl+B,KAAA0pB,OAAAlqB,EAAA,IACA2+B,GAAAn+B,KAAA0pB,OAAAlqB,EAAA,IACA4+B,GAAAp+B,KAAA0pB,OAAAlqB,EAAA,IAEAu+B,GAAAD,cACAE,GAAAF,OAAAC,GAEAM,GAAAn6B,EAAAw5B,YAAAO,GAAA/5B,EAAAg6B,GAAAh6B,EAAAi6B,GAAAj6B,EAAAk6B,GAAAl6B,EAAA45B,OAAAC,GAAAC,IACAK,GAAAl6B,EAAAu5B,YAAAO,GAAA95B,EAAA+5B,GAAA/5B,EAAAg6B,GAAAh6B,EAAAi6B,GAAAj6B,EAAA25B,OAAAC,GAAAC,IACAK,GAAAn7B,EAAAw6B,YAAAO,GAAA/6B,EAAAg7B,GAAAh7B,EAAAi7B,GAAAj7B,EAAAk7B,GAAAl7B,EAAA46B,OAAAC,GAAAC,IAEAK,IAIAr+B,KAAAy+B,sBAAA,WAEA,GAAA/5B,GAAAjF,EAAAuR,EAAAhR,KAAA0pB,OAAA/kB,OACA+5B,SAEA,KAAAh6B,EAAA,EAAcsM,EAAAtM,EAAOA,IAErBjF,EAAAO,KAAA0pB,OAAAhlB,GACAg6B,OAAAh6B,IAAAjF,EAAAyE,EAAAzE,EAAA0E,EAAA1E,EAAAyD,EAIA,OAAAw7B,SAMA1+B,KAAA2+B,UAAA,SAAAC,eAEA,GAAAl6B,GAAAgD,MAAAm3B,SAAA57B,SACAimB,MAAA,EAAA2U,SAAA,EAAAiB,YAAA,EACAC,YAAA,GAAAr1B,OAAAgW,QACAsf,OAAA,GAAAt1B,OAAAgW,QACAuf,gBACAC,YAAA,CAYA,KARAD,aAAA,KAEAL,8BAAA,KAEAC,SAAA7+B,KAAA0pB,OAAA/kB,OAAAi6B,cAEAG,YAAAvuB,KAAAxQ,KAAA0pB,OAAA,IAEAhlB,EAAA,EAAcm6B,SAAAn6B,EAAcA,IAE5BgD,MAAAhD,EAAAm6B,SAEA57B,SAAAjD,KAAAu+B,SAAA72B,OACAs3B,OAAAxuB,KAAAvN,UAEAi8B,aAAAF,OAAAjc,WAAAgc,aAEAA,YAAAvuB,KAAAvN,UAEAimB,OAAAlpB,KAAA0pB,OAAA/kB,OAAA,GAAA+C,MACAm2B,SAAAh0B,KAAA+G,MAAAsY,OAEA2U,UAAAiB,cAEAG,aAAApB,UAAAqB,YACAJ,YAAAjB,SAUA,OAFAoB,2BAAAt6B,QAAAu6B,aAEUC,OAAAF,aAAAG,MAAAF,cAIVl/B,KAAAq/B,yBAAA,SAAAC,cAEA,GAAA56B,GAAAY,EACAoC,MAAA63B,aAAAC,UACAC,aACAC,SAAAz8B,SACA08B,aACAX,OAAA,GAAAt1B,OAAAgW,QACAkgB,GAAA5/B,KAAA2+B,WAIA,KAFAgB,UAAAr7B,KAAA06B,OAAAxuB,KAAAxQ,KAAA0pB,OAAA,IAAA/V,SAEAjP,EAAA,EAAcA,EAAA1E,KAAA0pB,OAAA/kB,OAAwBD,IAAA,CAYtC,IAPA+6B,aAAAG,GAAAT,OAAAz6B,GAAAk7B,GAAAT,OAAAz6B,EAAA,GAEAg7B,SAAA71B,KAAA8Y,KAAA2c,aAAAG,aAAAG,GAAAR,OAEAG,cAAA76B,EAAA,IAAA1E,KAAA0pB,OAAA/kB,OAAA,GACA66B,UAAA96B,GAAA1E,KAAA0pB,OAAA/kB,OAAA,GAEAW,EAAA,EAAeo6B,SAAA,EAAAp6B,EAAkBA,IAEjCoC,MAAA63B,aAAAj6B,GAAA,EAAAo6B,WAAAF,UAAAD,cAEAt8B,SAAAjD,KAAAu+B,SAAA72B,OACAi4B,UAAAr7B,KAAA06B,OAAAxuB,KAAAvN,UAAA0Q,QAIAgsB,WAAAr7B,KAAA06B,OAAAxuB,KAAAxQ,KAAA0pB,OAAAhlB,IAAAiP,SAIA3T,KAAA0pB,OAAAiW,YAwBAj2B,MAAAm2B,SAAA,SAAAzf,EAAA9P,EAAA9Q,GAEAQ,KAAAogB,EAAAxW,SAAAwW,IAAA,GAAA1W,OAAAgW,QACA1f,KAAAsQ,EAAA1G,SAAA0G,IAAA,GAAA5G,OAAAgW,QACA1f,KAAAR,EAAAoK,SAAApK,IAAA,GAAAkK,OAAAgW,SAIAhW,MAAAm2B,SAAA/Z,OAAA,WAEA,GAAAwP,IAAA,GAAA5rB,OAAAgW,OAEA,iBAAAU,EAAA9P,EAAA9Q,EAAA6S,gBAEA,GAAA5N,QAAA4N,gBAAA,GAAA3I,OAAAgW,OAEAjb,QAAAwd,WAAAziB,EAAA8Q,GACAglB,GAAArT,WAAA7B,EAAA9P,GACA7L,OAAA0gB,MAAAmQ,GAEA,IAAAwK,gBAAAr7B,OAAAyb,UACA,OAAA4f,gBAAA,EAEAr7B,OAAA0O,eAAA,EAAAtJ,KAAAmI,KAAA8tB,iBAIAr7B,OAAA0L,IAAA,WAQAzG,MAAAm2B,SAAAE,mBAAA,WAEA,GAAAzK,IAAA,GAAA5rB,OAAAgW,QACAJ,GAAA,GAAA5V,OAAAgW,QACA4D,GAAA,GAAA5Z,OAAAgW,OAEA,iBAAAwJ,MAAA9I,EAAA9P,EAAA9Q,EAAA6S,gBAEAijB,GAAArT,WAAAziB,EAAA4gB,GACAd,GAAA2C,WAAA3R,EAAA8P,GACAkD,GAAArB,WAAAiH,MAAA9I,EAEA,IAAA4f,OAAA1K,GAAA3V,IAAA2V,IACA2K,MAAA3K,GAAA3V,IAAAL,IACA4gB,MAAA5K,GAAA3V,IAAA2D,IACA6c,MAAA7gB,GAAAK,IAAAL,IACA8gB,MAAA9gB,GAAAK,IAAA2D,IAEA+c,MAAAL,MAAAG,MAAAF,YAEAx7B,OAAA4N,gBAAA,GAAA3I,OAAAgW,OAGA,OAAA2gB,MAGA,MAAA57B,QAAA0L,IAAA,SAGA,IAAAmwB,UAAA,EAAAD,MACAE,GAAAJ,MAAAD,MAAAD,MAAAG,OAAAE,SACArgB,GAAA+f,MAAAI,MAAAH,MAAAC,OAAAI,QAGA,OAAA77B,QAAA0L,IAAA,EAAAowB,EAAAtgB,IAAAsgB,OAMA72B,MAAAm2B,SAAAxV,cAAA,WAEA,GAAA/K,IAAA,GAAA5V,OAAAgW,OAEA,iBAAAwJ,MAAA9I,EAAA9P,EAAA9Q,GAEA,GAAAiF,QAAAiF,MAAAm2B,SAAAE,mBAAA7W,MAAA9I,EAAA9P,EAAA9Q,EAAA8f,GAEA,OAAA7a,QAAAP,GAAA,GAAAO,OAAAN,GAAA,GAAAM,OAAAP,EAAAO,OAAAN,GAAA,MAMAuF,MAAAm2B,SAAAv/B,WAEAM,YAAA8I,MAAAm2B,SAEA1vB,IAAA,SAAAiQ,EAAA9P,EAAA9Q,GAMA,MAJAQ,MAAAogB,EAAA5P,KAAA4P,GACApgB,KAAAsQ,EAAAE,KAAAF,GACAtQ,KAAAR,EAAAgR,KAAAhR,GAEAQ,MAIAwgC,wBAAA,SAAA9W,OAAA+W,GAAAC,GAAAC,IAMA,MAJA3gC,MAAAogB,EAAA5P,KAAAkZ,OAAA+W,KACAzgC,KAAAsQ,EAAAE,KAAAkZ,OAAAgX,KACA1gC,KAAAR,EAAAgR,KAAAkZ,OAAAiX,KAEA3gC,MAIAwQ,KAAA,SAAAowB,UAMA,MAJA5gC,MAAAogB,EAAA5P,KAAAowB,SAAAxgB,GACApgB,KAAAsQ,EAAAE,KAAAowB,SAAAtwB,GACAtQ,KAAAR,EAAAgR,KAAAowB,SAAAphC,GAEAQ,MAIA6gC,KAAA,WAEA,GAAAvL,IAAA,GAAA5rB,OAAAgW,QACAJ,GAAA,GAAA5V,OAAAgW,OAEA,mBAKA,MAHA4V,IAAArT,WAAAjiB,KAAAR,EAAAQ,KAAAsQ,GACAgP,GAAA2C,WAAAjiB,KAAAogB,EAAApgB,KAAAsQ,GAEA,GAAAglB,GAAAnQ,MAAA7F,IAAA3a,aAMAm8B,SAAA,SAAAzuB,gBAEA,GAAA5N,QAAA4N,gBAAA,GAAA3I,OAAAgW,OACA,OAAAjb,QAAAud,WAAAhiB,KAAAogB,EAAApgB,KAAAsQ,GAAA3M,IAAA3D,KAAAR,GAAA2T,eAAA,MAIA2S,OAAA,SAAAzT,gBAEA,MAAA3I,OAAAm2B,SAAA/Z,OAAA9lB,KAAAogB,EAAApgB,KAAAsQ,EAAAtQ,KAAAR,EAAA6S,iBAIAskB,MAAA,SAAAtkB,gBAEA,GAAA5N,QAAA4N,gBAAA,GAAA3I,OAAAwvB,KAEA,OAAAz0B,QAAAo2B,sBAAA76B,KAAAogB,EAAApgB,KAAAsQ,EAAAtQ,KAAAR,IAIAugC,mBAAA,SAAA7W,MAAA7W,gBAEA,MAAA3I,OAAAm2B,SAAAE,mBAAA7W,MAAAlpB,KAAAogB,EAAApgB,KAAAsQ,EAAAtQ,KAAAR,EAAA6S,iBAIAgY,cAAA,SAAAnB,OAEA,MAAAxf,OAAAm2B,SAAAxV,cAAAnB,MAAAlpB,KAAAogB,EAAApgB,KAAAsQ,EAAAtQ,KAAAR,IAIA8T,OAAA,SAAAstB,UAEA,MAAAA,UAAAxgB,EAAA9M,OAAAtT,KAAAogB,IAAAwgB,SAAAtwB,EAAAgD,OAAAtT,KAAAsQ,IAAAswB,SAAAphC,EAAA8T,OAAAtT,KAAAR,IAIAmU,MAAA,WAEA,UAAAjK,OAAAm2B,UAAArvB,KAAAxQ,QAYA0J,MAAAq3B,MAAA,SAAAC,WAEAhhC,KAAAghC,UAAAp3B,SAAAo3B,qBAAA,EAEAhhC,KAAAihC,UAAA,EACAjhC,KAAAkhC,QAAA,EACAlhC,KAAAmhC,YAAA,EAEAnhC,KAAAohC,SAAA,GAIA13B,MAAAq3B,MAAAzgC,WAEAM,YAAA8I,MAAAq3B,MAEAvY,MAAA,WAEAxoB,KAAAihC,UAAAr3B,SAAA7H,KAAAs/B,aAAAz3B,SAAA7H,KAAAs/B,YAAAC,IACAv/B,KAAAs/B,YAAAC,MACAC,KAAAD,MAEAthC,KAAAkhC,QAAAlhC,KAAAihC,UACAjhC,KAAAohC,SAAA,GAGAI,KAAA,WAEAxhC,KAAAyhC,iBACAzhC,KAAAohC,SAAA,GAIAK,eAAA,WAGA,MADAzhC,MAAA0hC,WACA1hC,KAAAmhC,aAIAO,SAAA,WAEA,GAAArM,MAAA,CAQA,IANAr1B,KAAAghC,YAAAhhC,KAAAohC,SAEAphC,KAAAwoB,QAIAxoB,KAAAohC,QAAA,CAEA,GAAAO,SAAA/3B,SAAA7H,KAAAs/B,aAAAz3B,SAAA7H,KAAAs/B,YAAAC,IACAv/B,KAAAs/B,YAAAC,MACAC,KAAAD,KAEAjM,MAAA,MAAAsM,QAAA3hC,KAAAkhC,SACAlhC,KAAAkhC,QAAAS,QAEA3hC,KAAAmhC,aAAA9L,KAIA,MAAAA,QAYA3rB,MAAAk4B,gBAAA,aAEAl4B,MAAAk4B,gBAAAthC,WAEAM,YAAA8I,MAAAk4B,gBAEArgC,MAAA,SAAA0pB,QAEAA,OAAAroB,iBAAA8G,MAAAk4B,gBAAAthC,UAAAsC,iBACAqoB,OAAA4W,iBAAAn4B,MAAAk4B,gBAAAthC,UAAAuhC,iBACA5W,OAAA6W,oBAAAp4B,MAAAk4B,gBAAAthC,UAAAwhC,oBACA7W,OAAA8W,cAAAr4B,MAAAk4B,gBAAAthC,UAAAyhC,eAIAn/B,iBAAA,SAAAwD,KAAA47B,UAEAp4B,SAAA5J,KAAAiiC,aAAAjiC,KAAAiiC,cAEA,IAAAC,WAAAliC,KAAAiiC,UAEAr4B,UAAAs4B,UAAA97B,QAEA87B,UAAA97B,UAIA,KAAA87B,UAAA97B,MAAA+7B,QAAAH,WAEAE,UAAA97B,MAAA9B,KAAA09B,WAMAH,iBAAA,SAAAz7B,KAAA47B;AAEA,GAAAp4B,SAAA5J,KAAAiiC,WAAA,QAEA,IAAAC,WAAAliC,KAAAiiC,UAEA,OAAAr4B,UAAAs4B,UAAA97B,OAAA,KAAA87B,UAAA97B,MAAA+7B,QAAAH,WAEA,GAIA,GAIAF,oBAAA,SAAA17B,KAAA47B,UAEA,GAAAp4B,SAAA5J,KAAAiiC,WAAA,CAEA,GAAAC,WAAAliC,KAAAiiC,WACAG,cAAAF,UAAA97B,KAEA,IAAAwD,SAAAw4B,cAAA,CAEA,GAAA16B,OAAA06B,cAAAD,QAAAH,SAEA,MAAAt6B,OAEA06B,cAAAC,OAAA36B,MAAA,MAQAq6B,cAAA,SAAAO,OAEA,GAAA14B,SAAA5J,KAAAiiC,WAAA,CAEA,GAAAC,WAAAliC,KAAAiiC,WACAG,cAAAF,UAAAI,MAAAl8B,KAEA,IAAAwD,SAAAw4B,cAAA,CAEAE,MAAAxS,OAAA9vB,IAKA,QAHAwT,UACA7O,OAAAy9B,cAAAz9B,OAEAD,EAAA,EAAmBC,OAAAD,EAAYA,IAE/B8O,MAAA9O,GAAA09B,cAAA19B,EAIA,QAAAA,GAAA,EAAmBC,OAAAD,EAAYA,IAE/B8O,MAAA9O,GAAApF,KAAAU,KAAAsiC,WAkBA,SAAA54B,OAEAA,MAAA64B,UAAA,SAAA1N,OAAAC,UAAAZ,KAAAC,KAEAn0B,KAAA+0B,IAAA,GAAArrB,OAAAkrB,IAAAC,OAAAC,WAGA90B,KAAAk0B,WAAA,EACAl0B,KAAAm0B,SAAA3K,IAEAxpB,KAAAwiC,QACAC,UACA/+B,QACAg/B,YAAgBC,UAAA,GAChBC,OACAC,SAKA,IAAAC,UAAA,SAAA1iB,EAAA9P,GAEA,MAAA8P,GAAAyI,SAAAvY,EAAAuY,UAIAka,gBAAA,SAAA9X,OAAA+X,UAAAC,WAAAC,WAIA,GAFAjY,OAAAkY,QAAAH,UAAAC,YAEAC,aAAA,EAIA,OAFAE,UAAAnY,OAAAmY,SAEA1+B,EAAA,EAAAsM,EAAAoyB,SAAAz+B,OAAwCqM,EAAAtM,EAAOA,IAE/Cq+B,gBAAAK,SAAA1+B,GAAAs+B,UAAAC,YAAA,GAUAv5B,OAAA64B,UAAAjiC,WAEAM,YAAA8I,MAAA64B,UAEAc,UAAA,KACAC,cAAA,EAEAnzB,IAAA,SAAA0kB,OAAAC,WAIA90B,KAAA+0B,IAAA5kB,IAAA0kB,OAAAC,YAIAyO,cAAA,SAAA7E,OAAA77B,QAIAA,iBAAA6G,OAAA1G,mBAEAhD,KAAA+0B,IAAAF,OAAArkB,KAAA3N,OAAAI,UACAjD,KAAA+0B,IAAAD,UAAA3kB,IAAAuuB,OAAAx6B,EAAAw6B,OAAAv6B,EAAA,IAAA0L,UAAAhN,QAAArC,IAAAqC,OAAAI,UAAA6c,aAEIjd,iBAAA6G,OAAA85B,oBAEJxjC,KAAA+0B,IAAAF,OAAA1kB,IAAAuuB,OAAAx6B,EAAAw6B,OAAAv6B,EAAA,IAAA0L,UAAAhN,QACA7C,KAAA+0B,IAAAD,UAAA3kB,IAAA,QAAA8U,mBAAApiB,OAAAmiB,cAIAtb,MAAAM,MAAA,8CAMA+4B,gBAAA,SAAA9X,OAAAiY,WAEA,GAAAD,cAMA,OAJAF,iBAAA9X,OAAAjrB,KAAAijC,WAAAC,WAEAD,WAAAQ,KAAAX,UAEAG,YAIAS,iBAAA,SAAAC,QAAAT,WAEA,GAAAD,cAEA,IAAAU,kBAAA1H,SAAA,EAGA,MADAvyB,OAAAK,KAAA,8DACAk5B,UAIA,QAAAv+B,GAAA,EAAAsM,EAAA2yB,QAAAh/B,OAAuCqM,EAAAtM,EAAOA,IAE9Cq+B,gBAAAY,QAAAj/B,GAAA1E,KAAAijC,WAAAC,UAMA,OAFAD,YAAAQ,KAAAX,UAEAG,cAMCv5B,OAWDA,MAAAk6B,SAAA,WAEAC,OAAAC,eAAA9jC,KAAA,MAAqCuQ,MAAA7G,MAAAq6B,oBAErC/jC,KAAAg8B,KAAAtyB,MAAAG,KAAAgyB,eAEA77B,KAAAgkC,KAAA,GACAhkC,KAAAoG,KAAA,WAEApG,KAAAikC,OAAAr6B,OACA5J,KAAAojC,YAEApjC,KAAA+vB,GAAArmB,MAAAk6B,SAAAM,UAAAvwB,OAEA,IAAA1Q,UAAA,GAAAyG,OAAAgW,QACAzb,SAAA,GAAAyF,OAAAgU,MACAH,WAAA,GAAA7T,OAAAqT,WACA4V,MAAA,GAAAjpB,OAAAgW,QAAA,OAEAykB,iBAAA,WACA5mB,WAAAC,aAAAvZ,UAAA,IAGAmgC,mBAAA,WACAngC,SAAA+jB,kBAAAzK,WAAA3T,QAAA,GAGA3F,UAAAsd,SAAA4iB,kBACA5mB,WAAAgE,SAAA6iB,oBAEAP,OAAAQ,iBAAArkC,MACAiD,UACAqhC,YAAA,EACA/zB,MAAAtN,UAEAgB,UACAqgC,YAAA,EACA/zB,MAAAtM,UAEAsZ,YACA+mB,YAAA,EACA/zB,MAAAgN,YAEAoV,OACA2R,YAAA,EACA/zB,MAAAoiB,SAIA3yB,KAAAukC,oBAAA,EAEAvkC,KAAA2kB,OAAA,GAAAjb,OAAAkb,QACA5kB,KAAAglB,YAAA,GAAAtb,OAAAkb,QAEA5kB,KAAAwkC,kBAAA,EACAxkC,KAAAykC,wBAAA,EAEAzkC,KAAA0kC,SAAA,EAEA1kC,KAAA2kC,YAAA,EACA3kC,KAAA4kC,eAAA,EAEA5kC,KAAA6kC,eAAA,EACA7kC,KAAA8kC,YAAA,EAEA9kC,KAAA+kC,aAIAr7B,MAAAk6B,SAAAM,UAAA,GAAAx6B,OAAAgW,QAAA,OAEAhW,MAAAk6B,SAAAtjC,WAEAM,YAAA8I,MAAAk6B,SAEAvmB,GAAA2nB,cAIA,MAFAt7B,OAAAK,KAAA,kEAEA/J,KAAAiE,SAAAka,OAIAd,GAAA2nB,YAAAz0B,OAEA7G,MAAAK,KAAA,kEAEA/J,KAAAiE,SAAAka,MAAA5N,OAIA8M,GAAA4nB,iBAEAv7B,MAAAK,KAAA,kGAIAsT,GAAA4nB,eAAA10B,OAEA7G,MAAAK,KAAA,kGAIAm7B,YAAA,SAAAvgB,QAEA3kB,KAAA2kB,OAAAE,iBAAAF,OAAA3kB,KAAA2kB,QAEA3kB,KAAA2kB,OAAA8O,UAAAzzB,KAAAiD,SAAAjD,KAAAud,WAAAvd,KAAA2yB,QAIAwS,yBAAA,SAAA9mB,KAAAC,OAIAte,KAAAud,WAAAa,iBAAAC,KAAAC,QAIA8mB,qBAAA,SAAA3nB,OAEAzd,KAAAud,WAAAC,aAAAC,OAAA,IAIA4nB,sBAAA,SAAA9lC,GAIAS,KAAAud,WAAAiB,sBAAAjf,IAIA8vB,0BAAA,SAAAne,GAIAlR,KAAAud,WAAA/M,KAAAU,IAIAo0B,aAAA,WAKA,GAAAC,IAAA,GAAA77B,OAAAqT,UAEA,iBAAAsB,KAAAC,OAMA,MAJAinB,IAAAnnB,iBAAAC,KAAAC,OAEAte,KAAAud,WAAArK,SAAAqyB,IAEAvlC,SAMAuyB,QAAA,WAEA,GAAAjT,IAAA,GAAA5V,OAAAgW,QAAA,MAEA,iBAAApB,OAEA,MAAAte,MAAAslC,aAAAhmB,GAAAhB,WAMAkU,QAAA,WAEA,GAAAlT,IAAA,GAAA5V,OAAAgW,QAAA,MAEA,iBAAApB,OAEA,MAAAte,MAAAslC,aAAAhmB,GAAAhB,WAMAmU,QAAA,WAEA,GAAAnT,IAAA,GAAA5V,OAAAgW,QAAA,MAEA,iBAAApB,OAEA,MAAAte,MAAAslC,aAAAhmB,GAAAhB,WAMAknB,gBAAA,WAKA,GAAAlmB,IAAA,GAAA5V,OAAAgW,OAEA,iBAAArB,KAAAwK,UAMA,MAJAvJ,IAAA9O,KAAA6N,MAAAyC,gBAAA9gB,KAAAud,YAEAvd,KAAAiD,SAAAU,IAAA2b,GAAAnM,eAAA0V,WAEA7oB,SAMA8qB,UAAA,SAAAjC,SAAAxK,MAGA,MADA3U,OAAAK,KAAA,kGACA/J,KAAAwlC,gBAAAnnB,KAAAwK,WAIA4c,WAAA,WAEA,GAAAnmB,IAAA,GAAA5V,OAAAgW,QAAA,MAEA,iBAAAmJ,UAEA,MAAA7oB,MAAAwlC,gBAAAlmB,GAAAuJ,cAMA6c,WAAA,WAEA,GAAApmB,IAAA,GAAA5V,OAAAgW,QAAA,MAEA,iBAAAmJ,UAEA,MAAA7oB,MAAAwlC,gBAAAlmB,GAAAuJ,cAMA8c,WAAA,WAEA,GAAArmB,IAAA,GAAA5V,OAAAgW,QAAA,MAEA,iBAAAmJ,UAEA,MAAA7oB,MAAAwlC,gBAAAlmB,GAAAuJ,cAMA+c,aAAA,SAAAl2B,QAEA,MAAAA,QAAAsU,aAAAhkB,KAAAglB,cAIA6gB,aAAA,WAEA,GAAArK,IAAA,GAAA9xB,OAAAkb,OAEA,iBAAAlV,QAEA,MAAAA,QAAAsU,aAAAwX,GAAAzW,WAAA/kB,KAAAglB,kBAMA4K,OAAA,WAIA,GAAA4L,IAAA,GAAA9xB,OAAAkb,OAEA,iBAAAlV,QAEA8rB,GAAA5L,OAAAlgB,OAAA1P,KAAAiD,SAAAjD,KAAA+vB,IAEA/vB,KAAAud,WAAAiB,sBAAAgd,QAMA73B,IAAA,SAAAsnB,QAEA,GAAAzpB,UAAAmD,OAAA,GAEA,OAAAD,GAAA,EAAmBA,EAAAlD,UAAAmD,OAAsBD,IAEzC1E,KAAA2D,IAAAnC,UAAAkD,GAIA,OAAA1E,MAIA,MAAAirB,UAAAjrB,MAEA0J,MAAAM,MAAA,kEAAAihB,QACAjrB,OAIAirB,iBAAAvhB,OAAAk6B,UAEAh6B,SAAAqhB,OAAAgZ,QAEAhZ,OAAAgZ,OAAAx9B,OAAAwkB,QAIAA,OAAAgZ,OAAAjkC,KACAirB,OAAA8W,eAA0B37B,KAAA,UAE1BpG,KAAAojC,SAAA9+B,KAAA2mB,SAIAvhB,MAAAM,MAAA,gEAAAihB,QAIAjrB,OAIAyG,OAAA,SAAAwkB,QAEA,GAAAzpB,UAAAmD,OAAA,EAEA,OAAAD,GAAA,EAAmBA,EAAAlD,UAAAmD,OAAsBD,IAEzC1E,KAAAyG,OAAAjF,UAAAkD,GAMA,IAAAgD,OAAA1H,KAAAojC,SAAAjB,QAAAlX,OAEA,MAAAvjB,QAEAujB,OAAAgZ,OAAAr6B,OAEAqhB,OAAA8W,eAA0B37B,KAAA,YAE1BpG,KAAAojC,SAAAf,OAAA36B,MAAA,KAMAo+B,eAAA,SAAA9B,MAGA,MADAt6B,OAAAK,KAAA,6EACA/J,KAAA+lC,gBAAA/B,OAIAgC,cAAA,SAAA5mC,IAEA,MAAAY,MAAAimC,oBAAA,KAAA7mC,KAIA2mC,gBAAA,SAAA/B,MAEA,MAAAhkC,MAAAimC,oBAAA,OAAAjC,OAIAiC,oBAAA,SAAAjC,KAAAzzB,OAEA,GAAAvQ,KAAAgkC,QAAAzzB,MAAA,MAAAvQ,KAEA,QAAA0E,GAAA,EAAAsM,EAAAhR,KAAAojC,SAAAz+B,OAA4CqM,EAAAtM,EAAOA,IAAA,CAEnD,GAAAwhC,OAAAlmC,KAAAojC,SAAA1+B,GACAumB,OAAAib,MAAAD,oBAAAjC,KAAAzzB,MAEA,IAAA3G,SAAAqhB,OAEA,MAAAA,QAMA,MAAArhB,SAIAu8B,iBAAA,SAAA9zB,gBAEA,GAAA5N,QAAA4N,gBAAA,GAAA3I,OAAAgW,OAIA,OAFA1f,MAAAmrB,mBAAA,GAEA1mB,OAAA4hB,sBAAArmB,KAAAglB,cAIAohB,mBAAA,WAEA,GAAAnjC,UAAA,GAAAyG,OAAAgW,QACAiT,MAAA,GAAAjpB,OAAAgW,OAEA,iBAAArN,gBAEA,GAAA5N,QAAA4N,gBAAA,GAAA3I,OAAAqT,UAMA,OAJA/c,MAAAmrB,mBAAA,GAEAnrB,KAAAglB,YAAAyO,UAAAxwB,SAAAwB,OAAAkuB,OAEAluB,WAMA4hC,iBAAA,WAEA,GAAA9oB,YAAA,GAAA7T,OAAAqT,UAEA,iBAAA1K,gBAEA,GAAA5N,QAAA4N,gBAAA,GAAA3I,OAAAgU,KAIA,OAFA1d,MAAAomC,mBAAA7oB,YAEA9Y,OAAAujB,kBAAAzK,WAAAvd,KAAAiE,SAAAka,OAAA,OAMAmoB,cAAA,WAEA,GAAArjC,UAAA,GAAAyG,OAAAgW,QACAnC,WAAA,GAAA7T,OAAAqT,UAEA,iBAAA1K,gBAEA,GAAA5N,QAAA4N,gBAAA,GAAA3I,OAAAgW,OAMA,OAJA1f,MAAAmrB,mBAAA,GAEAnrB,KAAAglB,YAAAyO,UAAAxwB,SAAAsa,WAAA9Y,QAEAA,WAMA8hC,kBAAA,WAEA,GAAAhpB,YAAA,GAAA7T,OAAAqT,UAEA,iBAAA1K,gBAEA,GAAA5N,QAAA4N,gBAAA,GAAA3I,OAAAgW,OAIA,OAFA1f,MAAAomC,mBAAA7oB,YAEA9Y,OAAA0L,IAAA,OAAA2Q,gBAAAvD,gBAMA4lB,QAAA,aAEA/X,SAAA,SAAA5J,UAEAA,SAAAxhB,KAEA,QAAA0E,GAAA,EAAAsM,EAAAhR,KAAAojC,SAAAz+B,OAA4CqM,EAAAtM,EAAOA,IAEnD1E,KAAAojC,SAAA1+B,GAAA0mB,SAAA5J,WAMAglB,gBAAA,SAAAhlB,UAEA,GAAAxhB,KAAA0kC,WAAA,GAEAljB,SAAAxhB,KAEA,QAAA0E,GAAA,EAAAsM,EAAAhR,KAAAojC,SAAAz+B,OAA4CqM,EAAAtM,EAAOA,IAEnD1E,KAAAojC,SAAA1+B,GAAA8hC,gBAAAhlB,YAMAilB,kBAAA,SAAAjlB,UAEAxhB,KAAAikC,SAEAziB,SAAAxhB,KAAAikC,QAEAjkC,KAAAikC,OAAAwC,kBAAAjlB,YAMAklB,aAAA,WAEA1mC,KAAA2kB,OAAA6O,QAAAxzB,KAAAiD,SAAAjD,KAAAud,WAAAvd,KAAA2yB,OAEA3yB,KAAAykC,wBAAA,GAIAtZ,kBAAA,SAAAwb,OAEA3mC,KAAAwkC,oBAAA,GAAAxkC,KAAA0mC,gBAEA1mC,KAAAykC,0BAAA,GAAAkC,SAAA,KAEA/8B,SAAA5J,KAAAikC,OAEAjkC,KAAAglB,YAAAxU,KAAAxQ,KAAA2kB,QAIA3kB,KAAAglB,YAAAH,iBAAA7kB,KAAAikC,OAAAjf,YAAAhlB,KAAA2kB,QAIA3kB,KAAAykC,wBAAA,EAEAkC,OAAA,EAMA,QAAAjiC,GAAA,EAAAsM,EAAAhR,KAAAojC,SAAAz+B,OAA4CqM,EAAAtM,EAAOA,IAEnD1E,KAAAojC,SAAA1+B,GAAAymB,kBAAAwb,QAMAC,OAAA,WAEA,GAAAC,SACAC,UACAC,QAAA,IACA3gC,KAAA,SACA4gC,UAAA,mBAMAC,cAEAC,cAAA,SAAA/jC,UAQA,GANAyG,SAAAi9B,OAAAI,aAEAJ,OAAAI,eAIAr9B,SAAAq9B,WAAA9jC,SAAA64B,MAAA,CAEA,GAAAmL,MAAAhkC,SAAAyjC,eAEAO,MAAAL,SAEAG,WAAA9jC,SAAA64B,MAAAmL,KAEAN,OAAAI,WAAA3iC,KAAA6iC,MAIA,MAAAhkC,UAAA64B,MAMAoL,aAEAC,cAAA,SAAAhkC,UAQA,GANAuG,SAAAi9B,OAAAO,YAEAP,OAAAO,cAIAx9B,SAAAw9B,UAAA/jC,SAAA24B,MAAA,CAEA,GAAAmL,MAAA9jC,SAAAujC,eAEAO,MAAAL,SAEAM,UAAA/jC,SAAA24B,MAAAmL,KAEAN,OAAAO,UAAA9iC,KAAA6iC,MAIA,MAAA9jC,UAAA24B,MAMAsL,YAAA,SAAArc,QAEA,GAAAsc,QAsEA,IApEAA,KAAAvL,KAAA/Q,OAAA+Q,KACAuL,KAAAnhC,KAAA6kB,OAAA7kB,KAEA,KAAA6kB,OAAA+Y,OAAAuD,KAAAvD,KAAA/Y,OAAA+Y,MACA,OAAA17B,KAAAC,UAAA0iB,OAAA8Z,YAAiDwC,KAAAxC,SAAA9Z,OAAA8Z,UACjD9Z,OAAAyZ,WAAA,IAAA6C,KAAA7C,QAAAzZ,OAAAyZ,SAEAzZ,iBAAAvhB,OAAA1G,mBAEAukC,KAAAlT,IAAApJ,OAAAoJ,IACAkT,KAAAzkC,OAAAmoB,OAAAnoB,OACAykC,KAAArT,KAAAjJ,OAAAiJ,KACAqT,KAAApT,IAAAlJ,OAAAkJ,KAEIlJ,iBAAAvhB,OAAA85B,oBAEJ+D,KAAAzT,KAAA7I,OAAA6I,KACAyT,KAAAxT,MAAA9I,OAAA8I,MACAwT,KAAAtT,IAAAhJ,OAAAgJ,IACAsT,KAAAvT,OAAA/I,OAAA+I,OACAuT,KAAArT,KAAAjJ,OAAAiJ,KACAqT,KAAApT,IAAAlJ,OAAAkJ,KAEIlJ,iBAAAvhB,OAAA89B,aAEJD,KAAAhkC,MAAA0nB,OAAA1nB,MAAA0O,SAEIgZ,iBAAAvhB,OAAA+9B,kBAEJF,KAAAhkC,MAAA0nB,OAAA1nB,MAAA0O,SACAs1B,KAAAG,UAAAzc,OAAAyc,WAEIzc,iBAAAvhB,OAAAi+B,YAEJJ,KAAAhkC,MAAA0nB,OAAA1nB,MAAA0O,SACAs1B,KAAAG,UAAAzc,OAAAyc,UACAH,KAAA1e,SAAAoC,OAAApC,SACA0e,KAAAK,MAAA3c,OAAA2c,OAEI3c,iBAAAvhB,OAAAm+B,WAEJN,KAAAhkC,MAAA0nB,OAAA1nB,MAAA0O,SACAs1B,KAAAG,UAAAzc,OAAAyc,UACAH,KAAA1e,SAAAoC,OAAApC,SACA0e,KAAAjpB,MAAA2M,OAAA3M,MACAipB,KAAAO,SAAA7c,OAAA6c,SACAP,KAAAK,MAAA3c,OAAA2c,OAEI3c,iBAAAvhB,OAAAq+B,iBAEJR,KAAAhkC,MAAA0nB,OAAA1nB,MAAA0O,SACAs1B,KAAAS,YAAA/c,OAAA+c,YAAA/1B,UAEIgZ,iBAAAvhB,OAAAhG,MAAAunB,iBAAAvhB,OAAAm5B,MAAA5X,iBAAAvhB,OAAAg5B,YAEJ6E,KAAApkC,SAAA+jC,cAAAjc,OAAA9nB,UACAokC,KAAAlkC,SAAAgkC,cAAApc,OAAA5nB,UAEA4nB,iBAAAvhB,OAAAm5B,OAAA0E,KAAAU,KAAAhd,OAAAgd,OAEIhd,iBAAAvhB,OAAA+4B,SAEJ8E,KAAAlkC,SAAAgkC,cAAApc,OAAA5nB,WAIAkkC,KAAA5iB,OAAAsG,OAAAtG,OAAAlR,UAEAwX,OAAAmY,SAAAz+B,OAAA,GAEA4iC,KAAAnE,WAEA,QAAA1+B,GAAA,EAAoBA,EAAAumB,OAAAmY,SAAAz+B,OAA4BD,IAEhD6iC,KAAAnE,SAAA9+B,KAAAgjC,YAAArc,OAAAmY,SAAA1+B,KAMA,MAAA6iC,MAMA,OAFAV,QAAA5b,OAAAqc,YAAAtnC,MAEA6mC,QAIAlzB,MAAA,SAAAsX,OAAAiY,WA8BA,GA5BAt5B,SAAAqhB,gBAAA,GAAAvhB,OAAAk6B,UACAh6B,SAAAs5B,uBAAA,GAEAjY,OAAA+Y,KAAAhkC,KAAAgkC,KAEA/Y,OAAA8E,GAAAvf,KAAAxQ,KAAA+vB,IAEA9E,OAAAhoB,SAAAuN,KAAAxQ,KAAAiD,UACAgoB,OAAA1N,WAAA/M,KAAAxQ,KAAAud,YACA0N,OAAA0H,MAAAniB,KAAAxQ,KAAA2yB,OAEA1H,OAAAsZ,mBAAAvkC,KAAAukC,mBAEAtZ,OAAAtG,OAAAnU,KAAAxQ,KAAA2kB,QACAsG,OAAAjG,YAAAxU,KAAAxQ,KAAAglB,aAEAiG,OAAAuZ,iBAAAxkC,KAAAwkC,iBACAvZ,OAAAwZ,uBAAAzkC,KAAAykC,uBAEAxZ,OAAAyZ,QAAA1kC,KAAA0kC,QAEAzZ,OAAA0Z,WAAA3kC,KAAA2kC,WACA1Z,OAAA2Z,cAAA5kC,KAAA4kC,cAEA3Z,OAAA4Z,cAAA7kC,KAAA6kC,cAEA5Z,OAAA8Z,SAAAz8B,KAAA4/B,MAAA5/B,KAAAC,UAAAvI,KAAA+kC,WAEA7B,aAAA,EAEA,OAAAx+B,GAAA,EAAmBA,EAAA1E,KAAAojC,SAAAz+B,OAA0BD,IAAA,CAE7C,GAAAwhC,OAAAlmC,KAAAojC,SAAA1+B,EACAumB,QAAAtnB,IAAAuiC,MAAAvyB,SAMA,MAAAsX,UAMAvhB,MAAAk4B,gBAAAthC,UAAAiB,MAAAmI,MAAAk6B,SAAAtjC,WAEAoJ,MAAAq6B,gBAAA,EASAr6B,MAAAy+B,MAAA,SAAA/nB,EAAA9P,EAAA9Q,EAAAsmB,OAAAviB,MAAA6kC,eAEApoC,KAAAogB,IACApgB,KAAAsQ,IACAtQ,KAAAR,IAEAQ,KAAA8lB,wBAAApc,OAAAgW,QAAAoG,OAAA,GAAApc,OAAAgW,QACA1f,KAAAqoC,cAAAviB,iBAAAmW,OAAAnW,UAEA9lB,KAAAuD,sBAAAmG,OAAAuG,MAAA1M,MAAA,GAAAmG,OAAAuG,MACAjQ,KAAAsoC,aAAA/kC,gBAAA04B,OAAA14B,SAEAvD,KAAAuoC,kBAEAvoC,KAAAooC,cAAAx+B,SAAAw+B,4BAAA,GAIA1+B,MAAAy+B,MAAA7nC,WAEAM,YAAA8I,MAAAy+B,MAEAx0B,MAAA,WAEA,GAAA60B,MAAA,GAAA9+B,OAAAy+B,MAAAnoC,KAAAogB,EAAApgB,KAAAsQ,EAAAtQ,KAAAR,EAEAgpC,MAAA1iB,OAAAtV,KAAAxQ,KAAA8lB,QACA0iB,KAAAjlC,MAAAiN,KAAAxQ,KAAAuD,OAEAilC,KAAAJ,cAAApoC,KAAAooC,aAEA,QAAA1jC,GAAA,EAAAklB,GAAA5pB,KAAAqoC,cAAA1jC,OAAkDilB,GAAAllB,EAAQA,IAE1D8jC,KAAAH,cAAA3jC,GAAA1E,KAAAqoC,cAAA3jC,GAAAiP,OAIA,QAAAjP,GAAA,EAAAklB,GAAA5pB,KAAAsoC,aAAA3jC,OAAiDilB,GAAAllB,EAAQA,IAEzD8jC,KAAAF,aAAA5jC,GAAA1E,KAAAsoC,aAAA5jC,GAAAiP,OAIA,QAAAjP,GAAA,EAAAklB,GAAA5pB,KAAAuoC,eAAA5jC,OAAmDilB,GAAAllB,EAAQA,IAE3D8jC,KAAAD,eAAA7jC,GAAA1E,KAAAuoC,eAAA7jC,GAAAiP,OAIA,OAAA60B,QAYA9+B,MAAA++B,MAAA,SAAAroB,EAAA9P,EAAA9Q,EAAA0kB,EAAA4B,OAAAviB,MAAA6kC,eAGA,MADA1+B,OAAAK,KAAA,wEACA,GAAAL,OAAAy+B,MAAA/nB,EAAA9P,EAAA9Q,EAAAsmB,OAAAviB,MAAA6kC,gBAUA1+B,MAAAg/B,gBAAA,SAAAl1B,MAAAiQ,UAEAzjB,KAAAwT,YACAxT,KAAAyjB,kBAEAzjB,KAAA2oC,aAAA,GAIAj/B,MAAAg/B,gBAAApoC,WAEAM,YAAA8I,MAAAg/B,gBAEArrB,GAAA1Y,UAEA,MAAA3E,MAAAwT,MAAA7O,QAIAikC,OAAA,SAAAC,OAAArlB,UAAAslB,QAEAD,QAAA7oC,KAAAyjB,SACAqlB,QAAAtlB,UAAAC,QAEA,QAAA/e,GAAA,EAAAsM,EAAAhR,KAAAyjB,SAAqCzS,EAAAtM,EAAOA,IAE5C1E,KAAAwT,MAAAq1B,OAAAnkC,GAAA8e,UAAAhQ,MAAAs1B,OAAApkC,EAIA,OAAA1E,OAIAmQ,IAAA,SAAAI,MAAAmD,QAMA,MAJA9J,UAAA8J,gBAAA,GAEA1T,KAAAwT,MAAArD,IAAAI,MAAAmD,QAEA1T,MAIA4hB,KAAA,SAAAla,MAAAxD,GAIA,MAFAlE,MAAAwT,MAAA9L,MAAA1H,KAAAyjB,UAAAvf,EAEAlE,MAIA6hB,KAAA,SAAAna,MAAAvD,GAIA,MAFAnE,MAAAwT,MAAA9L,MAAA1H,KAAAyjB,SAAA,GAAAtf,EAEAnE,MAIA0jB,KAAA,SAAAhc,MAAAxE,GAIA,MAFAlD,MAAAwT,MAAA9L,MAAA1H,KAAAyjB,SAAA,GAAAvgB,EAEAlD,MAIA+oC,MAAA,SAAArhC,MAAAxD,EAAAC,GAOA,MALAuD,QAAA1H,KAAAyjB,SAEAzjB,KAAAwT,MAAA9L,OAAAxD,EACAlE,KAAAwT,MAAA9L,MAAA,GAAAvD,EAEAnE,MAIAgpC,OAAA,SAAAthC,MAAAxD,EAAAC,EAAAjB,GAQA,MANAwE,QAAA1H,KAAAyjB,SAEAzjB,KAAAwT,MAAA9L,OAAAxD,EACAlE,KAAAwT,MAAA9L,MAAA,GAAAvD,EACAnE,KAAAwT,MAAA9L,MAAA,GAAAxE,EAEAlD,MAIAipC,QAAA,SAAAvhC,MAAAxD,EAAAC,EAAAjB,EAAA8Z,GASA,MAPAtV,QAAA1H,KAAAyjB,SAEAzjB,KAAAwT,MAAA9L,OAAAxD,EACAlE,KAAAwT,MAAA9L,MAAA,GAAAvD,EACAnE,KAAAwT,MAAA9L,MAAA,GAAAxE,EACAlD,KAAAwT,MAAA9L,MAAA,GAAAsV,EAEAhd,MAIA2T,MAAA,WAEA,UAAAjK,OAAAg/B,gBAAA,GAAA1oC,MAAAwT,MAAA5S,YAAAZ,KAAAwT,OAAAxT,KAAAyjB,YAQA/Z,MAAAw/B,cAAA,SAAA3B,KAAA9jB,UAGA,MADA/Z,OAAAK,KAAA,+FACA,GAAAL,OAAAg/B,gBAAAnB,KAAA9jB,WAIA/Z,MAAAy/B,eAAA,SAAA5B,KAAA9jB,UAGA,MADA/Z,OAAAK,KAAA,gGACA,GAAAL,OAAAg/B,gBAAAnB,KAAA9jB,WAIA/Z,MAAA0/B,sBAAA,SAAA7B,KAAA9jB,UAGA,MADA/Z,OAAAK,KAAA,uGACA,GAAAL,OAAAg/B,gBAAAnB,KAAA9jB,WAKA/Z,MAAA2/B,eAAA,SAAA9B,KAAA9jB,UAGA,MADA/Z,OAAAK,KAAA,gGACA,GAAAL,OAAAg/B,gBAAAnB,KAAA9jB,WAIA/Z,MAAA4/B,gBAAA,SAAA/B,KAAA9jB,UAGA,MADA/Z,OAAAK,KAAA,iGACA,GAAAL,OAAAg/B,gBAAAnB,KAAA9jB,WAIA/Z,MAAA6/B,eAAA,SAAAhC,KAAA9jB,UAGA,MADA/Z,OAAAK,KAAA,gGACA,GAAAL,OAAAg/B,gBAAAnB,KAAA9jB,WAIA/Z,MAAA8/B,gBAAA,SAAAjC,KAAA9jB,UAGA,MADA/Z,OAAAK,KAAA,iGACA,GAAAL,OAAAg/B,gBAAAnB,KAAA9jB,WAIA/Z,MAAA+/B,iBAAA,SAAAlC,KAAA9jB,UAGA,MADA/Z,OAAAK,KAAA,kGACA,GAAAL,OAAAg/B,gBAAAnB,KAAA9jB,WAIA/Z,MAAAggC,iBAAA,SAAAnC,KAAA9jB,UAGA,MADA/Z,OAAAK,KAAA,kGACA,GAAAL,OAAAg/B,gBAAAnB,KAAA9jB,WAWA/Z,MAAAigC,uBAAA,SAAAn2B,MAAAiQ,UAEA/Z,MAAAg/B,gBAAAppC,KAAAU,KAAAwT,MAAAiQ,UAEAzjB,KAAA4pC,aAAqBl2B,OAAA,EAAAm2B,MAAA,KAIrBngC,MAAAigC,uBAAArpC,UAAAujC,OAAAiG,OAAApgC,MAAAg/B,gBAAApoC,WACAoJ,MAAAigC,uBAAArpC,UAAAM,YAAA8I,MAAAigC,uBAEAjgC,MAAAigC,uBAAArpC,UAAAqT,MAAA,WAEA,UAAAjK,OAAAigC,uBAAA,GAAA3pC,MAAAwT,MAAA5S,YAAAZ,KAAAwT,OAAAxT,KAAAyjB,WAWA/Z,MAAA8hB,eAAA,WAEAqY,OAAAC,eAAA9jC,KAAA,MAAqCuQ,MAAA7G,MAAAqgC,oBAErC/pC,KAAAg8B,KAAAtyB,MAAAG,KAAAgyB,eAEA77B,KAAAgkC,KAAA,GACAhkC,KAAAoG,KAAA,iBAEApG,KAAAyrB,cACAzrB,KAAAgqC,kBAEAhqC,KAAAiqC,aACAjqC,KAAAkqC,QAAAlqC,KAAAiqC,UAEAjqC,KAAAmqC,YAAA,KACAnqC,KAAAu6B,eAAA,MAIA7wB,MAAA8hB,eAAAlrB,WAEAM,YAAA8I,MAAA8hB,eAEA4e,aAAA,SAAApG,KAAAxgB,WAEA,MAAAA,qBAAA9Z,OAAAg/B,kBAAA,GAEAh/B,MAAAK,KAAA,+EAEA/J,KAAAyrB,WAAAuY,OAA8BxwB,MAAAhS,UAAA,GAAAiiB,SAAAjiB,UAAA,OAM9BxB,KAAAyrB,WAAAuY,MAAAxgB,eACAxjB,KAAAgqC,eAAAnG,OAAAwG,KAAArqC,KAAAyrB,eAIA6e,aAAA,SAAAtG,MAEA,MAAAhkC,MAAAyrB,WAAAuY,OAIAuG,YAAA,SAAA/hB,MAAAqhB,MAAAW,aAEAxqC,KAAAiqC,UAAA3lC,MAEAkkB,YACAqhB,YACAniC,MAAAkC,SAAA4gC,wBAAA,KAMAtF,YAAA,SAAAvgB,QAEA,GAAA1hB,UAAAjD,KAAAyrB,WAAAxoB,QAEA2G,UAAA3G,WAEA0hB,OAAAgI,oBAAA1pB,SAAAuQ,OACAvQ,SAAA0lC,aAAA,EAIA,IAAA7iB,QAAA9lB,KAAAyrB,WAAA3F,MAEA,IAAAlc,SAAAkc,OAAA,CAEA,GAAA4V,eAAA,GAAAhyB,OAAAoiB,SAAAsB,gBAAAzI,OAEA+W,cAAA/O,oBAAA7G,OAAAtS,OACAsS,OAAA6iB,aAAA,EAIA,OAAA3oC,KAAAmqC,aAEAnqC,KAAAyqC,qBAIA,OAAAzqC,KAAAu6B,gBAEAv6B,KAAAw6B,yBAMA7R,OAAA,WAEA3oB,KAAAyqC,oBAEA,IAAA/2B,QAAA1T,KAAAmqC,YAAAxhB,SAAA7F,QAIA,OAFA9iB,MAAAklC,aAAA,GAAAx7B,OAAAkb,SAAA0N,YAAA5e,SAEAA,QAIAg3B,aAAA,SAAAvnC,SAAAwnC,UAEAA,oBAA0BrC,aAAA5+B,MAAA0B,SAE1B,IAAAmgB,UAAApoB,SAAAooB,SACAqf,MAAAznC,SAAAynC,MACAC,cAAA1nC,SAAA0nC,cACAvC,aAAAqC,SAAArC,aACAwC,gBAAAD,cAAA,GAAAlmC,OAAA,EACAomC,qBAAA,GAAAH,MAAA,GAAAvC,cAAA1jC,OAEA+mB,UAAA,GAAAK,cAAA,EAAA6e,MAAAjmC,OAAA,EACA3E,MAAAoqC,aAAA,cAAA1gC,OAAAg/B,gBAAAhd,UAAA,GAEA,IAAAsf,SAAA,GAAAjf,cAAA,EAAA6e,MAAAjmC,OAAA,EAGA,IAFA3E,KAAAoqC,aAAA,YAAA1gC,OAAAg/B,gBAAAsC,QAAA,IAEA1C,eAAA5+B,MAAA0B,SAAA,CAEA,GAAA6/B,QAAA,GAAAlf,cAAA,EAAA6e,MAAAjmC,OAAA,EACA3E,MAAAoqC,aAAA,WAAA1gC,OAAAg/B,gBAAAuC,OAAA,IAIA,GAAAH,mBAAA,GAEA,GAAAI,KAAA,GAAAnf,cAAA,EAAA6e,MAAAjmC,OAAA,EACA3E,MAAAoqC,aAAA,QAAA1gC,OAAAg/B,gBAAAwC,IAAA,IAIA,OAAAxmC,GAAA,EAAAi8B,GAAA,EAAAwK,GAAA,EAAkCzmC,EAAAkmC,MAAAjmC,OAAkBD,IAAAi8B,IAAA,EAAAwK,IAAA,GAEpD,GAAA3C,MAAAoC,MAAAlmC,GAEA0b,EAAAmL,SAAAid,KAAApoB,GACA9P,EAAAib,SAAAid,KAAAl4B,GACA9Q,EAAA+rB,SAAAid,KAAAhpC,EAcA,IAZAksB,UAAAyf,IAAA/qB,EAAAlc,EACAwnB,UAAAyf,GAAA,GAAA/qB,EAAAjc,EACAunB,UAAAyf,GAAA,GAAA/qB,EAAAld,EAEAwoB,UAAAyf,GAAA,GAAA76B,EAAApM,EACAwnB,UAAAyf,GAAA,GAAA76B,EAAAnM,EACAunB,UAAAyf,GAAA,GAAA76B,EAAApN,EAEAwoB,UAAAyf,GAAA,GAAA3rC,EAAA0E,EACAwnB,UAAAyf,GAAA,GAAA3rC,EAAA2E,EACAunB,UAAAyf,GAAA,GAAA3rC,EAAA0D,EAEA6nC,wBAAA,GAEA,GAAAK,IAAA5C,KAAAH,cAAA,GACAgD,GAAA7C,KAAAH,cAAA,GACAiD,GAAA9C,KAAAH,cAAA,EAEA2C,SAAAG,IAAAC,GAAAlnC,EACA8mC,QAAAG,GAAA,GAAAC,GAAAjnC,EACA6mC,QAAAG,GAAA,GAAAC,GAAAloC,EAEA8nC,QAAAG,GAAA,GAAAE,GAAAnnC,EACA8mC,QAAAG,GAAA,GAAAE,GAAAlnC,EACA6mC,QAAAG,GAAA,GAAAE,GAAAnoC,EAEA8nC,QAAAG,GAAA,GAAAG,GAAApnC,EACA8mC,QAAAG,GAAA,GAAAG,GAAAnnC,EACA6mC,QAAAG,GAAA,GAAAG,GAAApoC,MAEI,CAEJ,GAAA8sB,GAAAwY,KAAA1iB,MAEAklB,SAAAG,IAAAnb,EAAA9rB,EACA8mC,QAAAG,GAAA,GAAAnb,EAAA7rB,EACA6mC,QAAAG,GAAA,GAAAnb,EAAA9sB,EAEA8nC,QAAAG,GAAA,GAAAnb,EAAA9rB,EACA8mC,QAAAG,GAAA,GAAAnb,EAAA7rB,EACA6mC,QAAAG,GAAA,GAAAnb,EAAA9sB,EAEA8nC,QAAAG,GAAA,GAAAnb,EAAA9rB,EACA8mC,QAAAG,GAAA,GAAAnb,EAAA7rB,EACA6mC,QAAAG,GAAA,GAAAnb,EAAA9sB,EAIA,GAAAolC,eAAA5+B,MAAA2B,WAAA,CAEA,GAAAkgC,IAAA/C,KAAAjlC,KAEA0nC,QAAAE,IAAAI,GAAAn7B,EACA66B,OAAAE,GAAA,GAAAI,GAAAl7B,EACA46B,OAAAE,GAAA,GAAAI,GAAAj7B,EAEA26B,OAAAE,GAAA,GAAAI,GAAAn7B,EACA66B,OAAAE,GAAA,GAAAI,GAAAl7B,EACA46B,OAAAE,GAAA,GAAAI,GAAAj7B,EAEA26B,OAAAE,GAAA,GAAAI,GAAAn7B,EACA66B,OAAAE,GAAA,GAAAI,GAAAl7B,EACA46B,OAAAE,GAAA,GAAAI,GAAAj7B,MAEI,IAAAg4B,eAAA5+B,MAAA4B,aAAA,CAEJ,GAAAkgC,KAAAhD,KAAAF,aAAA,GACAmD,IAAAjD,KAAAF,aAAA,GACAoD,IAAAlD,KAAAF,aAAA,EAEA2C,QAAAE,IAAAK,IAAAp7B,EACA66B,OAAAE,GAAA,GAAAK,IAAAn7B,EACA46B,OAAAE,GAAA,GAAAK,IAAAl7B,EAEA26B,OAAAE,GAAA,GAAAM,IAAAr7B,EACA66B,OAAAE,GAAA,GAAAM,IAAAp7B,EACA46B,OAAAE,GAAA,GAAAM,IAAAn7B,EAEA26B,OAAAE,GAAA,GAAAO,IAAAt7B,EACA66B,OAAAE,GAAA,GAAAO,IAAAr7B,EACA46B,OAAAE,GAAA,GAAAO,IAAAp7B,EAIA,GAAAw6B,mBAAA,GAEA,GAAAa,KAAAd,cAAA,GAAAnmC,GAAA,GACAknC,IAAAf,cAAA,GAAAnmC,GAAA,GACAmnC,IAAAhB,cAAA,GAAAnmC,GAAA,EAEAwmC,KAAAvK,IAAAgL,IAAAznC,EACAgnC,IAAAvK,GAAA,GAAAgL,IAAAxnC,EAEA+mC,IAAAvK,GAAA,GAAAiL,IAAA1nC,EACAgnC,IAAAvK,GAAA,GAAAiL,IAAAznC,EAEA+mC,IAAAvK,GAAA,GAAAkL,IAAA3nC,EACAgnC,IAAAvK,GAAA,GAAAkL,IAAA1nC,GAQA,MAFAnE,MAAAw6B,wBAEAx6B,MAIAyqC,mBAAA,WAEA,GAAA/6B,QAAA,GAAAhG,OAAAgW,OAEA,mBAEA,OAAA1f,KAAAmqC,cAEAnqC,KAAAmqC,YAAA,GAAAzgC,OAAAqhB,KAIA,IAAAW,WAAA1rB,KAAAyrB,WAAAxoB,SAAAuQ,KAEA,IAAAkY,UAAA,CAEA,GAAAogB,IAAA9rC,KAAAmqC,WACA2B,IAAAniB,WAEA,QAAAjlB,GAAA,EAAAklB,GAAA8B,UAAA/mB,OAA2CilB,GAAAllB,EAAQA,GAAA,EAEnDgL,OAAAS,IAAAub,UAAAhnB,GAAAgnB,UAAAhnB,EAAA,GAAAgnB,UAAAhnB,EAAA,IACAonC,GAAAjiB,cAAAna,SAMA9F,SAAA8hB,WAAA,IAAAA,UAAA/mB,UAEA3E,KAAAmqC,YAAA74B,IAAAnB,IAAA,OACAnQ,KAAAmqC,YAAA13B,IAAAtC,IAAA,SAIA47B,MAAA/rC,KAAAmqC,YAAA74B,IAAApN,IAAA6nC,MAAA/rC,KAAAmqC,YAAA74B,IAAAnN,IAAA4nC,MAAA/rC,KAAAmqC,YAAA74B,IAAApO,KAEAwG,MAAAM,MAAA,yIAQAwwB,sBAAA,WAEA,GAAAvQ,KAAA,GAAAvgB,OAAAqhB,KACArb,OAAA,GAAAhG,OAAAgW,OAEA,mBAEA,OAAA1f,KAAAu6B,iBAEAv6B,KAAAu6B,eAAA,GAAA7wB,OAAAkiB,OAIA,IAAAF,WAAA1rB,KAAAyrB,WAAAxoB,SAAAuQ,KAEA,IAAAkY,UAAA,CAEAzB,IAAAN,WAIA,QAFAhB,QAAA3oB,KAAAu6B,eAAA5R,OAEAjkB,EAAA,EAAAklB,GAAA8B,UAAA/mB,OAA2CilB,GAAAllB,EAAQA,GAAA,EAEnDgL,OAAAS,IAAAub,UAAAhnB,GAAAgnB,UAAAhnB,EAAA,GAAAgnB,UAAAhnB,EAAA,IACAulB,IAAAJ,cAAAna,OAIAua,KAAAtB,cAOA,QAFA0P,aAAA,EAEA3zB,EAAA,EAAAklB,GAAA8B,UAAA/mB,OAA2CilB,GAAAllB,EAAQA,GAAA,EAEnDgL,OAAAS,IAAAub,UAAAhnB,GAAAgnB,UAAAhnB,EAAA,GAAAgnB,UAAAhnB,EAAA,IACA2zB,YAAAxuB,KAAA4I,IAAA4lB,YAAA1P,OAAA3F,kBAAAtT,QAIA1P,MAAAu6B,eAAA1O,OAAAhiB,KAAAmI,KAAAqmB,aAEA0T,MAAA/rC,KAAAu6B,eAAA1O,SAEAniB,MAAAM,MAAA,qIAUAgiC,mBAAA,aAMAC,qBAAA,WAEA,GAAAxgB,YAAAzrB,KAAAyrB,UAEA,IAAAA,WAAAxoB,SAAA,CAEA,GAAAyoB,WAAAD,WAAAxoB,SAAAuQ,KAEA,IAAA5J,SAAA6hB,WAAA3F,OAEA9lB,KAAAoqC,aAAA,YAAA1gC,OAAAg/B,gBAAA,GAAA3c,cAAAL,UAAA/mB,QAAA,QAQA,QAFAqmC,SAAAvf,WAAA3F,OAAAtS,MAEA9O,EAAA,EAAAklB,GAAAohB,QAAArmC,OAAyCilB,GAAAllB,EAAQA,IAEjDsmC,QAAAtmC,GAAA,CAMA,IAEAwnC,IAAAC,GAAAC,GAFApB,QAAAvf,WAAA3F,OAAAtS,MAIA64B,GAAA,GAAA3iC,OAAAgW,QACA4sB,GAAA,GAAA5iC,OAAAgW,QACA6sB,GAAA,GAAA7iC,OAAAgW,QAEA8sB,GAAA,GAAA9iC,OAAAgW,QACA+sB,GAAA,GAAA/iC,OAAAgW,OAIA,IAAA+L,WAAA/jB,MAMA,OAJAglC,SAAAjhB,WAAA/jB,MAAA8L,MAEA02B,QAAAlqC,KAAAkqC,QAAAvlC,OAAA,EAAA3E,KAAAkqC,UAAgE1hB,MAAA,EAAAqhB,MAAA6C,QAAA/nC,OAAA+C,MAAA,IAEhEpC,EAAA,EAAAqnC,GAAAzC,QAAAvlC,OAAyCgoC,GAAArnC,IAAQA,EAMjD,OAJAkjB,OAAA0hB,QAAA5kC,GAAAkjB,MACAqhB,MAAAK,QAAA5kC,GAAAukC,MACAniC,MAAAwiC,QAAA5kC,GAAAoC,MAEAhD,EAAA8jB,MAAAoB,GAAApB,MAAAqhB,MAA6CjgB,GAAAllB,EAAQA,GAAA,EAErDwnC,GAAA,GAAAxkC,MAAAglC,QAAAhoC,IACAynC,GAAA,GAAAzkC,MAAAglC,QAAAhoC,EAAA,IACA0nC,GAAA,GAAA1kC,MAAAglC,QAAAhoC,EAAA,IAEA2nC,GAAA94B,UAAAmY,UAAAwgB,IACAI,GAAA/4B,UAAAmY,UAAAygB,IACAI,GAAAh5B,UAAAmY,UAAA0gB,IAEAI,GAAAvqB,WAAAsqB,GAAAD,IACAG,GAAAxqB,WAAAoqB,GAAAC,IACAE,GAAArnB,MAAAsnB,IAEAzB,QAAAkB,KAAAM,GAAAtoC,EACA8mC,QAAAkB,GAAA,IAAAM,GAAAroC,EACA6mC,QAAAkB,GAAA,IAAAM,GAAAtpC,EAEA8nC,QAAAmB,KAAAK,GAAAtoC,EACA8mC,QAAAmB,GAAA,IAAAK,GAAAroC,EACA6mC,QAAAmB,GAAA,IAAAK,GAAAtpC,EAEA8nC,QAAAoB,KAAAI,GAAAtoC,EACA8mC,QAAAoB,GAAA,IAAAI,GAAAroC,EACA6mC,QAAAoB,GAAA,IAAAI,GAAAtpC,MAUA,QAAAwB,GAAA,EAAAklB,GAAA8B,UAAA/mB,OAA2CilB,GAAAllB,EAAQA,GAAA,EAEnD2nC,GAAA94B,UAAAmY,UAAAhnB,GACA4nC,GAAA/4B,UAAAmY,UAAAhnB,EAAA,GACA6nC,GAAAh5B,UAAAmY,UAAAhnB,EAAA,GAEA8nC,GAAAvqB,WAAAsqB,GAAAD,IACAG,GAAAxqB,WAAAoqB,GAAAC,IACAE,GAAArnB,MAAAsnB,IAEAzB,QAAAtmC,GAAA8nC,GAAAtoC,EACA8mC,QAAAtmC,EAAA,GAAA8nC,GAAAroC,EACA6mC,QAAAtmC,EAAA,GAAA8nC,GAAAtpC,EAEA8nC,QAAAtmC,EAAA,GAAA8nC,GAAAtoC,EACA8mC,QAAAtmC,EAAA,GAAA8nC,GAAAroC,EACA6mC,QAAAtmC,EAAA,GAAA8nC,GAAAtpC,EAEA8nC,QAAAtmC,EAAA,GAAA8nC,GAAAtoC,EACA8mC,QAAAtmC,EAAA,GAAA8nC,GAAAroC,EACA6mC,QAAAtmC,EAAA,GAAA8nC,GAAAtpC,CAMAlD,MAAA4sC,mBAEAnhB,WAAA3F,OAAA6iB,aAAA,IAMAkE,gBAAA,WAoDA,QAAAC,gBAAA1sB,EAAA9P,EAAA9Q,GAEA0sC,GAAA34B,UAAAmY,UAAA,EAAAtL,GACA+rB,GAAA54B,UAAAmY,UAAA,EAAApb,GACA87B,GAAA74B,UAAAmY,UAAA,EAAAlsB,GAEAutC,IAAAx5B,UAAA23B,IAAA,EAAA9qB,GACA4sB,IAAAz5B,UAAA23B,IAAA,EAAA56B,GACA28B,IAAA15B,UAAA23B,IAAA,EAAA1rC,GAEA0tC,GAAAf,GAAAjoC,EAAAgoC,GAAAhoC,EACAorB,GAAA8c,GAAAloC,EAAAgoC,GAAAhoC,EAEAipC,GAAAhB,GAAAhoC,EAAA+nC,GAAA/nC,EACAorB,GAAA6c,GAAAjoC,EAAA+nC,GAAA/nC,EAEAipC,GAAAjB,GAAAjpC,EAAAgpC,GAAAhpC,EACAssB,GAAA4c,GAAAlpC,EAAAgpC,GAAAhpC,EAEA6a,GAAAivB,IAAA9oC,EAAA6oC,IAAA7oC,EACA+Z,GAAAgvB,IAAA/oC,EAAA6oC,IAAA7oC,EAEAuyB,GAAAuW,IAAA7oC,EAAA4oC,IAAA5oC,EACAw5B,GAAAsP,IAAA9oC,EAAA4oC,IAAA5oC,EAEAiM,EAAA,GAAA2N,GAAA4f,GAAA1f,GAAAwY,IAEA4W,KAAAl9B,KACAwtB,GAAAuP,GAAAzW,GAAAnH,IAAAlf,GACAutB,GAAAwP,GAAA1W,GAAAlH,IAAAnf,GACAutB,GAAAyP,GAAA3W,GAAAjH,IAAApf,GAGAk9B,KAAAn9B,KACA4N,GAAAuR,GAAArR,GAAAivB,IAAA98B,GACA2N,GAAAwR,GAAAtR,GAAAkvB,IAAA/8B,GACA2N,GAAAyR,GAAAvR,GAAAmvB,IAAAh9B,GAGAm9B,KAAAntB,GAAAzc,IAAA0pC,MACAE,KAAAj9B,GAAA3M,IAAA0pC,MACAE,KAAA/tC,GAAAmE,IAAA0pC,MAEAG,KAAAptB,GAAAzc,IAAA2pC,MACAE,KAAAl9B,GAAA3M,IAAA2pC,MACAE,KAAAhuC,GAAAmE,IAAA2pC,MAsCA,QAAAG,cAAAxtB,GAEA+P,EAAAzc,UAAAy3B,QAAA,EAAA/qB,GACAytB,GAAAl9B,KAAAwf,GAEA7e,EAAAo8B,KAAAttB,GAIAiN,IAAA1c,KAAAW,GACA+b,IAAA1sB,IAAAwvB,EAAA7c,eAAA6c,EAAArQ,IAAAxO,KAAA2O,YAIA6tB,KAAA9tB,aAAA6tB,GAAAv8B,GACArI,KAAA6kC,KAAAhuB,IAAA6tB,KAAAvtB,IACAjD,EAAA,EAAAlU,KAAA,KAEA8kC,SAAA,EAAA3tB,GAAAiN,IAAAhpB,EACA0pC,SAAA,EAAA3tB,EAAA,GAAAiN,IAAA/oB,EACAypC,SAAA,EAAA3tB,EAAA,GAAAiN,IAAAhqB,EACA0qC,SAAA,EAAA3tB,EAAA,GAAAjD,EAvJA,GAAApT,SAAA5J,KAAAyrB,WAAA/jB,OACAkC,SAAA5J,KAAAyrB,WAAAxoB,UACA2G,SAAA5J,KAAAyrB,WAAA3F,QACAlc,SAAA5J,KAAAyrB,WAAAoiB,GAGA,WADAnkC,OAAAK,KAAA,wHAKA,IAAA2iC,SAAA1sC,KAAAyrB,WAAA/jB,MAAA8L,MACAkY,UAAA1rB,KAAAyrB,WAAAxoB,SAAAuQ,MACAw3B,QAAAhrC,KAAAyrB,WAAA3F,OAAAtS,MACA03B,IAAAlrC,KAAAyrB,WAAAoiB,GAAAr6B,MAEAs6B,UAAApiB,UAAA/mB,OAAA,CAEAiF,UAAA5J,KAAAyrB,WAAAsiB,SAEA/tC,KAAAoqC,aAAA,aAAA1gC,OAAAg/B,gBAAA,GAAA3c,cAAA,EAAA+hB,WAAA,GAQA,QAJAF,UAAA5tC,KAAAyrB,WAAAsiB,QAAAv6B,MAEA+5B,QAAAC,QAEAhP,EAAA,EAAkBsP,UAAAtP,EAAeA,IAEjC+O,KAAA/O,GAAA,GAAA90B,OAAAgW,QACA8tB,KAAAhP,GAAA,GAAA90B,OAAAgW,OAIA,IAQAwtB,IAAA5d,GAAA6d,GAAA5d,GAAA6d,GAAA5d,GACAzR,GAAAE,GAAAwY,GAAAkH,GAAAvtB,EAqDA1L,EAAAklB,GACAtkB,EAAAqnC,GACAqB,GAAAC,GAAAC,GAhEAhC,GAAA,GAAAxiC,OAAAgW,QACAysB,GAAA,GAAAziC,OAAAgW,QACA0sB,GAAA,GAAA1iC,OAAAgW,QAEAqtB,IAAA,GAAArjC,OAAAiY,QACAqrB,IAAA,GAAAtjC,OAAAiY,QACAsrB,IAAA,GAAAvjC,OAAAiY,QAKA0rB,KAAA,GAAA3jC,OAAAgW,QAAA4tB,KAAA,GAAA5jC,OAAAgW,OAuDA,KAAA1f,KAAAiqC,UAAAtlC,QAEA3E,KAAAuqC,YAAA,EAAAmC,QAAA/nC,OAAA,EAIA,IAAAslC,WAAAjqC,KAAAiqC,SAEA,KAAA3kC,EAAA,EAAAqnC,GAAA1C,UAAAtlC,OAAqCgoC,GAAArnC,IAAQA,EAAA,CAE7C,GAAAkjB,OAAAyhB,UAAA3kC,GAAAkjB,MACAqhB,MAAAI,UAAA3kC,GAAAukC,MACAniC,MAAAuiC,UAAA3kC,GAAAoC,KAEA,KAAAhD,EAAA8jB,MAAAoB,GAAApB,MAAAqhB,MAAuCjgB,GAAAllB,EAAQA,GAAA,EAE/CspC,GAAAtmC,MAAAglC,QAAAhoC,GACAupC,GAAAvmC,MAAAglC,QAAAhoC,EAAA,GACAwpC,GAAAxmC,MAAAglC,QAAAhoC,EAAA,GAEAooC,eAAAkB,GAAAC,GAAAC,IAMA,GAEAlxB,GAAA7L,EAAArI,KAFAokB,IAAA,GAAAxjB,OAAAgW,QAAAiuB,KAAA,GAAAjkC,OAAAgW,QACAsQ,EAAA,GAAAtmB,OAAAgW,QAAAguB,GAAA,GAAAhkC,OAAAgW,OA4BA,KAAApa,EAAA,EAAAqnC,GAAA1C,UAAAtlC,OAAqCgoC,GAAArnC,IAAQA,EAAA,CAE7C,GAAAkjB,OAAAyhB,UAAA3kC,GAAAkjB,MACAqhB,MAAAI,UAAA3kC,GAAAukC,MACAniC,MAAAuiC,UAAA3kC,GAAAoC,KAEA,KAAAhD,EAAA8jB,MAAAoB,GAAApB,MAAAqhB,MAAuCjgB,GAAAllB,EAAQA,GAAA,EAE/CspC,GAAAtmC,MAAAglC,QAAAhoC,GACAupC,GAAAvmC,MAAAglC,QAAAhoC,EAAA,GACAwpC,GAAAxmC,MAAAglC,QAAAhoC,EAAA,GAEA+oC,aAAAO,IACAP,aAAAQ,IACAR,aAAAS,MAcAC,eAAA,SAAApkB,MAEAngB,SAAAmgB,YAAA,MAyBA,QAvBA2iB,SAAA1sC,KAAAyrB,WAAA/jB,MAAA8L,MACA+X,SAAAvrB,KAAAyrB,WAAAxoB,SAAAuQ,MAEA46B,WAAA1B,QAAA/nC,OAAA,EAQA0pC,cAAA,GAAAC,aAAA5B,QAAA/nC,QACA4pC,SAAA,EACAC,UAAA,EAEAtE,UAAmB1hB,MAAA,EAAAqhB,MAAA,EAAAniC,MAAA,IACnBgM,OAAAw2B,QAAA,GAEAuE,mBAAA,EACAC,eAAA,EACAC,aAAA,GAAAC,YAAA,GACAC,UAAA,GAAAD,YAAArjB,SAAA5mB,QACAmqC,aAAA,GAAAF,YAAArjB,SAAA5mB,QACAW,EAAA,EAAkBA,EAAAimB,SAAA5mB,OAAqBW,IAASupC,UAAAvpC,GAAA,GAAsBwpC,aAAAxpC,GAAA,EAMtE,QAAAypC,QAAA,EAAuBX,WAAAW,OAAqBA,SAAA,CAC5CL,eAAA,CAEA,QAAAM,IAAA,EAAoB,EAAAA,GAAQA,KAAA,CAC5B,GAAAC,KAAAvC,QAAA,EAAAqC,OAAAC,GACA,KAAAH,UAAAI,MAEAN,aAAA,EAAAK,IAAAC,IACAN,aAAA,EAAAK,GAAA,MACAN,kBACKG,UAAAI,KAAAv7B,OAAAhM,OAELinC,aAAA,EAAAK,IAAAC,IACAN,aAAA,EAAAK,GAAA,MACAP,uBAGAE,aAAA,EAAAK,IAAAC,IACAN,aAAA,EAAAK,GAAA,GAAAH,UAAAI,MAIA,GAAAC,SAAAV,UAAAE,cACA,IAAAQ,QAAAx7B,OAAAhM,MAAAqiB,KAAA,CACA,GAAAolB,aAAsB3mB,MAAA+lB,SAAA1E,MAAA,EAAAniC,MAAA8mC,UACtBtE,SAAA5lC,KAAA6qC,YACAz7B,OAAAy7B,UAGA,QAAAlvB,GAAA,EAAoB,EAAAA,EAAOA,GAAA,GAC3B,GAAAmvB,SAAAT,aAAA1uB,EAAA,EACAmvB,SAAA,IAAAA,QAAA17B,OAAAhM,QACAinC,aAAA1uB,EAAA,QAKA,OAAAA,GAAA,EAAmB,EAAAA,EAAOA,GAAA,GAC1B,GAAAgvB,KAAAN,aAAA1uB,GACAmvB,QAAAT,aAAA1uB,EAAA,EAEA,MAAAmvB,UACAA,QAAAZ,aAEAK,UAAAI,KAAAG,QACAN,aAAAM,SAAAH,IACAZ,cAAAE,YAAAa,QAAA17B,OAAAhM,MACAgM,OAAAm2B,SAiBA,MAZA7pC,MAAAqvC,eAAAhB,cAAAS,aAAAN,WACAxuC,KAAAkqC,gBACAlqC,KAAAiqC,UAAAC,QAUAA,SAIAoF,MAAA,SAAAnsC,SAAAuQ,QAEA,GAAAvQ,mBAAAuG,OAAA8hB,iBAAA,EAGA,WADA9hB,OAAAM,MAAA,kFAAA7G,SAKAyG,UAAA8J,gBAAA,EAEA,IAAA+X,YAAAzrB,KAAAyrB,UAEA,QAAAtqB,OAAAsqB,YAEA,GAAA7hB,SAAAzG,SAAAsoB,WAAAtqB,KAUA,OARAouC,YAAA9jB,WAAAtqB,KACAquC,gBAAAD,WAAA/7B,MAEAi8B,WAAAtsC,SAAAsoB,WAAAtqB,KACAuuC,gBAAAD,WAAAj8B,MAEAm8B,cAAAF,WAAAhsB,SAEA/e,EAAA,EAAAY,EAAAqqC,cAAAj8B,OAA+ChP,EAAAgrC,gBAAA/qC,OAA4BD,IAAAY,IAE3EkqC,gBAAAlqC,GAAAoqC,gBAAAhrC,EAMA,OAAA1E,OAIA4sC,iBAAA,WAMA,OAFA1oC,GAAAC,EAAAjB,EAAA8sB,EAFAgb,QAAAhrC,KAAAyrB,WAAA3F,OAAAtS,MAIA9O,EAAA,EAAAklB,GAAAohB,QAAArmC,OAAuCilB,GAAAllB,EAAQA,GAAA,EAE/CR,EAAA8mC,QAAAtmC,GACAP,EAAA6mC,QAAAtmC,EAAA,GACAxB,EAAA8nC,QAAAtmC,EAAA,GAEAsrB,EAAA,EAAAnmB,KAAAmI,KAAA9N,IAAAC,IAAAjB,KAEA8nC,QAAAtmC,IAAAsrB,EACAgb,QAAAtmC,EAAA,IAAAsrB,EACAgb,QAAAtmC,EAAA,IAAAsrB,GAaAqf,eAAA,SAAAO,YAAAC,SAAAC,aAGA,GAAAC,oBACA,QAAAC,QAAAhwC,MAAAyrB,WACA,YAAAukB,KAAA,CAEA,GAAAC,aAAAjwC,KAAAyrB,WAAAukB,MAAAx8B,KACAu8B,kBAAAC,MAAA,GAAAC,aAAArvC,YAAAZ,KAAAyrB,WAAAukB,MAAAvsB,SAAAqsB,aAIA,OAAAV,SAAA,EAAwBU,YAAAV,QAAuBA,UAAA,CAC/C,GAAAH,KAAAY,SAAAT,QACA,QAAAY,QAAAhwC,MAAAyrB,WACA,YAAAukB,KAKA,OAHAE,WAAAlwC,KAAAyrB,WAAAukB,MAAAx8B,MACA28B,SAAAnwC,KAAAyrB,WAAAukB,MAAAvsB,SACA2sB,WAAAL,iBAAAC,MACAxR,EAAA,EAAoB2R,SAAA3R,EAAcA,IAClC4R,WAAAhB,QAAAe,SAAA3R,GAAA0R,UAAAjB,IAAAkB,SAAA3R,GAKAx+B,KAAAyrB,WAAA,MAAAjY,MAAAo8B,WACA,QAAAI,QAAAhwC,MAAAyrB,WACA,SAAAukB,OAEAhwC,KAAAyrB,WAAAukB,MAAAx8B,MAAAu8B,iBAAAC,MACAhwC,KAAAyrB,WAAAukB,MAAAK,SAAArwC,KAAAyrB,WAAAukB,MAAAvsB,SAAAqsB,cAIAlJ,OAAA,WAEA,GAAAC,SACAC,UACAC,QAAA,EACA3gC,KAAA,iBACA4gC,UAAA,0BAEAhL,KAAAh8B,KAAAg8B,KACA51B,KAAApG,KAAAoG,KACAmhC,MACA9b,gBAIAA,WAAAzrB,KAAAyrB,WACAye,QAAAlqC,KAAAkqC,QACA3P,eAAAv6B,KAAAu6B,cAEA,QAAAp5B,OAAAsqB,YAAA,CAEA,GAAAjI,WAAAiI,WAAAtqB,KAEAqS,MAAAyoB,MAAA37B,UAAA6R,MAAA7S,KAAAkkB,UAAAhQ,MAEAqzB,QAAAU,KAAA9b,WAAAtqB,MACAsiB,SAAAD,UAAAC,SACArd,KAAAod,UAAAhQ,MAAA5S,YAAAojC,KACAxwB,aAoBA,MAfA02B,SAAAvlC,OAAA,IAEAkiC,OAAAU,KAAA2C,QAAA5hC,KAAA4/B,MAAA5/B,KAAAC,UAAA2hC,WAIA,OAAA3P,iBAEAsM,OAAAU,KAAAhN,gBACA5R,OAAA4R,eAAA5R,OAAAlV,UACAoY,OAAA0O,eAAA1O,SAKAgb,QAIAlzB,MAAA,WAEA,GAAAxQ,UAAA,GAAAuG,OAAA8hB,cAEA,QAAAwkB,QAAAhwC,MAAAyrB,WAAA,CAEA,GAAA6kB,YAAAtwC,KAAAyrB,WAAAukB,KACA7sC,UAAAinC,aAAA4F,KAAAM,WAAA38B,SAIA,OAAAjP,GAAA,EAAAklB,GAAA5pB,KAAAkqC,QAAAvlC,OAA4CilB,GAAAllB,EAAQA,IAAA,CAEpD,GAAAgP,QAAA1T,KAAAkqC,QAAAxlC,EAEAvB,UAAA+mC,QAAA5lC,MAEAkkB,MAAA9U,OAAA8U,MACA9gB,MAAAgM,OAAAhM,MACAmiC,MAAAn2B,OAAAm2B,QAMA,MAAA1mC,WAIAotC,QAAA,WAEAvwC,KAAA+hC,eAAuB37B,KAAA,cAMvBsD,MAAAk4B,gBAAAthC,UAAAiB,MAAAmI,MAAA8hB,eAAAlrB,WAaAoJ,MAAA4hB,SAAA,WAEAuY,OAAAC,eAAA9jC,KAAA,MAAqCuQ,MAAA7G,MAAAqgC,oBAErC/pC,KAAAg8B,KAAAtyB,MAAAG,KAAAgyB,eAEA77B,KAAAgkC,KAAA,GACAhkC,KAAAoG,KAAA,WAEApG,KAAAurB,YACAvrB,KAAAirC,UAEAjrC,KAAA4qC,SAEA5qC,KAAA6qC,mBAEA7qC,KAAAwwC,gBACAxwC,KAAAywC,eACAzwC,KAAA0wC,gBAEA1wC,KAAA2wC,eACA3wC,KAAA4wC,eAEA5wC,KAAA6wC,iBAEA7wC,KAAAmqC,YAAA,KACAnqC,KAAAu6B,eAAA,KAEAv6B,KAAA8wC,aAAA,EAEA9wC,KAAA+wC,SAAA,EAIA/wC,KAAAgxC,oBAAA,EACAhxC,KAAAixC,oBAAA,EACAjxC,KAAAkxC,eAAA,EACAlxC,KAAAmxC,mBAAA,EACAnxC,KAAAoxC,oBAAA,EACApxC,KAAAqxC,kBAAA,EACArxC,KAAAsxC,yBAAA,EAEAtxC,KAAAuxC,kBAAA,GAIA7nC,MAAA4hB,SAAAhrB,WAEAM,YAAA8I,MAAA4hB,SAEA4Z,YAAA,SAAAvgB,QAIA,OAFA+W,eAAA,GAAAhyB,OAAAoiB,SAAAsB,gBAAAzI,QAEAjgB,EAAA,EAAAklB,GAAA5pB,KAAAurB,SAAA5mB,OAA6CilB,GAAAllB,EAAQA,IAAA,CAErD,GAAA8sC,QAAAxxC,KAAAurB,SAAA7mB,EACA8sC,QAAAxtB,aAAAW,QAIA,OAAAjgB,GAAA,EAAAklB,GAAA5pB,KAAA4qC,MAAAjmC,OAA0CilB,GAAAllB,EAAQA,IAAA,CAElD,GAAA8jC,MAAAxoC,KAAA4qC,MAAAlmC;AACA8jC,KAAA1iB,OAAAhC,aAAA4X,cAAA5b,WAEA,QAAAxa,GAAA,EAAAqnC,GAAAnE,KAAAH,cAAA1jC,OAAmDgoC,GAAArnC,EAAQA,IAE3DkjC,KAAAH,cAAA/iC,GAAAwe,aAAA4X,cAAA5b,YAMA,OAAA9f,KAAAmqC,aAEAnqC,KAAAyqC,qBAIA,OAAAzqC,KAAAu6B,gBAEAv6B,KAAAw6B,wBAIAx6B,KAAAgxC,oBAAA,EACAhxC,KAAAmxC,mBAAA,GAIAM,mBAAA,SAAAtuC,UAeA,OAbA+nB,OAAAlrB,KAEAyrB,WAAAtoB,SAAAsoB,WAEAF,SAAAE,WAAAxoB,SAAAuQ,MACAk5B,QAAA9iC,SAAA6hB,WAAA/jB,MAAA+jB,WAAA/jB,MAAA8L,MAAA5J,OACAohC,QAAAphC,SAAA6hB,WAAA3F,OAAA2F,WAAA3F,OAAAtS,MAAA5J,OACAqhC,OAAArhC,SAAA6hB,WAAAloB,MAAAkoB,WAAAloB,MAAAiQ,MAAA5J,OACAshC,IAAAthC,SAAA6hB,WAAAoiB,GAAApiB,WAAAoiB,GAAAr6B,MAAA5J,OAEA8nC,eACAC,WAEAjtC,EAAA,EAAAY,EAAA,EAAyBZ,EAAA6mB,SAAA5mB,OAAqBD,GAAA,EAAAY,GAAA,EAE9C4lB,MAAAK,SAAAjnB,KAAA,GAAAoF,OAAAgW,QAAA6L,SAAA7mB,GAAA6mB,SAAA7mB,EAAA,GAAA6mB,SAAA7mB,EAAA,KAEAkF,SAAAohC,SAEA0G,YAAAptC,KAAA,GAAAoF,OAAAgW,QAAAsrB,QAAAtmC,GAAAsmC,QAAAtmC,EAAA,GAAAsmC,QAAAtmC,EAAA,KAIAkF,SAAAqhC,QAEA/f,MAAA+f,OAAA3mC,KAAA,GAAAoF,OAAAuG,MAAAg7B,OAAAvmC,GAAAumC,OAAAvmC,EAAA,GAAAumC,OAAAvmC,EAAA,KAIAkF,SAAAshC,KAEAyG,QAAArtC,KAAA,GAAAoF,OAAAiY,QAAAupB,IAAA5lC,GAAA4lC,IAAA5lC,EAAA,IAMA,IAAAssC,SAAA,SAAAxxB,EAAA9P,EAAA9Q,GAEA,GAAA6oC,eAAAz+B,SAAAohC,SAAA0G,YAAAtxB,GAAAzM,QAAA+9B,YAAAphC,GAAAqD,QAAA+9B,YAAAlyC,GAAAmU,YACA20B,aAAA1+B,SAAAqhC,QAAA/f,MAAA+f,OAAA7qB,GAAAzM,QAAAuX,MAAA+f,OAAA36B,GAAAqD,QAAAuX,MAAA+f,OAAAzrC,GAAAmU,WAEAuX,OAAA0f,MAAAtmC,KAAA,GAAAoF,OAAAy+B,MAAA/nB,EAAA9P,EAAA9Q,EAAA6oC,cAAAC,eAEA1+B,SAAAshC,KAEAhgB,MAAA2f,cAAA,GAAAvmC,MAAAqtC,QAAAvxB,GAAAzM,QAAAg+B,QAAArhC,GAAAqD,QAAAg+B,QAAAnyC,GAAAmU,UAMA,IAAA/J,SAAA8iC,QAAA,CAEA,GAAAzC,WAAA9mC,SAAA8mC,SAEA,IAAAA,UAAAtlC,OAAA,EAEA,OAAAD,GAAA,EAAoBA,EAAAulC,UAAAtlC,OAAsBD,IAQ1C,OANAmtC,UAAA5H,UAAAvlC,GAEA8jB,MAAAqpB,SAAArpB,MACAqhB,MAAAgI,SAAAhI,MACAniC,MAAAmqC,SAAAnqC,MAEApC,EAAAkjB,MAAAmkB,GAAAnkB,MAAAqhB,MAA6C8C,GAAArnC,EAAQA,GAAA,EAErDssC,QAAAlqC,MAAAglC,QAAApnC,GAAAoC,MAAAglC,QAAApnC,EAAA,GAAAoC,MAAAglC,QAAApnC,EAAA,QAQA,QAAAZ,GAAA,EAAoBA,EAAAgoC,QAAA/nC,OAAoBD,GAAA,EAExCktC,QAAAlF,QAAAhoC,GAAAgoC,QAAAhoC,EAAA,GAAAgoC,QAAAhoC,EAAA,QAQA,QAAAA,GAAA,EAAmBA,EAAA6mB,SAAA5mB,OAAA,EAAyBD,GAAA,EAE5CktC,QAAAltC,IAAA,EAAAA,EAAA,EAoBA,OAdA1E,MAAAgsC,qBAEA,OAAA7oC,SAAAgnC,cAEAnqC,KAAAmqC,YAAAhnC,SAAAgnC,YAAAx2B,SAIA,OAAAxQ,SAAAo3B,iBAEAv6B,KAAAu6B,eAAAp3B,SAAAo3B,eAAA5mB,SAIA3T,MAIA2oB,OAAA,WAEA3oB,KAAAyqC,oBAEA,IAAA/2B,QAAA1T,KAAAmqC,YAAAxhB,SAAA7F,QAIA,OAFA9iB,MAAAklC,aAAA,GAAAx7B,OAAAkb,SAAA0N,YAAA5e,SAEAA,QAIAs4B,mBAAA,WAIA,OAFAQ,IAAA,GAAA9iC,OAAAgW,QAAA+sB,GAAA,GAAA/iC,OAAAgW,QAEAmN,EAAA,EAAAilB,GAAA9xC,KAAA4qC,MAAAjmC,OAA0CmtC,GAAAjlB,EAAQA,IAAA,CAElD,GAAA2b,MAAAxoC,KAAA4qC,MAAA/d,GAEAqf,GAAAlsC,KAAAurB,SAAAid,KAAApoB,GACA+rB,GAAAnsC,KAAAurB,SAAAid,KAAAl4B,GACA87B,GAAApsC,KAAAurB,SAAAid,KAAAhpC,EAEAgtC,IAAAvqB,WAAAmqB,GAAAD,IACAM,GAAAxqB,WAAAiqB,GAAAC,IACAK,GAAArnB,MAAAsnB,IAEAD,GAAA1sB,YAEA0oB,KAAA1iB,OAAAtV,KAAAg8B,MAMAP,qBAAA,SAAA8F,cAEA,GAAA9xB,GAAA+xB,GAAAnlB,EAAAilB,GAAAtJ,KAAAjd,QAIA,KAFAA,SAAA,GAAA0Q,OAAAj8B,KAAAurB,SAAA5mB,QAEAsb,EAAA,EAAA+xB,GAAAhyC,KAAAurB,SAAA5mB,OAAyCqtC,GAAA/xB,EAAQA,IAEjDsL,SAAAtL,GAAA,GAAAvW,OAAAgW,OAIA,IAAAqyB,aAAA,CAKA,GAAA7F,IAAAC,GAAAC,GACAI,GAAA,GAAA9iC,OAAAgW,QAAA+sB,GAAA,GAAA/iC,OAAAgW,OAEA,KAAAmN,EAAA,EAAAilB,GAAA9xC,KAAA4qC,MAAAjmC,OAAuCmtC,GAAAjlB,EAAQA,IAE/C2b,KAAAxoC,KAAA4qC,MAAA/d,GAEAqf,GAAAlsC,KAAAurB,SAAAid,KAAApoB,GACA+rB,GAAAnsC,KAAAurB,SAAAid,KAAAl4B,GACA87B,GAAApsC,KAAAurB,SAAAid,KAAAhpC,GAEAgtC,GAAAvqB,WAAAmqB,GAAAD,IACAM,GAAAxqB,WAAAiqB,GAAAC,IACAK,GAAArnB,MAAAsnB,IAEAlhB,SAAAid,KAAApoB,GAAAzc,IAAA6oC,IACAjhB,SAAAid,KAAAl4B,GAAA3M,IAAA6oC,IACAjhB,SAAAid,KAAAhpC,GAAAmE,IAAA6oC,QAMA,KAAA3f,EAAA,EAAAilB,GAAA9xC,KAAA4qC,MAAAjmC,OAAuCmtC,GAAAjlB,EAAQA,IAE/C2b,KAAAxoC,KAAA4qC,MAAA/d,GAEAtB,SAAAid,KAAApoB,GAAAzc,IAAA6kC,KAAA1iB,QACAyF,SAAAid,KAAAl4B,GAAA3M,IAAA6kC,KAAA1iB,QACAyF,SAAAid,KAAAhpC,GAAAmE,IAAA6kC,KAAA1iB,OAMA,KAAA7F,EAAA,EAAA+xB,GAAAhyC,KAAAurB,SAAA5mB,OAAyCqtC,GAAA/xB,EAAQA,IAEjDsL,SAAAtL,GAAAH,WAIA,KAAA+M,EAAA,EAAAilB,GAAA9xC,KAAA4qC,MAAAjmC,OAAsCmtC,GAAAjlB,EAAQA,IAE9C2b,KAAAxoC,KAAA4qC,MAAA/d,GAEA2b,KAAAH,cAAA,GAAA9c,SAAAid,KAAApoB,GAAAzM,QACA60B,KAAAH,cAAA,GAAA9c,SAAAid,KAAAl4B,GAAAqD,QACA60B,KAAAH,cAAA,GAAA9c,SAAAid,KAAAhpC,GAAAmU,SAMAs+B,oBAAA,WAEA,GAAAvtC,GAAAklB,GAAAiD,EAAAilB,GAAAtJ,IAMA,KAAA3b,EAAA,EAAAilB,GAAA9xC,KAAA4qC,MAAAjmC,OAAsCmtC,GAAAjlB,EAAQA,IAgB9C,IAdA2b,KAAAxoC,KAAA4qC,MAAA/d,GAEA2b,KAAA0J,qBAMA1J,KAAA0J,qBAAA1hC,KAAAg4B,KAAA1iB,QAJA0iB,KAAA0J,qBAAA1J,KAAA1iB,OAAAnS,QAQA60B,KAAA2J,0BAAA3J,KAAA2J,4BAEAztC,EAAA,EAAAklB,GAAA4e,KAAAH,cAAA1jC,OAA+CilB,GAAAllB,EAAQA,IAEvD8jC,KAAA2J,wBAAAztC,GAMA8jC,KAAA2J,wBAAAztC,GAAA8L,KAAAg4B,KAAAH,cAAA3jC,IAJA8jC,KAAA2J,wBAAAztC,GAAA8jC,KAAAH,cAAA3jC,GAAAiP,OAcA,IAAAy+B,QAAA,GAAA1oC,OAAA4hB,QAGA,KAFA8mB,OAAAxH,MAAA5qC,KAAA4qC,MAEAlmC,EAAA,EAAAklB,GAAA5pB,KAAAwwC,aAAA7rC,OAA6CilB,GAAAllB,EAAQA,IAAA,CAIrD,IAAA1E,KAAA0wC,aAAAhsC,GAAA,CAEA1E,KAAA0wC,aAAAhsC,MACA1E,KAAA0wC,aAAAhsC,GAAA2tC,eACAryC,KAAA0wC,aAAAhsC,GAAA2jC,gBAEA,IAGAiK,YAAAjK,cAHAkK,eAAAvyC,KAAA0wC,aAAAhsC,GAAA2tC,YACAG,iBAAAxyC,KAAA0wC,aAAAhsC,GAAA2jC,aAIA,KAAAxb,EAAA,EAAAilB,GAAA9xC,KAAA4qC,MAAAjmC,OAAwCmtC,GAAAjlB,EAAQA,IAEhDylB,WAAA,GAAA5oC,OAAAgW,QACA2oB,eAAsBjoB,EAAA,GAAA1W,OAAAgW,QAAApP,EAAA,GAAA5G,OAAAgW,QAAAlgB,EAAA,GAAAkK,OAAAgW,SAEtB6yB,eAAAjuC,KAAAguC,YACAE,iBAAAluC,KAAA+jC,eAMA,GAAAqI,cAAA1wC,KAAA0wC,aAAAhsC,EAIA0tC,QAAA7mB,SAAAvrB,KAAAwwC,aAAA9rC,GAAA6mB,SAIA6mB,OAAApG,qBACAoG,OAAAnG,sBAIA,IAAAqG,YAAAjK,aAEA,KAAAxb,EAAA,EAAAilB,GAAA9xC,KAAA4qC,MAAAjmC,OAAuCmtC,GAAAjlB,EAAQA,IAE/C2b,KAAAxoC,KAAA4qC,MAAA/d,GAEAylB,WAAA5B,aAAA2B,YAAAxlB,GACAwb,cAAAqI,aAAArI,cAAAxb,GAEAylB,WAAA9hC,KAAAg4B,KAAA1iB,QAEAuiB,cAAAjoB,EAAA5P,KAAAg4B,KAAAH,cAAA,IACAA,cAAA/3B,EAAAE,KAAAg4B,KAAAH,cAAA,IACAA,cAAA7oC,EAAAgR,KAAAg4B,KAAAH,cAAA,IAQA,IAAAxb,EAAA,EAAAilB,GAAA9xC,KAAA4qC,MAAAjmC,OAAsCmtC,GAAAjlB,EAAQA,IAE9C2b,KAAAxoC,KAAA4qC,MAAA/d,GAEA2b,KAAA1iB,OAAA0iB,KAAA0J,qBACA1J,KAAAH,cAAAG,KAAA2J,yBAMAtF,gBAAA,WAqBA,QAAAC,gBAAA2F,QAAAryB,EAAA9P,EAAA9Q,EAAAkzC,GAAAC,GAAAC,IAEA1G,GAAAuG,QAAAlnB,SAAAnL,GACA+rB,GAAAsG,QAAAlnB,SAAAjb,GACA87B,GAAAqG,QAAAlnB,SAAA/rB,GAEAutC,IAAAc,GAAA6E,IACA1F,IAAAa,GAAA8E,IACA1F,IAAAY,GAAA+E,IAEA1F,GAAAf,GAAAjoC,EAAAgoC,GAAAhoC,EACAorB,GAAA8c,GAAAloC,EAAAgoC,GAAAhoC,EACAipC,GAAAhB,GAAAhoC,EAAA+nC,GAAA/nC,EACAorB,GAAA6c,GAAAjoC,EAAA+nC,GAAA/nC,EACAipC,GAAAjB,GAAAjpC,EAAAgpC,GAAAhpC,EACAssB,GAAA4c,GAAAlpC,EAAAgpC,GAAAhpC,EAEA6a,GAAAivB,IAAA9oC,EAAA6oC,IAAA7oC,EACA+Z,GAAAgvB,IAAA/oC,EAAA6oC,IAAA7oC,EACAuyB,GAAAuW,IAAA7oC,EAAA4oC,IAAA5oC,EACAw5B,GAAAsP,IAAA9oC,EAAA4oC,IAAA5oC,EAEAiM,EAAA,GAAA2N,GAAA4f,GAAA1f,GAAAwY,IACA4W,KAAAl9B,KAAAwtB,GAAAuP,GAAAzW,GAAAnH,IAAAlf,GACAutB,GAAAwP,GAAA1W,GAAAlH,IAAAnf,GACAutB,GAAAyP,GAAA3W,GAAAjH,IAAApf,GACAk9B,KAAAn9B,KAAA4N,GAAAuR,GAAArR,GAAAivB,IAAA98B,GACA2N,GAAAwR,GAAAtR,GAAAkvB,IAAA/8B,GACA2N,GAAAyR,GAAAvR,GAAAmvB,IAAAh9B,GAEAm9B,KAAAntB,GAAAzc,IAAA0pC,MACAE,KAAAj9B,GAAA3M,IAAA0pC,MACAE,KAAA/tC,GAAAmE,IAAA0pC,MAEAG,KAAAptB,GAAAzc,IAAA2pC,MACAE,KAAAl9B,GAAA3M,IAAA2pC,MACAE,KAAAhuC,GAAAmE,IAAA2pC,MApDA,GAAAzgB,GAAAilB,GAAA7xB,EAAA+xB,GAAAttC,EAAAmuC,YACArK,KAAAqF,GAAA3B,GAAAC,GAAAC,GAAAW,IAAAC,IAAAC,IACAC,GAAA5d,GAAA6d,GAAA5d,GAAA6d,GAAA5d,GACAzR,GAAAE,GAAAwY,GAAAkH,GAAAvtB,EAAAe,EAAArI,KAIAkU,EAHAuwB,QAAAC,QACAH,KAAA,GAAA3jC,OAAAgW,QAAA4tB,KAAA,GAAA5jC,OAAAgW,QACAwN,IAAA,GAAAxjB,OAAAgW,QAAAiuB,KAAA,GAAAjkC,OAAAgW,QACAsQ,EAAA,GAAAtmB,OAAAgW,OAEA,KAAAO,EAAA,EAAA+xB,GAAAhyC,KAAAurB,SAAA5mB,OAAyCqtC,GAAA/xB,EAAQA,IAEjDstB,KAAAttB,GAAA,GAAAvW,OAAAgW,QACA8tB,KAAAvtB,GAAA,GAAAvW,OAAAgW,OA4CA,KAAAmN,EAAA,EAAAilB,GAAA9xC,KAAA4qC,MAAAjmC,OAAsCmtC,GAAAjlB,EAAQA,IAE9C2b,KAAAxoC,KAAA4qC,MAAA/d,GACAghB,GAAA7tC,KAAA6qC,cAAA,GAAAhe,GAEAigB,eAAA9sC,KAAAwoC,KAAApoB,EAAAooB,KAAAl4B,EAAAk4B,KAAAhpC,EAAA,MAIA,IAAAszC,YAAA,gBAEA,KAAAjmB,EAAA,EAAAilB,GAAA9xC,KAAA4qC,MAAAjmC,OAAsCmtC,GAAAjlB,EAAQA,IAI9C,IAFA2b,KAAAxoC,KAAA4qC,MAAA/d,GAEAnoB,EAAA,EAAeA,EAAAmF,KAAAyH,IAAAk3B,KAAAH,cAAA1jC,OAAA,GAA8CD,IAE7DsrB,EAAAxf,KAAAg4B,KAAAH,cAAA3jC,IAEAmuC,YAAArK,KAAAsK,UAAApuC,IAEAyM,EAAAo8B,KAAAsF,aAIA3lB,IAAA1c,KAAAW,GACA+b,IAAA1sB,IAAAwvB,EAAA7c,eAAA6c,EAAArQ,IAAAxO,KAAA2O,YAIA6tB,KAAA9tB,aAAA2oB,KAAAH,cAAA3jC,GAAAyM,GACArI,KAAA6kC,KAAAhuB,IAAA6tB,KAAAqF,cACA71B,EAAA,EAAAlU,KAAA,KAEA0/B,KAAAD,eAAA7jC,GAAA,GAAAgF,OAAAod,QAAAoG,IAAAhpB,EAAAgpB,IAAA/oB,EAAA+oB,IAAAhqB,EAAA8Z,EAMAhd,MAAA8wC,aAAA,GAIAiC,qBAAA,WAKA,OAHA7uB,GAAA,EACAqH,SAAAvrB,KAAAurB,SAEA7mB,EAAA,EAAAklB,GAAA2B,SAAA5mB,OAAwCilB,GAAAllB,EAAQA,IAEhDA,EAAA,IAEAwf,GAAAqH,SAAA7mB,GAAAqe,WAAAwI,SAAA7mB,EAAA,KAIA1E,KAAA6wC,cAAAnsC,GAAAwf,GAMAumB,mBAAA,WAEA,OAAAzqC,KAAAmqC,cAEAnqC,KAAAmqC,YAAA,GAAAzgC,OAAAqhB,MAIA/qB,KAAAmqC,YAAA1gB,cAAAzpB,KAAAurB,WAIAiP,sBAAA,WAEA,OAAAx6B,KAAAu6B,iBAEAv6B,KAAAu6B,eAAA,GAAA7wB,OAAAkiB,QAIA5rB,KAAAu6B,eAAA9Q,cAAAzpB,KAAAurB,WAIA+jB,MAAA,SAAAnsC,SAAAwhB,OAAAquB,qBAEA,GAAA7vC,mBAAAuG,OAAA4hB,WAAA,EAGA,WADA5hB,OAAAM,MAAA,sEAAA7G,SAKA,IAAAu4B,cACAuX,aAAAjzC,KAAAurB,SAAA5mB,OACAuuC,UAAAlzC,KAAAurB,SACA4nB,UAAAhwC,SAAAooB,SACA6nB,OAAApzC,KAAA4qC,MACAyI,OAAAlwC,SAAAynC,MACA0I,KAAAtzC,KAAA6qC,cAAA,GACA0I,KAAApwC,SAAA0nC,cAAA,EAEAjhC,UAAAopC,0CAAA,GAEAppC,SAAA+a,SAEA+W,cAAA,GAAAhyB,OAAAoiB,SAAAsB,gBAAAzI,QAMA,QAAAjgB,GAAA,EAAAklB,GAAAupB,UAAAxuC,OAAyCilB,GAAAllB,EAAQA,IAAA,CAEjD,GAAA8sC,QAAA2B,UAAAzuC,GAEA8uC,WAAAhC,OAAA79B,OAEA/J,UAAA+a,QAAA6uB,WAAAxvB,aAAAW,QAEAuuB,UAAA5uC,KAAAkvC,YAMA,IAAA9uC,EAAA,EAAAklB,GAAAypB,OAAA1uC,OAAkCilB,GAAAllB,EAAQA,IAAA,CAE1C,GAAA+uC,UAAA3tB,OAAAviB,MAAAilC,KAAA6K,OAAA3uC,GACAgvC,kBAAAlL,KAAAH,cACAsL,iBAAAnL,KAAAF,YAEAmL,UAAA,GAAA/pC,OAAAy+B,MAAAK,KAAApoB,EAAA6yB,aAAAzK,KAAAl4B,EAAA2iC,aAAAzK,KAAAhpC,EAAAyzC,cACAQ,SAAA3tB,OAAAtV,KAAAg4B,KAAA1iB,QAEAlc,SAAA8xB,cAEA+X,SAAA3tB,OAAAhC,aAAA4X,cAAA5b,WAIA,QAAAxa,GAAA,EAAAqnC,GAAA+G,kBAAA/uC,OAAkDgoC,GAAArnC,EAAQA,IAE1DwgB,OAAA4tB,kBAAApuC,GAAAqO,QAEA/J,SAAA8xB,cAEA5V,OAAAhC,aAAA4X,cAAA5b,YAIA2zB,SAAApL,cAAA/jC,KAAAwhB,OAIA2tB,UAAAlwC,MAAAiN,KAAAg4B,KAAAjlC,MAEA,QAAA+B,GAAA,EAAAqnC,GAAAgH,iBAAAhvC,OAAiDgoC,GAAArnC,EAAQA,IAEzD/B,MAAAowC,iBAAAruC,GACAmuC,SAAAnL,aAAAhkC,KAAAf,MAAAoQ,QAIA8/B,UAAArL,cAAAI,KAAAJ,cAAA4K,oBAEAI,OAAA9uC,KAAAmvC,UAMA,IAAA/uC,EAAA,EAAAklB,GAAA2pB,KAAA5uC,OAAgCilB,GAAAllB,EAAQA,IAAA,CAExC,GAAAmpC,IAAA0F,KAAA7uC,GAAAkvC,SAEA,IAAAhqC,SAAAikC,GAAA,CAMA,OAAAvoC,GAAA,EAAAqnC,GAAAkB,GAAAlpC,OAAmCgoC,GAAArnC,EAAQA,IAE3CsuC,OAAAtvC,KAAAupC,GAAAvoC,GAAAqO,QAIA2/B,MAAAhvC,KAAAsvC,WAMAC,UAAA,SAAApwC,MAEA,MAAAA,gBAAAiG,OAAAhG,OAAA,MAEAgG,OAAAM,MAAA,kEAAAvG,OAKAA,KAAA+gC,kBAAA/gC,KAAAijC,mBAEA1mC,MAAAsvC,MAAA7rC,KAAAN,SAAAM,KAAAkhB,UAUAmvB,cAAA,WAEA,GAGA7zB,GAAA9e,IAGAuD,EAAAklB,GAAA4e,KACAkE,QAAApnC,EAAAqnC,GAPAoH,eACAC,UAAAC,WAGAC,gBAAA,EACA7Q,UAAAx5B,KAAA8H,IAAA,GAAAuiC,gBAIA,KAAAxvC,EAAA,EAAAklB,GAAA5pB,KAAAurB,SAAA5mB,OAAyCilB,GAAAllB,EAAQA,IAEjDub,EAAAjgB,KAAAurB,SAAA7mB,GACAvD,IAAA0I,KAAA+Y,MAAA3C,EAAA/b,EAAAm/B,WAAA,IAAAx5B,KAAA+Y,MAAA3C,EAAA9b,EAAAk/B,WAAA,IAAAx5B,KAAA+Y,MAAA3C,EAAA/c,EAAAmgC,WAEAz5B,SAAAmqC,YAAA5yC,MAEA4yC,YAAA5yC,KAAAuD,EACAsvC,OAAA1vC,KAAAtE,KAAAurB,SAAA7mB,IACAuvC,QAAAvvC,GAAAsvC,OAAArvC,OAAA,GAKAsvC,QAAAvvC,GAAAuvC,QAAAF,YAAA5yC,KASA,IAAAgzC,uBAEA,KAAAzvC,EAAA,EAAAklB,GAAA5pB,KAAA4qC,MAAAjmC,OAAsCilB,GAAAllB,EAAQA,IAAA,CAE9C8jC,KAAAxoC,KAAA4qC,MAAAlmC,GAEA8jC,KAAApoB,EAAA6zB,QAAAzL,KAAApoB,GACAooB,KAAAl4B,EAAA2jC,QAAAzL,KAAAl4B,GACAk4B,KAAAhpC,EAAAy0C,QAAAzL,KAAAhpC,GAEAktC,SAAAlE,KAAApoB,EAAAooB,KAAAl4B,EAAAk4B,KAAAhpC,EAMA,QAJA40C,UAAA,GAIApkB,EAAA,EAAmB,EAAAA,EAAOA,IAC1B,GAAA0c,QAAA1c,IAAA0c,SAAA1c,EAAA,OAEAokB,SAAApkB,EACAmkB,oBAAA7vC,KAAAI,EACA,QAOA,IAAAA,EAAAyvC,oBAAAxvC,OAAA,EAA2CD,GAAA,EAAQA,IAAA,CACnD,GAAA2vC,KAAAF,oBAAAzvC,EAIA,KAFA1E,KAAA4qC,MAAAvI,OAAAgS,IAAA,GAEA/uC,EAAA,EAAAqnC,GAAA3sC,KAAA6qC,cAAAlmC,OAA+CgoC,GAAArnC,EAAQA,IAEvDtF,KAAA6qC,cAAAvlC,GAAA+8B,OAAAgS,IAAA,GAQA,GAAAhf,MAAAr1B,KAAAurB,SAAA5mB,OAAAqvC,OAAArvC,MAEA,OADA3E,MAAAurB,SAAAyoB,OACA3e,MAIAuR,OAAA,WAkIA,QAAA0N,QAAA/jC,MAAAtN,SAAAsxC,SAEA,MAAAA,SAAAhkC,MAAA,GAAAtN,SAAAsN,QAAA,GAAAtN,UAIA,QAAAuxC,gBAAA1uB,QAEA,GAAA2uB,MAAA3uB,OAAA5hB,EAAAM,WAAAshB,OAAA3hB,EAAAK,WAAAshB,OAAA5iB,EAAAsB,UAEA,OAAAoF,UAAA8qC,YAAAD,MAEAC,YAAAD,OAIAC,YAAAD,MAAAzJ,QAAArmC,OAAA,EACAqmC,QAAA1mC,KAAAwhB,OAAA5hB,EAAA4hB,OAAA3hB,EAAA2hB,OAAA5iB,GAEAwxC,YAAAD,OAIA,QAAAE,eAAApxC,OAEA,GAAAkxC,MAAAlxC,MAAA6M,EAAA5L,WAAAjB,MAAA8M,EAAA7L,WAAAjB,MAAA+M,EAAA9L,UAEA,OAAAoF,UAAAgrC,WAAAH,MAEAG,WAAAH,OAIAG,WAAAH,MAAAxJ,OAAAtmC,OACAsmC,OAAA3mC,KAAAf,MAAA0O,UAEA2iC,WAAAH,OAIA,QAAAI,YAAAhH,IAEA,GAAA4G,MAAA5G,GAAA3pC,EAAAM,WAAAqpC,GAAA1pC,EAAAK,UAEA,OAAAoF,UAAAkrC,QAAAL,MAEAK,QAAAL,OAIAK,QAAAL,MAAAvJ,IAAAvmC,OAAA,EACAumC,IAAA5mC,KAAAupC,GAAA3pC,EAAA2pC,GAAA1pC,GAEA2wC,QAAAL,OArLA,GAAA5N,SACAC,UACAC,QAAA,EACA3gC,KAAA,iBACA4gC,UAAA,0BAEAhL,KAAAh8B,KAAAg8B,KACA51B,KAAApG,KAAAoG,KAKA,IAFA,KAAApG,KAAAgkC,OAAA6C,OAAA7C,KAAAhkC,KAAAgkC,MAEAp6B,SAAA5J,KAAA+0C,WAAA,CAEA,GAAAA,YAAA/0C,KAAA+0C,UAEA,QAAA5zC,OAAA4zC,YAEAnrC,SAAAmrC,WAAA5zC,OAAA0lC,OAAA1lC,KAAA4zC,WAAA5zC,KAIA,OAAA0lC,QAMA,OAFAtb,aAEA7mB,EAAA,EAAkBA,EAAA1E,KAAAurB,SAAA5mB,OAA0BD,IAAA,CAE5C,GAAA8sC,QAAAxxC,KAAAurB,SAAA7mB,EACA6mB,UAAAjnB,KAAAktC,OAAAttC,EAAAstC,OAAArtC,EAAAqtC,OAAAtuC,GAYA,OARA0nC,UACAI,WACA0J,eACAzJ,UACA2J,cACA1J,OACA4J,WAEApwC,EAAA,EAAkBA,EAAA1E,KAAA4qC,MAAAjmC,OAAuBD,IAAA,CAEzC,GAAA8jC,MAAAxoC,KAAA4qC,MAAAlmC,GAEAswC,aAAA,EACAC,WAAA,EACAnK,gBAAAlhC,SAAA5J,KAAA6qC,cAAA,GAAAnmC,GACAwwC,cAAA1M,KAAA1iB,OAAAnhB,SAAA,EACAwwC,oBAAA3M,KAAAH,cAAA1jC,OAAA,EACAywC,aAAA,IAAA5M,KAAAjlC,MAAA6M,GAAA,IAAAo4B,KAAAjlC,MAAA8M,GAAA,IAAAm4B,KAAAjlC,MAAA+M,EACA+kC,mBAAA7M,KAAAF,aAAA3jC,OAAA,EAEA2wC,SAAA,CAuBA,IArBAA,SAAAhB,OAAAgB,SAAA,KACAA,SAAAhB,OAAAgB,SAAA,EAAAN,aACAM,SAAAhB,OAAAgB,SAAA,EAAAL,WACAK,SAAAhB,OAAAgB,SAAA,EAAAxK,iBACAwK,SAAAhB,OAAAgB,SAAA,EAAAJ,eACAI,SAAAhB,OAAAgB,SAAA,EAAAH,qBACAG,SAAAhB,OAAAgB,SAAA,EAAAF,cACAE,SAAAhB,OAAAgB,SAAA,EAAAD,oBAEAzK,MAAAtmC,KAAAgxC,UACA1K,MAAAtmC,KAAAkkC,KAAApoB,EAAAooB,KAAAl4B,EAAAk4B,KAAAhpC,GAWAsrC,gBAAA,CAEA,GAAAD,eAAA7qC,KAAA6qC,cAAA,GAAAnmC,EAEAkmC,OAAAtmC,KACAuwC,WAAAhK,cAAA,IACAgK,WAAAhK,cAAA,IACAgK,WAAAhK,cAAA,KAWA,GANAqK,eAEAtK,MAAAtmC,KAAAkwC,eAAAhM,KAAA1iB,SAIAqvB,oBAAA,CAEA,GAAA9M,eAAAG,KAAAH,aAEAuC,OAAAtmC,KACAkwC,eAAAnM,cAAA,IACAmM,eAAAnM,cAAA,IACAmM,eAAAnM,cAAA,KAWA,GANA+M,cAEAxK,MAAAtmC,KAAAqwC,cAAAnM,KAAAjlC,QAIA8xC,mBAAA,CAEA,GAAA/M,cAAAE,KAAAF,YAEAsC,OAAAtmC,KACAqwC,cAAArM,aAAA,IACAqM,cAAArM,aAAA,IACAqM,cAAArM,aAAA,MA0EA,MAVAzB,QAAAU,QAEAV,OAAAU,KAAAhc,kBACAsb,OAAAU,KAAAyD,gBACAC,OAAAtmC,OAAA,IAAAkiC,OAAAU,KAAA0D,eACAC,IAAAvmC,OAAA,IAAAkiC,OAAAU,KAAA2D,WACArE,OAAAU,KAAAqD,YAIA/D,QAIAlzB,MAAA,WAMA,OAJAxQ,UAAA,GAAAuG,OAAA4hB,SAEAC,SAAAvrB,KAAAurB,SAEA7mB,EAAA,EAAAklB,GAAA2B,SAAA5mB,OAAwCilB,GAAAllB,EAAQA,IAEhDvB,SAAAooB,SAAAjnB,KAAAinB,SAAA7mB,GAAAiP,QAMA,QAFAi3B,OAAA5qC,KAAA4qC,MAEAlmC,EAAA,EAAAklB,GAAAghB,MAAAjmC,OAAqCilB,GAAAllB,EAAQA,IAE7CvB,SAAAynC,MAAAtmC,KAAAsmC,MAAAlmC,GAAAiP,QAIA,QAAAjP,GAAA,EAAAklB,GAAA5pB,KAAA6qC,cAAAlmC,OAAkDilB,GAAAllB,EAAQA,IAAA,CAE1D,GAAAmmC,eAAA7qC,KAAA6qC,cAAAnmC,EAEAkF,UAAAzG,SAAA0nC,cAAAnmC,KAEAvB,SAAA0nC,cAAAnmC,MAIA,QAAAY,GAAA,EAAAqnC,GAAA9B,cAAAlmC,OAA8CgoC,GAAArnC,EAAQA,IAAA,CAItD,OAFA4lC,KAAAL,cAAAvlC,GAAAiwC,WAEA/W,EAAA,EAAAgX,GAAAtK,IAAAvmC,OAAqC6wC,GAAAhX,EAAQA,IAAA,CAE7C,GAAAqP,IAAA3C,IAAA1M,EAEA+W,SAAAjxC,KAAAupC,GAAAl6B,SAIAxQ,SAAA0nC,cAAAnmC,GAAAJ,KAAAixC,UAMA,MAAApyC,WAIAotC,QAAA,WAEAvwC,KAAA+hC,eAAuB37B,KAAA,cAMvBsD,MAAAk4B,gBAAAthC,UAAAiB,MAAAmI,MAAA4hB,SAAAhrB,WAEAoJ,MAAAqgC,gBAAA,EAUArgC,MAAA+rC,OAAA,WAEA/rC,MAAAk6B,SAAAtkC,KAAAU,MAEAA,KAAAoG,KAAA,SAEApG,KAAA01C,mBAAA,GAAAhsC,OAAAkb,QACA5kB,KAAA8kB,iBAAA,GAAApb,OAAAkb,SAIAlb,MAAA+rC,OAAAn1C,UAAAujC,OAAAiG,OAAApgC,MAAAk6B,SAAAtjC,WACAoJ,MAAA+rC,OAAAn1C,UAAAM,YAAA8I,MAAA+rC,OAEA/rC,MAAA+rC,OAAAn1C,UAAAimC,kBAAA,WAEA,GAAAhpB,YAAA,GAAA7T,OAAAqT,UAEA,iBAAA1K,gBAEA,GAAA5N,QAAA4N,gBAAA,GAAA3I,OAAAgW,OAIA,OAFA1f,MAAAomC,mBAAA7oB,YAEA9Y,OAAA0L,IAAA,QAAA2Q,gBAAAvD,gBAMA7T,MAAA+rC,OAAAn1C,UAAAsvB,OAAA,WAIA,GAAA4L,IAAA,GAAA9xB,OAAAkb,OAEA,iBAAAlV,QAEA8rB,GAAA5L,OAAA5vB,KAAAiD,SAAAyM,OAAA1P,KAAA+vB,IAEA/vB,KAAAud,WAAAiB,sBAAAgd,QAMA9xB,MAAA+rC,OAAAn1C,UAAAqT,MAAA,SAAA9Q,QASA,MAPA+G,UAAA/G,gBAAA,GAAA6G,OAAA+rC,QAEA/rC,MAAAk6B,SAAAtjC,UAAAqT,MAAArU,KAAAU,KAAA6C,QAEAA,OAAA6yC,mBAAAllC,KAAAxQ,KAAA01C,oBACA7yC,OAAAiiB,iBAAAtU,KAAAxQ,KAAA8kB,kBAEAjiB,QAYA6G,MAAAisC,WAAA,SAAAzhB,KAAAC,IAAAyhB,gBAEAlsC,MAAAk6B,SAAAtkC,KAAAU,MAEAA,KAAAoG,KAAA,YAEA,IAAAiuB,KAAA,GAAAvxB,OAAA,EAEA+yC,SAAA,GAAAnsC,OAAA1G,kBAAAqxB,IAAAvxB,OAAAoxB,KAAAC,IACA0hB,UAAA9lB,GAAA5f,IAAA,QACA0lC,SAAAjmB,OAAA,GAAAlmB,OAAAgW,QAAA,QACA1f,KAAA2D,IAAAkyC,SAEA,IAAAC,UAAA,GAAApsC,OAAA1G,kBAAAqxB,IAAAvxB,OAAAoxB,KAAAC,IACA2hB,UAAA/lB,GAAA5f,IAAA,QACA2lC,SAAAlmB,OAAA,GAAAlmB,OAAAgW,QAAA,SACA1f,KAAA2D,IAAAmyC,SAEA,IAAAC,UAAA,GAAArsC,OAAA1G,kBAAAqxB,IAAAvxB,OAAAoxB,KAAAC,IACA4hB,UAAAhmB,GAAA5f,IAAA,OACA4lC,SAAAnmB,OAAA,GAAAlmB,OAAAgW,QAAA,QACA1f,KAAA2D,IAAAoyC,SAEA,IAAAC,UAAA,GAAAtsC,OAAA1G,kBAAAqxB,IAAAvxB,OAAAoxB,KAAAC,IACA6hB,UAAAjmB,GAAA5f,IAAA,QACA6lC,SAAApmB,OAAA,GAAAlmB,OAAAgW,QAAA,SACA1f,KAAA2D,IAAAqyC,SAEA,IAAAC,UAAA,GAAAvsC,OAAA1G,kBAAAqxB,IAAAvxB,OAAAoxB,KAAAC,IACA8hB,UAAAlmB,GAAA5f,IAAA,QACA8lC,SAAArmB,OAAA,GAAAlmB,OAAAgW,QAAA,QACA1f,KAAA2D,IAAAsyC,SAEA,IAAAC,UAAA,GAAAxsC,OAAA1G,kBAAAqxB,IAAAvxB,OAAAoxB,KAAAC,IACA+hB,UAAAnmB,GAAA5f,IAAA,QACA+lC,SAAAtmB,OAAA,GAAAlmB,OAAAgW,QAAA,SACA1f,KAAA2D,IAAAuyC,UAEAl2C,KAAAm2C,aAAA,GAAAzsC,OAAA0sC,sBAAAR,+BAAuFS,OAAA3sC,MAAAiF,UAAA2nC,UAAA5sC,MAAAkE,aAAA2oC,UAAA7sC,MAAAkE,eAEvF5N,KAAAw2C,cAAA,SAAA32C,SAAAK,OAEA,GAAAi2C,cAAAn2C,KAAAm2C,aACAM,gBAAAN,aAAAM,eAEAN,cAAAM,iBAAA,EAEAN,aAAAO,eAAA,EACA72C,SAAAoC,OAAA/B,MAAA21C,SAAAM,cAEAA,aAAAO,eAAA,EACA72C,SAAAoC,OAAA/B,MAAA41C,SAAAK,cAEAA,aAAAO,eAAA,EACA72C,SAAAoC,OAAA/B,MAAA61C,SAAAI,cAEAA,aAAAO,eAAA,EACA72C,SAAAoC,OAAA/B,MAAA81C,SAAAG,cAEAA,aAAAO,eAAA,EACA72C,SAAAoC,OAAA/B,MAAA+1C,SAAAE,cAEAA,aAAAM,gCAEAN,aAAAO,eAAA,EACA72C,SAAAoC,OAAA/B,MAAAg2C,SAAAC,gBAMAzsC,MAAAisC,WAAAr1C,UAAAujC,OAAAiG,OAAApgC,MAAAk6B,SAAAtjC,WACAoJ,MAAAisC,WAAAr1C,UAAAM,YAAA8I,MAAAisC,WAQAjsC,MAAA85B,mBAAA,SAAA1P,KAAAC,MAAAE,IAAAD,OAAAE,KAAAC,KAEAzqB,MAAA+rC,OAAAn2C,KAAAU,MAEAA,KAAAoG,KAAA,qBAEApG,KAAA22C,KAAA,EAEA32C,KAAA8zB,UACA9zB,KAAA+zB,YACA/zB,KAAAi0B,QACAj0B,KAAAg0B,cAEAh0B,KAAAk0B,KAAAtqB,SAAAsqB,UAAA,GACAl0B,KAAAm0B,IAAAvqB,SAAAuqB,QAAA,IAEAn0B,KAAA+C,0BAIA2G,MAAA85B,mBAAAljC,UAAAujC,OAAAiG,OAAApgC,MAAA+rC,OAAAn1C,WACAoJ,MAAA85B,mBAAAljC,UAAAM,YAAA8I,MAAA85B,mBAEA95B,MAAA85B,mBAAAljC,UAAAyC,uBAAA,WAEA,GAAAkgB,KAAAjjB,KAAA+zB,MAAA/zB,KAAA8zB,OAAA,EAAA9zB,KAAA22C,MACAzzB,IAAAljB,KAAAi0B,IAAAj0B,KAAAg0B,SAAA,EAAAh0B,KAAA22C,MACAC,IAAA52C,KAAA+zB,MAAA/zB,KAAA8zB,MAAA,EACA+iB,IAAA72C,KAAAi0B,IAAAj0B,KAAAg0B,QAAA,CAEAh0B,MAAA8kB,iBAAA6P,iBAAAiiB,GAAA3zB,GAAA2zB,GAAA3zB,GAAA4zB,GAAA3zB,GAAA2zB,GAAA3zB,GAAAljB,KAAAk0B,KAAAl0B,KAAAm0B,MAIAzqB,MAAA85B,mBAAAljC,UAAAqT,MAAA,WAEA,GAAA9Q,QAAA,GAAA6G,OAAA85B,kBAgBA,OAdA95B,OAAA+rC,OAAAn1C,UAAAqT,MAAArU,KAAAU,KAAA6C,QAEAA,OAAA8zC,KAAA32C,KAAA22C,KAEA9zC,OAAAixB,KAAA9zB,KAAA8zB,KACAjxB,OAAAkxB,MAAA/zB,KAAA+zB,MACAlxB,OAAAoxB,IAAAj0B,KAAAi0B,IACApxB,OAAAmxB,OAAAh0B,KAAAg0B,OAEAnxB,OAAAqxB,KAAAl0B,KAAAk0B,KACArxB,OAAAsxB,IAAAn0B,KAAAm0B,IAEAtxB,OAAAiiB,iBAAAtU,KAAAxQ,KAAA8kB,kBAEAjiB,QAWA6G,MAAA1G,kBAAA,SAAAqxB,IAAAvxB,OAAAoxB,KAAAC,KAEAzqB,MAAA+rC,OAAAn2C,KAAAU,MAEAA,KAAAoG,KAAA,oBAEApG,KAAA22C,KAAA,EAEA32C,KAAAq0B,IAAAzqB,SAAAyqB,QAAA,GACAr0B,KAAA8C,OAAA8G,SAAA9G,cAAA,EACA9C,KAAAk0B,KAAAtqB,SAAAsqB,UAAA,GACAl0B,KAAAm0B,IAAAvqB,SAAAuqB,QAAA,IAEAn0B,KAAA+C,0BAIA2G,MAAA1G,kBAAA1C,UAAAujC,OAAAiG,OAAApgC,MAAA+rC,OAAAn1C,WACAoJ,MAAA1G,kBAAA1C,UAAAM,YAAA8I,MAAA1G,kBASA0G,MAAA1G,kBAAA1C,UAAAw2C,QAAA,SAAAC,YAAAC,aAEAptC,SAAAotC,0BAAA,IAEAh3C,KAAAq0B,IAAA,EAAA3qB,MAAAG,KAAAuzB,SAAAvzB,KAAAotC,KAAAD,aAAA,EAAAD,eACA/2C,KAAA+C,0BAyCA2G,MAAA1G,kBAAA1C,UAAA42C,cAAA,SAAAC,UAAAC,WAAAlzC,EAAAC,EAAAkzC,MAAAC,QAEAt3C,KAAAm3C,oBACAn3C,KAAAo3C,sBACAp3C,KAAAkE,IACAlE,KAAAmE,IACAnE,KAAAq3C,YACAr3C,KAAAs3C,cAEAt3C,KAAA+C,0BAKA2G,MAAA1G,kBAAA1C,UAAAyC,uBAAA,WAEA,GAAAsxB,KAAA3qB,MAAAG,KAAAuzB,SAAA,EAAAvzB,KAAAotC,KAAAptC,KAAAuS,IAAA,GAAA1S,MAAAG,KAAA0qB,SAAAv0B,KAAAq0B,MAAAr0B,KAAA22C,MAEA,IAAA32C,KAAAm3C,UAAA,CAEA,GAAAr0C,QAAA9C,KAAAm3C,UAAAn3C,KAAAo3C,WACAnjB,IAAApqB,KAAAuS,IAAA1S,MAAAG,KAAA0qB,SAAA,GAAAF,MAAAr0B,KAAAk0B,KACAF,QAAAC,IACAH,KAAAhxB,OAAAkxB,OACAD,MAAAjxB,OAAAmxB,IACAojB,MAAAxtC,KAAA+V,IAAAmU,MAAAD,MACAwjB,OAAAztC,KAAA+V,IAAAqU,IAAAD,OAEAh0B,MAAA8kB,iBAAA+O,YACAC,KAAA9zB,KAAAkE,EAAAmzC,MAAAr3C,KAAAm3C,UACArjB,MAAA9zB,KAAAkE,EAAAlE,KAAAq3C,aAAAr3C,KAAAm3C,UACAljB,KAAAj0B,KAAAmE,EAAAnE,KAAAs3C,eAAAt3C,KAAAo3C,WACAnjB,IAAAj0B,KAAAmE,EAAAmzC,OAAAt3C,KAAAo3C,WACAp3C,KAAAk0B,KACAl0B,KAAAm0B,SAKAn0B,MAAA8kB,iBAAAsP,gBAAAC,IAAAr0B,KAAA8C,OAAA9C,KAAAk0B,KAAAl0B,KAAAm0B,MAMAzqB,MAAA1G,kBAAA1C,UAAAqT,MAAA,WAEA,GAAA9Q,QAAA,GAAA6G,OAAA1G,iBAaA,OAXA0G,OAAA+rC,OAAAn1C,UAAAqT,MAAArU,KAAAU,KAAA6C,QAEAA,OAAA8zC,KAAA32C,KAAA22C,KAEA9zC,OAAAwxB,IAAAr0B,KAAAq0B,IACAxxB,OAAAC,OAAA9C,KAAA8C,OACAD,OAAAqxB,KAAAl0B,KAAAk0B,KACArxB,OAAAsxB,IAAAn0B,KAAAm0B,IAEAtxB,OAAAiiB,iBAAAtU,KAAAxQ,KAAA8kB,kBAEAjiB,QAWA6G,MAAA6tC,MAAA,SAAAh0C,OAEAmG,MAAAk6B,SAAAtkC,KAAAU,MAEAA,KAAAoG,KAAA,QAEApG,KAAAuD,MAAA,GAAAmG,OAAAuG,MAAA1M,QAIAmG,MAAA6tC,MAAAj3C,UAAAujC,OAAAiG,OAAApgC,MAAAk6B,SAAAtjC,WACAoJ,MAAA6tC,MAAAj3C,UAAAM,YAAA8I,MAAA6tC,MAEA7tC,MAAA6tC,MAAAj3C,UAAAqT,MAAA,SAAA6jC,OAQA,MANA5tC,UAAA4tC,cAAA,GAAA9tC,OAAA6tC,OAEA7tC,MAAAk6B,SAAAtjC,UAAAqT,MAAArU,KAAAU,KAAAw3C,OAEAA,MAAAj0C,MAAAiN,KAAAxQ,KAAAuD,OAEAi0C,OAUA9tC,MAAA89B,aAAA,SAAAjkC,OAEAmG,MAAA6tC,MAAAj4C,KAAAU,KAAAuD,OAEAvD,KAAAoG,KAAA,gBAIAsD,MAAA89B,aAAAlnC,UAAAujC,OAAAiG,OAAApgC,MAAA6tC,MAAAj3C,WACAoJ,MAAA89B,aAAAlnC,UAAAM,YAAA8I,MAAA89B,aAEA99B,MAAA89B,aAAAlnC,UAAAqT,MAAA,WAEA,GAAA6jC,OAAA,GAAA9tC,OAAA89B,YAIA,OAFA99B,OAAA6tC,MAAAj3C,UAAAqT,MAAArU,KAAAU,KAAAw3C,OAEAA,OAWA9tC,MAAA+tC,UAAA,SAAAl0C,MAAAmkC,WAEAh+B,MAAA6tC,MAAAj4C,KAAAU,KAAAuD,OAEAvD,KAAAoG,KAAA,YAEApG,KAAA8lB,OAAA,GAAApc,OAAAgW,QAAA,QACA1f,KAAA+zB,MAAA,GAAArqB,OAAAgW,QAAA,OAEA1f,KAAA0nC,UAAA99B,SAAA89B,oBAAA,EAEA1nC,KAAAq3C,MAAA,EACAr3C,KAAAs3C,OAAA,EAEAt3C,KAAA03C,oBAAA,IACA13C,KAAA23C,kBAAA,GACA33C,KAAA43C,qBAAA,IAIAluC,MAAA+tC,UAAAn3C,UAAAujC,OAAAiG,OAAApgC,MAAA6tC,MAAAj3C,WACAoJ,MAAA+tC,UAAAn3C,UAAAM,YAAA8I,MAAA+tC,UAUA/tC,MAAA+9B,iBAAA,SAAAlkC,MAAAmkC,WAEAh+B,MAAA6tC,MAAAj4C,KAAAU,KAAAuD,OAEAvD,KAAAoG,KAAA,mBAEApG,KAAAiD,SAAAkN,IAAA,OACAnQ,KAAA8vB,OAAA,GAAApmB,OAAAk6B,SAEA5jC,KAAA0nC,UAAA99B,SAAA89B,oBAAA,EAEA1nC,KAAA2kC,YAAA,EACA3kC,KAAA63C,YAAA,EAIA73C,KAAA83C,iBAAA,GACA93C,KAAA+3C,gBAAA,IAEA/3C,KAAAg4C,iBAAA,KACAh4C,KAAAi4C,kBAAA,IACAj4C,KAAAk4C,gBAAA,IACAl4C,KAAAm4C,mBAAA,KAEAn4C,KAAAo4C,qBAAA,EAEAp4C,KAAAq4C,WAAA,EACAr4C,KAAAs4C,eAAA,GAEAt4C,KAAAu4C,eAAA,IACAv4C,KAAAw4C,gBAAA,IAIAx4C,KAAAy4C,eAAA,EAEAz4C,KAAA04C,oBAAA,GAAAhvC,OAAAgW,QAAA,UACA1f,KAAA24C,mBAAA,EAEA34C,KAAA44C,mBAAA,OACA54C,KAAA64C,oBAAA,aACA74C,KAAA84C,qBAAA,aAEA94C,KAAA+4C,oBAAA,aACA/4C,KAAAg5C,mBAAA,YAEAh5C,KAAAi5C,sBAIAj5C,KAAAk5C,UAAA,KACAl5C,KAAAm5C,cAAA,KACAn5C,KAAAo5C,aAAA,KACAp5C,KAAAq5C,aAAA,MAIA3vC,MAAA+9B,iBAAAnnC,UAAAujC,OAAAiG,OAAApgC,MAAA6tC,MAAAj3C,WACAoJ,MAAA+9B,iBAAAnnC,UAAAM,YAAA8I,MAAA+9B,iBAEA/9B,MAAA+9B,iBAAAnnC,UAAAqT,MAAA,WAEA,GAAA6jC,OAAA,GAAA9tC,OAAA+9B,gBA2CA,OAzCA/9B,OAAA6tC,MAAAj3C,UAAAqT,MAAArU,KAAAU,KAAAw3C,OAEAA,MAAA1nB,OAAA9vB,KAAA8vB,OAAAnc,QAEA6jC,MAAA9P,UAAA1nC,KAAA0nC,UAEA8P,MAAA7S,WAAA3kC,KAAA2kC,WACA6S,MAAAK,WAAA73C,KAAA63C,WAIAL,MAAAM,iBAAA93C,KAAA83C,iBACAN,MAAAO,gBAAA/3C,KAAA+3C,gBAEAP,MAAAQ,iBAAAh4C,KAAAg4C,iBACAR,MAAAS,kBAAAj4C,KAAAi4C,kBACAT,MAAAU,gBAAAl4C,KAAAk4C,gBACAV,MAAAW,mBAAAn4C,KAAAm4C,mBAEAX,MAAAY,oBAAAp4C,KAAAo4C,oBAEAZ,MAAAa,WAAAr4C,KAAAq4C,WACAb,MAAAc,eAAAt4C,KAAAs4C,eAEAd,MAAAe,eAAAv4C,KAAAu4C,eACAf,MAAAgB,gBAAAx4C,KAAAw4C,gBAIAhB,MAAAiB,cAAAz4C,KAAAy4C,cAEAjB,MAAAkB,oBAAAloC,KAAAxQ,KAAA04C,qBACAlB,MAAAmB,mBAAA34C,KAAA24C,mBAEAnB,MAAAoB,kBAAA54C,KAAA44C,kBAAAzmC,MAAA,GACAqlC,MAAAqB,mBAAA74C,KAAA64C,mBAAA1mC,MAAA,GACAqlC,MAAAsB,oBAAA94C,KAAA84C,oBAAA3mC,MAAA,GAEAqlC,MAAAuB,mBAAA/4C,KAAA+4C,mBAAA5mC,MAAA,GACAqlC,MAAAwB,kBAAAh5C,KAAAg5C,kBAAA7mC,MAAA,GAEAqlC,OAUA9tC,MAAAq+B,gBAAA,SAAAuR,SAAAtR,YAAAN,WAEAh+B,MAAA6tC,MAAAj4C,KAAAU,KAAAs5C,UAEAt5C,KAAAoG,KAAA,kBAEApG,KAAAiD,SAAAkN,IAAA,SAEAnQ,KAAAgoC,YAAA,GAAAt+B,OAAAuG,MAAA+3B,aACAhoC,KAAA0nC,UAAA99B,SAAA89B,oBAAA,GAIAh+B,MAAAq+B,gBAAAznC,UAAAujC,OAAAiG,OAAApgC,MAAA6tC,MAAAj3C,WACAoJ,MAAAq+B,gBAAAznC,UAAAM,YAAA8I,MAAAq+B,gBAEAr+B,MAAAq+B,gBAAAznC,UAAAqT,MAAA,WAEA,GAAA6jC,OAAA,GAAA9tC,OAAAq+B,eAOA,OALAr+B,OAAA6tC,MAAAj3C,UAAAqT,MAAArU,KAAAU,KAAAw3C,OAEAA,MAAAxP,YAAAx3B,KAAAxQ,KAAAgoC,aACAwP,MAAA9P,UAAA1nC,KAAA0nC,UAEA8P,OAUA9tC,MAAAi+B,WAAA,SAAApkC,MAAAmkC,UAAA7e,SAAA+e,OAEAl+B,MAAA6tC,MAAAj4C,KAAAU,KAAAuD,OAEAvD,KAAAoG,KAAA,aAEApG,KAAA0nC,UAAA99B,SAAA89B,oBAAA,EACA1nC,KAAA6oB,SAAAjf,SAAAif,kBAAA,EACA7oB,KAAA4nC,MAAAh+B,SAAAg+B,YAAA,GAIAl+B,MAAAi+B,WAAArnC,UAAAujC,OAAAiG,OAAApgC,MAAA6tC,MAAAj3C,WACAoJ,MAAAi+B,WAAArnC,UAAAM,YAAA8I,MAAAi+B,WAEAj+B,MAAAi+B,WAAArnC,UAAAqT,MAAA,WAEA,GAAA6jC,OAAA,GAAA9tC,OAAAi+B,UAQA,OANAj+B,OAAA6tC,MAAAj3C,UAAAqT,MAAArU,KAAAU,KAAAw3C,OAEAA,MAAA9P,UAAA1nC,KAAA0nC,UACA8P,MAAA3uB,SAAA7oB,KAAA6oB,SACA2uB,MAAA5P,MAAA5nC,KAAA4nC,MAEA4P,OAUA9tC,MAAAm+B,UAAA,SAAAtkC,MAAAmkC,UAAA7e,SAAAvK,MAAAwpB,SAAAF,OAEAl+B,MAAA6tC,MAAAj4C,KAAAU,KAAAuD,OAEAvD,KAAAoG,KAAA,YAEApG,KAAAiD,SAAAkN,IAAA,OACAnQ,KAAA8vB,OAAA,GAAApmB,OAAAk6B,SAEA5jC,KAAA0nC,UAAA99B,SAAA89B,oBAAA,EACA1nC,KAAA6oB,SAAAjf,SAAAif,kBAAA,EACA7oB,KAAAse,MAAA1U,SAAA0U,YAAAzU,KAAAud,GAAA,EACApnB,KAAA8nC,SAAAl+B,SAAAk+B,kBAAA,GACA9nC,KAAA4nC,MAAAh+B,SAAAg+B,YAAA,EAEA5nC,KAAA2kC,YAAA,EACA3kC,KAAA63C,YAAA,EAIA73C,KAAA83C,iBAAA,GACA93C,KAAA+3C,gBAAA,IACA/3C,KAAAu5C,gBAAA,GAEAv5C,KAAAo4C,qBAAA,EAEAp4C,KAAAq4C,WAAA,EACAr4C,KAAAs4C,eAAA,GAEAt4C,KAAAu4C,eAAA,IACAv4C,KAAAw4C,gBAAA,IAIAx4C,KAAAk5C,UAAA,KACAl5C,KAAAm5C,cAAA,KACAn5C,KAAAo5C,aAAA,KACAp5C,KAAAq5C,aAAA,MAIA3vC,MAAAm+B,UAAAvnC,UAAAujC,OAAAiG,OAAApgC,MAAA6tC,MAAAj3C,WACAoJ,MAAAm+B,UAAAvnC,UAAAM,YAAA8I,MAAAm+B,UAEAn+B,MAAAm+B,UAAAvnC,UAAAqT,MAAA,WAEA,GAAA6jC,OAAA,GAAA9tC,OAAAm+B,SA6BA,OA3BAn+B,OAAA6tC,MAAAj3C,UAAAqT,MAAArU,KAAAU,KAAAw3C,OAEAA,MAAA1nB,OAAA9vB,KAAA8vB,OAAAnc,QAEA6jC,MAAA9P,UAAA1nC,KAAA0nC,UACA8P,MAAA3uB,SAAA7oB,KAAA6oB,SACA2uB,MAAAl5B,MAAAte,KAAAse,MACAk5B,MAAA1P,SAAA9nC,KAAA8nC,SACA0P,MAAA5P,MAAA5nC,KAAA4nC,MAEA4P,MAAA7S,WAAA3kC,KAAA2kC,WACA6S,MAAAK,WAAA73C,KAAA63C,WAIAL,MAAAM,iBAAA93C,KAAA83C,iBACAN,MAAAO,gBAAA/3C,KAAA+3C,gBACAP,MAAA+B,gBAAAv5C,KAAAu5C,gBAEA/B,MAAAY,oBAAAp4C,KAAAo4C,oBAEAZ,MAAAa,WAAAr4C,KAAAq4C,WACAb,MAAAc,eAAAt4C,KAAAs4C,eAEAd,MAAAe,eAAAv4C,KAAAu4C,eACAf,MAAAgB,gBAAAx4C,KAAAw4C,gBAEAhB,OAUA9tC,MAAA8vC,OAEAC,SAEA91C,IAAA,SAAAxC,IAAAu4C,MAIA15C,KAAAy5C,MAAAt4C,KAAAu4C,MAIAC,IAAA,SAAAx4C,KAIA,MAAAnB,MAAAy5C,MAAAt4C,MAIAsF,OAAA,SAAAtF,WAEAnB,MAAAy5C,MAAAt4C,MAIAQ,MAAA,WAEA3B,KAAAy5C,WAYA/vC,MAAAkwC,OAAA,SAAAC,YAEA75C,KAAA65C,sBACA75C,KAAA85C,iBAAAD,WAAAnwC,MAAAkwC,OAAAt5C,UAAAy5C,mBAAA,KAEA/5C,KAAAg6C,YAAA,GAAAtwC,OAAAuwC,YAEAj6C,KAAAk6C,YAAA,aACAl6C,KAAAm6C,eAAA,aACAn6C,KAAAo6C,eAAA,cAIA1wC,MAAAkwC,OAAAt5C,WAEAM,YAAA8I,MAAAkwC,OAEAS,YAAAzwC,OAEAmwC,iBAAA,WAEA,GAAAh2B,GAAAlgB,SAAAoC,cAAA,MAeA,OAbA8d,GAAA3S,MAAAnO,SAAA,WACA8gB,EAAA3S,MAAA2iB,MAAA,MACAhQ,EAAA3S,MAAA6iB,IAAA,MACAlQ,EAAA3S,MAAAkpC,SAAA,QACAv2B,EAAA3S,MAAAmpC,UAAA,OACAx2B,EAAA3S,MAAAopC,WAAA,mBACAz2B,EAAA3S,MAAA7N,MAAA,OACAwgB,EAAA3S,MAAAimC,MAAA,QACAtzB,EAAA3S,MAAAqpC,QAAA,0BACA12B,EAAA3S,MAAAspC,OAAA,IAEA32B,EAAA42B,UAAA,cAEA52B,GAIA62B,eAAA,SAAAC,UAEA,GAAAC,SAAA,SAIAA,UAFAD,SAAAzb,OAEA,IAAAyb,SAAAx7C,OAAAw7C,SAAAzb,OAAA2b,QAAA,QAKAF,SAAAx7C,OAAA,MAAA07C,QAAA,SAIA/6C,KAAA85C,iBAAAa,UAAAG,SAIAE,eAAA,SAAAC,KAEA,GAAA11C,OAAA01C,IAAAlf,MAAA,IAEA,YAAAx2B,MAAAZ,OAAA,MAEAY,MAAA21C,MAEA31C,MAAAV,KAAA,WAIAs2C,cAAA,SAAA/T,UAAAgU,aAIA,OAFA5nC,UAEA9O,EAAA,EAAkBA,EAAA0iC,UAAAziC,SAAsBD,EAExC8O,MAAA9O,GAAA1E,KAAAq7C,eAAAjU,UAAA1iC,GAAA02C,YAIA,OAAA5nC,QAIA8nC,cAAA,SAAAlU,WAEA,OAAA1iC,GAAA,EAAAklB,GAAAwd,UAAAziC,OAAyCilB,GAAAllB,EAAQA,IAAA,CAEjD,GAAAnF,GAAA6nC,UAAA1iC,EAEA,IAAAnF,YAAAmK,OAAA6xC,eAAA,SAIA,UAIAF,eAAA,SAAA97C,EAAA67C,aAIA,QAAAI,cAAAxrB,GAEA,GAAAhf,GAAAnH,KAAAzJ,IAAA4vB,GAAAnmB,KAAA4xC,GACA,OAAA5xC,MAAA8H,IAAA,EAAA9H,KAAA+Y,MAAA5R,IAIA,QAAA0qC,gBAAAC,MAAA3X,KAAA4X,WAAAC,OAAAnoC,OAAAooC,KAAAC,YAEA,GAEAC,SAFAC,SAAAb,YAAAQ,WAIAM,OAAAxyC,MAAAkwC,OAAAuC,SAAAxC,IAAAsC,SA0DA,IAxDA,OAAAC,OAEAF,QAAAE,OAAAE,KAAAH,WAIAD,QAAA,GAAAtyC,OAAA2yC,QAEAH,OAAAhxB,MAAA8uB,YACAkC,OAAA7B,YAAAnvB,MAAAmvB,YACA6B,OAAAE,KAAAH,SAAA,SAAAK,OAEA,GAAA5yC,MAAAG,KAAA0zB,aAAA+e,MAAAjF,UAAA,GACA3tC,MAAAG,KAAA0zB,aAAA+e,MAAAhF,WAAA,GAEA,GAAAD,OAAAmE,aAAAc,MAAAjF,OACAC,OAAAkE,aAAAc,MAAAhF,QAEAiF,OAAA14C,SAAAoC,cAAA,SACAs2C,QAAAlF,YACAkF,OAAAjF,aAEA,IAAA7E,SAAA8J,OAAAC,WAAA,KACA/J,SAAAgK,UAAAH,MAAA,IAAAjF,MAAAC,QAEA0E,QAAAM,MAAAC,WAIAP,SAAAM,WAIAN,SAAArT,aAAA,KAMAqT,QAAAJ,sBAEAC,SAEAG,QAAAH,OAAA1rC,IAAA0rC,OAAA,GAAAA,OAAA,IAEA,IAAAA,OAAA,KAAAG,QAAAU,MAAAhzC,MAAA4D,gBACA,IAAAuuC,OAAA,KAAAG,QAAAW,MAAAjzC,MAAA4D,iBAIAoG,QAEAsoC,QAAAtoC,OAAAvD,IAAAuD,OAAA,GAAAA,OAAA,IAIAooC,KAAA,CAEA,GAAAc,UACAf,OAAAnyC,MAAA4D,eACAuvC,OAAAnzC,MAAA8D,uBAGA5D,UAAAgzC,QAAAd,KAAA,MAAAE,QAAAU,MAAAE,QAAAd,KAAA,KACAlyC,SAAAgzC,QAAAd,KAAA,MAAAE,QAAAW,MAAAC,QAAAd,KAAA,KAIAC,aAEAC,QAAAD,uBAIAJ,MAAA3X,MAAAgY,QAIA,QAAAc,SAAAC,KAEA,WAAAA,IAAA,aAAAA,IAAA,WAAAA,IAAA,GAjGA,GAAA7xB,OAAAlrB,KAuGAg9C,MAAA,sBACAC,OAAe15C,MAAA,SAAA25C,QAAA,EAAAC,IAAA,KAAAC,SAAA,KAAAC,UAAA,KAAAC,QAAA,KAAA95C,WAAA,EAIf,IAAAjE,EAAAg+C,QAAA,CAEA,GAAAA,SAAAh+C,EAAAg+C,QAAAt0C,aAEA,WAAAs0C,QAAAP,MAAA,oBACA,UAAAO,UAAAP,MAAA,qBAIApzC,SAAArK,EAAAi+C,UAAA5zC,SAAAF,MAAAnK,EAAAi+C,YAEAP,MAAAO,SAAA9zC,MAAAnK,EAAAi+C,WAIA5zC,SAAArK,EAAAk+C,cAEAR,MAAAQ,YAAAl+C,EAAAk+C,aAIA7zC,SAAArK,EAAA29C,SAAA39C,EAAA29C,QAAA,IAEAD,MAAAQ,aAAA,GAIA7zC,SAAArK,EAAAm+C,YAEAT,MAAAS,UAAAn+C,EAAAm+C,WAIA9zC,SAAArK,EAAAo+C,aAEAV,MAAAU,WAAAp+C,EAAAo+C,YAIA/zC,SAAArK,EAAAmlC,UAEAuY,MAAAvY,QAAAnlC,EAAAmlC,SAIA96B,SAAArK,EAAAq+C,YAEAX,MAAAY,KAAAn0C,MAAAqB,UAIAnB,SAAArK,EAAAu+C,cAEAb,MAAAY,KAAAn0C,MAAAsB,YAIApB,SAAArK,EAAAiE,YAEAy5C,MAAAz5C,UAAAjE,EAAAiE,WAIAoG,SAAArK,EAAA+oC,eAEA,SAAA/oC,EAAA+oC,aAEA2U,MAAA3U,aAAA5+B,MAAA2B,WAEI9L,EAAA+oC,eAEJ2U,MAAA3U,aAAA5+B,MAAA4B,eAQA/L,EAAAw+C,aAEAd,MAAA15C,MAAAu5C,QAAAv9C,EAAAw+C,cAEGx+C,EAAAy+C,WAEHf,MAAA15C,MAAAhE,EAAAy+C,UAIAz+C,EAAA0+C,gBAEAhB,MAAAiB,SAAApB,QAAAv9C,EAAA0+C,gBAIA1+C,EAAA4+C,gBAEAlB,MAAAmB,SAAAtB,QAAAv9C,EAAA4+C,gBAMAv0C,SAAArK,EAAA8+C,eAEAl+C,QAAA4J,KAAA,0DACAxK,EAAA29C,QAAA39C,EAAA8+C,cAIAz0C,SAAArK,EAAA29C,UAEAD,MAAAC,QAAA39C,EAAA29C,SAIA39C,EAAA++C,eAEArB,MAAAsB,UAAAh/C,EAAA++C,cAMA/+C,EAAAi/C,YAAApD,aAEAM,eAAAuB,MAAA,MAAA19C,EAAAi/C,WAAAj/C,EAAAk/C,iBAAAl/C,EAAAm/C,iBAAAn/C,EAAAo/C,eAAAp/C,EAAAq/C,sBAIAr/C,EAAAs/C,UAAAzD,aAEAM,eAAAuB,MAAA,WAAA19C,EAAAs/C,SAAAt/C,EAAAu/C,eAAAv/C,EAAAw/C,eAAAx/C,EAAAy/C,aAAAz/C,EAAA0/C,oBAIA1/C,EAAA2/C,SAAA9D,aAEAM,eAAAuB,MAAA,UAAA19C,EAAA2/C,QAAA3/C,EAAA4/C,cAAA5/C,EAAA6/C,cAAA7/C,EAAA8/C,YAAA9/C,EAAA+/C,mBAIA//C,EAAAggD,WAAAnE,aAEAM,eAAAuB,MAAA,YAAA19C,EAAAggD,UAAAhgD,EAAAigD,gBAAAjgD,EAAAkgD,gBAAAlgD,EAAAmgD,cAAAngD,EAAAogD,qBAIApgD,EAAAqgD,aAAAxE,aAEAM,eAAAuB,MAAA,cAAA19C,EAAAqgD,YAAArgD,EAAAsgD,kBAAAtgD,EAAAugD,kBAAAvgD,EAAAwgD,gBAAAxgD,EAAAygD,uBAIAzgD,EAAA0gD,UAAA7E,aAEAM,eAAAuB,MAAA,WAAA19C,EAAA0gD,SAAA1gD,EAAA2gD,eAAA3gD,EAAA4gD,eAAA5gD,EAAA6gD,aAAA7gD,EAAA8gD,oBAMA9gD,EAAA+gD,eAEArD,MAAAsD,UAAAhhD,EAAA+gD,cAIA/gD,EAAAihD,kBAEAvD,MAAAwD,YAAA,GAAA/2C,OAAAiY,QAAApiB,EAAAihD,gBAAAjhD,EAAAihD,iBAIA,IAAAn9C,UAAA,GAAAqG,OAAAszC,OAAAC,MAIA,OAFArzC,UAAArK,EAAAmhD,UAAAr9C,SAAA2gC,KAAAzkC,EAAAmhD,SAEAr9C,WAMAqG,MAAAkwC,OAAAuC,UAEAwE,YAEAh9C,IAAA,SAAAi9C,MAAA1E,QAEAl8C,KAAA2gD,SAAAr8C,KAAAs8C,MAAA1E,SAIAvC,IAAA,SAAAD,MAEA,OAAAh1C,GAAA,EAAAsM,EAAAhR,KAAA2gD,SAAAh8C,OAA4CqM,EAAAtM,EAAOA,GAAA,GAEnD,GAAAk8C,OAAA5gD,KAAA2gD,SAAAj8C,GACAw3C,OAAAl8C,KAAA2gD,SAAAj8C,EAAA,EAEA,IAAAk8C,MAAA93C,KAAA4wC,MAEA,MAAAwC,QAMA,cAYAxyC,MAAAm3C,UAAA,SAAAC,SAEA9gD,KAAA8gD,QAAAl3C,SAAAk3C,gBAAAp3C,MAAAq3C,uBAIAr3C,MAAAm3C,UAAAvgD,WAEAM,YAAA8I,MAAAm3C,UAEAzE,KAAA,SAAAnB,IAAA+F,OAAAC,WAAAC,SAEA,GAAAh2B,OAAAlrB,KAEAmhD,OAAAz3C,MAAA8vC,MAAAG,IAAAsB,IAEA,IAAArxC,SAAAu3C,OAGA,YADAH,eAAAG,QAKA,IAAAC,SAAA,GAAAC,eACAD,SAAAE,KAAA,MAAArG,KAAA,GAEAmG,QAAAx+C,iBAAA,gBAAA0/B,OAEA54B,MAAA8vC,MAAA71C,IAAAs3C,IAAAj7C,KAAAuhD,UAEAP,eAAAhhD,KAAAuhD,UAEAr2B,MAAA41B,QAAAU,QAAAvG,OAEG,GAEHrxC,SAAAq3C,YAEAG,QAAAx+C,iBAAA,oBAAA0/B,OAEA2e,WAAA3e,SAEI,GAIJ14B,SAAAs3C,SAEAE,QAAAx+C,iBAAA,iBAAA0/B,OAEA4e,QAAA5e,SAEI,GAIJ14B,SAAA5J,KAAAq6C,cAAA+G,QAAA/G,YAAAr6C,KAAAq6C,aACAzwC,SAAA5J,KAAAyhD,eAAAL,QAAAK,aAAAzhD,KAAAyhD;AAEAL,QAAAM,KAAA,MAEAx2B,MAAA41B,QAAAa,UAAA1G,MAIA2G,gBAAA,SAAArxC,OAEAvQ,KAAAyhD,aAAAlxC,OAIAsxC,eAAA,SAAAtxC,OAEAvQ,KAAAq6C,YAAA9pC,QAYA7G,MAAAuwC,YAAA,SAAA6G,SAEA9gD,KAAA8gD,QAAAl3C,SAAAk3C,gBAAAp3C,MAAAq3C,uBAIAr3C,MAAAuwC,YAAA35C,WAEAM,YAAA8I,MAAAuwC,YAEAmC,KAAA,SAAAnB,IAAA+F,OAAAC,WAAAC,SAEA,GAAAh2B,OAAAlrB,KAEAmhD,OAAAz3C,MAAA8vC,MAAAG,IAAAsB,IAEA,IAAArxC,SAAAu3C,OAGA,WADAH,QAAAG,OAKA,IAAA7E,OAAAz4C,SAAAoC,cAAA,MAsCA,OApCAq2C,OAAA15C,iBAAA,gBAAA0/B,OAEA54B,MAAA8vC,MAAA71C,IAAAs3C,IAAAj7C,MAEAghD,eAAAhhD,MAEAkrB,MAAA41B,QAAAU,QAAAvG,OAEG,GAEHrxC,SAAAq3C,YAEA3E,MAAA15C,iBAAA,oBAAA0/B,OAEA2e,WAAA3e,SAEI,GAIJ14B,SAAAs3C,SAEA5E,MAAA15C,iBAAA,iBAAA0/B,OAEA4e,QAAA5e,SAEI,GAIJ14B,SAAA5J,KAAAq6C,cAAAiC,MAAAjC,YAAAr6C,KAAAq6C,aAEAiC,MAAAt7C,IAAAi6C,IAEA/vB,MAAA41B,QAAAa,UAAA1G,KAEAqB,OAIAuF,eAAA,SAAAtxC,OAEAvQ,KAAAq6C,YAAA9pC,QAaA7G,MAAAo4C,WAAA,SAAAjI,YAEAnwC,MAAAkwC,OAAAt6C,KAAAU,KAAA65C,YAEA75C,KAAA+hD,iBAAA,GAIAr4C,MAAAo4C,WAAAxhD,UAAAujC,OAAAiG,OAAApgC,MAAAkwC,OAAAt5C,WACAoJ,MAAAo4C,WAAAxhD,UAAAM,YAAA8I,MAAAo4C,WAEAp4C,MAAAo4C,WAAAxhD,UAAA87C,KAAA,SAAAnB,IAAAz5B,SAAA45B,aAIAA,yBAAA,gBAAAA,yBAAAp7C,KAAAg7C,eAAAC,KAEAj7C,KAAAk6C,cACAl6C,KAAAgiD,aAAAhiD,KAAAi7C,IAAAz5B,SAAA45B,cAIA1xC,MAAAo4C,WAAAxhD,UAAA0hD,aAAA,SAAAvP,QAAAwI,IAAAz5B,SAAA45B,YAAA6G,kBAEA,GAAAC,KAAA,GAAAb,gBAEA18C,OAAA,CAEAu9C,KAAAC,mBAAA,WAEA,GAAAD,IAAAE,aAAAF,IAAAG,KAEA,SAAAH,IAAAI,QAAA,IAAAJ,IAAAI,OAAA,CAEA,GAAAJ,IAAAK,aAAA,CAEA,GAAApb,MAAA7+B,KAAA4/B,MAAAga,IAAAK,cACAzb,SAAAK,KAAAL,QAEA,IAAAl9B,SAAAk9B,SAAA,CAEA,cAAAA,SAAA1gC,KAGA,WADAsD,OAAAM,MAAA,qBAAAixC,IAAA,qDAKA,cAAAnU,SAAA1gC,KAGA,WADAsD,OAAAM,MAAA,qBAAAixC,IAAA,wDAOA,GAAAx2C,QAAAguC,QAAAvK,MAAAf,KAAAiU,YACA55B,UAAA/c,OAAAtB,SAAAsB,OAAA2iC,eAIA19B,OAAAM,MAAA,qBAAAixC,IAAA,iDAQAxI,SAAA2H,qBAIA1wC,OAAAM,MAAA,mCAAAixC,IAAA,KAAAiH,IAAAI,OAAA,SAIGJ,KAAAE,aAAAF,IAAAM,QAEHP,mBAEA,IAAAt9C,SAEAA,OAAAu9C,IAAAO,kBAAA,mBAIAR,kBAAuB7iB,MAAAz6B,OAAAtF,OAAA6iD,IAAAK,aAAA59C,UAIpBu9C,IAAAE,aAAAF,IAAAQ,kBAEH94C,SAAAq4C,mBAEAt9C,OAAAu9C,IAAAO,kBAAA,oBAQAP,IAAAZ,KAAA,MAAArG,KAAA,GACAiH,IAAAH,gBAAA/hD,KAAA+hD,gBACAG,IAAAR,KAAA,OAIAh4C,MAAAo4C,WAAAxhD,UAAA4nC,MAAA,SAAAf,KAAAiU,aAaA,QAAAuH,YAAAhwB,OAEA,QAAAiwB,UAAAryC,MAAAtN,UAEA,MAAAsN,OAAA,GAAAtN,SAIA,GAAAyB,GAAAY,EAAAu9C,GAEAnvC,OAAAovC,QAEAC,WAAAC,YAAAC,QAAA7a,cAEAhiC,KACA88C,OACAlO,YACAlK,gBACAoK,cAAAC,oBACAC,aAAAC,mBAEA7D,OAAAhJ,KAAA2a,MAAAC,MAAAzyC,IAAAmV,OAEAu9B,QAAAxV,GAAAtN,EAAAtgB,EAEA2qB,MAAAzD,KAAAyD,MACArf,SAAA4b,KAAA5b,SACAyf,QAAA7D,KAAA6D,QACAC,OAAA9D,KAAA8D,OAEAqY,UAAA,CAEA,IAAA15C,SAAAu9B,KAAA+D,IAAA,CAIA,IAAAxmC,EAAA,EAAeA,EAAAyiC,KAAA+D,IAAAvmC,OAAqBD,IAEpCyiC,KAAA+D,IAAAxmC,GAAAC,QAAA2+C,WAIA,KAAA5+C,EAAA,EAAe4+C,UAAA5+C,EAAeA,IAE9BvB,SAAA0nC,cAAAnmC,MASA,IAHAgP,OAAA,EACAovC,QAAAv3B,SAAA5mB,OAEAm+C,QAAApvC,QAEA89B,OAAA,GAAA9nC,OAAAgW,QAEA8xB,OAAAttC,EAAAqnB,SAAA7X,UAAAif,MACA6e,OAAArtC,EAAAonB,SAAA7X,UAAAif,MACA6e,OAAAtuC,EAAAqoB,SAAA7X,UAAAif,MAEAxvB,SAAAooB,SAAAjnB,KAAAktC,OAOA,KAHA99B,OAAA,EACAovC,QAAAlY,MAAAjmC,OAEAm+C,QAAApvC,QAeA,GAbAtN,KAAAwkC,MAAAl3B,UAGAwvC,OAAAN,SAAAx8C,KAAA,GACA4uC,YAAA4N,SAAAx8C,KAAA,GACA0kC,gBAAA8X,SAAAx8C,KAAA,GACA8uC,cAAA0N,SAAAx8C,KAAA,GACA+uC,oBAAAyN,SAAAx8C,KAAA,GACAgvC,aAAAwN,SAAAx8C,KAAA,GACAivC,mBAAAuN,SAAAx8C,KAAA,GAIA88C,OAAA,CA0BA,GAxBAC,MAAA,GAAAz5C,OAAAy+B,MACAgb,MAAA/iC,EAAAwqB,MAAAl3B,QACAyvC,MAAA7yC,EAAAs6B,MAAAl3B,OAAA,GACAyvC,MAAA3jD,EAAAorC,MAAAl3B,OAAA,GAEA0vC,MAAA,GAAA15C,OAAAy+B,MACAib,MAAAhjC,EAAAwqB,MAAAl3B,OAAA,GACA0vC,MAAA9yC,EAAAs6B,MAAAl3B,OAAA,GACA0vC,MAAA5jD,EAAAorC,MAAAl3B,OAAA,GAEAA,QAAA,EAEAshC,cAEA5M,cAAAwC,MAAAl3B,UACAyvC,MAAA/a,4BACAgb,MAAAhb,6BAMAya,GAAA1/C,SAAAynC,MAAAjmC,OAEAmmC,gBAEA,IAAApmC,EAAA,EAAiB4+C,UAAA5+C,EAAeA,IAOhC,IALA2+C,QAAAlc,KAAA+D,IAAAxmC,GAEAvB,SAAA0nC,cAAAnmC,GAAAm+C,OACA1/C,SAAA0nC,cAAAnmC,GAAAm+C,GAAA,MAEAv9C,EAAA,EAAkB,EAAAA,EAAOA,IAEzB29C,QAAArY,MAAAl3B,UAEA6sB,EAAA8iB,QAAA,EAAAJ,SACAhjC,EAAAojC,QAAA,EAAAJ,QAAA,GAEApV,GAAA,GAAAnkC,OAAAiY,QAAA4e,EAAAtgB,GAEA,IAAA3a,GAAAnC,SAAA0nC,cAAAnmC,GAAAm+C,IAAAv+C,KAAAupC,IACA,IAAAvoC,GAAAnC,SAAA0nC,cAAAnmC,GAAAm+C,GAAA,GAAAv+C,KAAAupC,GAsBA,IAdAqH,gBAEA8N,YAAA,EAAApY,MAAAl3B,UAEAyvC,MAAAr9B,OAAA3V,IACA66B,QAAAgY,eACAhY,QAAAgY,eACAhY,QAAAgY,cAGAI,MAAAt9B,OAAAtV,KAAA2yC,MAAAr9B,SAIAqvB,oBAEA,IAAAzwC,EAAA,EAAiB,EAAAA,EAAOA,IAExBs+C,YAAA,EAAApY,MAAAl3B,UAEAoS,OAAA,GAAApc,OAAAgW,QACAsrB,QAAAgY,eACAhY,QAAAgY,eACAhY,QAAAgY,cAIA,IAAAt+C,GAAAy+C,MAAA9a,cAAA/jC,KAAAwhB,QACA,IAAAphB,GAAA0+C,MAAA/a,cAAA/jC,KAAAwhB,OAkBA,IAXAsvB,eAEA2N,WAAAnY,MAAAl3B,UACA/C,IAAAs6B,OAAA8X,YAEAI,MAAA5/C,MAAAkN,OAAAE,KACAyyC,MAAA7/C,MAAAkN,OAAAE,MAKA0kC,mBAEA,IAAA3wC,EAAA,EAAiB,EAAAA,EAAOA,IAExBq+C,WAAAnY,MAAAl3B,UACA/C,IAAAs6B,OAAA8X,YAEA,IAAAr+C,GAAAy+C,MAAA7a,aAAAhkC,KAAA,GAAAoF,OAAAuG,MAAAU,MACA,IAAAjM,GAAA0+C,MAAA9a,aAAAhkC,KAAA,GAAAoF,OAAAuG,MAAAU,KAMAxN,UAAAynC,MAAAtmC,KAAA6+C,OACAhgD,SAAAynC,MAAAtmC,KAAA8+C,WAEI,CAkBJ,GAhBA5a,KAAA,GAAA9+B,OAAAy+B,MACAK,KAAApoB,EAAAwqB,MAAAl3B,UACA80B,KAAAl4B,EAAAs6B,MAAAl3B,UACA80B,KAAAhpC,EAAAorC,MAAAl3B,UAEAshC,cAEA5M,cAAAwC,MAAAl3B,UACA80B,KAAAJ,6BAMAya,GAAA1/C,SAAAynC,MAAAjmC,OAEAmmC,gBAEA,IAAApmC,EAAA,EAAiB4+C,UAAA5+C,EAAeA,IAMhC,IAJA2+C,QAAAlc,KAAA+D,IAAAxmC,GAEAvB,SAAA0nC,cAAAnmC,GAAAm+C,OAEAv9C,EAAA,EAAkB,EAAAA,EAAOA,IAEzB29C,QAAArY,MAAAl3B,UAEA6sB,EAAA8iB,QAAA,EAAAJ,SACAhjC,EAAAojC,QAAA,EAAAJ,QAAA,GAEApV,GAAA,GAAAnkC,OAAAiY,QAAA4e,EAAAtgB,GAEA9c,SAAA0nC,cAAAnmC,GAAAm+C,IAAAv+C,KAAAupC,GAoBA,IAZAqH,gBAEA8N,YAAA,EAAApY,MAAAl3B,UAEA80B,KAAA1iB,OAAA3V,IACA66B,QAAAgY,eACAhY,QAAAgY,eACAhY,QAAAgY,eAKA7N,oBAEA,IAAAzwC,EAAA,EAAiB,EAAAA,EAAOA,IAExBs+C,YAAA,EAAApY,MAAAl3B,UAEAoS,OAAA,GAAApc,OAAAgW,QACAsrB,QAAAgY,eACAhY,QAAAgY,eACAhY,QAAAgY,cAGAxa,KAAAH,cAAA/jC,KAAAwhB,OAeA,IARAsvB,eAEA2N,WAAAnY,MAAAl3B,UACA80B,KAAAjlC,MAAAkN,OAAAw6B,OAAA8X,cAKA1N,mBAEA,IAAA3wC,EAAA,EAAiB,EAAAA,EAAOA,IAExBq+C,WAAAnY,MAAAl3B,UACA80B,KAAAF,aAAAhkC,KAAA,GAAAoF,OAAAuG,MAAAg7B,OAAA8X,aAMA5/C,UAAAynC,MAAAtmC,KAAAkkC,OAQA,QAAA+a,aACA,GAAAC,qBAAA55C,SAAAu9B,KAAAqc,oBAAArc,KAAAqc,oBAAA,CAEA,IAAArc,KAAAwJ,YAEA,OAAAjsC,GAAA,EAAAsM,EAAAm2B,KAAAwJ,YAAAhsC,OAAgDqM,EAAAtM,EAAOA,GAAA8+C,oBAAA,CAEvD,GAAAt/C,GAAAijC,KAAAwJ,YAAAjsC,GACAP,EAAAq/C,oBAAA,EAAArc,KAAAwJ,YAAAjsC,EAAA,KACAxB,EAAAsgD,oBAAA,EAAArc,KAAAwJ,YAAAjsC,EAAA,KACAsY,EAAAwmC,oBAAA,EAAArc,KAAAwJ,YAAAjsC,EAAA,IAEAvB,UAAAwtC,YAAArsC,KAAA,GAAAoF,OAAAod,QAAA5iB,EAAAC,EAAAjB,EAAA8Z,IAMA,GAAAmqB,KAAAyJ,YAEA,OAAAlsC,GAAA,EAAAsM,EAAAm2B,KAAAyJ,YAAAjsC,OAAgDqM,EAAAtM,EAAOA,GAAA8+C,oBAAA,CAEvD,GAAApjC,GAAA+mB,KAAAyJ,YAAAlsC,GACA4L,EAAAkzC,oBAAA,EAAArc,KAAAyJ,YAAAlsC,EAAA,KACAlF,EAAAgkD,oBAAA,EAAArc,KAAAyJ,YAAAlsC,EAAA,KACAwf,EAAAs/B,oBAAA,EAAArc,KAAAyJ,YAAAlsC,EAAA,IAEAvB,UAAAytC,YAAAtsC,KAAA,GAAAoF,OAAAod,QAAA1G,EAAA9P,EAAA9Q,EAAA0kB,IAMA/gB,SAAAsgD,MAAAtc,KAAAsc,MAEAtgD,SAAAsgD,OAAAtgD,SAAAsgD,MAAA9+C,OAAA,IAAAxB,SAAAwtC,YAAAhsC,SAAAxB,SAAAytC,YAAAjsC,QAAAxB,SAAAytC,YAAAjsC,SAAAxB,SAAAooB,SAAA5mB,SAEA+E,MAAAK,KAAA,wDAAA5G,SAAAooB,SAAA5mB,OAAA,mBACAxB,SAAAytC,YAAAjsC,OAAA,uBAAAxB,SAAAwtC,YAAAhsC,OAAA,mBAOAxB,SAAAugD,UAAAvc,KAAAuc,UACAvgD,SAAAwgD,WAAAxc,KAAAwc,WAIA,QAAAC,eAAAjxB,OAEA,GAAA/oB,SAAAu9B,KAAAqJ,aAAA,CAEA,GAAA9rC,GAAAsM,EAAAiP,EAAA+xB,GAAA6R,YAAAC,WAEA,KAAAp/C,EAAA,EAAAsM,EAAAm2B,KAAAqJ,aAAA7rC,OAA6CqM,EAAAtM,EAAOA,IASpD,IAPAvB,SAAAqtC,aAAA9rC,MACAvB,SAAAqtC,aAAA9rC,GAAAs/B,KAAAmD,KAAAqJ,aAAA9rC,GAAAs/B,KACA7gC,SAAAqtC,aAAA9rC,GAAA6mB,YAEAs4B,YAAA1gD,SAAAqtC,aAAA9rC,GAAA6mB,SACAu4B,YAAA3c,KAAAqJ,aAAA9rC,GAAA6mB,SAEAtL,EAAA,EAAA+xB,GAAA8R,YAAAn/C,OAAyCqtC,GAAA/xB,EAAQA,GAAA,GAEjD,GAAAuxB,QAAA,GAAA9nC,OAAAgW,OACA8xB,QAAAttC,EAAA4/C,YAAA7jC,GAAA0S,MACA6e,OAAArtC,EAAA2/C,YAAA7jC,EAAA,GAAA0S,MACA6e,OAAAtuC,EAAA4gD,YAAA7jC,EAAA,GAAA0S,MAEAkxB,YAAAv/C,KAAAktC,SAQA,GAAA5nC,SAAAu9B,KAAAsJ,YAAA,CAEA,GAAA/rC,GAAAsM,EAAAxR,EAAAukD,GAAAC,UAAAC,UAAA1gD,KAEA,KAAAmB,EAAA,EAAAsM,EAAAm2B,KAAAsJ,YAAA9rC,OAA4CqM,EAAAtM,EAAOA,IASnD,IAPAvB,SAAAstC,YAAA/rC,MACAvB,SAAAstC,YAAA/rC,GAAAs/B,KAAAmD,KAAAsJ,YAAA/rC,GAAAs/B,KACA7gC,SAAAstC,YAAA/rC,GAAAumC,UAEA+Y,UAAA7gD,SAAAstC,YAAA/rC,GAAAumC,OACAgZ,UAAA9c,KAAAsJ,YAAA/rC,GAAAumC,OAEAzrC,EAAA,EAAAukD,GAAAE,UAAAt/C,OAAuCo/C,GAAAvkD,EAAQA,GAAA,EAE/C+D,MAAA,GAAAmG,OAAAuG,MAAA,UACA1M,MAAA2M,OAAA+zC,UAAAzkD,GAAAykD,UAAAzkD,EAAA,GAAAykD,UAAAzkD,EAAA,IACAwkD,UAAA1/C,KAAAf,QAxZA,GAAAJ,UAAA,GAAAuG,OAAA4hB,SACAqH,MAAA/oB,SAAAu9B,KAAAxU,MAAA,EAAAwU,KAAAxU,MAAA,CAiaA,IA/ZAgwB,WAAAhwB,OAEA4wB,YACAK,cAAAjxB,OAEAxvB,SAAA6oC,qBACA7oC,SAAAq3B,wBAyZA5wB,SAAAu9B,KAAAC,WAAA,IAAAD,KAAAC,UAAAziC,OAEA,OAAUxB,kBAIV,IAAAikC,WAAApnC,KAAAm7C,cAAAhU,KAAAC,UAAAgU,YAQA,OANAp7C,MAAAs7C,cAAAlU,YAEAjkC,SAAA0pC,mBAIU1pC,kBAAAikC,sBAYV19B,MAAAw6C,eAAA,SAAAlD,OAAAC,WAAAC,SAEA,GAAAh2B,OAAAlrB,KAEAX,OAAA,EAAA+/B,MAAA,CAEAp/B,MAAAghD,cACAhhD,KAAAihD,sBACAjhD,KAAAkhD,gBAEAlhD,KAAA2hD,UAAA,SAAA1G,KAEA7b,SAIAp/B,KAAAwhD,QAAA,SAAAvG,KAEA57C,SAEAuK,SAAAshB,MAAA+1B,YAEA/1B,MAAA+1B,WAAAhG,IAAA57C,OAAA+/B,OAIA//B,SAAA+/B,OAAAx1B,SAAAshB,MAAA81B,QAEA91B,MAAA81B,WAQAt3C,MAAAq3C,sBAAA,GAAAr3C,OAAAw6C,eAQAx6C,MAAAy6C,qBAAA,SAAArD,SAEA9gD,KAAA8gD,QAAAl3C,SAAAk3C,gBAAAp3C,MAAAq3C,uBAIAr3C,MAAAy6C,qBAAA7jD,WAEAM,YAAA8I,MAAAy6C,qBAEA/H,KAAA,SAAAnB,IAAA+F,OAAAC,WAAAC,SAEA,GAAAh2B,OAAAlrB,KAEAk8C,OAAA,GAAAxyC,OAAAm3C,UAAA31B,MAAA41B,QACA5E,QAAA2F,eAAA7hD,KAAAq6C,aACA6B,OAAAE,KAAAnB,IAAA,SAAAmJ,MAEApD,OAAA91B,MAAAgd,MAAA5/B,KAAA4/B,MAAAkc,SAEGnD,WAAAC,UAIHW,eAAA,SAAAtxC,OAEAvQ,KAAAq6C,YAAA9pC,OAIA23B,MAAA,SAAAf,MAEA,GAAAhkC,UAAA,GAAAuG,OAAA8hB,eAEAC,WAAA0b,KAAAI,KAAA9b,UAEA,QAAAtqB,OAAAsqB,YAAA,CAEA,GAAAjI,WAAAiI,WAAAtqB,KACAkjD,WAAA,GAAAtiD,MAAAyhB,UAAApd,MAAAod,UAAAhQ,MAEArQ,UAAAinC,aAAAjpC,IAAA,GAAAuI,OAAAg/B,gBAAA2b,WAAA7gC,UAAAC,WAIA,GAAAymB,SAAA/C,KAAAI,KAAA2C,OAEAtgC,UAAAsgC,UAEA/mC,SAAA+mC,QAAA5hC,KAAA4/B,MAAA5/B,KAAAC,UAAA2hC,UAIA,IAAA3P,gBAAA4M,KAAAI,KAAAhN,cAEA,IAAA3wB,SAAA2wB,eAAA,CAEA,GAAA5R,QAAA,GAAAjf,OAAAgW,OAEA9V,UAAA2wB,eAAA5R,QAEAA,OAAApV,UAAAgnB,eAAA5R,QAIAxlB,SAAAo3B,eAAA,GAAA7wB,OAAAkiB,OAAAjD,OAAA4R,eAAA1O,QAIA,MAAA1oB,YAYAuG,MAAA46C,eAAA,SAAAxD,SAEA9gD,KAAA8gD,QAAAl3C,SAAAk3C,gBAAAp3C,MAAAq3C,uBAIAr3C,MAAA46C,eAAAhkD,WAEAM,YAAA8I,MAAA46C,eAEAlI,KAAA,SAAAnB,IAAA+F,OAAAC,WAAAC,SAEA,GAAAh2B,OAAAlrB,KAEAk8C,OAAA,GAAAxyC,OAAAm3C,UAAA31B,MAAA41B,QACA5E,QAAA2F,eAAA7hD,KAAAq6C,aACA6B,OAAAE,KAAAnB,IAAA,SAAAmJ,MAEApD,OAAA91B,MAAAgd,MAAA5/B,KAAA4/B,MAAAkc,SAEGnD,WAAAC,UAIHW,eAAA,SAAAtxC,OAEAvQ,KAAAq6C,YAAA9pC,OAIA23B,MAAA,SAAAf,MAEA,GAAA9jC,UAAA,GAAAqG,OAAAy9B,KAAA/gC,KAqBA,IAnBAwD,SAAAu9B,KAAA5jC,OAAAF,SAAAE,MAAAkN,OAAA02B,KAAA5jC,OACAqG,SAAAu9B,KAAAiX,UAAA/6C,SAAA+6C,SAAA3tC,OAAA02B,KAAAiX,UACAx0C,SAAAu9B,KAAA+W,UAAA76C,SAAA66C,SAAAztC,OAAA02B,KAAA+W,UACAt0C,SAAAu9B,KAAAoX,YAAAl7C,SAAAk7C,UAAApX,KAAAoX,WACA30C,SAAAu9B,KAAAod,WAAAlhD,SAAAkhD,SAAApd,KAAAod,UACA36C,SAAAu9B,KAAAqd,eAAAnhD,SAAAmhD,aAAArd,KAAAqd,cACA56C,SAAAu9B,KAAAsd,iBAAAphD,SAAAohD,eAAAtd,KAAAsd,gBACA76C,SAAAu9B,KAAAmB,eAAAjlC,SAAAilC,aAAAnB,KAAAmB,cACA1+B,SAAAu9B,KAAAoW,UAAAl6C,SAAAk6C,QAAApW,KAAAoW,SACA3zC,SAAAu9B,KAAAqW,WAAAn6C,SAAAm6C,SAAArW,KAAAqW,UACA5zC,SAAAu9B,KAAA0W,OAAAx6C,SAAAw6C,KAAA1W,KAAA0W,MACAj0C,SAAAu9B,KAAA+V,UAAA75C,SAAA65C,QAAA/V,KAAA+V,SACAtzC,SAAAu9B,KAAAsW,cAAAp6C,SAAAo6C,YAAAtW,KAAAsW,aACA7zC,SAAAu9B,KAAA3jC,YAAAH,SAAAG,UAAA2jC,KAAA3jC,WAGAoG,SAAAu9B,KAAApd,OAAA1mB,SAAA0mB,KAAAod,KAAApd,MACAngB,SAAAu9B,KAAAud,kBAAArhD,SAAAqhD,gBAAAvd,KAAAud,iBAEA96C,SAAAu9B,KAAAC,UAEA,OAAA1iC,GAAA,EAAAsM,EAAAm2B,KAAAC,UAAAziC,OAA8CqM,EAAAtM,EAAOA,IAErDrB,SAAA+jC,UAAA9iC,KAAAtE,KAAAkoC,MAAAf,KAAAC,UAAA1iC,IAMA,OAAArB,YAYAqG,MAAAi7C,aAAA,SAAA7D,SAEA9gD,KAAA8gD,QAAAl3C,SAAAk3C,gBAAAp3C,MAAAq3C,sBACA/gD,KAAAo7C,YAAA,IAIA1xC,MAAAi7C,aAAArkD,WAEAM,YAAA8I,MAAAi7C,aAEAvI,KAAA,SAAAnB,IAAA+F,OAAAC,WAAAC,SAEA,KAAAlhD,KAAAo7C,cAEAp7C,KAAAo7C,YAAAH,IAAA2J,UAAA,EAAA3J,IAAA4J,YAAA,QAIA,IAAA35B,OAAAlrB,KAEAk8C,OAAA,GAAAxyC,OAAAm3C,UAAA31B,MAAA41B,QACA5E,QAAA2F,eAAA7hD,KAAAq6C,aACA6B,OAAAE,KAAAnB,IAAA,SAAAmJ,MAEAl5B,MAAAgd,MAAA5/B,KAAA4/B,MAAAkc,MAAApD,SAEGC,WAAAC,UAIH4D,eAAA,SAAAv0C,OAEAvQ,KAAAo7C,YAAA7qC,OAIAsxC,eAAA,SAAAtxC,OAEAvQ,KAAAq6C,YAAA9pC,OAIA23B,MAAA,SAAAf,KAAA6Z,QAEA,GAAA/Z,YAAAjnC,KAAA+kD,gBAAA5d,KAAAF,YAEA+d,OAAAhlD,KAAAilD,YAAA9d,KAAA6d,OAAA,WAEAp7C,SAAAo3C,eAAA/1B,UAGAi6B,SAAAllD,KAAAmlD,cAAAhe,KAAA+d,SAAAF,QACA5d,UAAApnC,KAAAolD,eAAAje,KAAAC,UAAA8d,UACAj6B,OAAAjrB,KAAAsnC,YAAAH,KAAAlc,OAAAgc,WAAAG,UAQA,QANAx9B,SAAAu9B,KAAA6d,QAAA,IAAA7d,KAAA6d,OAAArgD,SAEAiF,SAAAo3C,eAAA/1B,QAIAA,QAIA85B,gBAAA,SAAA5d,MAEA,GAAAF,cAEA,IAAAr9B,SAAAu9B,KAKA,OAHAke,gBAAA,GAAA37C,OAAAo4C,WACAwD,qBAAA,GAAA57C,OAAAy6C,qBAEAz/C,EAAA,EAAAsM,EAAAm2B,KAAAxiC,OAAoCqM,EAAAtM,EAAOA,IAAA,CAE3C,GAAAvB,UACAokC,KAAAJ,KAAAziC,EAEA,QAAA6iC,KAAAnhC,MAEA,oBACA,0BAEAjD,SAAA,GAAAuG,OAAA69B,KAAAnhC,MACAmhC,KAAA8P,MACA9P,KAAA+P,OACA/P,KAAAge,cACAhe,KAAAie,eAGA,MAEA,mBACA,mBAEAriD,SAAA,GAAAuG,OAAAtG,YACAmkC,KAAA8P,MACA9P,KAAA+P,OACA/P,KAAAke,MACAle,KAAAge,cACAhe,KAAAie,eACAje,KAAAme,cAGA,MAEA,sBAEAviD,SAAA,GAAAuG,OAAAi8C,eACApe,KAAA1b,OACA0b,KAAAqe,SAGA,MAEA,wBAEAziD,SAAA,GAAAuG,OAAAm8C,iBACAte,KAAAue,UACAve,KAAAwe,aACAxe,KAAA+P,OACA/P,KAAAye,eACAze,KAAAie,eACAje,KAAA0e,UAGA,MAEA,sBAEA9iD,SAAA,GAAAuG,OAAAw8C,eACA3e,KAAA1b,OACA0b,KAAAge,cACAhe,KAAAie,eACAje,KAAA4e,SACA5e,KAAA6e,UACA7e,KAAA8e,WACA9e,KAAA+e,YAGA,MAEA,2BAEAnjD,SAAA,GAAAuG,OAAA68C,oBACAhf,KAAA1b,OACA0b,KAAAif,OAGA,MAEA,qBAEArjD,SAAA,GAAAuG,OAAA+8C,cACAlf,KAAA1b,OACA0b,KAAAmf,KACAnf,KAAAye,eACAze,KAAAof,gBACApf,KAAAqf,IAGA,MAEA,yBAEAzjD,SAAA,GAAAuG,OAAAm9C,kBACAtf,KAAA1b,OACA0b,KAAAmf,KACAnf,KAAAye,eACAze,KAAAof,gBACApf,KAAA9nC,EACA8nC,KAAAr2B,EACAq2B,KAAAuf,YAGA,MAEA,sBAEA3jD,SAAAmiD,qBAAApd,MAAAX,KAEA,MAEA,gBAEApkC,SAAAkiD,eAAAnd,MAAAX,WAAApkC,SAMAA,SAAA64B,KAAAuL,KAAAvL,KAEApyB,SAAA29B,KAAAvD,OAAA7gC,SAAA6gC,KAAAuD,KAAAvD,MAEAiD,WAAAM,KAAAvL,MAAA74B,SAMA,MAAA8jC,aAIAme,eAAA,SAAAje,KAAA+d,UAEA,GAAA9d,aAEA,IAAAx9B,SAAAu9B,KAgBA,OAdA4f,YAAA,SAAA/iB,MAQA,MANAp6B,UAAAs7C,SAAAlhB,OAEAt6B,MAAAK,KAAA,wCAAAi6B,MAIAkhB,SAAAlhB,OAIAkY,OAAA,GAAAxyC,OAAA46C,eAEA5/C,EAAA,EAAAsM,EAAAm2B,KAAAxiC,OAAoCqM,EAAAtM,EAAOA,IAAA,CAE3C,GAAA6iC,MAAAJ,KAAAziC,GACArB,SAAA64C,OAAAhU,MAAAX,KAEAlkC,UAAA24B,KAAAuL,KAAAvL,KAEApyB,SAAA29B,KAAAvD,OAAA3gC,SAAA2gC,KAAAuD,KAAAvD,MAEAp6B,SAAA29B,KAAA4V,MAEA95C,SAAA85C,IAAA4J,WAAAxf,KAAA4V,MAIAvzC,SAAA29B,KAAA+V,UAEAj6C,SAAAi6C,QAAAyJ,WAAAxf,KAAA+V,SACA/V,KAAAgZ,YACAl9C,SAAAk9C,UAAA,GAAA72C,OAAAiY,QAAA4lB,KAAAgZ,UAAAhZ,KAAAgZ,aAKA32C,SAAA29B,KAAAyf,WAEA3jD,SAAA2jD,SAAAD,WAAAxf,KAAAyf,WAIAp9C,SAAA29B,KAAA0f,SAEA5jD,SAAA4jD,OAAAF,WAAAxf,KAAA0f,SAIAr9C,SAAA29B,KAAA8V,YAEAh6C,SAAAg6C,UAAA0J,WAAAxf,KAAA8V,WACA9V,KAAAkZ,cACAp9C,SAAAo9C,YAAA,GAAA/2C,OAAAiY,QAAA4lB,KAAAkZ,YAAAlZ,KAAAkZ,eAKA72C,SAAA29B,KAAA6V,WAEA/5C,SAAA+5C,SAAA2J,WAAAxf,KAAA6V,WAIAxzC,SAAA29B,KAAA2f,cAEA7jD,SAAA6jD,YAAAH,WAAAxf,KAAA2f,cAIA9f,UAAAG,KAAAvL,MAAA34B,SAMA,MAAA+jC,YAIA6d,YAAA,SAAA9d,KAAA6Z,QAEA,GAAA91B,OAAAlrB,KACAglD,SAEA,IAAAp7C,SAAAu9B,WAAAxiC,OAAA,GAEA,GAAAm8C,SAAA,GAAAp3C,OAAAw6C,eAAAlD,QAEA9E,OAAA,GAAAxyC,OAAAuwC,YAAA6G,QACA5E,QAAA2F,eAAA7hD,KAAAq6C,YAcA,QAZA8M,WAAA,SAAAlM,KAIA,MAFA/vB,OAAA41B,QAAAa,UAAA1G,KAEAiB,OAAAE,KAAAnB,IAAA,WAEA/vB,MAAA41B,QAAAU,QAAAvG,QAMAv2C,EAAA,EAAAsM,EAAAm2B,KAAAxiC,OAAoCqM,EAAAtM,EAAOA,IAAA,CAE3C,GAAA43C,OAAAnV,KAAAziC,GACA0iD,KAAA,4BAAAt+C,KAAAwzC,MAAArB,KAAAqB,MAAArB,IAAA/vB,MAAAkwB,YAAAkB,MAAArB,GAEA+J,QAAA1I,MAAAtgB,MAAAmrB,UAAAC,OAMA,MAAApC,SAIAG,cAAA,SAAAhe,KAAA6d,QAEA,GAAAE,YAEA,IAAAt7C,SAAAu9B,KAEA,OAAAziC,GAAA,EAAAsM,EAAAm2B,KAAAxiC,OAAoCqM,EAAAtM,EAAOA,IAAA,CAE3C,GAAA6iC,MAAAJ,KAAAziC,EAEAkF,UAAA29B,KAAA+U,OAEA5yC,MAAAK,KAAA,+CAAAw9B,KAAAvL,MAIApyB,SAAAo7C,OAAAzd,KAAA+U,QAEA5yC,MAAAK,KAAA,sCAAAw9B,KAAA+U,MAIA,IAAAN,SAAA,GAAAtyC,OAAA2yC,QAAA2I,OAAAzd,KAAA+U,OACAN,SAAArT,aAAA,EAEAqT,QAAAhgB,KAAAuL,KAAAvL,KAEApyB,SAAA29B,KAAAvD,OAAAgY,QAAAhY,KAAAuD,KAAAvD,MACAp6B,SAAA29B,KAAAsU,SAAAG,QAAAH,OAAA,GAAAnyC,OAAAiY,QAAA4lB,KAAAsU,OAAA,GAAAtU,KAAAsU,OAAA,KACAjyC,SAAA29B,KAAAgP,YAAAyF,QAAAzF,UAAA7sC,MAAA69B,KAAAgP,YACA3sC,SAAA29B,KAAA+O,YAAA0F,QAAA1F,UAAA5sC,MAAA69B,KAAA+O,YACA1sC,SAAA29B,KAAAwU,aAAAC,QAAAD,WAAAxU,KAAAwU,YACAxU,KAAAuU,eAAA7f,SAEA+f,QAAAU,MAAAhzC,MAAA69B,KAAAuU,KAAA,IACAE,QAAAW,MAAAjzC,MAAA69B,KAAAuU,KAAA,KAIAoJ,SAAA3d,KAAAvL,MAAAggB,QAMA,MAAAkJ,WAIA5d,YAAA,WAEA,GAAA3iB,QAAA,GAAAjb,OAAAkb,OAEA,iBAAA2iB,KAAAN,WAAAG,WAEA,GAAAnc,QAEAo8B,YAAA,SAAArjB,MAQA,MANAp6B,UAAAq9B,WAAAjD,OAEAt6B,MAAAK,KAAA,yCAAAi6B,MAIAiD,WAAAjD,OAIAsjB,YAAA,SAAAtjB,MAQA,MANAp6B,UAAAw9B,UAAApD,OAEAt6B,MAAAK,KAAA,yCAAAi6B,MAIAoD,UAAApD,MAIA,QAAAuD,KAAAnhC,MAEA,YAEA6kB,OAAA,GAAAvhB,OAAA5J,KAEA,MAEA,yBAEAmrB,OAAA,GAAAvhB,OAAA1G,kBAAAukC,KAAAlT,IAAAkT,KAAAzkC,OAAAykC,KAAArT,KAAAqT,KAAApT,IAEA,MAEA,0BAEAlJ,OAAA,GAAAvhB,OAAA85B,mBAAA+D,KAAAzT,KAAAyT,KAAAxT,MAAAwT,KAAAtT,IAAAsT,KAAAvT,OAAAuT,KAAArT,KAAAqT,KAAApT,IAEA,MAEA,oBAEAlJ,OAAA,GAAAvhB,OAAA89B,aAAAD,KAAAhkC,MAEA,MAEA,wBAEA0nB,OAAA,GAAAvhB,OAAA+9B,iBAAAF,KAAAhkC,MAAAgkC,KAAAG,UAEA,MAEA,kBAEAzc,OAAA,GAAAvhB,OAAAi+B,WAAAJ,KAAAhkC,MAAAgkC,KAAAG,UAAAH,KAAA1e,SAAA0e,KAAAK,MAEA,MAEA,iBAEA3c,OAAA,GAAAvhB,OAAAm+B,UAAAN,KAAAhkC,MAAAgkC,KAAAG,UAAAH,KAAA1e,SAAA0e,KAAAjpB,MAAAipB,KAAAO,SAAAP,KAAAK,MAEA,MAEA,uBAEA3c,OAAA,GAAAvhB,OAAAq+B,gBAAAR,KAAAhkC,MAAAgkC,KAAAS,YAAAT,KAAAG,UAEA,MAEA,YAEAzc,OAAA,GAAAvhB,OAAAhG,KAAA2jD,YAAA9f,KAAApkC,UAAAmkD,YAAA/f,KAAAlkC,UAEA,MAEA,YAEA4nB,OAAA,GAAAvhB,OAAAm5B,KAAAwkB,YAAA9f,KAAApkC,UAAAmkD,YAAA/f,KAAAlkC,UAAAkkC,KAAAU,KAEA,MAEA,kBAEAhd,OAAA,GAAAvhB,OAAAg5B,WAAA2kB,YAAA9f,KAAApkC,UAAAmkD,YAAA/f,KAAAlkC,UAEA,MAEA,cAEA4nB,OAAA,GAAAvhB,OAAA+4B,OAAA6kB,YAAA/f,KAAAlkC,UAEA,MAEA,aAEA4nB,OAAA,GAAAvhB,OAAA69C,KAEA,MAEA,SAEAt8B,OAAA,GAAAvhB,OAAAk6B,SAuBA,GAnBA3Y,OAAA+Q,KAAAuL,KAAAvL,KAEApyB,SAAA29B,KAAAvD,OAAA/Y,OAAA+Y,KAAAuD,KAAAvD,MACAp6B,SAAA29B,KAAA5iB,QAEAA,OAAApR,UAAAg0B,KAAA5iB,QACAA,OAAA8O,UAAAxI,OAAAhoB,SAAAgoB,OAAA1N,WAAA0N,OAAA0H,SAIA/oB,SAAA29B,KAAAtkC,UAAAgoB,OAAAhoB,SAAAsQ,UAAAg0B,KAAAtkC,UACA2G,SAAA29B,KAAAtjC,UAAAgnB,OAAAhnB,SAAAsP,UAAAg0B,KAAAtjC,UACA2F,SAAA29B,KAAA5U,OAAA1H,OAAA0H,MAAApf,UAAAg0B,KAAA5U,QAIA/oB,SAAA29B,KAAA7C,UAAAzZ,OAAAyZ,QAAA6C,KAAA7C,SACA96B,SAAA29B,KAAAxC,WAAA9Z,OAAA8Z,SAAAwC,KAAAxC,UAEAn7B,SAAA29B,KAAAnE,SAEA,OAAA8C,SAAAqB,MAAAnE,SAEAnY,OAAAtnB,IAAA3D,KAAAsnC,YAAAC,KAAAnE,SAAA8C,OAAAe,WAAAG,WAMA,OAAAnc,aAcAvhB,MAAA89C,cAAA,SAAA1G,SAEA9gD,KAAA8gD,QAAAl3C,SAAAk3C,gBAAAp3C,MAAAq3C,uBAIAr3C,MAAA89C,cAAAlnD,WAEAM,YAAA8I,MAAA89C,cAEApL,KAAA,SAAAnB,IAAA+F,OAAAC,WAAAC,SAEA,GAAAh2B,OAAAlrB,KAEAk8C,OAAA,GAAAxyC,OAAAuwC,YAAA/uB,MAAA41B,QACA5E,QAAA2F,eAAA7hD,KAAAq6C,aACA6B,OAAAE,KAAAnB,IAAA,SAAAqB,OAEA,GAAAN,SAAA,GAAAtyC,OAAA2yC,QAAAC,MACAN,SAAArT,aAAA,EAEA/+B,SAAAo3C,QAEAA,OAAAhF,UAIGiF,WAAAC,UAIHW,eAAA,SAAAtxC,OAEAvQ,KAAAq6C,YAAA9pC,QAcA7G,MAAA+9C,kBAAA/9C,MAAAg+C,oBAAA,WAGA1nD,KAAA2nD,QAAA,MAIAj+C,MAAAg+C,oBAAApnD,WAEAM,YAAA8I,MAAAg+C,oBAEAtL,KAAA,SAAAnB,IAAA+F,OAAAC,WAAAC,SAEA,GAAAh2B,OAAAlrB,KAEAg8C,QAAA,GAAAtyC,OAAAk+C,YAEA1L,OAAA,GAAAxyC,OAAAm3C,SA2DA,OA1DA3E,QAAA0F,gBAAA,eAEA1F,OAAAE,KAAAnB,IAAA,SAAA4M,QAEA,GAAAC,SAAA58B,MAAAy8B,QAAAE,OAEAC,WAEAl+C,SAAAk+C,QAAAxL,MAEAN,QAAAM,MAAAwL,QAAAxL,MAEI1yC,SAAAk+C,QAAAvgB,OAEJyU,QAAAM,MAAAjF,MAAAyQ,QAAAzQ,MACA2E,QAAAM,MAAAhF,OAAAwQ,QAAAxQ,OACA0E,QAAAM,MAAA/U,KAAAugB,QAAAvgB,MAIAyU,QAAAU,MAAA9yC,SAAAk+C,QAAApL,MAAAoL,QAAApL,MAAAhzC,MAAA6D,oBACAyuC,QAAAW,MAAA/yC,SAAAk+C,QAAAnL,MAAAmL,QAAAnL,MAAAjzC,MAAA6D,oBAEAyuC,QAAA1F,UAAA1sC,SAAAk+C,QAAAxR,UAAAwR,QAAAxR,UAAA5sC,MAAAkE,aACAouC,QAAAzF,UAAA3sC,SAAAk+C,QAAAvR,UAAAuR,QAAAvR,UAAA7sC,MAAAoE,yBAEAkuC,QAAAD,WAAAnyC,SAAAk+C,QAAA/L,WAAA+L,QAAA/L,WAAA,EAEAnyC,SAAAk+C,QAAAzR,SAEA2F,QAAA3F,OAAAyR,QAAAzR,QAGAzsC,SAAAk+C,QAAA1hD,OAEA41C,QAAA51C,KAAA0hD,QAAA1hD,MAIAwD,SAAAk+C,QAAAC,UAEA/L,QAAA+L,QAAAD,QAAAC,SAIA,IAAAD,QAAAE,cAEAhM,QAAAzF,UAAA7sC,MAAAkE,cAIAouC,QAAArT,aAAA,EAEAqY,eAAAhF,QAAA8L,WAEG7G,WAAAC,SAGHlF,UAcAtyC,MAAAu+C,wBAAA,WAGAjoD,KAAA2nD,QAAA,MAKAj+C,MAAAu+C,wBAAA3nD,WAEAM,YAAA8I,MAAAu+C,wBAEA7L,KAAA,SAAAnB,IAAA+F,OAAAE,SAEA,GAAAh2B,OAAAlrB,KAEAglD,UAEAhJ,QAAA,GAAAtyC,OAAAw+C,iBACAlM,SAAAM,MAAA0I,MAEA,IAAA9I,QAAA,GAAAxyC,OAAAm3C,SAGA,IAFA3E,OAAA0F,gBAAA,eAEA3G,cAAAhf,OAmCA,OAjCA58B,QAAA,EAEA8oD,YAAA,SAAAzjD,GAEAw3C,OAAAE,KAAAnB,IAAAv2C,GAAA,SAAAmjD,QAEA,GAAAO,UAAAl9B,MAAAy8B,QAAAE,QAAA,EAEA7C,QAAAtgD,IACA2yC,MAAA+Q,SAAA/Q,MACAC,OAAA8Q,SAAA9Q,OACAjB,OAAA+R,SAAA/R,OACA0R,QAAAK,SAAAL,SAGA1oD,QAAA,EAEA,IAAAA,SAEA,GAAA+oD,SAAAJ,cACAhM,QAAAzF,UAAA7sC,MAAAkE,cAEAouC,QAAA3F,OAAA+R,SAAA/R,OACA2F,QAAArT,aAAA,EAEAqY,eAAAhF,aAQAt3C,EAAA,EAAAklB,GAAAqxB,IAAAt2C,OAAoCilB,GAAAllB,IAAQA,EAE5CyjD,YAAAzjD,OAQAw3C,QAAAE,KAAAnB,IAAA,SAAA4M,QAEA,GAAAO,UAAAl9B,MAAAy8B,QAAAE,QAAA,EAEA,IAAAO,SAAAC,UAIA,OAFAzd,OAAAwd,SAAAL,QAAApjD,OAAAyjD,SAAAJ,YAEAn7B,EAAA,EAAqB+d,MAAA/d,EAAWA,IAAA,CAEhCm4B,OAAAn4B,IAAqBk7B,WAErB,QAAArjD,GAAA,EAAsBA,EAAA0jD,SAAAJ,YAA0BtjD,IAEhDsgD,OAAAn4B,GAAAk7B,QAAAzjD,KAAA8jD,SAAAL,QAAAl7B,EAAAu7B,SAAAJ,YAAAtjD,IACAsgD,OAAAn4B,GAAAwpB,OAAA+R,SAAA/R,OACA2O,OAAAn4B,GAAAwqB,MAAA+Q,SAAA/Q,MACA2N,OAAAn4B,GAAAyqB,OAAA8Q,SAAA9Q,WAQA0E,SAAAM,MAAAjF,MAAA+Q,SAAA/Q,MACA2E,QAAAM,MAAAhF,OAAA8Q,SAAA9Q,OACA0E,QAAA+L,QAAAK,SAAAL,OAIA,KAAAK,SAAAJ,cAEAhM,QAAAzF,UAAA7sC,MAAAkE,cAIAouC,QAAA3F,OAAA+R,SAAA/R,OACA2F,QAAArT,aAAA,EAEAqY,eAAAhF,UAMA,OAAAA,WAaAtyC,MAAA4+C,SAAA,WAEAzkB,OAAAC,eAAA9jC,KAAA,MAAqCuQ,MAAA7G,MAAA6+C,oBAErCvoD,KAAAg8B,KAAAtyB,MAAAG,KAAAgyB,eAEA77B,KAAAgkC,KAAA,GACAhkC,KAAAoG,KAAA,WAEApG,KAAA69C,KAAAn0C,MAAAoB,UAEA9K,KAAAk9C,QAAA,EACAl9C,KAAAy9C,aAAA,EAEAz9C,KAAAw9C,SAAA9zC,MAAA8B,eAEAxL,KAAAwoD,SAAA9+C,MAAA4C,eACAtM,KAAAyoD,SAAA/+C,MAAA6C,uBACAvM,KAAA0oD,cAAAh/C,MAAAmC,YACA7L,KAAA2oD,cAAA,KACA3oD,KAAA4oD,cAAA,KACA5oD,KAAA6oD,mBAAA,KAEA7oD,KAAA09C,WAAA,EACA19C,KAAA29C,YAAA,EAEA39C,KAAA8oD,YAAA,EAEA9oD,KAAA+oD,eAAA,EACA/oD,KAAAgpD,oBAAA,EACAhpD,KAAAipD,mBAAA,EAEAjpD,KAAAkpD,UAAA,EAEAlpD,KAAAmpD,SAAA,EAEAnpD,KAAA0kC,SAAA,EAEA1kC,KAAAopD,cAAA,GAIA1/C,MAAA4+C,SAAAhoD,WAEAM,YAAA8I,MAAA4+C,SAEAjrC,GAAAsrB,eAEA,MAAA3oC,MAAAopD,cAIA/rC,GAAAsrB,aAAAp4B,OAEAA,SAAA,GAAAvQ,KAAAwG,SAEAxG,KAAAopD,aAAA74C,OAIA84C,UAAA,SAAAC,QAEA,GAAA1/C,SAAA0/C,OAEA,OAAAnoD,OAAAmoD,QAAA,CAEA,GAAAC,UAAAD,OAAAnoD,IAEA,IAAAyI,SAAA2/C,UAOA,GAAApoD,MAAAnB,MAAA,CAEA,GAAAwpD,cAAAxpD,KAAAmB,IAEAqoD,wBAAA9/C,OAAAuG,MAEAu5C,aAAAr5C,IAAAo5C,UAEKC,uBAAA9/C,OAAAgW,SAAA6pC,mBAAA7/C,OAAAgW,QAEL8pC,aAAAh5C,KAAA+4C,UAEK,YAAApoD,IAGLnB,KAAAmB,KAAAsoD,OAAAF,UAIAvpD,KAAAmB,KAAAooD,cAxBA7/C,OAAAK,KAAA,oBAAA5I,IAAA,+BAkCAylC,OAAA,WAEA,GAAAC,SACAC,UACAC,QAAA,IACA3gC,KAAA,WACA4gC,UAAA,oBAEAhL,KAAAh8B,KAAAg8B,KACA51B,KAAApG,KAAAoG,KAmEA,OAhEA,KAAApG,KAAAgkC,OAAA6C,OAAA7C,KAAAhkC,KAAAgkC,MAEAhkC,eAAA0J,OAAApG,mBAEAujC,OAAAtjC,MAAAvD,KAAAuD,MAAA0O,SACAjS,KAAAsoC,eAAA5+B,MAAA0B,WAAAy7B,OAAAyB,aAAAtoC,KAAAsoC,cACAtoC,KAAAw9C,WAAA9zC,MAAA8B,iBAAAq7B,OAAA2W,SAAAx9C,KAAAw9C,UACAx9C,KAAA69C,OAAAn0C,MAAAoB,YAAA+7B,OAAAgX,KAAA79C,KAAA69C,OAEG79C,eAAA0J,OAAAggD,qBAEH7iB,OAAAtjC,MAAAvD,KAAAuD,MAAA0O,SACA40B,OAAAuX,SAAAp+C,KAAAo+C,SAAAnsC,SACAjS,KAAAsoC,eAAA5+B,MAAA0B,WAAAy7B,OAAAyB,aAAAtoC,KAAAsoC,cACAtoC,KAAAu9C,UAAA7zC,MAAAyB,gBAAA07B,OAAA0W,QAAAv9C,KAAAu9C,SACAv9C,KAAAw9C,WAAA9zC,MAAA8B,iBAAAq7B,OAAA2W,SAAAx9C,KAAAw9C,UACAx9C,KAAA69C,OAAAn0C,MAAAoB,YAAA+7B,OAAAgX,KAAA79C,KAAA69C,OAEG79C,eAAA0J,OAAAigD,mBAEH9iB,OAAAtjC,MAAAvD,KAAAuD,MAAA0O,SACA40B,OAAAuX,SAAAp+C,KAAAo+C,SAAAnsC,SACA40B,OAAAqX,SAAAl+C,KAAAk+C,SAAAjsC,SACA40B,OAAA0X,UAAAv+C,KAAAu+C,UACAv+C,KAAAsoC,eAAA5+B,MAAA0B,WAAAy7B,OAAAyB,aAAAtoC,KAAAsoC,cACAtoC,KAAAu9C,UAAA7zC,MAAAyB,gBAAA07B,OAAA0W,QAAAv9C,KAAAu9C,SACAv9C,KAAAw9C,WAAA9zC,MAAA8B,iBAAAq7B,OAAA2W,SAAAx9C,KAAAw9C,UACAx9C,KAAA69C,OAAAn0C,MAAAoB,YAAA+7B,OAAAgX,KAAA79C,KAAA69C,OAEG79C,eAAA0J,OAAAkgD,oBAEH5pD,KAAAw9C,WAAA9zC,MAAA8B,iBAAAq7B,OAAA2W,SAAAx9C,KAAAw9C,UACAx9C,KAAA69C,OAAAn0C,MAAAoB,YAAA+7B,OAAAgX,KAAA79C,KAAA69C,OAEG79C,eAAA0J,OAAAmgD,mBAEH7pD,KAAAw9C,WAAA9zC,MAAA8B,iBAAAq7B,OAAA2W,SAAAx9C,KAAAw9C,UACAx9C,KAAA69C,OAAAn0C,MAAAoB,YAAA+7B,OAAAgX,KAAA79C,KAAA69C,OAEG79C,eAAA0J,OAAAogD,oBAEHjjB,OAAA9c,KAAA/pB,KAAA+pB,KACA8c,OAAA6d,gBAAA1kD,KAAA0kD,gBACA7d,OAAAtjC,MAAAvD,KAAAuD,MAAA0O,SAEAjS,KAAAsoC,eAAA5+B,MAAA0B,WAAAy7B,OAAAyB,aAAAtoC,KAAAsoC,cACAtoC,KAAAw9C,WAAA9zC,MAAA8B,iBAAAq7B,OAAA2W,SAAAx9C,KAAAw9C,WAEGx9C,eAAA0J,OAAA6xC,gBAEH1U,OAAA0d,SAAAvkD,KAAAukD,SACA1d,OAAA2d,aAAAxkD,KAAAwkD,aACA3d,OAAA4d,eAAAzkD,KAAAykD,gBAEGzkD,eAAA0J,OAAAqgD,iBAEHljB,OAAAtjC,MAAAvD,KAAAuD,MAAA0O,UAIAjS,KAAAk9C,QAAA,IAAArW,OAAAqW,QAAAl9C,KAAAk9C,SACAl9C,KAAAy9C,eAAA,IAAA5W,OAAA4W,YAAAz9C,KAAAy9C,aACAz9C,KAAAwD,aAAA,IAAAqjC,OAAArjC,UAAAxD,KAAAwD,WAEAqjC,QAIAlzB,MAAA,SAAAtQ,UAiCA,MA/BAuG,UAAAvG,oBAAA,GAAAqG,OAAA4+C,UAEAjlD,SAAA2gC,KAAAhkC,KAAAgkC,KAEA3gC,SAAAw6C,KAAA79C,KAAA69C,KAEAx6C,SAAA65C,QAAAl9C,KAAAk9C,QACA75C,SAAAo6C,YAAAz9C,KAAAy9C,YAEAp6C,SAAAm6C,SAAAx9C,KAAAw9C,SAEAn6C,SAAAmlD,SAAAxoD,KAAAwoD,SACAnlD,SAAAolD,SAAAzoD,KAAAyoD,SACAplD,SAAAqlD,cAAA1oD,KAAA0oD,cACArlD,SAAAslD,cAAA3oD,KAAA2oD,cACAtlD,SAAAulD,cAAA5oD,KAAA4oD,cACAvlD,SAAAwlD,mBAAA7oD,KAAA6oD,mBAEAxlD,SAAAq6C,UAAA19C,KAAA09C,UACAr6C,SAAAs6C,WAAA39C,KAAA29C,WAEAt6C,SAAA0lD,cAAA/oD,KAAA+oD,cACA1lD,SAAA2lD,oBAAAhpD,KAAAgpD,oBACA3lD,SAAA4lD,mBAAAjpD,KAAAipD,mBAEA5lD,SAAA6lD,UAAAlpD,KAAAkpD,UAEA7lD,SAAA8lD,SAAAnpD,KAAAmpD,SAEA9lD,SAAAqhC,QAAA1kC,KAAA0kC,QAEArhC,UAIAmD,OAAA,WAEAxG,KAAA+hC,eAAuB37B,KAAA,YAIvBmqC,QAAA,WAEAvwC,KAAA+hC,eAAuB37B,KAAA,cAMvBsD,MAAAk4B,gBAAAthC,UAAAiB,MAAAmI,MAAA4+C,SAAAhoD,WAEAoJ,MAAA6+C,gBAAA,EA0BA7+C,MAAAsgD,kBAAA,SAAAjV,YAEArrC,MAAA4+C,SAAAhpD,KAAAU,MAEAA,KAAAoG,KAAA,oBAEApG,KAAAuD,MAAA,GAAAmG,OAAAuG,MAAA,UAEAjQ,KAAAiqD,UAAA,EACAjqD,KAAAkqD,QAAA,QACAlqD,KAAAmqD,SAAA,QAEAnqD,KAAAsoC,aAAA5+B,MAAA0B,SAEApL,KAAAoqD,KAAA,EAEApqD,KAAAqpD,UAAAtU,aAIArrC,MAAAsgD,kBAAA1pD,UAAAujC,OAAAiG,OAAApgC,MAAA4+C,SAAAhoD,WACAoJ,MAAAsgD,kBAAA1pD,UAAAM,YAAA8I,MAAAsgD,kBAEAtgD,MAAAsgD,kBAAA1pD,UAAAqT,MAAA,WAEA,GAAAtQ,UAAA,GAAAqG,OAAAsgD,iBAcA,OAZAtgD,OAAA4+C,SAAAhoD,UAAAqT,MAAArU,KAAAU,KAAAqD,UAEAA,SAAAE,MAAAiN,KAAAxQ,KAAAuD,OAEAF,SAAA4mD,UAAAjqD,KAAAiqD,UACA5mD,SAAA6mD,QAAAlqD,KAAAkqD,QACA7mD,SAAA8mD,SAAAnqD,KAAAmqD,SAEA9mD,SAAAilC,aAAAtoC,KAAAsoC,aAEAjlC,SAAA+mD,IAAApqD,KAAAoqD,IAEA/mD,UA6BAqG,MAAA2gD,mBAAA,SAAAtV,YAEArrC,MAAA4+C,SAAAhpD,KAAAU,MAEAA,KAAAoG,KAAA,qBAEApG,KAAAuD,MAAA,GAAAmG,OAAAuG,MAAA,UAEAjQ,KAAAiqD,UAAA,EAEAjqD,KAAA2yB,MAAA,EACA3yB,KAAAsqD,SAAA,EACAtqD,KAAAuqD,QAAA,EAEAvqD,KAAAsoC,cAAA,EAEAtoC,KAAAoqD,KAAA,EAEApqD,KAAAqpD,UAAAtU,aAIArrC,MAAA2gD,mBAAA/pD,UAAAujC,OAAAiG,OAAApgC,MAAA4+C,SAAAhoD,WACAoJ,MAAA2gD,mBAAA/pD,UAAAM,YAAA8I,MAAA2gD,mBAEA3gD,MAAA2gD,mBAAA/pD,UAAAqT,MAAA,WAEA,GAAAtQ,UAAA,GAAAqG,OAAA2gD,kBAgBA,OAdA3gD,OAAA4+C,SAAAhoD,UAAAqT,MAAArU,KAAAU,KAAAqD,UAEAA,SAAAE,MAAAiN,KAAAxQ,KAAAuD,OAEAF,SAAA4mD,UAAAjqD,KAAAiqD,UAEA5mD,SAAAsvB,MAAA3yB,KAAA2yB,MACAtvB,SAAAinD,SAAAtqD,KAAAsqD,SACAjnD,SAAAknD,QAAAvqD,KAAAuqD,QAEAlnD,SAAAilC,aAAAtoC,KAAAsoC,aAEAjlC,SAAA+mD,IAAApqD,KAAAoqD,IAEA/mD,UA2CAqG,MAAApG,kBAAA,SAAAyxC,YAEArrC,MAAA4+C,SAAAhpD,KAAAU,MAEAA,KAAAoG,KAAA,oBAEApG,KAAAuD,MAAA,GAAAmG,OAAAuG,MAAA,UAEAjQ,KAAAm9C,IAAA,KAEAn9C,KAAAo9C,SAAA,KAEAp9C,KAAAknD,YAAA,KAEAlnD,KAAAgnD,SAAA,KAEAhnD,KAAAinD,OAAA,KACAjnD,KAAAwqD,QAAA9gD,MAAAmD,kBACA7M,KAAAyqD,aAAA,EACAzqD,KAAA0qD,gBAAA,IAEA1qD,KAAAoqD,KAAA,EAEApqD,KAAAu9C,QAAA7zC,MAAAyB,cAEAnL,KAAAwD,WAAA,EACAxD,KAAA2qD,mBAAA,EACA3qD,KAAA4qD,iBAAA,QACA5qD,KAAA6qD,kBAAA,QAEA7qD,KAAAsoC,aAAA5+B,MAAA0B,SAEApL,KAAA8qD,UAAA,EACA9qD,KAAAwwC,cAAA,EAEAxwC,KAAAqpD,UAAAtU,aAIArrC,MAAApG,kBAAAhD,UAAAujC,OAAAiG,OAAApgC,MAAA4+C,SAAAhoD,WACAoJ,MAAApG,kBAAAhD,UAAAM,YAAA8I,MAAApG,kBAEAoG,MAAApG,kBAAAhD,UAAAqT,MAAA,WAEA,GAAAtQ,UAAA,GAAAqG,OAAApG,iBAiCA,OA/BAoG,OAAA4+C,SAAAhoD,UAAAqT,MAAArU,KAAAU,KAAAqD,UAEAA,SAAAE,MAAAiN,KAAAxQ,KAAAuD,OAEAF,SAAA85C,IAAAn9C,KAAAm9C,IAEA95C,SAAA+5C,SAAAp9C,KAAAo9C,SAEA/5C,SAAA6jD,YAAAlnD,KAAAknD,YAEA7jD,SAAA2jD,SAAAhnD,KAAAgnD,SAEA3jD,SAAA4jD,OAAAjnD,KAAAinD,OACA5jD,SAAAmnD,QAAAxqD,KAAAwqD,QACAnnD,SAAAonD,aAAAzqD,KAAAyqD,aACApnD,SAAAqnD,gBAAA1qD,KAAA0qD,gBAEArnD,SAAA+mD,IAAApqD,KAAAoqD,IAEA/mD,SAAAk6C,QAAAv9C,KAAAu9C,QAEAl6C,SAAAG,UAAAxD,KAAAwD,UACAH,SAAAsnD,mBAAA3qD,KAAA2qD,mBACAtnD,SAAAunD,iBAAA5qD,KAAA4qD,iBACAvnD,SAAAwnD,kBAAA7qD,KAAA6qD,kBAEAxnD,SAAAilC,aAAAtoC,KAAAsoC,aAEAjlC,SAAAynD,SAAA9qD,KAAA8qD,SACAznD,SAAAmtC,aAAAxwC,KAAAwwC,aAEAntC,UA8CAqG,MAAAggD,oBAAA,SAAA3U,YAEArrC,MAAA4+C,SAAAhpD,KAAAU,MAEAA,KAAAoG,KAAA,sBAEApG,KAAAuD,MAAA,GAAAmG,OAAAuG,MAAA,UACAjQ,KAAAo+C,SAAA,GAAA10C,OAAAuG,MAAA,GAEAjQ,KAAA+qD,YAAA,EACA/qD,KAAAgrD,QAAA,GAAAthD,OAAAgW,QAAA,OAEA1f,KAAAm9C,IAAA,KAEAn9C,KAAAo9C,SAAA,KAEAp9C,KAAAknD,YAAA,KAEAlnD,KAAAgnD,SAAA,KAEAhnD,KAAAinD,OAAA,KACAjnD,KAAAwqD,QAAA9gD,MAAAmD,kBACA7M,KAAAyqD,aAAA,EACAzqD,KAAA0qD,gBAAA,IAEA1qD,KAAAoqD,KAAA,EAEApqD,KAAAu9C,QAAA7zC,MAAAyB,cAEAnL,KAAAwD,WAAA,EACAxD,KAAA2qD,mBAAA,EACA3qD,KAAA4qD,iBAAA,QACA5qD,KAAA6qD,kBAAA,QAEA7qD,KAAAsoC,aAAA5+B,MAAA0B,SAEApL,KAAA8qD,UAAA,EACA9qD,KAAAwwC,cAAA,EACAxwC,KAAA0wC,cAAA,EAEA1wC,KAAAqpD,UAAAtU,aAIArrC,MAAAggD,oBAAAppD,UAAAujC,OAAAiG,OAAApgC,MAAA4+C,SAAAhoD,WACAoJ,MAAAggD,oBAAAppD,UAAAM,YAAA8I,MAAAggD,oBAEAhgD,MAAAggD,oBAAAppD,UAAAqT,MAAA,WAEA,GAAAtQ,UAAA,GAAAqG,OAAAggD,mBAsCA,OApCAhgD,OAAA4+C,SAAAhoD,UAAAqT,MAAArU,KAAAU,KAAAqD,UAEAA,SAAAE,MAAAiN,KAAAxQ,KAAAuD,OACAF,SAAA+6C,SAAA5tC,KAAAxQ,KAAAo+C,UAEA/6C,SAAA0nD,WAAA/qD,KAAA+qD,WACA1nD,SAAA2nD,QAAAx6C,KAAAxQ,KAAAgrD,SAEA3nD,SAAA85C,IAAAn9C,KAAAm9C,IAEA95C,SAAA+5C,SAAAp9C,KAAAo9C,SAEA/5C,SAAA6jD,YAAAlnD,KAAAknD,YAEA7jD,SAAA2jD,SAAAhnD,KAAAgnD,SAEA3jD,SAAA4jD,OAAAjnD,KAAAinD,OACA5jD,SAAAmnD,QAAAxqD,KAAAwqD,QACAnnD,SAAAonD,aAAAzqD,KAAAyqD,aACApnD,SAAAqnD,gBAAA1qD,KAAA0qD,gBAEArnD,SAAA+mD,IAAApqD,KAAAoqD,IAEA/mD,SAAAk6C,QAAAv9C,KAAAu9C,QAEAl6C,SAAAG,UAAAxD,KAAAwD,UACAH,SAAAsnD,mBAAA3qD,KAAA2qD,mBACAtnD,SAAAunD,iBAAA5qD,KAAA4qD,iBACAvnD,SAAAwnD,kBAAA7qD,KAAA6qD,kBAEAxnD,SAAAilC,aAAAtoC,KAAAsoC,aAEAjlC,SAAAynD,SAAA9qD,KAAA8qD,SACAznD,SAAAmtC,aAAAxwC,KAAAwwC;AACAntC,SAAAqtC,aAAA1wC,KAAA0wC,aAEArtC,UAsDAqG,MAAAigD,kBAAA,SAAA5U,YAEArrC,MAAA4+C,SAAAhpD,KAAAU,MAEAA,KAAAoG,KAAA,oBAEApG,KAAAuD,MAAA,GAAAmG,OAAAuG,MAAA,UACAjQ,KAAAo+C,SAAA,GAAA10C,OAAAuG,MAAA,GACAjQ,KAAAk+C,SAAA,GAAAx0C,OAAAuG,MAAA,SACAjQ,KAAAu+C,UAAA,GAEAv+C,KAAAirD,OAAA,EAEAjrD,KAAA+qD,YAAA,EACA/qD,KAAAgrD,QAAA,GAAAthD,OAAAgW,QAAA,OAEA1f,KAAAm9C,IAAA,KAEAn9C,KAAAo9C,SAAA,KAEAp9C,KAAAs9C,QAAA,KACAt9C,KAAAugD,UAAA,EAEAvgD,KAAAq9C,UAAA,KACAr9C,KAAAygD,YAAA,GAAA/2C,OAAAiY,QAAA,KAEA3hB,KAAAknD,YAAA,KAEAlnD,KAAAgnD,SAAA,KAEAhnD,KAAAinD,OAAA,KACAjnD,KAAAwqD,QAAA9gD,MAAAmD,kBACA7M,KAAAyqD,aAAA,EACAzqD,KAAA0qD,gBAAA,IAEA1qD,KAAAoqD,KAAA,EAEApqD,KAAAu9C,QAAA7zC,MAAAyB,cAEAnL,KAAAwD,WAAA,EACAxD,KAAA2qD,mBAAA,EACA3qD,KAAA4qD,iBAAA,QACA5qD,KAAA6qD,kBAAA,QAEA7qD,KAAAsoC,aAAA5+B,MAAA0B,SAEApL,KAAA8qD,UAAA,EACA9qD,KAAAwwC,cAAA,EACAxwC,KAAA0wC,cAAA,EAEA1wC,KAAAqpD,UAAAtU,aAIArrC,MAAAigD,kBAAArpD,UAAAujC,OAAAiG,OAAApgC,MAAA4+C,SAAAhoD,WACAoJ,MAAAigD,kBAAArpD,UAAAM,YAAA8I,MAAAigD,kBAEAjgD,MAAAigD,kBAAArpD,UAAAqT,MAAA,WAEA,GAAAtQ,UAAA,GAAAqG,OAAAigD,iBAgDA,OA9CAjgD,OAAA4+C,SAAAhoD,UAAAqT,MAAArU,KAAAU,KAAAqD,UAEAA,SAAAE,MAAAiN,KAAAxQ,KAAAuD,OACAF,SAAA+6C,SAAA5tC,KAAAxQ,KAAAo+C,UACA/6C,SAAA66C,SAAA1tC,KAAAxQ,KAAAk+C,UACA76C,SAAAk7C,UAAAv+C,KAAAu+C,UAEAl7C,SAAA4nD,MAAAjrD,KAAAirD,MAEA5nD,SAAA0nD,WAAA/qD,KAAA+qD,WACA1nD,SAAA2nD,QAAAx6C,KAAAxQ,KAAAgrD,SAEA3nD,SAAA85C,IAAAn9C,KAAAm9C,IAEA95C,SAAA+5C,SAAAp9C,KAAAo9C,SAEA/5C,SAAAi6C,QAAAt9C,KAAAs9C,QACAj6C,SAAAk9C,UAAAvgD,KAAAugD,UAEAl9C,SAAAg6C,UAAAr9C,KAAAq9C,UACAh6C,SAAAo9C,YAAAjwC,KAAAxQ,KAAAygD,aAEAp9C,SAAA6jD,YAAAlnD,KAAAknD,YAEA7jD,SAAA2jD,SAAAhnD,KAAAgnD,SAEA3jD,SAAA4jD,OAAAjnD,KAAAinD,OACA5jD,SAAAmnD,QAAAxqD,KAAAwqD,QACAnnD,SAAAonD,aAAAzqD,KAAAyqD,aACApnD,SAAAqnD,gBAAA1qD,KAAA0qD,gBAEArnD,SAAA+mD,IAAApqD,KAAAoqD,IAEA/mD,SAAAk6C,QAAAv9C,KAAAu9C,QAEAl6C,SAAAG,UAAAxD,KAAAwD,UACAH,SAAAsnD,mBAAA3qD,KAAA2qD,mBACAtnD,SAAAunD,iBAAA5qD,KAAA4qD,iBACAvnD,SAAAwnD,kBAAA7qD,KAAA6qD,kBAEAxnD,SAAAilC,aAAAtoC,KAAAsoC,aAEAjlC,SAAAynD,SAAA9qD,KAAA8qD,SACAznD,SAAAmtC,aAAAxwC,KAAAwwC,aACAntC,SAAAqtC,aAAA1wC,KAAA0wC,aAEArtC,UAsBAqG,MAAAmgD,kBAAA,SAAA9U,YAEArrC,MAAA4+C,SAAAhpD,KAAAU,MAEAA,KAAAoG,KAAA,oBAEApG,KAAAwwC,cAAA,EACAxwC,KAAAwD,WAAA,EACAxD,KAAA2qD,mBAAA,EAEA3qD,KAAAqpD,UAAAtU,aAIArrC,MAAAmgD,kBAAAvpD,UAAAujC,OAAAiG,OAAApgC,MAAA4+C,SAAAhoD,WACAoJ,MAAAmgD,kBAAAvpD,UAAAM,YAAA8I,MAAAmgD,kBAEAngD,MAAAmgD,kBAAAvpD,UAAAqT,MAAA,WAEA,GAAAtQ,UAAA,GAAAqG,OAAAmgD,iBAOA,OALAngD,OAAA4+C,SAAAhoD,UAAAqT,MAAArU,KAAAU,KAAAqD,UAEAA,SAAAG,UAAAxD,KAAAwD,UACAH,SAAAsnD,mBAAA3qD,KAAA2qD,mBAEAtnD,UAsBAqG,MAAAkgD,mBAAA,SAAA7U,YAEArrC,MAAA4+C,SAAAhpD,KAAAU,KAAA+0C,YAEA/0C,KAAAoG,KAAA,qBAEApG,KAAAwD,WAAA,EACAxD,KAAA2qD,mBAAA,EAEA3qD,KAAAwwC,cAAA,EAEAxwC,KAAAqpD,UAAAtU,aAIArrC,MAAAkgD,mBAAAtpD,UAAAujC,OAAAiG,OAAApgC,MAAA4+C,SAAAhoD,WACAoJ,MAAAkgD,mBAAAtpD,UAAAM,YAAA8I,MAAAkgD,mBAEAlgD,MAAAkgD,mBAAAtpD,UAAAqT,MAAA,WAEA,GAAAtQ,UAAA,GAAAqG,OAAAkgD,kBAOA,OALAlgD,OAAA4+C,SAAAhoD,UAAAqT,MAAArU,KAAAU,KAAAqD,UAEAA,SAAAG,UAAAxD,KAAAwD,UACAH,SAAAsnD,mBAAA3qD,KAAA2qD,mBAEAtnD,UAUAqG,MAAAwhD,iBAAA,SAAA9jB,WAEApnC,KAAAg8B,KAAAtyB,MAAAG,KAAAgyB,eAEA77B,KAAAoG,KAAA,mBAEApG,KAAAonC,8BAAAnL,OAAAmL,cAIA19B,MAAAwhD,iBAAA5qD,WAEAM,YAAA8I,MAAAwhD,iBAEAtkB,OAAA,WAaA,OAXAC,SACAC,UACAC,QAAA,IACA3gC,KAAA,WACA4gC,UAAA,oBAEAhL,KAAAh8B,KAAAg8B,KACA51B,KAAApG,KAAAoG,KACAghC,cAGA1iC,EAAA,EAAAsM,EAAAhR,KAAAonC,UAAAziC,OAA6CqM,EAAAtM,EAAOA,IAEpDmiC,OAAAO,UAAA9iC,KAAAtE,KAAAonC,UAAA1iC,GAAAkiC,SAIA,OAAAC,SAIAlzB,MAAA,WAIA,OAFAtQ,UAAA,GAAAqG,OAAAwhD,iBAEAxmD,EAAA,EAAkBA,EAAA1E,KAAAonC,UAAAziC,OAA2BD,IAE7CrB,SAAA+jC,UAAA9iC,KAAAtE,KAAAonC,UAAA1iC,GAAAiP,QAIA,OAAAtQ,YA8BAqG,MAAAogD,mBAAA,SAAA/U,YAEArrC,MAAA4+C,SAAAhpD,KAAAU,MAEAA,KAAAoG,KAAA,qBAEApG,KAAAuD,MAAA,GAAAmG,OAAAuG,MAAA,UAEAjQ,KAAAm9C,IAAA,KAEAn9C,KAAA+pB,KAAA,EACA/pB,KAAA0kD,iBAAA,EAEA1kD,KAAAsoC,aAAA5+B,MAAA0B,SAEApL,KAAAoqD,KAAA,EAEApqD,KAAAqpD,UAAAtU,aAIArrC,MAAAogD,mBAAAxpD,UAAAujC,OAAAiG,OAAApgC,MAAA4+C,SAAAhoD,WACAoJ,MAAAogD,mBAAAxpD,UAAAM,YAAA8I,MAAAogD,mBAEApgD,MAAAogD,mBAAAxpD,UAAAqT,MAAA,WAEA,GAAAtQ,UAAA,GAAAqG,OAAAogD,kBAeA,OAbApgD,OAAA4+C,SAAAhoD,UAAAqT,MAAArU,KAAAU,KAAAqD,UAEAA,SAAAE,MAAAiN,KAAAxQ,KAAAuD,OAEAF,SAAA85C,IAAAn9C,KAAAm9C,IAEA95C,SAAA0mB,KAAA/pB,KAAA+pB,KACA1mB,SAAAqhD,gBAAA1kD,KAAA0kD,gBAEArhD,SAAAilC,aAAAtoC,KAAAsoC,aAEAjlC,SAAA+mD,IAAApqD,KAAAoqD,IAEA/mD,UAMAqG,MAAAyhD,sBAAA,SAAApW,YAGA,MADArrC,OAAAK,KAAA,6EACA,GAAAL,OAAAogD,mBAAA/U,aAIArrC,MAAA0hD,uBAAA,SAAArW,YAGA,MADArrC,OAAAK,KAAA,8EACA,GAAAL,OAAAogD,mBAAA/U,aAoCArrC,MAAA6xC,eAAA,SAAAxG,YAEArrC,MAAA4+C,SAAAhpD,KAAAU,MAEAA,KAAAoG,KAAA,iBAEApG,KAAAqrD,WACArrD,KAAAukD,YACAvkD,KAAAyrB,WAAA,KAEAzrB,KAAAwkD,aAAA,+FACAxkD,KAAAykD,eAAA,gEAEAzkD,KAAAu9C,QAAA7zC,MAAAyB,cAEAnL,KAAAiqD,UAAA,EAEAjqD,KAAAwD,WAAA,EACAxD,KAAA2qD,mBAAA,EAEA3qD,KAAAoqD,KAAA,EAEApqD,KAAAsrD,QAAA,EAEAtrD,KAAAsoC,aAAA5+B,MAAA0B,SAEApL,KAAA8qD,UAAA,EAEA9qD,KAAAwwC,cAAA,EACAxwC,KAAA0wC,cAAA,EAIA1wC,KAAAurD,wBACAhoD,OAAA,OACAsqC,IAAA,KACA2d,KAAA,MAGAxrD,KAAAyrD,oBAAA7hD,OAEA5J,KAAAqpD,UAAAtU,aAIArrC,MAAA6xC,eAAAj7C,UAAAujC,OAAAiG,OAAApgC,MAAA4+C,SAAAhoD,WACAoJ,MAAA6xC,eAAAj7C,UAAAM,YAAA8I,MAAA6xC,eAEA7xC,MAAA6xC,eAAAj7C,UAAAqT,MAAA,WAEA,GAAAtQ,UAAA,GAAAqG,OAAA6xC,cA4BA,OA1BA7xC,OAAA4+C,SAAAhoD,UAAAqT,MAAArU,KAAAU,KAAAqD,UAEAA,SAAAohD,eAAAzkD,KAAAykD,eACAphD,SAAAmhD,aAAAxkD,KAAAwkD,aAEAnhD,SAAAkhD,SAAA76C,MAAAgiD,cAAA/3C,MAAA3T,KAAAukD,UAEAlhD,SAAAooB,WAAAzrB,KAAAyrB,WACApoB,SAAAgoD,QAAArrD,KAAAqrD,QAEAhoD,SAAAk6C,QAAAv9C,KAAAu9C,QAEAl6C,SAAAG,UAAAxD,KAAAwD,UACAH,SAAAsnD,mBAAA3qD,KAAA2qD,mBAEAtnD,SAAA+mD,IAAApqD,KAAAoqD,IAEA/mD,SAAAioD,OAAAtrD,KAAAsrD,OAEAjoD,SAAAilC,aAAAtoC,KAAAsoC,aAEAjlC,SAAAynD,SAAA9qD,KAAA8qD,SAEAznD,SAAAmtC,aAAAxwC,KAAAwwC,aACAntC,SAAAqtC,aAAA1wC,KAAA0wC,aAEArtC,UAUAqG,MAAAiiD,kBAAA,SAAA5W,YAEArrC,MAAA6xC,eAAAj8C,KAAAU,KAAA+0C,YAEA/0C,KAAAoG,KAAA,qBAIAsD,MAAAiiD,kBAAArrD,UAAAujC,OAAAiG,OAAApgC,MAAA6xC,eAAAj7C,WACAoJ,MAAAiiD,kBAAArrD,UAAAM,YAAA8I,MAAAiiD,kBAEAjiD,MAAAiiD,kBAAArrD,UAAAqT,MAAA,WAEA,GAAAtQ,UAAA,GAAAqG,OAAAiiD,iBAIA,OAFAjiD,OAAA6xC,eAAAj7C,UAAAqT,MAAArU,KAAAU,KAAAqD,UAEAA,UAyBAqG,MAAAqgD,eAAA,SAAAhV,YAEArrC,MAAA4+C,SAAAhpD,KAAAU,MAEAA,KAAAoG,KAAA,iBAEApG,KAAAuD,MAAA,GAAAmG,OAAAuG,MAAA,UACAjQ,KAAAm9C,IAAA,KAEAn9C,KAAAiE,SAAA,EAEAjE,KAAAoqD,KAAA,EAIApqD,KAAAqpD,UAAAtU,aAIArrC,MAAAqgD,eAAAzpD,UAAAujC,OAAAiG,OAAApgC,MAAA4+C,SAAAhoD,WACAoJ,MAAAqgD,eAAAzpD,UAAAM,YAAA8I,MAAAqgD,eAEArgD,MAAAqgD,eAAAzpD,UAAAqT,MAAA,WAEA,GAAAtQ,UAAA,GAAAqG,OAAAqgD,cAWA,OATArgD,OAAA4+C,SAAAhoD,UAAAqT,MAAArU,KAAAU,KAAAqD,UAEAA,SAAAE,MAAAiN,KAAAxQ,KAAAuD,OACAF,SAAA85C,IAAAn9C,KAAAm9C,IAEA95C,SAAAY,SAAAjE,KAAAiE,SAEAZ,SAAA+mD,IAAApqD,KAAAoqD,IAEA/mD,UAYAqG,MAAA2yC,QAAA,SAAAC,MAAAsP,QAAAlP,MAAAC,MAAArG,UAAAC,UAAAF,OAAAjwC,KAAA21C,YAEAlY,OAAAC,eAAA9jC,KAAA,MAAqCuQ,MAAA7G,MAAAmiD,mBAErC7rD,KAAAg8B,KAAAtyB,MAAAG,KAAAgyB,eAEA77B,KAAAgkC,KAAA,GACAhkC,KAAA47C,WAAA,GAEA57C,KAAAs8C,MAAA1yC,SAAA0yC,YAAA5yC,MAAA2yC,QAAAyP,cACA9rD,KAAA+nD,WAEA/nD,KAAA4rD,QAAAhiD,SAAAgiD,gBAAAliD,MAAA2yC,QAAA0P,gBAEA/rD,KAAA08C,MAAA9yC,SAAA8yC,YAAAhzC,MAAA6D,oBACAvN,KAAA28C,MAAA/yC,SAAA+yC,YAAAjzC,MAAA6D,oBAEAvN,KAAAs2C,UAAA1sC,SAAA0sC,oBAAA5sC,MAAAkE,aACA5N,KAAAu2C,UAAA3sC,SAAA2sC,oBAAA7sC,MAAAoE,yBAEA9N,KAAA+7C,WAAAnyC,SAAAmyC,sBAAA,EAEA/7C,KAAAq2C,OAAAzsC,SAAAysC,cAAA3sC,MAAAkF,WACA5O,KAAAoG,KAAAwD,SAAAxD,UAAAsD,MAAAqE,iBAEA/N,KAAA0T,OAAA,GAAAhK,OAAAiY,QAAA,KACA3hB,KAAA67C,OAAA,GAAAnyC,OAAAiY,QAAA,KAEA3hB,KAAAy2C,iBAAA,EACAz2C,KAAAgsD,kBAAA,EACAhsD,KAAAisD,OAAA,EACAjsD,KAAAksD,gBAAA,EAEAlsD,KAAAopD,cAAA,EACAppD,KAAAmsD,SAAA,MAIAziD,MAAA2yC,QAAAyP,cAAAliD,OACAF,MAAA2yC,QAAA0P,gBAAAriD,MAAAsD,UAEAtD,MAAA2yC,QAAA/7C,WAEAM,YAAA8I,MAAA2yC,QAEAh/B,GAAAsrB,eAEA,MAAA3oC,MAAAopD,cAIA/rC,GAAAsrB,aAAAp4B,OAEAA,SAAA,GAAAvQ,KAAAwG,SAEAxG,KAAAopD,aAAA74C,OAIAoD,MAAA,SAAAqoC,SA4BA,MA1BApyC,UAAAoyC,kBAAA,GAAAtyC,OAAA2yC,SAEAL,QAAAM,MAAAt8C,KAAAs8C,MACAN,QAAA+L,QAAA/nD,KAAA+nD,QAAA51C,MAAA,GAEA6pC,QAAA4P,QAAA5rD,KAAA4rD,QAEA5P,QAAAU,MAAA18C,KAAA08C,MACAV,QAAAW,MAAA38C,KAAA28C,MAEAX,QAAA1F,UAAAt2C,KAAAs2C,UACA0F,QAAAzF,UAAAv2C,KAAAu2C,UAEAyF,QAAAD,WAAA/7C,KAAA+7C,WAEAC,QAAA3F,OAAAr2C,KAAAq2C,OACA2F,QAAA51C,KAAApG,KAAAoG,KAEA41C,QAAAtoC,OAAAlD,KAAAxQ,KAAA0T,QACAsoC,QAAAH,OAAArrC,KAAAxQ,KAAA67C,QAEAG,QAAAvF,gBAAAz2C,KAAAy2C,gBACAuF,QAAAgQ,iBAAAhsD,KAAAgsD,iBACAhQ,QAAAiQ,MAAAjsD,KAAAisD,MACAjQ,QAAAkQ,gBAAAlsD,KAAAksD,gBAEAlQ,SAIAx1C,OAAA,WAEAxG,KAAA+hC,eAAuB37B,KAAA,YAIvBmqC,QAAA,WAEAvwC,KAAA+hC,eAAuB37B,KAAA,cAMvBsD,MAAAk4B,gBAAAthC,UAAAiB,MAAAmI,MAAA2yC,QAAA/7C,WAEAoJ,MAAAmiD,eAAA,EAQAniD,MAAA0iD,YAAA,SAAApH,OAAA4G,QAAAlP,MAAAC,MAAArG,UAAAC,UAAAF,OAAAjwC,KAAA21C,YAEA6P,QAAAhiD,SAAAgiD,gBAAAliD,MAAAuD,sBAEAvD,MAAA2yC,QAAA/8C,KAAAU,KAAAglD,OAAA4G,QAAAlP,MAAAC,MAAArG,UAAAC,UAAAF,OAAAjwC,KAAA21C,YAEA/7C,KAAAglD,eAIAt7C,MAAA0iD,YAAA9rD,UAAAujC,OAAAiG,OAAApgC,MAAA2yC,QAAA/7C,WACAoJ,MAAA0iD,YAAA9rD,UAAAM,YAAA8I,MAAA0iD,YAEA1iD,MAAA0iD,YAAAz4C,MAAA,SAAAqoC,SAQA,MANApyC,UAAAoyC,kBAAA,GAAAtyC,OAAA0iD,aAEA1iD,MAAA2yC,QAAA/7C,UAAAqT,MAAArU,KAAAU,KAAAg8C,SAEAA,QAAAgJ,OAAAhlD,KAAAglD,OAEAhJ,SAUAtyC,MAAAw+C,kBAAA,SAAAH,QAAA1Q,MAAAC,OAAAjB,OAAAjwC,KAAAwlD,QAAAlP,MAAAC,MAAArG,UAAAC,UAAAwF,YAEAryC,MAAA2yC,QAAA/8C,KAAAU,KAAA,KAAA4rD,QAAAlP,MAAAC,MAAArG,UAAAC,UAAAF,OAAAjwC,KAAA21C,YAEA/7C,KAAAs8C,OAAejF,YAAAC,eACft3C,KAAA+nD,gBAKA/nD,KAAAisD,OAAA,EAKAjsD,KAAAy2C,iBAAA,GAIA/sC,MAAAw+C,kBAAA5nD,UAAAujC,OAAAiG,OAAApgC,MAAA2yC,QAAA/7C,WACAoJ,MAAAw+C,kBAAA5nD,UAAAM,YAAA8I,MAAAw+C,kBAEAx+C,MAAAw+C,kBAAA5nD,UAAAqT,MAAA,WAEA,GAAAqoC,SAAA,GAAAtyC,OAAAw+C,iBAIA,OAFAx+C,OAAA2yC,QAAA/7C,UAAAqT,MAAArU,KAAAU,KAAAg8C,SAEAA,SAUAtyC,MAAAk+C,YAAA,SAAArgB,KAAA8P,MAAAC,OAAAjB,OAAAjwC,KAAAwlD,QAAAlP,MAAAC,MAAArG,UAAAC,UAAAwF,YAEAryC,MAAA2yC,QAAA/8C,KAAAU,KAAA,KAAA4rD,QAAAlP,MAAAC,MAAArG,UAAAC,UAAAF,OAAAjwC,KAAA21C,YAEA/7C,KAAAs8C,OAAe/U,UAAA8P,YAAAC,gBAIf5tC,MAAAk+C,YAAAtnD,UAAAujC,OAAAiG,OAAApgC,MAAA2yC,QAAA/7C,WACAoJ,MAAAk+C,YAAAtnD,UAAAM,YAAA8I,MAAAk+C,YAEAl+C,MAAAk+C,YAAAtnD,UAAAqT,MAAA,WAEA,GAAAqoC,SAAA,GAAAtyC,OAAAk+C,WAIA,OAFAl+C,OAAA2yC,QAAA/7C,UAAAqT,MAAArU,KAAAU,KAAAg8C,SAEAA,SAUAtyC,MAAA2iD,aAAA,SAAAC,MAAAV,QAAAlP,MAAAC,MAAArG,UAAAC,UAAAF,OAAAjwC,KAAA21C,YAEAryC,MAAA2yC,QAAA/8C,KAAAU,KAAAssD,MAAAV,QAAAlP,MAAAC,MAAArG,UAAAC,UAAAF,OAAAjwC,KAAA21C,YAEA/7C,KAAAy2C,iBAAA,CAEA,IAAAvrB,OAAAlrB,KAEAwG,OAAA,WAEAxC,sBAAAwC,QAEA8lD,MAAAlK,aAAAkK,MAAAC,mBAEArhC,MAAAyd,aAAA,GAMAniC,WAIAkD,MAAA2iD,aAAA/rD,UAAAujC,OAAAiG,OAAApgC,MAAA2yC,QAAA/7C,WACAoJ,MAAA2iD,aAAA/rD,UAAAM,YAAA8I,MAAA2iD,aAQA3iD,MAAA69C,MAAA,WAEA79C,MAAAk6B,SAAAtkC,KAAAU,MAEAA,KAAAoG,KAAA,SAIAsD,MAAA69C,MAAAjnD,UAAAujC,OAAAiG,OAAApgC,MAAAk6B,SAAAtjC,WACAoJ,MAAA69C,MAAAjnD,UAAAM,YAAA8I,MAAA69C,MAQA79C,MAAAg5B,WAAA,SAAAv/B,SAAAE,UAEAqG,MAAAk6B,SAAAtkC,KAAAU,MAEAA,KAAAoG,KAAA,aAEApG,KAAAmD,SAAAyG,SAAAzG,kBAAA,GAAAuG,OAAA4hB,SACAtrB,KAAAqD,SAAAuG,SAAAvG,kBAAA,GAAAqG,OAAAogD,oBAAoFvmD,MAAA,SAAAsG,KAAAsyB,YAIpFzyB,MAAAg5B,WAAApiC,UAAAujC,OAAAiG,OAAApgC,MAAAk6B,SAAAtjC,WACAoJ,MAAAg5B,WAAApiC,UAAAM,YAAA8I,MAAAg5B,WAEAh5B,MAAAg5B,WAAApiC,UAAA6iC,QAAA,WAEA,GAAAqpB,eAAA,GAAA9iD,OAAAkb,QACAmQ,IAAA,GAAArrB,OAAAkrB,GAEA,iBAAAoO,UAAAC,YAEA,GAAAhY,QAAAjrB,KACAmD,SAAA8nB,OAAA9nB,SACAw/B,UAAAK,UAAAR,OAAAE,WAAAC,SAKA,IAHA6pB,cAAAznC,WAAA/kB,KAAAglB,aACA+P,IAAAvkB,KAAAwyB,UAAAjO,KAAA/Q,aAAAwoC,eAEA,OAAArpD,SAAAgnC,aAEApV,IAAAvK,kBAAArnB,SAAAgnC,gBAAA,EAFA,CAUA,GAAAsiB,gBAAA9pB,YAAA3iC,KAAA2yB,MAAAzuB,EAAAlE,KAAA2yB,MAAAxuB,EAAAnE,KAAA2yB,MAAAzvB,GAAA,GACAD,SAAA,GAAAyG,OAAAgW,QAEAgtC,UAAA,SAAAxjC,MAAAxhB,OAEA,GAAAilD,kBAAA53B,IAAArK,gBAAAxB,MAEA,IAAAujC,eAAAE,iBAAA,CAEA,GAAAC,gBAAA73B,IAAAzL,oBAAAJ,MACA0jC,gBAAA5oC,aAAAiH,OAAAjG,YAEA,IAAA6D,UAAAma,UAAAjO,IAAAF,OAAA9R,WAAA6pC,eAEA3pB,YAAA3+B,MAEAukB,kBACAgkC,cAAAF,iBACAzjC,MAAA0jC,eAAAj5C,QACAjM,YACA8gC,KAAA,KACAvd,iBAQA,IAAA9nB,mBAAAuG,OAAA8hB,eAAA,CAEA,GAAAC,YAAAtoB,SAAAsoB,WACAC,UAAAD,WAAAxoB,SAAAuQ,KAEA,IAAA5J,SAAA6hB,WAAA/jB,MAAA,CAEA,GAAAglC,SAAAjhB,WAAA/jB,MAAA8L,MACA02B,QAAA/mC,SAAA+mC,OAEA,QAAAA,QAAAvlC,OAAA,CAEA,GAAA+O,SACA8U,MAAA,EACAqhB,MAAA6C,QAAA/nC,OACA+C,MAAA,EAGAwiC,UAAAx2B,QAIA,OAAAo5C,IAAA,EAAAC,GAAA7iB,QAAAvlC,OAA0CooD,GAAAD,KAASA,GAMnD,OAJAtkC,OAAA0hB,QAAA4iB,IAAAtkC,MACAqhB,MAAAK,QAAA4iB,IAAAjjB,MACAniC,MAAAwiC,QAAA4iB,IAAAplD,MAEAhD,EAAA8jB,MAAAoB,GAAApB,MAAAqhB,MAA6CjgB,GAAAllB,EAAQA,IAAA,CAErD,GAAA0b,GAAA1Y,MAAAglC,QAAAhoC,EAEAzB,UAAAsQ,UAAAmY,UAAA,EAAAtL,GAEAssC,UAAAzpD,SAAAmd,QAUA,QAFA4sC,YAAAthC,UAAA/mB,OAAA,EAEAD,EAAA,EAAoBsoD,WAAAtoD,EAAgBA,IAEpCzB,SAAAkN,IACAub,UAAA,EAAAhnB,GACAgnB,UAAA,EAAAhnB,EAAA,GACAgnB,UAAA,EAAAhnB,EAAA,IAGAgoD,UAAAzpD,SAAAyB,OAUA,QAFA6mB,UAAAvrB,KAAAmD,SAAAooB,SAEA7mB,EAAA,EAAmBA,EAAA6mB,SAAA5mB,OAAqBD,IAExCgoD,UAAAnhC,SAAA7mB,WAUAgF,MAAAg5B,WAAApiC,UAAAqT,MAAA,SAAAsX,QAMA,MAJArhB,UAAAqhB,gBAAA,GAAAvhB,OAAAg5B,WAAA1iC,KAAAmD,SAAAnD,KAAAqD,WAEAqG,MAAAk6B,SAAAtjC,UAAAqT,MAAArU,KAAAU,KAAAirB,QAEAA,QAMAvhB,MAAAujD,eAAA,SAAA9pD,SAAAE,UAGA,MADAqG,OAAAK,KAAA,8DACA,GAAAL,OAAAg5B,WAAAv/B,SAAAE,WAUAqG,MAAAm5B,KAAA,SAAA1/B,SAAAE,SAAA4kC,MAEAv+B,MAAAk6B,SAAAtkC,KAAAU,MAEAA,KAAAoG,KAAA,OAEApG,KAAAmD,SAAAyG,SAAAzG,kBAAA,GAAAuG,OAAA4hB,SACAtrB,KAAAqD,SAAAuG,SAAAvG,kBAAA,GAAAqG,OAAAsgD,mBAAmFzmD,MAAA,SAAAsG,KAAAsyB,WAEnFn8B,KAAAioC,KAAAr+B,SAAAq+B,UAAAv+B,MAAAwjD,WAIAxjD,MAAAwjD,UAAA,EACAxjD,MAAAyjD,WAAA,EAEAzjD,MAAAm5B,KAAAviC,UAAAujC,OAAAiG,OAAApgC,MAAAk6B,SAAAtjC,WACAoJ,MAAAm5B,KAAAviC,UAAAM,YAAA8I,MAAAm5B,KAEAn5B,MAAAm5B,KAAAviC,UAAA6iC,QAAA,WAEA,GAAAqpB,eAAA,GAAA9iD,OAAAkb,QACAmQ,IAAA,GAAArrB,OAAAkrB,IACAsB,OAAA,GAAAxsB,OAAAkiB,MAEA,iBAAAoX,UAAAC,YAEA,GAAAI,WAAAL,UAAAM,cACA8pB,YAAA/pB,oBAEAlgC,SAAAnD,KAAAmD,QASA,IAPA,OAAAA,SAAAo3B,gBAAAp3B,SAAAq3B,wBAIAtE,OAAA1lB,KAAArN,SAAAo3B,gBACArE,OAAAlS,aAAAhkB,KAAAglB,aAEAge,UAAAjO,IAAAkB,qBAAAC,WAAA,GAMAs2B,cAAAznC,WAAA/kB,KAAAglB,aACA+P,IAAAvkB,KAAAwyB,UAAAjO,KAAA/Q,aAAAwoC,cAEA,IAAAa,QAAA,GAAA3jD,OAAAgW,QACA4tC,KAAA,GAAA5jD,OAAAgW,QACA6tC,aAAA,GAAA7jD,OAAAgW,QACA8tC,SAAA,GAAA9jD,OAAAgW,QACA+tC,KAAAztD,KAAAioC,OAAAv+B,MAAAwjD,UAAA,GAEA,IAAA/pD,mBAAAuG,OAAA8hB,eAAA,CAEA,GAAAC,YAAAtoB,SAAAsoB,UAEA,IAAA7hB,SAAA6hB,WAAA/jB,MAAA,CAEA,GAAAglC,SAAAjhB,WAAA/jB,MAAA8L,MACAkY,UAAAD,WAAAxoB,SAAAuQ,MACA02B,QAAA/mC,SAAA+mC,OAEA,KAAAA,QAAAvlC,SAEAulC,UAAkB1hB,MAAA,EAAAqhB,MAAA6C,QAAA/nC,OAAA+C,MAAA,IAIlB,QAAAolD,IAAA,EAAqBA,GAAA5iB,QAAAvlC,OAAqBmoD,KAM1C,OAJAtkC,OAAA0hB,QAAA4iB,IAAAtkC,MACAqhB,MAAAK,QAAA4iB,IAAAjjB,MACAniC,MAAAwiC,QAAA4iB,IAAAplD,MAEAhD,EAAA8jB,MAAyBA,MAAAqhB,MAAA,EAAAnlC,EAAuBA,GAAA+oD,KAAA,CAEhD,GAAArtC,GAAA1Y,MAAAglC,QAAAhoC,GACA4L,EAAA5I,MAAAglC,QAAAhoC,EAAA,EAEA2oD,QAAA95C,UAAAmY,UAAA,EAAAtL,GACAktC,KAAA/5C,UAAAmY,UAAA,EAAApb,EAEA,IAAAo9C,QAAA34B,IAAAG,oBAAAm4B,OAAAC,KAAAE,SAAAD,aAEA,MAAAG,OAAAN,aAAA,CAEA,GAAAvkC,UAAAkM,IAAAF,OAAA9R,WAAAyqC,SAEA3kC,UAAAma,UAAA9O,MAAArL,SAAAma,UAAA7O,KAEA8O,WAAA3+B,MAEAukB,kBAGAK,MAAAqkC,aAAA55C,QAAAqQ,aAAAhkB,KAAAglB,aACAtd,MAAAhD,EACAipD,YAAAb,GACAtkB,KAAA,KACAsK,UAAA,KACA7nB,OAAAjrB,aAYA,QAFA0rB,WAAAD,WAAAxoB,SAAAuQ,MAEA9O,EAAA,EAAoBA,EAAAgnB,UAAA/mB,OAAA,IAA8BD,GAAA+oD,KAAA,CAElDJ,OAAA95C,UAAAmY,UAAA,EAAAhnB,GACA4oD,KAAA/5C,UAAAmY,UAAA,EAAAhnB,EAAA,EAEA,IAAAgpD,QAAA34B,IAAAG,oBAAAm4B,OAAAC,KAAAE,SAAAD,aAEA,MAAAG,OAAAN,aAAA,CAEA,GAAAvkC,UAAAkM,IAAAF,OAAA9R,WAAAyqC,SAEA3kC,UAAAma,UAAA9O,MAAArL,SAAAma,UAAA7O,KAEA8O,WAAA3+B,MAEAukB,kBAGAK,MAAAqkC,aAAA55C,QAAAqQ,aAAAhkB,KAAAglB,aACAtd,MAAAhD,EACA8jC,KAAA,KACAsK,UAAA,KACA7nB,OAAAjrB,aAQG,IAAAmD,mBAAAuG,OAAA4hB,SAKH,OAHAC,UAAApoB,SAAAooB,SACAqiC,WAAAriC,SAAA5mB,OAEAD,EAAA,EAAmBkpD,WAAA,EAAAlpD,EAAoBA,GAAA+oD,KAAA,CAEvC,GAAAC,QAAA34B,IAAAG,oBAAA3J,SAAA7mB,GAAA6mB,SAAA7mB,EAAA,GAAA8oD,SAAAD,aAEA,MAAAG,OAAAN,aAAA,CAEA,GAAAvkC,UAAAkM,IAAAF,OAAA9R,WAAAyqC,SAEA3kC,UAAAma,UAAA9O,MAAArL,SAAAma,UAAA7O,KAEA8O,WAAA3+B,MAEAukB,kBAGAK,MAAAqkC,aAAA55C,QAAAqQ,aAAAhkB,KAAAglB,aACAtd,MAAAhD,EACA8jC,KAAA,KACAsK,UAAA,KACA7nB,OAAAjrB,cAYA0J,MAAAm5B,KAAAviC,UAAAqT,MAAA,SAAAsX,QAMA,MAJArhB,UAAAqhB,gBAAA,GAAAvhB,OAAAm5B,KAAA7iC,KAAAmD,SAAAnD,KAAAqD,SAAArD,KAAAioC,OAEAv+B,MAAAk6B,SAAAtjC,UAAAqT,MAAArU,KAAAU,KAAAirB,QAEAA,QAaAvhB,MAAAhG,KAAA,SAAAP,SAAAE,UAEAqG,MAAAk6B,SAAAtkC,KAAAU,MAEAA,KAAAoG,KAAA,OAEApG,KAAAmD,SAAAyG,SAAAzG,kBAAA,GAAAuG,OAAA4hB,SACAtrB,KAAAqD,SAAAuG,SAAAvG,kBAAA,GAAAqG,OAAApG,mBAAmFC,MAAA,SAAAsG,KAAAsyB,WAEnFn8B,KAAA6tD,sBAIAnkD,MAAAhG,KAAApD,UAAAujC,OAAAiG,OAAApgC,MAAAk6B,SAAAtjC,WACAoJ,MAAAhG,KAAApD,UAAAM,YAAA8I,MAAAhG,KAEAgG,MAAAhG,KAAApD,UAAAutD,mBAAA,WAEA,GAAAjkD,SAAA5J,KAAAmD,SAAAqtC,cAAAxwC,KAAAmD,SAAAqtC,aAAA7rC,OAAA,GAEA3E,KAAA8tD,gBAAA,GACA9tD,KAAA+tD,0BACA/tD,KAAAguD,yBACAhuD,KAAAiuD,wBAEA,QAAA1uD,GAAA,EAAA2uD,GAAAluD,KAAAmD,SAAAqtC,aAAA7rC,OAA0DupD,GAAA3uD,EAAQA,IAElES,KAAAguD,sBAAA1pD,KAAA,GACAtE,KAAAiuD,sBAAAjuD,KAAAmD,SAAAqtC,aAAAjxC,GAAAykC,MAAAzkC,IAQAmK,MAAAhG,KAAApD,UAAA6tD,0BAAA,SAAAnqB,MAEA,MAAAp6B,UAAA5J,KAAAiuD,sBAAAjqB,MAEAhkC,KAAAiuD,sBAAAjqB,OAIAt6B,MAAAK,KAAA,sDAAAi6B,KAAA,iCAEA,IAKAt6B,MAAAhG,KAAApD,UAAA6iC,QAAA,WAEA,GAAAqpB,eAAA,GAAA9iD,OAAAkb,QACAmQ,IAAA,GAAArrB,OAAAkrB,IACAsB,OAAA,GAAAxsB,OAAAkiB,OAEAsgB,GAAA,GAAAxiC,OAAAgW,QACAysB,GAAA,GAAAziC,OAAAgW,QACA0sB,GAAA,GAAA1iC,OAAAgW,OAEA,iBAAAsjB,UAAAC,YAEA,GAAA9/B,UAAAnD,KAAAmD,QASA,IALA,OAAAA,SAAAo3B,gBAAAp3B,SAAAq3B,wBAEAtE,OAAA1lB,KAAArN,SAAAo3B,gBACArE,OAAAlS,aAAAhkB,KAAAglB,aAEAge,UAAAjO,IAAAkB,qBAAAC,WAAA,IAQAs2B,cAAAznC,WAAA/kB,KAAAglB,aACA+P,IAAAvkB,KAAAwyB,UAAAjO,KAAA/Q,aAAAwoC,eAEA,OAAArpD,SAAAgnC,aAEApV,IAAAvK,kBAAArnB,SAAAgnC,gBAAA,GAQA,GAAAhnC,mBAAAuG,OAAA8hB,eAAA,CAEA,GAAAnoB,UAAArD,KAAAqD,QAEA,IAAAuG,SAAAvG,SAAA,MAEA,IAEA+c,GAAA9P,EAAA9Q,EAFAisB,WAAAtoB,SAAAsoB,WAGA4X,UAAAL,UAAAK,SAEA,IAAAz5B,SAAA6hB,WAAA/jB,MAAA,CAEA,GAAAglC,SAAAjhB,WAAA/jB,MAAA8L,MACAkY,UAAAD,WAAAxoB,SAAAuQ,MACA02B,QAAA/mC,SAAA+mC,OAEA,KAAAA,QAAAvlC,SAEAulC,UAAkB1hB,MAAA,EAAAqhB,MAAA6C,QAAA/nC,OAAA+C,MAAA,IAIlB,QAAAolD,IAAA,EAAAC,GAAA7iB,QAAAvlC,OAA0CooD,GAAAD,KAASA,GAMnD,OAJAtkC,OAAA0hB,QAAA4iB,IAAAtkC,MACAqhB,MAAAK,QAAA4iB,IAAAjjB,MACAniC,MAAAwiC,QAAA4iB,IAAAplD,MAEAhD,EAAA8jB,MAAAoB,GAAApB,MAAAqhB,MAA6CjgB,GAAAllB,EAAQA,GAAA,GAUrD,GARA0b,EAAA1Y,MAAAglC,QAAAhoC,GACA4L,EAAA5I,MAAAglC,QAAAhoC,EAAA,GACAlF,EAAAkI,MAAAglC,QAAAhoC,EAAA,GAEAwnC,GAAA34B,UAAAmY,UAAA,EAAAtL,GACA+rB,GAAA54B,UAAAmY,UAAA,EAAApb,GACA87B,GAAA74B,UAAAmY,UAAA,EAAAlsB,GAEA6D,SAAAw6C,OAAAn0C,MAAAqB,SAEA,GAAAqjD,mBAAAr5B,IAAA4C,kBAAAyU,GAAAD,GAAAD,IAAA,OAIA,IAAAkiB,mBAAAr5B,IAAA4C,kBAAAuU,GAAAC,GAAAC,GAAA/oC,SAAAw6C,OAAAn0C,MAAAsB,WAIA,WAAAojD,kBAAA,CAEAA,kBAAApqC,aAAAhkB,KAAAglB,YAEA,IAAA6D,UAAAma,UAAAjO,IAAAF,OAAA9R,WAAAqrC,kBAEA/qB,WAAAxa,mBAAAma,UAAA9O,MAAArL,SAAAma,UAAA7O,KAEA8O,WAAA3+B,MAEAukB,kBACAK,MAAAklC,kBACA5lB,KAAA,GAAA9+B,OAAAy+B,MAAA/nB,EAAA9P,EAAA9Q,EAAAkK,MAAAm2B,SAAA/Z,OAAAomB,GAAAC,GAAAC,KACA0G,UAAA,KACA7nB,OAAAjrB,aAYA,QAFA0rB,WAAAD,WAAAxoB,SAAAuQ,MAEA9O,EAAA,EAAAY,EAAA,EAAAskB,GAAA8B,UAAA/mB,OAAkDilB,GAAAllB,EAAQA,GAAA,EAAAY,GAAA,GAU1D,GARA8a,EAAA1b,EACA4L,EAAA5L,EAAA,EACAlF,EAAAkF,EAAA,EAEAwnC,GAAA34B,UAAAmY,UAAApmB,GACA6mC,GAAA54B,UAAAmY,UAAApmB,EAAA,GACA8mC,GAAA74B,UAAAmY,UAAApmB,EAAA,GAEAjC,SAAAw6C,OAAAn0C,MAAAqB,SAEA,GAAAqjD,mBAAAr5B,IAAA4C,kBAAAyU,GAAAD,GAAAD,IAAA,OAIA,IAAAkiB,mBAAAr5B,IAAA4C,kBAAAuU,GAAAC,GAAAC,GAAA/oC,SAAAw6C,OAAAn0C,MAAAsB,WAIA,WAAAojD,kBAAA,CAEAA,kBAAApqC,aAAAhkB,KAAAglB,YAEA,IAAA6D,UAAAma,UAAAjO,IAAAF,OAAA9R,WAAAqrC,kBAEA/qB,WAAAxa,mBAAAma,UAAA9O,MAAArL,SAAAma,UAAA7O,KAEA8O,WAAA3+B,MAEAukB,kBACAK,MAAAklC,kBACA5lB,KAAA,GAAA9+B,OAAAy+B,MAAA/nB,EAAA9P,EAAA9Q,EAAAkK,MAAAm2B,SAAA/Z,OAAAomB,GAAAC,GAAAC,KACA0G,UAAA,KACA7nB,OAAAjrB,aAQG,IAAAmD,mBAAAuG,OAAA4hB,SAUH,OALAlL,GAAA9P,EAAA9Q,EAHA6uD,eAAAruD,KAAAqD,mBAAAqG,OAAAwhD,iBACAoD,gBAAAD,kBAAA,EAAAruD,KAAAqD,SAAA+jC,UAAA,KAGA/D,UAAAL,UAAAK,UAEA9X,SAAApoB,SAAAooB,SAEAsB,EAAA,EAAAilB,GAAA3uC,SAAAynC,MAAAjmC,OAA+CmtC,GAAAjlB,EAAQA,IAAA,CAEvD,GAAA2b,MAAArlC,SAAAynC,MAAA/d,GAEAxpB,SAAAgrD,kBAAA,EAAAC,gBAAA9lB,KAAAJ,eAAApoC,KAAAqD,QAEA,IAAAuG,SAAAvG,SAAA,CAMA,GAJA+c,EAAAmL,SAAAid,KAAApoB,GACA9P,EAAAib,SAAAid,KAAAl4B,GACA9Q,EAAA+rB,SAAAid,KAAAhpC,GAEA6D,SAAAmtC,gBAAA,GAEA,GAAAA,cAAArtC,SAAAqtC,aACA+d,gBAAAvuD,KAAAguD,qBAEA9hB,IAAA/7B,IAAA,OACAg8B,GAAAh8B,IAAA,OACAi8B,GAAAj8B,IAAA,MAEA,QAAAgB,GAAA,EAAAq9C,GAAAhe,aAAA7rC,OAA+C6pD,GAAAr9C,EAAQA,IAAA,CAEvD,GAAAs9C,WAAAF,gBAAAp9C,EAEA,QAAAs9C,UAAA,CAEA,GAAAC,SAAAle,aAAAr/B,GAAAoa,QAEA2gB,IAAAhoC,IAAAwqD,QAAAlmB,KAAApoB,GAAAlc,EAAAkc,EAAAlc,GAAAuqD,UACAviB,GAAA/nC,IAAAuqD,QAAAlmB,KAAApoB,GAAAjc,EAAAic,EAAAjc,GAAAsqD,UACAviB,GAAAhpC,IAAAwrD,QAAAlmB,KAAApoB,GAAAld,EAAAkd,EAAAld,GAAAurD,UAEAtiB,GAAAjoC,IAAAwqD,QAAAlmB,KAAAl4B,GAAApM,EAAAoM,EAAApM,GAAAuqD,UACAtiB,GAAAhoC,IAAAuqD,QAAAlmB,KAAAl4B,GAAAnM,EAAAmM,EAAAnM,GAAAsqD,UACAtiB,GAAAjpC,IAAAwrD,QAAAlmB,KAAAl4B,GAAApN,EAAAoN,EAAApN,GAAAurD,UAEAriB,GAAAloC,IAAAwqD,QAAAlmB,KAAAhpC,GAAA0E,EAAA1E,EAAA0E,GAAAuqD,UACAriB,GAAAjoC,IAAAuqD,QAAAlmB,KAAAhpC,GAAA2E,EAAA3E,EAAA2E,GAAAsqD,UACAriB,GAAAlpC,IAAAwrD,QAAAlmB,KAAAhpC,GAAA0D,EAAA1D,EAAA0D,GAAAurD,WAIAviB,GAAAvoC,IAAAyc,GACA+rB,GAAAxoC,IAAA2M,GACA87B,GAAAzoC,IAAAnE,GAEA4gB,EAAA8rB,GACA57B,EAAA67B,GACA3sC,EAAA4sC,GAIA,GAAA/oC,SAAAw6C,OAAAn0C,MAAAqB,SAEA,GAAAqjD,mBAAAr5B,IAAA4C,kBAAAn4B,EAAA8Q,EAAA8P,GAAA,OAIA,IAAAguC,mBAAAr5B,IAAA4C,kBAAAvX,EAAA9P,EAAA9Q,EAAA6D,SAAAw6C,OAAAn0C,MAAAsB,WAIA,WAAAojD,kBAAA,CAEAA,kBAAApqC,aAAAhkB,KAAAglB,YAEA,IAAA6D,UAAAma,UAAAjO,IAAAF,OAAA9R,WAAAqrC,kBAEA/qB,WAAAxa,mBAAAma,UAAA9O,MAAArL,SAAAma,UAAA7O,KAEA8O,WAAA3+B,MAEAukB,kBACAK,MAAAklC,kBACA5lB,UACAsK,UAAAjmB,EACA5B,OAAAjrB,cAYA0J,MAAAhG,KAAApD,UAAAqT,MAAA,SAAAsX,OAAAiY,WAMA,MAJAt5B,UAAAqhB,gBAAA,GAAAvhB,OAAAhG,KAAA1D,KAAAmD,SAAAnD,KAAAqD,WAEAqG,MAAAk6B,SAAAtjC,UAAAqT,MAAArU,KAAAU,KAAAirB,OAAAiY,WAEAjY,QAYAvhB,MAAAilD,KAAA,SAAAC,MAEAllD,MAAAk6B,SAAAtkC,KAAAU,MAEAA,KAAAoG,KAAA,OAEApG,KAAA4uD,WAIAllD,MAAAilD,KAAAruD,UAAAujC,OAAAiG,OAAApgC,MAAAk6B,SAAAtjC,WACAoJ,MAAAilD,KAAAruD,UAAAM,YAAA8I,MAAAilD,KAWAjlD,MAAAmlD,SAAA,SAAApL,MAAAqL,aAAAC,kBAcA,GAZA/uD,KAAA+uD,iBAAAnlD,SAAAmlD,mCAAA,EAEA/uD,KAAAgvD,eAAA,GAAAtlD,OAAAkb,QAIA6+B,gBAEAzjD,KAAAyjD,YAAAtxC,MAAA,GAIAnS,KAAA+uD,iBAAA,CASA,GAAAhlC,KAGAA,MADA/pB,KAAAyjD,MAAA9+C,OAAA,IACA,GACA3E,KAAAyjD,MAAA9+C,OAAA,GACA,GACA3E,KAAAyjD,MAAA9+C,OAAA,GACA,GAEA,EAEA3E,KAAAivD,iBAAAllC,KACA/pB,KAAAkvD,kBAAAnlC,KAEA/pB,KAAAmvD,aAAA,GAAApjC,cAAA/rB,KAAAivD,iBAAAjvD,KAAAkvD,kBAAA,GACAlvD,KAAAovD,YAAA,GAAA1lD,OAAAk+C,YAAA5nD,KAAAmvD,aAAAnvD,KAAAivD,iBAAAjvD,KAAAkvD,kBAAAxlD,MAAAkF,WAAAlF,MAAA2E,WACArO,KAAAovD,YAAA7Y,UAAA7sC,MAAA+D,cACAzN,KAAAovD,YAAA9Y,UAAA5sC,MAAA+D,cACAzN,KAAAovD,YAAA3Y,iBAAA,EACAz2C,KAAAovD,YAAAnD,OAAA,MAIAjsD,MAAAmvD,aAAA,GAAApjC,cAAA,GAAA/rB,KAAAyjD,MAAA9+C,OAMA,IAAAiF,SAAAklD,aAEA9uD,KAAAqvD,wBAIA,IAAArvD,KAAAyjD,MAAA9+C,SAAAmqD,aAAAnqD,OAEA3E,KAAA8uD,0BAAA38C,MAAA,OAEG,CAEHzI,MAAAK,KAAA,mDAEA/J,KAAA8uD,eAEA,QAAAx+C,GAAA,EAAAg/C,GAAAtvD,KAAAyjD,MAAA9+C,OAA2C2qD,GAAAh/C,EAAQA,IAEnDtQ,KAAA8uD,aAAAxqD,KAAA,GAAAoF,OAAAkb,WAUAlb,MAAAmlD,SAAAvuD,UAAA+uD,kBAAA,WAEArvD,KAAA8uD,eAEA,QAAAx+C,GAAA,EAAAg/C,GAAAtvD,KAAAyjD,MAAA9+C,OAAyC2qD,GAAAh/C,EAAQA,IAAA,CAEjD,GAAAyP,SAAA,GAAArW,OAAAkb,OAEA5kB,MAAAyjD,MAAAnzC,IAEAyP,QAAAgF,WAAA/kB,KAAAyjD,MAAAnzC,GAAA0U,aAIAhlB,KAAA8uD,aAAAxqD,KAAAyb,WAMArW,MAAAmlD,SAAAvuD,UAAAivD,KAAA,WAMA,OAJAC,MAIAl/C,EAAA,EAAAg/C,GAAAtvD,KAAAyjD,MAAA9+C,OAAyC2qD,GAAAh/C,EAAQA,IAEjDk/C,KAAAxvD,KAAAyjD,MAAAnzC,GAEAk/C,MAEAA,KAAAxqC,YAAAD,WAAA/kB,KAAA8uD,aAAAx+C,GAQA,QAAAA,GAAA,EAAAg/C,GAAAtvD,KAAAyjD,MAAA9+C,OAAyC2qD,GAAAh/C,EAAQA,IAEjDk/C,KAAAxvD,KAAAyjD,MAAAnzC,GAEAk/C,OAEAA,KAAAvrB,QAEAurB,KAAA7qC,OAAAI,WAAAyqC,KAAAvrB,OAAAjf,aACAwqC,KAAA7qC,OAAAzR,SAAAs8C,KAAAxqC,cAIAwqC,KAAA7qC,OAAAnU,KAAAg/C,KAAAxqC,aAIAwqC,KAAA7qC,OAAA8O,UAAA+7B,KAAAvsD,SAAAusD,KAAAjyC,WAAAiyC,KAAA78B,SAQAjpB,MAAAmlD,SAAAvuD,UAAAkG,OAAA,WAEA,GAAAipD,cAAA,GAAA/lD,OAAAkb,OAEA,mBAIA,OAAAtU,GAAA,EAAAg/C,GAAAtvD,KAAAyjD,MAAA9+C,OAA0C2qD,GAAAh/C,EAAQA,IAAA,CAIlD,GAAAqU,QAAA3kB,KAAAyjD,MAAAnzC,GAAAtQ,KAAAyjD,MAAAnzC,GAAA0U,YAAAhlB,KAAAgvD,cAEAS,cAAA5qC,iBAAAF,OAAA3kB,KAAA8uD,aAAAx+C,IACAm/C,aAAAtiC,qBAAAntB,KAAAmvD,aAAA,GAAA7+C,GAIAtQ,KAAA+uD,mBAEA/uD,KAAAovD,YAAAzmB,aAAA,OAiBAj/B,MAAAgmD,YAAA,SAAAvsD,SAAAE,SAAA0rD,kBAEArlD,MAAAhG,KAAApE,KAAAU,KAAAmD,SAAAE,UAEArD,KAAAoG,KAAA,cAEApG,KAAA2vD,SAAA,WACA3vD,KAAA4vD,WAAA,GAAAlmD,OAAAkb,QACA5kB,KAAA6vD,kBAAA,GAAAnmD,OAAAkb,OAOA,IAAA6+B,SAEA,IAAAzjD,KAAAmD,UAAAyG,SAAA5J,KAAAmD,SAAAsgD,MAAA,CAIA,OAFA+L,MAAAM,MAAArwD,EAAAyR,EAAAH,EAEAT,EAAA,EAAAg/C,GAAAtvD,KAAAmD,SAAAsgD,MAAA9+C,OAAmD2qD,GAAAh/C,IAAQA,EAE3Dw/C,MAAA9vD,KAAAmD,SAAAsgD,MAAAnzC,GAEA7Q,EAAAqwD,MAAAC,IACA7+C,EAAA4+C,MAAAE,KACAj/C,EAAA++C,MAAAG,IAEAT,KAAA,GAAA9lD,OAAAilD,KAAA3uD,MACAyjD,MAAAn/C,KAAAkrD,MAEAA,KAAAxrB,KAAA8rB,MAAA9rB,KACAwrB,KAAAvsD,SAAAkN,IAAA1Q,EAAA,GAAAA,EAAA,GAAAA,EAAA,IACA+vD,KAAAjyC,WAAApN,IAAAe,EAAA,GAAAA,EAAA,GAAAA,EAAA,GAAAA,EAAA,IAEAtH,SAAAmH,EAEAy+C,KAAA78B,MAAAxiB,IAAAY,EAAA,GAAAA,EAAA,GAAAA,EAAA,IAIAy+C,KAAA78B,MAAAxiB,IAAA,MAMA,QAAAG,GAAA,EAAAg/C,GAAAtvD,KAAAmD,SAAAsgD,MAAA9+C,OAAmD2qD,GAAAh/C,IAAQA,EAE3Dw/C,MAAA9vD,KAAAmD,SAAAsgD,MAAAnzC,GAEA,KAAAw/C,MAAA7rB,OAEAwf,MAAAqM,MAAA7rB,QAAAtgC,IAAA8/C,MAAAnzC,IAIAtQ,KAAA2D,IAAA8/C,MAAAnzC,IAQAtQ,KAAAkwD,uBAEAlwD,KAAAmrB,mBAAA,GACAnrB,KAAA+G,KAAA,GAAA2C,OAAAmlD,SAAApL,MAAA75C,OAAAmlD,oBAKArlD,MAAAgmD,YAAApvD,UAAAujC,OAAAiG,OAAApgC,MAAAhG,KAAApD,WACAoJ,MAAAgmD,YAAApvD,UAAAM,YAAA8I,MAAAgmD,YAEAhmD,MAAAgmD,YAAApvD,UAAAyG,KAAA,SAAAopD,SAAAP,YAEA5vD,KAAAmwD,kBAEAvmD,SAAAgmD,aAEA5vD,KAAAmrB,mBAAA,GAEAykC,WAAA5vD,KAAAglB,aAIAhlB,KAAA4vD,WAAAp/C,KAAAo/C,YACA5vD,KAAA6vD,kBAAA9qC,WAAA6qC,aAIAlmD,MAAAgmD,YAAApvD,UAAAivD,KAAA,WAEAvvD,KAAAmwD,SAAAZ,QAIA7lD,MAAAgmD,YAAApvD,UAAA4vD,qBAAA,WAEA,GAAAlwD,KAAAmD,mBAAAuG,OAAA4hB,SAEA,OAAA5mB,GAAA,EAAkBA,EAAA1E,KAAAmD,SAAAytC,YAAAjsC,OAAsCD,IAAA,CAExD,GAAA0rD,IAAApwD,KAAAmD,SAAAwtC,YAAAjsC,GAEAiuB,MAAA,EAAAy9B,GAAAlrC,iBAEAyN,SAAAnJ,IAEA4mC,GAAAj9C,eAAAwf,OAIAy9B,GAAAjgD,IAAA,KAcAzG,MAAAgmD,YAAApvD,UAAA6qB,kBAAA,SAAAwb,OAEAj9B,MAAAhG,KAAApD,UAAA6qB,kBAAA7rB,KAAAU,MAAA,GAEA,aAAAA,KAAA2vD,SAEA3vD,KAAA6vD,kBAAA9qC,WAAA/kB,KAAAglB,aAEE,aAAAhlB,KAAA2vD,SAEF3vD,KAAA6vD,kBAAA9qC,WAAA/kB,KAAA4vD,YAIAlmD,MAAAK,KAAA,6CAAA/J,KAAA2vD,WAMAjmD,MAAAgmD,YAAApvD,UAAAqT,MAAA,SAAAsX,QAUA,MARArhB,UAAAqhB,SAEAA,OAAA,GAAAvhB,OAAAgmD,YAAA1vD,KAAAmD,SAAAnD,KAAAqD,SAAArD,KAAA+uD,mBAIArlD,MAAAhG,KAAApD,UAAAqT,MAAArU,KAAAU,KAAAirB,QAEAA,QAWAvhB,MAAA2mD,cAAA,SAAAltD,SAAAE,UAEAqG,MAAAhG,KAAApE,KAAAU,KAAAmD,SAAAE,UAEArD,KAAAoG,KAAA,gBAIApG,KAAAswD,SAAA,IACAtwD,KAAAuwD,cAAA,EACAvwD,KAAAwwD,KAAA,EAIAxwD,KAAAywD,aAAA,EACAzwD,KAAA0wD,gBAAA,EAEA1wD,KAAA80B,UAAA,EACA90B,KAAA2wD,oBAAA,EAEA3wD,KAAA4wD,cAAA,EAAA5wD,KAAAmD,SAAAqtC,aAAA7rC,OAAA,IAIA+E,MAAA2mD,cAAA/vD,UAAAujC,OAAAiG,OAAApgC,MAAAhG,KAAApD,WACAoJ,MAAA2mD,cAAA/vD,UAAAM,YAAA8I,MAAA2mD,cAEA3mD,MAAA2mD,cAAA/vD,UAAAswD,cAAA,SAAApoC,MAAAC,KAEAzoB,KAAA6wD,cAAAroC,MACAxoB,KAAA8wD,YAAAroC,IAEAzoB,KAAA2E,OAAA3E,KAAA8wD,YAAA9wD,KAAA6wD,cAAA,GAIAnnD,MAAA2mD,cAAA/vD,UAAAywD,oBAAA,WAEA/wD,KAAA80B,UAAA,EACA90B,KAAA2wD,oBAAA,GAIAjnD,MAAA2mD,cAAA/vD,UAAA0wD,qBAAA,WAEAhxD,KAAA80B,UAAA,GACA90B,KAAA2wD,oBAAA,GAIAjnD,MAAA2mD,cAAA/vD,UAAA2wD,gBAAA,WAEA,GAAA9tD,UAAAnD,KAAAmD,QAEAA,UAAAwgD,aAAAxgD,SAAAwgD,cAMA,QAJAuN,gBAAAvN,WAAAxgD,SAAAwgD,WAEAwN,QAAA,kBAEAzsD,EAAA,EAAAklB,GAAAzmB,SAAAqtC,aAAA7rC,OAAoDilB,GAAAllB,EAAQA,IAAA,CAE5D,GAAA0sD,OAAAjuD,SAAAqtC,aAAA9rC,GACAa,MAAA6rD,MAAAptB,KAAAqtB,MAAAF,QAEA,IAAA5rD,aAAAZ,OAAA,GAEA,GAAA2sD,OAAA/rD,MAAA,EAEAo+C,YAAA2N,SAAA3N,WAAA2N,QAAuD9oC,MAAAgB,IAAAf,MAAAe,MAEvD,IAAAk6B,WAAAC,WAAA2N,MAEA5sD,GAAAg/C,UAAAl7B,QAAAk7B,UAAAl7B,MAAA9jB,GACAA,EAAAg/C,UAAAj7B,MAAAi7B,UAAAj7B,IAAA/jB,GAEAwsD,gCAAAI,QAMAnuD,SAAA+tD,+BAIAxnD,MAAA2mD,cAAA/vD,UAAAixD,kBAAA,SAAAD,MAAA9oC,MAAAC,KAEAzoB,KAAAmD,SAAAwgD,aAAA3jD,KAAAmD,SAAAwgD,eAEA3jD,KAAAmD,SAAAwgD,WAAA2N,QAAsC9oC,YAAAC,UAItC/e,MAAA2mD,cAAA/vD,UAAAkxD,cAAA,SAAAF,MAAAG,KAEA,GAAA/N,WAAA1jD,KAAAmD,SAAAwgD,WAAA2N,MAEA5N,YAEA1jD,KAAA4wD,cAAAlN,UAAAl7B,MAAAk7B,UAAAj7B,KACAzoB,KAAAswD,SAAA,MAAA5M,UAAAj7B,IAAAi7B,UAAAl7B,OAAAipC,KACAzxD,KAAAwwD,KAAA,GAIA9mD,MAAAK,KAAA,kCAAAunD,MAAA,oCAMA5nD,MAAA2mD,cAAA/vD,UAAAoxD,gBAAA,SAAA/+C,OAEA,GAAAg/C,WAAA3xD,KAAAswD,SAAAtwD,KAAA2E,MAEA3E,MAAAwwD,MAAAxwD,KAAA80B,UAAAniB,MAEA3S,KAAAuwD,cAEAvwD,KAAAwwD,KAAAxwD,KAAAswD,UAAAtwD,KAAAwwD,KAAA,KAEAxwD,KAAA80B,WAAA,GAEA90B,KAAAwwD,KAAAxwD,KAAAswD,WAEAtwD,KAAAwwD,KAAAxwD,KAAAswD,SACAtwD,KAAA2wD,oBAAA,GAIA3wD,KAAAwwD,KAAA,IAEAxwD,KAAAwwD,KAAA,EACAxwD,KAAA2wD,oBAAA,KAQA3wD,KAAAwwD,KAAAxwD,KAAAwwD,KAAAxwD,KAAAswD,SAEAtwD,KAAAwwD,KAAA,IAAAxwD,KAAAwwD,MAAAxwD,KAAAswD,UAIA,IAAAsB,UAAA5xD,KAAA6wD,cAAAnnD,MAAAG,KAAA0Y,MAAA1Y,KAAA+G,MAAA5Q,KAAAwwD,KAAAmB,WAAA,EAAA3xD,KAAA2E,OAAA,EAEAitD,YAAA5xD,KAAA0wD,kBAEA1wD,KAAAguD,sBAAAhuD,KAAAywD,cAAA,EACAzwD,KAAAguD,sBAAAhuD,KAAA0wD,iBAAA,EAEA1wD,KAAAguD,sBAAA4D,UAAA,EAEA5xD,KAAAywD,aAAAzwD,KAAA0wD,gBACA1wD,KAAA0wD,gBAAAkB,SAIA,IAAAC,KAAA7xD,KAAAwwD,KAAAmB,mBAEA3xD,MAAA2wD,qBAEAkB,IAAA,EAAAA,KAIA7xD,KAAAguD,sBAAAhuD,KAAA0wD,iBAAAmB,IACA7xD,KAAAguD,sBAAAhuD,KAAAywD,cAAA,EAAAoB,KAIAnoD,MAAA2mD,cAAA/vD,UAAAwxD,mBAAA,SAAA1xC,EAAA9P,EAAAa,GAIA,OAFA4gD,YAAA/xD,KAAAguD,sBAEAtpD,EAAA,EAAAsM,EAAA+gD,WAAAptD,OAAwCqM,EAAAtM,EAAOA,IAE/CqtD,WAAArtD,GAAA,CAIA0b,GAAA,KAAA2xC,WAAA3xC,GAAA,EAAAjP,GACAb,EAAA,KAAAyhD,WAAAzhD,GAAAa,IAIAzH,MAAA2mD,cAAA/vD,UAAAqT,MAAA,SAAAsX,QAgBA,MAdArhB,UAAAqhB,gBAAA,GAAAvhB,OAAA2mD,cAAArwD,KAAAmD,SAAAnD,KAAAqD,WAEA4nB,OAAAqlC,SAAAtwD,KAAAswD,SACArlC,OAAAslC,aAAAvwD,KAAAuwD,aACAtlC,OAAAulC,KAAAxwD,KAAAwwD,KAEAvlC,OAAAwlC,aAAAzwD,KAAAywD,aACAxlC,OAAAylC,gBAAA1wD,KAAA0wD,gBAEAzlC,OAAA6J,UAAA90B,KAAA80B,UACA7J,OAAA0lC,mBAAA3wD,KAAA2wD,mBAEAjnD,MAAAhG,KAAApD,UAAAqT,MAAArU,KAAAU,KAAAirB,QAEAA,QAYAvhB,MAAAk5B,IAAA,WAEAl5B,MAAAk6B,SAAAtkC,KAAAU,MAEAA,KAAA2jC,YAKAj6B,MAAAk5B,IAAAtiC,UAAAujC,OAAAiG,OAAApgC,MAAAk6B,SAAAtjC,WACAoJ,MAAAk5B,IAAAtiC,UAAAM,YAAA8I,MAAAk5B,IAEAl5B,MAAAk5B,IAAAtiC,UAAA0xD,SAAA,SAAA/mC,OAAApC,UAEAjf,SAAAif,oBAAA,GAEAA,SAAAhf,KAAA+V,IAAAiJ,SAEA,QAAA7X,GAAA,EAAiBA,EAAAhR,KAAA2jC,QAAAh/B,UAEjBkkB,SAAA7oB,KAAA2jC,QAAA3yB,GAAA6X,UAF0C7X,KAU1ChR,KAAA2jC,QAAAtB,OAAArxB,EAAA,GAA6B6X,kBAAAoC,gBAC7BjrB,KAAA2D,IAAAsnB,SAIAvhB,MAAAk5B,IAAAtiC,UAAA2xD,qBAAA,SAAAppC,UAEA,OAAAnkB,GAAA,EAAAsM,EAAAhR,KAAA2jC,QAAAh/B,OAA0CqM,EAAAtM,KAE1CmkB,SAAA7oB,KAAA2jC,QAAAj/B,GAAAmkB,UAFiDnkB,KAUjD,MAAA1E,MAAA2jC,QAAAj/B,EAAA,GAAAumB,QAIAvhB,MAAAk5B,IAAAtiC,UAAA6iC,QAAA,WAEA,GAAA+uB,gBAAA,GAAAxoD,OAAAgW,OAEA,iBAAAsjB,UAAAC,YAEAivB,eAAA7rC,sBAAArmB,KAAAglB,YAEA,IAAA6D,UAAAma,UAAAjO,IAAAF,OAAA9R,WAAAmvC;AAEAlyD,KAAAiyD,qBAAAppC,UAAAsa,QAAAH,UAAAC,gBAMAv5B,MAAAk5B,IAAAtiC,UAAAkG,OAAA,WAEA,GAAA8Y,IAAA,GAAA5V,OAAAgW,QACA4D,GAAA,GAAA5Z,OAAAgW,OAEA,iBAAA7c,QAEA,GAAA7C,KAAA2jC,QAAAh/B,OAAA,GAEA2a,GAAA+G,sBAAAxjB,OAAAmiB,aACA1B,GAAA+C,sBAAArmB,KAAAglB,YAEA,IAAA6D,UAAAvJ,GAAAyD,WAAAO,GAEAtjB,MAAA2jC,QAAA,GAAA1Y,OAAAyZ,SAAA,CAEA,QAAAhgC,GAAA,EAAAsM,EAAAhR,KAAA2jC,QAAAh/B,OAA4CqM,EAAAtM,GAE5CmkB,UAAA7oB,KAAA2jC,QAAAj/B,GAAAmkB,SAFmDnkB,IAInD1E,KAAA2jC,QAAAj/B,EAAA,GAAAumB,OAAAyZ,SAAA,EACA1kC,KAAA2jC,QAAAj/B,GAAAumB,OAAAyZ,SAAA,CAUA,MAAU1zB,EAAAtM,EAAOA,IAEjB1E,KAAA2jC,QAAAj/B,GAAAumB,OAAAyZ,SAAA,OAUAh7B,MAAAk5B,IAAAtiC,UAAAqT,MAAA,SAAAsX,QAEArhB,SAAAqhB,gBAAA,GAAAvhB,OAAAk5B,KAEAl5B,MAAAk6B,SAAAtjC,UAAAqT,MAAArU,KAAAU,KAAAirB,OAEA,QAAAvmB,GAAA,EAAAsM,EAAAhR,KAAA2jC,QAAAh/B,OAA0CqM,EAAAtM,EAAOA,IAAA,CACjD,GAAAR,GAAAlE,KAAA2jC,QAAAj/B,GAAAumB,OAAAtX,OACAzP,GAAAwgC,QAAA,IAAAhgC,EACAumB,OAAA+mC,SAAA9tD,EAAAlE,KAAA2jC,QAAAj/B,GAAAmkB,UAGA,MAAAoC,SAWAvhB,MAAA+4B,OAAA,WAEA,GAAAiK,SAAA,GAAA4B,cAAA,cACA/iB,SAAA,GAAAQ,gBAAA,qCACAmf,IAAA,GAAAnf,eAAA,kBAEA5oB,SAAA,GAAAuG,OAAA8hB,cAKA,OAJAroB,UAAAinC,aAAA,WAAA1gC,OAAAg/B,gBAAAgE,QAAA,IACAvpC,SAAAinC,aAAA,cAAA1gC,OAAAg/B,gBAAAnd,SAAA,IACApoB,SAAAinC,aAAA,QAAA1gC,OAAAg/B,gBAAAwC,IAAA,IAEA,SAAA7nC,UAEAqG,MAAAk6B,SAAAtkC,KAAAU,MAEAA,KAAAoG,KAAA,SAEApG,KAAAmD,kBACAnD,KAAAqD,SAAAuG,SAAAvG,kBAAA,GAAAqG,OAAAqgD,mBAMArgD,MAAA+4B,OAAAniC,UAAAujC,OAAAiG,OAAApgC,MAAAk6B,SAAAtjC,WACAoJ,MAAA+4B,OAAAniC,UAAAM,YAAA8I,MAAA+4B,OAEA/4B,MAAA+4B,OAAAniC,UAAA6iC,QAAA,WAEA,GAAA+uB,gBAAA,GAAAxoD,OAAAgW,OAEA,iBAAAsjB,UAAAC,YAEAivB,eAAA7rC,sBAAArmB,KAAAglB,YAEA,IAAA6D,UAAAma,UAAAjO,IAAArK,gBAAAwnC,eAEArpC,UAAA7oB,KAAA2yB,MAAAzuB,GAMA++B,WAAA3+B,MAEAukB,kBACAK,MAAAlpB,KAAAiD,SACAulC,KAAA,KACAvd,OAAAjrB,WAQA0J,MAAA+4B,OAAAniC,UAAAqT,MAAA,SAAAsX,QAMA,MAJArhB,UAAAqhB,gBAAA,GAAAvhB,OAAA+4B,OAAAziC,KAAAqD,WAEAqG,MAAAk6B,SAAAtjC,UAAAqT,MAAArU,KAAAU,KAAAirB,QAEAA,QAMAvhB,MAAAyoD,SAAAzoD,MAAA+4B,OASA/4B,MAAA0oD,UAAA,SAAApW,QAAAjyB,KAAAlB,SAAA20B,SAAAj6C,OAEAmG,MAAAk6B,SAAAtkC,KAAAU,MAEAA,KAAAqyD,cAEAryD,KAAAsyD,eAAA,GAAA5oD,OAAAgW,QACA1f,KAAAuyD,qBAAA3oD,OAEAA,SAAAoyC,SAEAh8C,KAAA2D,IAAAq4C,QAAAjyB,KAAAlB,SAAA20B,SAAAj6C,QAMAmG,MAAA0oD,UAAA9xD,UAAAujC,OAAAiG,OAAApgC,MAAAk6B,SAAAtjC,WACAoJ,MAAA0oD,UAAA9xD,UAAAM,YAAA8I,MAAA0oD,UAOA1oD,MAAA0oD,UAAA9xD,UAAAqD,IAAA,SAAAq4C,QAAAjyB,KAAAlB,SAAA20B,SAAAj6C,MAAA25C,SAEAtzC,SAAAmgB,YAAA,IACAngB,SAAAif,oBAAA,GACAjf,SAAAszC,kBAAA,GACAtzC,SAAArG,cAAA,GAAAmG,OAAAuG,MAAA,WACArG,SAAA4zC,oBAAA9zC,MAAA8B,gBAEAqd,SAAAhf,KAAAyH,IAAAuX,SAAAhf,KAAA4I,IAAA,EAAAoW,WAEA7oB,KAAAqyD,WAAA/tD,MACA03C,gBACAjyB,UACAlB,kBACA3kB,EAAA,EAAAC,EAAA,EAAAjB,EAAA,EACAyvB,MAAA,EACA1uB,SAAA,EACAi5C,gBACA35C,YACAi6C,qBAUA9zC,MAAA0oD,UAAA9xD,UAAAkyD,iBAAA,WAEA,GAAA3lC,GACA4lC,MADA3gB,GAAA9xC,KAAAqyD,WAAA1tD,OAEA+tD,KAAA,GAAA1yD,KAAAsyD,eAAApuD,EACAyuD,KAAA,GAAA3yD,KAAAsyD,eAAAnuD,CAEA,KAAA0oB,EAAA,EAAailB,GAAAjlB,EAAQA,IAErB4lC,MAAAzyD,KAAAqyD,WAAAxlC,GAEA4lC,MAAAvuD,EAAAlE,KAAAsyD,eAAApuD,EAAAwuD,KAAAD,MAAA5pC,SACA4pC,MAAAtuD,EAAAnE,KAAAsyD,eAAAnuD,EAAAwuD,KAAAF,MAAA5pC,SAEA4pC,MAAAG,eAAAH,MAAAvuD,EAAA2F,KAAAud,GAAA,IACAqrC,MAAAxuD,UAAA,KAAAwuD,MAAAG,eAAAH,MAAAxuD,WAaAyF,MAAA5J,MAAA,WAEA4J,MAAAk6B,SAAAtkC,KAAAU,MAEAA,KAAAoG,KAAA,QAEApG,KAAAoqD,IAAA,KACApqD,KAAA6yD,iBAAA,KAEA7yD,KAAA8yD,YAAA,GAIAppD,MAAA5J,MAAAQ,UAAAujC,OAAAiG,OAAApgC,MAAAk6B,SAAAtjC,WACAoJ,MAAA5J,MAAAQ,UAAAM,YAAA8I,MAAA5J,MAEA4J,MAAA5J,MAAAQ,UAAAqT,MAAA,SAAAsX,QAYA,MAVArhB,UAAAqhB,gBAAA,GAAAvhB,OAAA5J,OAEA4J,MAAAk6B,SAAAtjC,UAAAqT,MAAArU,KAAAU,KAAAirB,QAEA,OAAAjrB,KAAAoqD,MAAAn/B,OAAAm/B,IAAApqD,KAAAoqD,IAAAz2C,SACA,OAAA3T,KAAA6yD,mBAAA5nC,OAAA4nC,iBAAA7yD,KAAA6yD,iBAAAl/C,SAEAsX,OAAA6nC,WAAA9yD,KAAA8yD,WACA7nC,OAAAuZ,iBAAAxkC,KAAAwkC,iBAEAvZ,QAWAvhB,MAAAqpD,IAAA,SAAAxvD,MAAA2wB,KAAAC,KAEAn0B,KAAAgkC,KAAA,GAEAhkC,KAAAuD,MAAA,GAAAmG,OAAAuG,MAAA1M,OAEAvD,KAAAk0B,KAAAtqB,SAAAsqB,UAAA,EACAl0B,KAAAm0B,IAAAvqB,SAAAuqB,QAAA,KAIAzqB,MAAAqpD,IAAAzyD,UAAAqT,MAAA,WAEA,UAAAjK,OAAAqpD,IAAA/yD,KAAAuD,MAAA0O,SAAAjS,KAAAk0B,KAAAl0B,KAAAm0B,MAWAzqB,MAAAspD,QAAA,SAAAzvD,MAAA0vD,SAEAjzD,KAAAgkC,KAAA,GAEAhkC,KAAAuD,MAAA,GAAAmG,OAAAuG,MAAA1M,OACAvD,KAAAizD,QAAArpD,SAAAqpD,gBAAA,OAIAvpD,MAAAspD,QAAA1yD,UAAAqT,MAAA,WAEA,UAAAjK,OAAAspD,QAAAhzD,KAAAuD,MAAA0O,SAAAjS,KAAAizD,UAMAvpD,MAAAwpD,eAIAxpD,MAAAwpD,YAAA,gjFAIAxpD,MAAAwpD,YAAA,iGAIAxpD,MAAAwpD,YAAA,itJAIAxpD,MAAAwpD,YAAA,gHAIAxpD,MAAAwpD,YAAA,6TAIAxpD,MAAAwpD,YAAA,iPAIAxpD,MAAAwpD,YAAA,seAIAxpD,MAAAwpD,YAAA,qKAIAxpD,MAAAwpD,YAAA,4EAIAxpD,MAAAwpD,YAAA,68OAIAxpD,MAAAwpD,YAAA,mMAIAxpD,MAAAwpD,YAAA,waAIAxpD,MAAAwpD,YAAA,4XAIAxpD,MAAAwpD,YAAA,4JAIAxpD,MAAAwpD,YAAA,kvBAIAxpD,MAAAwpD,YAAA,mJAIAxpD,MAAAwpD,YAAA,4GAIAxpD,MAAAwpD,YAAA,kKAIAxpD,MAAAwpD,YAAA,mJAIAxpD,MAAAwpD,YAAA,2KAIAxpD,MAAAwpD,YAAA,gEAIAxpD,MAAAwpD,YAAA,6KAIAxpD,MAAAwpD,YAAA,4EAIAxpD,MAAAwpD,YAAA,uFAIAxpD,MAAAwpD,YAAA,4eAIAxpD,MAAAwpD,YAAA,yMAIAxpD,MAAAwpD,YAAA,iFAIAxpD,MAAAwpD,YAAA,wEAIAxpD,MAAAwpD,YAAA,woCAIAxpD,MAAAwpD,YAAA,uNAIAxpD,MAAAwpD,YAAA,kxDAIAxpD,MAAAwpD,YAAA,gGAIAxpD,MAAAwpD,YAAA,2RAIAxpD,MAAAwpD,YAAA,0MAIAxpD,MAAAwpD,YAAA,sNAIAxpD,MAAAwpD,YAAA,weAIAxpD,MAAAwpD,YAAA,klCAIAxpD,MAAAwpD,YAAA,iVAIAxpD,MAAAwpD,YAAA;AAIAxpD,MAAAwpD,YAAA,kPAIAxpD,MAAAwpD,YAAA,+MAIAxpD,MAAAwpD,YAAA,2HAIAxpD,MAAAwpD,YAAA,iJAIAxpD,MAAAwpD,YAAA,4EAIAxpD,MAAAwpD,YAAA,ktBAIAxpD,MAAAwpD,YAAA,idAIAxpD,MAAAwpD,YAAA,4zOAIAxpD,MAAAwpD,YAAA,gYAIAxpD,MAAAwpD,YAAA,0gBAIAxpD,MAAAwpD,YAAA,4jCAIAxpD,MAAAwpD,YAAA,gNAIAxpD,MAAAwpD,YAAA,wGAIAxpD,MAAAwpD,YAAA,yFAQAxpD,MAAAgiD,eAEApc,MAAA,SAAAiV,UAIA,OAFA4O,WAEA5yB,EAAA,EAAkBA,EAAAgkB,SAAA5/C,OAAqB47B,IAAA,CAEvC,GAAArT,KAAAltB,KAAA2T,MAAA4wC,SAAAhkB,GAEA,QAAA9gC,KAAAytB,KAEAimC,OAAA1zD,GAAAytB,IAAAztB,GAMA,MAAA0zD,SAIAx/C,MAAA,SAAAy/C,cAEA,GAAAC,gBAEA,QAAA9yB,KAAA6yB,cAAA,CAEAC,aAAA9yB,KAEA,QAAA9gC,KAAA2zD,cAAA7yB,GAAA,CAEA,GAAA+yB,eAAAF,aAAA7yB,GAAA9gC,EAEA6zD,yBAAA5pD,OAAAuG,OACAqjD,wBAAA5pD,OAAAiY,SACA2xC,wBAAA5pD,OAAAgW,SACA4zC,wBAAA5pD,OAAAod,SACAwsC,wBAAA5pD,OAAAkb,SACA0uC,wBAAA5pD,OAAA2yC,QAEAgX,aAAA9yB,GAAA9gC,GAAA6zD,cAAA3/C,QAEK2/C,wBAAAr3B,OAELo3B,aAAA9yB,GAAA9gC,GAAA6zD,cAAAnhD,QAIAkhD,aAAA9yB,GAAA9gC,GAAA6zD,eAQA,MAAAD,gBAYA3pD,MAAA6pD,aAEAC,QAEAC,SAAertD,KAAA,IAAAmK,MAAA,GAAA7G,OAAAuG,MAAA,WACfitC,SAAe92C,KAAA,IAAAmK,MAAA,GAEf4sC,KAAW/2C,KAAA,IAAAmK,MAAA,MACXmjD,cAAoBttD,KAAA,KAAAmK,MAAA,GAAA7G,OAAAod,QAAA,UAEpBs2B,UAAgBh3C,KAAA,IAAAmK,MAAA,MAChB22C,aAAmB9gD,KAAA,IAAAmK,MAAA,MACnBy2C,UAAgB5gD,KAAA,IAAAmK,MAAA,MAEhB02C,QAAc7gD,KAAA,IAAAmK,MAAA,MACdojD,YAAkBvtD,KAAA,IAAAmK,MAAA,IAClBk6C,cAAoBrkD,KAAA,IAAAmK,MAAA,GACpBm6C,iBAAuBtkD,KAAA,IAAAmK,MAAA,KAEvBy9C,uBAA6B5nD,KAAA,IAAAmK,MAAA,IAI7BqjD,MAEAtW,SAAel3C,KAAA,IAAAmK,MAAA,MACfgwC,WAAiBn6C,KAAA,IAAAmK,MAAA,IAIjBsjD,WAEAxW,WAAiBj3C,KAAA,IAAAmK,MAAA,MACjBkwC,aAAmBr6C,KAAA,KAAAmK,MAAA,GAAA7G,OAAAiY,QAAA,OAGnByoC,KAEA0J,YAAkB1tD,KAAA,IAAAmK,MAAA,OAClBwjD,SAAe3tD,KAAA,IAAAmK,MAAA,GACfyjD,QAAc5tD,KAAA,IAAAmK,MAAA,KACd0jD,UAAgB7tD,KAAA,IAAAmK,MAAA,GAAA7G,OAAAuG,MAAA,YAIhBq7C,QAEA4I,mBAAyB9tD,KAAA,KAAAmK,UAEzB4jD,2BAAiC/tD,KAAA,KAAAmK,UACjC6jD,uBAA6BhuD,KAAA,KAAAmK,UAE7B8jD,0BAAgCjuD,KAAA,KAAAmK,UAChC+jD,yBAA+BluD,KAAA,KAAAmK,UAC/BgkD,4BAAkCnuD,KAAA,KAAAmK,UAElCikD,iBAAuBpuD,KAAA,KAAAmK,UACvBkkD,oBAA0BruD,KAAA,KAAAmK,UAC1BmkD,oBAA0BtuD,KAAA,MAAAmK,UAC1BokD,iBAAuBvuD,KAAA,MAAAmK,UAEvBqkD,gBAAsBxuD,KAAA,KAAAmK,UACtBskD,mBAAyBzuD,KAAA,KAAAmK,UACzBukD,oBAA0B1uD,KAAA,KAAAmK,UAC1BwkD,mBAAyB3uD,KAAA,MAAAmK,UACzBykD,mBAAyB5uD,KAAA,MAAAmK,UACzB0kD,mBAAyB7uD,KAAA,MAAAmK,UACzB2kD,gBAAsB9uD,KAAA,MAAAmK,WAItB4kD,UAEAC,SAAehvD,KAAA,IAAAmK,MAAA,GAAA7G,OAAAuG,MAAA,WACfitC,SAAe92C,KAAA,IAAAmK,MAAA,GACfwZ,MAAY3jB,KAAA,IAAAmK,MAAA,GACZoiB,OAAavsB,KAAA,IAAAmK,MAAA,GACb4sC,KAAW/2C,KAAA,IAAAmK,MAAA,MACXmjD,cAAoBttD,KAAA,KAAAmK,MAAA,GAAA7G,OAAAod,QAAA,UAEpBgtC,YAAkB1tD,KAAA,IAAAmK,MAAA,OAClBwjD,SAAe3tD,KAAA,IAAAmK,MAAA,GACfyjD,QAAc5tD,KAAA,IAAAmK,MAAA,KACd0jD,UAAgB7tD,KAAA,IAAAmK,MAAA,GAAA7G,OAAAuG,MAAA,YAIhBolD,WAEAnc,WAAgB9yC,KAAA,KAAAmK,UAChB4oC,eAAoB/yC,KAAA,MAAAmK,UAEpB8nC,YAAkBjyC,KAAA,MAAAmK,UAClB+nC,gBAAqBlyC,KAAA,MAAAmK,UAErB8oC,cAAoBjzC,KAAA,MAAAmK,YAiBpB7G,MAAA4rD,WAEAC,OAEAhR,SAAA76C,MAAAgiD,cAAApc,OAEA5lC,MAAA6pD,YAAA,OACA7pD,MAAA6pD,YAAA,IACA7pD,MAAA6pD,YAAA,YAIA/O,cAEA96C,MAAAwpD,YAAA,OACAxpD,MAAAwpD,YAAA,gBACAxpD,MAAAwpD,YAAA,qBACAxpD,MAAAwpD,YAAA,mBACAxpD,MAAAwpD,YAAA,kBACAxpD,MAAAwpD,YAAA,wBACAxpD,MAAAwpD,YAAA,qBACAxpD,MAAAwpD,YAAA,sBACAxpD,MAAAwpD,YAAA,wBAEA,gBAEAxpD,MAAAwpD,YAAA,WACAxpD,MAAAwpD,YAAA,gBACAxpD,MAAAwpD,YAAA,aACAxpD,MAAAwpD,YAAA,gBAEA,qBAEAxpD,MAAAwpD,YAAA,mBACAxpD,MAAAwpD,YAAA,kBACAxpD,MAAAwpD,YAAA,qBAEA,UAEAxpD,MAAAwpD,YAAA,mBACAxpD,MAAAwpD,YAAA,gBACAxpD,MAAAwpD,YAAA,eACAxpD,MAAAwpD,YAAA,mBAEAxpD,MAAAwpD,YAAA,gBACAxpD,MAAAwpD,YAAA,cACAxpD,MAAAwpD,YAAA,iBAEA,KAEAruD,KAAA,MAEA4/C,gBAEA,wBACA,yBAEA/6C,MAAAwpD,YAAA,OACAxpD,MAAAwpD,YAAA,oBACAxpD,MAAAwpD,YAAA,kBACAxpD,MAAAwpD,YAAA,uBACAxpD,MAAAwpD,YAAA,uBACAxpD,MAAAwpD,YAAA,qBACAxpD,MAAAwpD,YAAA,kBACAxpD,MAAAwpD,YAAA,wBACAxpD,MAAAwpD,YAAA,0BACAxpD,MAAAwpD,YAAA,0BAEA,gBAEA,qCACA,iDAEAxpD,MAAAwpD,YAAA,qBACAxpD,MAAAwpD,YAAA,aACAxpD,MAAAwpD,YAAA,eACAxpD,MAAAwpD,YAAA,kBACAxpD,MAAAwpD,YAAA,mBACAxpD,MAAAwpD,YAAA,qBAEA,qCAEAxpD,MAAAwpD,YAAA,kBACAxpD,MAAAwpD,YAAA,gBACAxpD,MAAAwpD,YAAA,mBAEAxpD,MAAAwpD,YAAA,yBAEAxpD,MAAAwpD,YAAA,aAEA,yDAEA,KAEAruD,KAAA,OAIA2wD,SAEAjR,SAAA76C,MAAAgiD,cAAApc,OAEA5lC,MAAA6pD,YAAA,OACA7pD,MAAA6pD,YAAA,IACA7pD,MAAA6pD,YAAA,OACA7pD,MAAA6pD,YAAA,WAGAnV,UAAkBh4C,KAAA,IAAAmK,MAAA,GAAA7G,OAAAuG,MAAA,IAClB+6C,SAAkB5kD,KAAA,KAAAmK,MAAA,GAAA7G,OAAAgW,QAAA,WAKlB8kC,cAEA,kBAEA,4BAEA,sBAEA,4BAEA,SAEA96C,MAAAwpD,YAAA,OACAxpD,MAAAwpD,YAAA,gBACAxpD,MAAAwpD,YAAA,qBACAxpD,MAAAwpD,YAAA,mBACAxpD,MAAAwpD,YAAA,2BACAxpD,MAAAwpD,YAAA,kBACAxpD,MAAAwpD,YAAA,wBACAxpD,MAAAwpD,YAAA,qBACAxpD,MAAAwpD,YAAA,sBACAxpD,MAAAwpD,YAAA,wBAEA,gBAEAxpD,MAAAwpD,YAAA,WACAxpD,MAAAwpD,YAAA,gBACAxpD,MAAAwpD,YAAA,aAEAxpD,MAAAwpD,YAAA,mBACAxpD,MAAAwpD,YAAA,gBACAxpD,MAAAwpD,YAAA,kBACAxpD,MAAAwpD,YAAA,qBAEAxpD,MAAAwpD,YAAA,mBACAxpD,MAAAwpD,YAAA,gBACAxpD,MAAAwpD,YAAA,eACAxpD,MAAAwpD,YAAA,mBAEAxpD,MAAAwpD,YAAA,gBACAxpD,MAAAwpD,YAAA,cACAxpD,MAAAwpD,YAAA,sBACAxpD,MAAAwpD,YAAA,iBAEA,KAEAruD,KAAA,MAEA4/C,gBAEA,wBACA,yBACA,yBAEA,4BAEA,sBAEA,4BAEA,SAEA/6C,MAAAwpD,YAAA,OACAxpD,MAAAwpD,YAAA,oBACAxpD,MAAAwpD,YAAA,kBACAxpD,MAAAwpD,YAAA,uBACAxpD,MAAAwpD,YAAA,uBACAxpD,MAAAwpD,YAAA,qBACAxpD,MAAAwpD,YAAA,kBACAxpD,MAAAwpD,YAAA,wBACAxpD,MAAAwpD,YAAA,0BACAxpD,MAAAwpD,YAAA,0BAEA,gBAEA,qCACA,iDAEAxpD,MAAAwpD,YAAA,qBACAxpD,MAAAwpD,YAAA,aACAxpD,MAAAwpD,YAAA,eACAxpD,MAAAwpD,YAAA,kBACAxpD,MAAAwpD,YAAA,mBACAxpD,MAAAwpD,YAAA,qBAEA,uBAKA,0BACA,iEACA,SACA,gEAEA,SAEA,gEAEA,UAEAxpD,MAAAwpD,YAAA,kBACAxpD,MAAAwpD,YAAA,gBACAxpD,MAAAwpD,YAAA,mBAEAxpD,MAAAwpD,YAAA,yBAEAxpD,MAAAwpD,YAAA,aAEA,yDAEA,KAEAruD,KAAA,OAIA4wD,OAEAlR,SAAA76C,MAAAgiD,cAAApc,OAEA5lC,MAAA6pD,YAAA,OACA7pD,MAAA6pD,YAAA,KACA7pD,MAAA6pD,YAAA,UACA7pD,MAAA6pD,YAAA,IACA7pD,MAAA6pD,YAAA,OACA7pD,MAAA6pD,YAAA,WAGAnV,UAAkBh4C,KAAA,IAAAmK,MAAA,GAAA7G,OAAAuG,MAAA,IAClBiuC,UAAkB93C,KAAA,IAAAmK,MAAA,GAAA7G,OAAAuG,MAAA,UAClBsuC,WAAkBn4C,KAAA,IAAAmK,MAAA,IAClBy6C,SAAkB5kD,KAAA,KAAAmK,MAAA,GAAA7G,OAAAgW,QAAA,WAKlB8kC,cAEA,gBAEA,8BAEA,sBAEA,yBAEA,SAEA96C,MAAAwpD,YAAA,OACAxpD,MAAAwpD,YAAA,gBACAxpD,MAAAwpD,YAAA,qBACAxpD,MAAAwpD,YAAA,mBACAxpD,MAAAwpD,YAAA,yBACAxpD,MAAAwpD,YAAA,kBACAxpD,MAAAwpD,YAAA,wBACAxpD,MAAAwpD,YAAA,qBACAxpD,MAAAwpD,YAAA,sBACAxpD,MAAAwpD,YAAA,wBAEA,gBAEAxpD,MAAAwpD,YAAA,WACAxpD,MAAAwpD,YAAA,gBACAxpD,MAAAwpD,YAAA,aAEAxpD,MAAAwpD,YAAA,mBACAxpD,MAAAwpD,YAAA,gBACAxpD,MAAAwpD,YAAA,kBACAxpD,MAAAwpD,YAAA,qBAEA,sBAEA,6CAEA,SAEAxpD,MAAAwpD,YAAA,mBACAxpD,MAAAwpD,YAAA,gBACAxpD,MAAAwpD,YAAA,eACAxpD,MAAAwpD,YAAA,mBAEA,oCAEAxpD,MAAAwpD,YAAA,gBACAxpD,MAAAwpD,YAAA,cACAxpD,MAAAwpD,YAAA,oBACAxpD,MAAAwpD,YAAA,iBAEA,KAEAruD,KAAA,MAEA4/C,gBAEA,gBAEA,wBACA,yBACA,yBACA,2BACA,yBAEA/6C,MAAAwpD,YAAA,OACAxpD,MAAAwpD,YAAA,oBACAxpD,MAAAwpD,YAAA,kBACAxpD,MAAAwpD,YAAA,uBACAxpD,MAAAwpD,YAAA,uBACAxpD,MAAAwpD,YAAA,qBACAxpD,MAAAwpD,YAAA,kBACAxpD,MAAAwpD,YAAA,2BACAxpD,MAAAwpD,YAAA,wBACAxpD,MAAAwpD,YAAA,sBACAxpD,MAAAwpD,YAAA,wBACAxpD,MAAAwpD,YAAA,0BACAxpD,MAAAwpD,YAAA,0BAEA,gBAEA,qCACA,iDAEAxpD,MAAAwpD,YAAA,qBACAxpD,MAAAwpD,YAAA,aACAxpD,MAAAwpD,YAAA,eACAxpD,MAAAwpD,YAAA,kBACAxpD,MAAAwpD,YAAA,mBACAxpD,MAAAwpD,YAAA,qBAEAxpD,MAAAwpD,YAAA,sBAEAxpD,MAAAwpD,YAAA,kBACAxpD,MAAAwpD,YAAA,gBACAxpD,MAAAwpD,YAAA,mBAEAxpD,MAAAwpD,YAAA,yBAEAxpD,MAAAwpD,YAAA,aAEA,yDAEA,KAEAruD,KAAA,OAIA6wD,gBAEAnR,SAAA76C,MAAAgiD,cAAApc,OAEA5lC,MAAA6pD,YAAA,SACA7pD,MAAA6pD,YAAA,YAIA/O,cAEA,sBACA,uBAEA96C,MAAAwpD,YAAA,OACAxpD,MAAAwpD,YAAA,kBACAxpD,MAAAwpD,YAAA,sBACAxpD,MAAAwpD,YAAA,wBAEA,gBAEAxpD,MAAAwpD,YAAA,aAEA,8DAEA,8BACA,gEACA,SACA,yBACA,UAEA,gDAEAxpD,MAAAwpD,YAAA,mBACAxpD,MAAAwpD,YAAA,gBACAxpD,MAAAwpD,YAAA,iBAEA,KAEAruD,KAAA,MAEA4/C,gBAEA,wBACA,yBAEA/6C,MAAAwpD,YAAA,OACAxpD,MAAAwpD,YAAA,oBACAxpD,MAAAwpD,YAAA,2BACAxpD,MAAAwpD,YAAA,kBACAxpD,MAAAwpD,YAAA,wBACAxpD,MAAAwpD,YAAA,0BAEA,gBAEA,qCACA,iDAEAxpD,MAAAwpD,YAAA,qBACAxpD,MAAAwpD,YAAA,sBACAxpD,MAAAwpD,YAAA,eACAxpD,MAAAwpD,YAAA,mBAEA,qCAEAxpD,MAAAwpD,YAAA,mBACAxpD,MAAAwpD,YAAA,aAEA,yDAEA,KAEAruD,KAAA,OAIA8wD,QAEApR,SAAA76C,MAAAgiD,cAAApc,OAEA5lC,MAAA6pD,YAAA,OACA7pD,MAAA6pD,YAAA,KAGA5gC,OAAkBvsB,KAAA,IAAAmK,MAAA,GAClB+5C,UAAkBlkD,KAAA,IAAAmK,MAAA,GAClBqlD,WAAkBxvD,KAAA,IAAAmK,MAAA,MAKlBi0C,cAEA,uBACA,gCAEA,+BAEA96C,MAAAwpD,YAAA,OACAxpD,MAAAwpD,YAAA,kBACAxpD,MAAAwpD,YAAA,wBAEA,gBAEAxpD,MAAAwpD,YAAA,aAEA,yCAEA,8DACA,gDAEAxpD,MAAAwpD,YAAA,mBAEA,KAEAruD,KAAA,MAEA4/C,gBAEA,wBACA,yBAEA,0BACA,2BAEA,+BAEA/6C,MAAAwpD,YAAA,OACAxpD,MAAAwpD,YAAA,oBACAxpD,MAAAwpD,YAAA,kBACAxpD,MAAAwpD,YAAA,0BAEA,gBAEA,uDAEA,aAEA,KAEA,qCACA,iDAEAxpD,MAAAwpD,YAAA,qBACAxpD,MAAAwpD,YAAA,eAEA,qCAEAxpD,MAAAwpD,YAAA,aAEA,yDAEA,KAEAruD,KAAA,OAIA4gD,OAEAlB,UAEAsR,OAAazvD,KAAA,IAAAmK,MAAA,GACbulD,MAAa1vD,KAAA,IAAAmK,MAAA,KACb2sC,SAAgB92C,KAAA,IAAAmK,MAAA,IAIhBi0C,cAEA96C,MAAAwpD,YAAA,OACAxpD,MAAAwpD,YAAA,wBACAxpD,MAAAwpD,YAAA,wBAEA,gBAEAxpD,MAAAwpD,YAAA,mBACAxpD,MAAAwpD,YAAA,eACAxpD,MAAAwpD,YAAA,mBAEA,KAEAruD,KAAA,MAEA4/C,gBAEA,uBACA,sBACA,yBAEA/6C,MAAAwpD,YAAA,OACAxpD,MAAAwpD,YAAA,0BAEA,gBAEAxpD,MAAAwpD,YAAA,qBAEA,8BAEA,oDAEA,SAEA,mDAEA,UAEA,yDACA,kDAEA,KAEAruD,KAAA,OAIAihB,QAEAy+B,UAEArH,SAAgB92C,KAAA,IAAAmK,MAAA,IAIhBi0C,cAEA,wBAEA96C,MAAAwpD,YAAA,OACAxpD,MAAAwpD,YAAA,wBACAxpD,MAAAwpD,YAAA,wBAEA,gBAEA,iDAEAxpD,MAAAwpD,YAAA,mBACAxpD,MAAAwpD,YAAA,eACAxpD,MAAAwpD,YAAA,mBAEA,KAEAruD,KAAA,MAEA4/C,gBAEA,yBACA,wBAEA/6C,MAAAwpD,YAAA,OACAxpD,MAAAwpD,YAAA,0BAEA,gBAEA,qEAEAxpD,MAAAwpD,YAAA,qBAEA,KAEAruD,KAAA,OAQAkxD,MAEAxR,UAAayR,OAAW5vD,KAAA,IAAAmK,MAAA,MACxB0lD,OAAe7vD,KAAA,IAAAmK,MAAA,KAEfi0C,cAEA,+BAEA96C,MAAAwpD,YAAA,OACAxpD,MAAAwpD,YAAA,wBAEA,gBAEA,iEAEA,6EAEAxpD,MAAAwpD,YAAA,mBAEA,KAEAruD,KAAA,MAEA4/C,gBAEA,6BACA,uBAEA,+BAEA/6C,MAAAwpD,YAAA,OACAxpD,MAAAwpD,YAAA,0BAEA,gBAEA,6FAEAxpD,MAAAwpD,YAAA,qBAEA,KAEAruD,KAAA,OAQAqxD,UAEA3R,UAAa4R,WAAe/vD,KAAA,IAAAmK,MAAA,MAC5B0lD,OAAe7vD,KAAA,IAAAmK,MAAA,KAEfi0C,cAEA,+BAEA96C,MAAAwpD,YAAA,OACAxpD,MAAAwpD,YAAA,wBAEA,gBAEA,iEAEA,6EAEAxpD,MAAAwpD,YAAA,mBAEA,KAEAruD,KAAA,MAEA4/C,gBAEA,+BACA,uBAEA,+BAEA/6C,MAAAwpD,YAAA,OACAxpD,MAAAwpD,YAAA,0BAEA,gBAGA,gDACA,iBACA,6DACA,wEACA,mDAEAxpD,MAAAwpD,YAAA,qBAEA,KAEAruD,KAAA,OAgBAuxD,WAEA7R,YAEAC,cAEA96C,MAAAwpD,YAAA,OACAxpD,MAAAwpD,YAAA,wBACAxpD,MAAAwpD,YAAA,qBACAxpD,MAAAwpD,YAAA,wBAEA,gBAEAxpD,MAAAwpD,YAAA,gBACAxpD,MAAAwpD,YAAA,mBACAxpD,MAAAwpD,YAAA,gBACAxpD,MAAAwpD,YAAA,eACAxpD,MAAAwpD,YAAA,mBAEA,KAEAruD,KAAA,MAEA4/C,gBAEA/6C,MAAAwpD,YAAA,OACAxpD,MAAAwpD,YAAA,0BAEA,4CAEA,oFACA,6EACA,iFACA,+BACA,eAEA,IAEA,gBAEAxpD,MAAAwpD,YAAA,qBAEA,8BAEA,sDAEA,SAEA,qDAEA,UAOA,KAEAruD,KAAA,QAeA6E,MAAAvH,cAAA,SAAA4yC,YAqkBA,QAAAshB,uBAAAlzD,UAEAA,SAAAmzD,oBAAAC,IAAAC,eACArzD,SAAAszD,mBAAAF,IAAAC,eAEAE,MAAAC,KAAAC,OAAA3vB,aAIA,QAAA4vB,mBAAA1zD,UAEAA,SAAAmzD,oBAAAC,IAAAC,eACArzD,SAAAszD,mBAAAF,IAAAC,eACArzD,SAAA2zD,0BAAAP,IAAAC,eAEAE,MAAAC,KAAAC,OAAA3vB,aAIA,QAAA8vB,mBAAAC,eAEAA,cAAAV,oBAAAC,IAAAC,eACAQ,cAAAC,oBAAAV,IAAAC,eACAQ,cAAAE,qBAAAX,IAAAC,eACAQ,cAAAP,mBAAAF,IAAAC,eACAQ,cAAAG,gBAAAZ,IAAAC,eACAQ,cAAAI,iBAAAb,IAAAC,eAEAQ,cAAAK,yBAAAd,IAAAC,eACAQ,cAAAM,yBAAAf,IAAAC,eAEAQ,cAAAO,kBAAAhB,IAAAC,eACAQ,cAAAQ,kBAAAjB,IAAAC,cAEA,IAAAiB,iBAAAT,cAAAS,eAEA,IAAAA,gBAAA,CAEAT,cAAAU,6BAEA,QAAAn4D,GAAA,EAAA2uD,GAAAuJ,gBAAyCvJ,GAAA3uD,EAAQA,IAEjDy3D,cAAAU,2BAAApzD,KAAAiyD,IAAAC,gBAMA,GAAAmB,iBAAAX,cAAAW,eAEA,IAAAA,gBAAA,CAEAX,cAAAY,6BAEA,QAAAr4D,GAAA,EAAA2uD,GAAAyJ,gBAAyCzJ,GAAA3uD,EAAQA,IAEjDy3D,cAAAY,2BAAAtzD,KAAAiyD,IAAAC,gBAMAE,MAAAC,KAAAC,OAAA3vB,aAyTA,QAAA4wB,sBAAA5sC,QAEA,GAAA9nB,UAAA8nB,OAAA9nB,SACAE,SAAA4nB,OAAA5nB,SAEAy0D,UAAA30D,SAAAooB,SAAA5mB,MAEA,IAAAtB,SAAAooB,WAAA,CAEA7hB,SAAAzG,SAAA40D,8BAEA50D,SAAA40D,+BAIA,QAAA/zB,QAAA3gC,UAAAooB,WAAA,CAEA,GAAAjI,WAAAngB,SAAAooB,WAAAuY,KAEA,KAAAxgB,UAAAw0C,oBAAAx0C,UAAAy0C,oBAAA,CAEAz0C,UAAAw0C,oBAAA,CAEA,IAAAjuC,MAAA,CAEA,QAAAvG,UAAApd,KAAA2jB,KAAA,EACA,OAAAvG,UAAApd,KAAA2jB,KAAA,EACA,OAAAvG,UAAApd,KAAA2jB,KAAA,EACA,MAAAvG,UAAApd,OAAA2jB,KAAA,GAEAvG,UAAAuG,UAEAvG,UAAAhQ,MAAA,GAAAuY,cAAA+rC,UAAA/tC,MAEAvG,UAAAqkC,OAAA0O,IAAAC,eACAhzC,UAAAqkC,OAAAqQ,mBAAAl0B,KAEAxgB,UAAAmlB,aAAA,EAIAxlC,SAAA40D,4BAAAzzD,KAAAkf,aAQA,QAAA20C,qBAAAh1D,SAAA8nB,QAEA,GAAA6sC,WAAA30D,SAAAooB,SAAA5mB,MAEAxB,UAAAi1D,cAAA,GAAArsC,cAAA,EAAA+rC,WACA30D,SAAAk1D,aAAA,GAAAtsC,cAAA,EAAA+rC,WAEA30D,SAAAm1D,qBAAAR,UAEAD,qBAAA5sC,QAIA,QAAAstC,iBAAAp1D,SAAA8nB,QAEA,GAAA6sC,WAAA30D,SAAAooB,SAAA5mB,MAEAxB,UAAAi1D,cAAA,GAAArsC,cAAA,EAAA+rC;AACA30D,SAAAk1D,aAAA,GAAAtsC,cAAA,EAAA+rC,WACA30D,SAAAq1D,oBAAA,GAAAzsC,cAAA,EAAA+rC,WAEA30D,SAAAs1D,iBAAAX,UAEAD,qBAAA5sC,QAIA,QAAAytC,iBAAA1B,cAAA/rC,QAEA,GAAA9nB,UAAA8nB,OAAA9nB,SACAw1D,OAAA3B,cAAA2B,OAEAb,UAAA,EAAAa,OAAAh0D,OACAi0D,MAAA,EAAAD,OAAAh0D,OACAk0D,OAAA,EAAAF,OAAAh0D,OAEAtB,SAAAy1D,kBAAA7tC,OAAA+rC,cAEAA,eAAAoB,cAAA,GAAArsC,cAAA,EAAA+rC,WACAd,cAAA+B,cAAA,GAAAhtC,cAAA,EAAA+rC,WACAd,cAAAqB,aAAA,GAAAtsC,cAAA,EAAA+rC,WACAd,cAAAgC,UAAA,GAAAjtC,cAAA,EAAA+rC,WAEA30D,SAAA0nC,cAAAlmC,OAAA,IAEAqyD,cAAAiC,WAAA,GAAAltC,cAAA,EAAA+rC,YAIA30D,SAAA2tC,cAEAkmB,cAAAkC,eAAA,GAAAntC,cAAA,EAAA+rC,YAIA7sC,OAAA9nB,SAAAwtC,YAAAhsC,QAAAsmB,OAAA9nB,SAAAytC,YAAAjsC,SAEAqyD,cAAAmC,iBAAA,GAAAptC,cAAA,EAAA+rC,WACAd,cAAAoC,kBAAA,GAAArtC,cAAA,EAAA+rC,WAIA,IAAAuB,WAAA,OAAAC,WAAA3f,IAAA,2BAAAif,MAAA,MAAAW,YAAAjrB,WAEA0oB,eAAAwC,YAAAH,UACArC,cAAAyC,YAAA,GAAAJ,WAAA,EAAAT,OACA5B,cAAA0C,YAAA,GAAAL,WAAA,EAAAR,OAEA,IAAApB,iBAAAT,cAAAS,eAEA,IAAAA,gBAAA,CAEAT,cAAA2C,uBAEA,QAAAp6D,GAAA,EAAA2uD,GAAAuJ,gBAAyCvJ,GAAA3uD,EAAQA,IAEjDy3D,cAAA2C,qBAAAr1D,KAAA,GAAAynB,cAAA,EAAA+rC,YAMA,GAAAH,iBAAAX,cAAAW,eAEA,IAAAA,gBAAA,CAEAX,cAAA4C,uBAEA,QAAAr6D,GAAA,EAAA2uD,GAAAyJ,gBAAyCzJ,GAAA3uD,EAAQA,IAEjDy3D,cAAA4C,qBAAAt1D,KAAA,GAAAynB,cAAA,EAAA+rC,YAYA,GANAd,cAAA6C,iBAAA,EAAAjB,MACA5B,cAAAyB,iBAAA,EAAAI,OAKAx1D,SAAAooB,WAAA,CAEA7hB,SAAAotD,cAAAe,8BAEAf,cAAAe,+BAIA,QAAA/zB,QAAA3gC,UAAAooB,WAAA,CAKA,GAAAquC,mBAAAz2D,SAAAooB,WAAAuY,MAEAxgB,YAEA,QAAAu2C,YAAAD,mBAEAt2C,UAAAu2C,UAAAD,kBAAAC,SAIA,KAAAv2C,UAAAw0C,oBAAAx0C,UAAAy0C,oBAAA,CAEAz0C,UAAAw0C,oBAAA,CAEA,IAAAjuC,MAAA,CAEA,QAAAvG,UAAApd,KAAA2jB,KAAA,EACA,OAAAvG,UAAApd,KAAA2jB,KAAA,EACA,OAAAvG,UAAApd,KAAA2jB,KAAA,EACA,MAAAvG,UAAApd,OAAA2jB,KAAA,GAEAvG,UAAAuG,UAEAvG,UAAAhQ,MAAA,GAAAuY,cAAA+rC,UAAA/tC,MAEAvG,UAAAqkC,OAAA0O,IAAAC,eACAhzC,UAAAqkC,OAAAqQ,mBAAAl0B,KAEA81B,kBAAAnxB,aAAA,EACAnlB,UAAAw2C,WAAAF,kBAIA9C,cAAAe,4BAAAzzD,KAAAkf,YAMAwzC,cAAAiD,iBAAA,EAIA,QAAAnB,mBAAA7tC,OAAA+rC,eAEA,MAAA/rC,QAAA5nB,mBAAAqG,OAAAwhD,iBACAjgC,OAAA5nB,SAAA+jC,UAAA4vB,cAAA5uB,eACAnd,OAAA5nB,SAIA,QAAA62D,0BAAA72D,UAEA,MAAAA,oBAAAqG,OAAAigD,oBAAA,GAAAtmD,SAAAk6C,UAAA7zC,MAAAwB,YAMA,QAAAivD,oBAAAh3D,SAAAi3D,KAAAnvC,QAEA,GAAAhL,GAAAzgB,EAAAgyC,OAAA99B,OAAAnQ,MAeAmB,EAAAklB,GACAywC,GAAAC,IAAA/pD,MACAgqD,gBAfAhvC,SAAApoB,SAAAooB,SACAymB,GAAAzmB,SAAA5mB,OAEAsmC,OAAA9nC,SAAA8nC,OACA8Y,GAAA9Y,OAAAtmC,OAEA61D,YAAAr3D,SAAAi1D,cACAqC,WAAAt3D,SAAAk1D,aAEAqC,cAAAv3D,SAAA6tC,mBACA2pB,YAAAx3D,SAAAkuC,iBAEAupB,iBAAAz3D,SAAA40D,2BAKA,IAAA2C,cAAA,CAEA,IAAAz6C,EAAA,EAAe+xB,GAAA/xB,EAAQA,IAEvBuxB,OAAAjmB,SAAAtL,GAEAvM,OAAA,EAAAuM,EAEAu6C,YAAA9mD,QAAA89B,OAAAttC,EACAs2D,YAAA9mD,OAAA,GAAA89B,OAAArtC,EACAq2D,YAAA9mD,OAAA,GAAA89B,OAAAtuC,CAIAqzD,KAAAsE,WAAAtE,IAAAuE,aAAA33D,SAAAmzD,qBACAC,IAAAwE,WAAAxE,IAAAuE,aAAAN,YAAAJ,MAIA,GAAAO,YAAA,CAEA,IAAAn7D,EAAA,EAAeukD,GAAAvkD,EAAQA,IAEvB+D,MAAA0nC,OAAAzrC,GAEAkU,OAAA,EAAAlU,EAEAi7D,WAAA/mD,QAAAnQ,MAAA6M,EACAqqD,WAAA/mD,OAAA,GAAAnQ,MAAA8M,EACAoqD,WAAA/mD,OAAA,GAAAnQ,MAAA+M,CAIAimD,KAAAsE,WAAAtE,IAAAuE,aAAA33D,SAAAszD,oBACAF,IAAAwE,WAAAxE,IAAAuE,aAAAL,WAAAL,MAIA,GAAAQ,iBAEA,IAAAl2D,EAAA,EAAAklB,GAAAgxC,iBAAAj2D,OAA6CilB,GAAAllB,EAAQA,IAAA,CAIrD,GAFA61D,gBAAAK,iBAAAl2D,GAEA61D,gBAAA5xB,cAAA/+B,SAAA2wD,gBAAAS,SAAA,aAAAT,gBAAAS,SAMA,GAJAV,IAAAC,gBAAAhqD,MAAA5L,OAEA+O,OAAA,EAEA,IAAA6mD,gBAAAxwC,KAEA,IAAAswC,GAAA,EAAmBC,IAAAD,GAAUA,KAE7BE,gBAAA/mD,MAAA6mD,IAAAE,gBAAAhqD,MAAA8pD,QAIM,QAAAE,gBAAAxwC,KAEN,IAAAswC,GAAA,EAAmBC,IAAAD,GAAUA,KAE7B9pD,MAAAgqD,gBAAAhqD,MAAA8pD,IAEAE,gBAAA/mD,MAAAE,QAAAnD,MAAArM,EACAq2D,gBAAA/mD,MAAAE,OAAA,GAAAnD,MAAApM,EAEAuP,QAAA,MAIM,QAAA6mD,gBAAAxwC,KAEN,SAAAwwC,gBAAAn0D,KAEA,IAAAi0D,GAAA,EAAoBC,IAAAD,GAAUA,KAE9B9pD,MAAAgqD,gBAAAhqD,MAAA8pD,IAEAE,gBAAA/mD,MAAAE,QAAAnD,MAAAH,EACAmqD,gBAAA/mD,MAAAE,OAAA,GAAAnD,MAAAF,EACAkqD,gBAAA/mD,MAAAE,OAAA,GAAAnD,MAAAD,EAEAoD,QAAA,MAMA,KAAA2mD,GAAA,EAAoBC,IAAAD,GAAUA,KAE9B9pD,MAAAgqD,gBAAAhqD,MAAA8pD,IAEAE,gBAAA/mD,MAAAE,QAAAnD,MAAArM,EACAq2D,gBAAA/mD,MAAAE,OAAA,GAAAnD,MAAApM,EACAo2D,gBAAA/mD,MAAAE,OAAA,GAAAnD,MAAArN,EAEAwQ,QAAA,MAMM,QAAA6mD,gBAAAxwC,KAEN,IAAAswC,GAAA,EAAmBC,IAAAD,GAAUA,KAE7B9pD,MAAAgqD,gBAAAhqD,MAAA8pD,IAEAE,gBAAA/mD,MAAAE,QAAAnD,MAAArM,EACAq2D,gBAAA/mD,MAAAE,OAAA,GAAAnD,MAAApM,EACAo2D,gBAAA/mD,MAAAE,OAAA,GAAAnD,MAAArN,EACAq3D,gBAAA/mD,MAAAE,OAAA,GAAAnD,MAAAyM,EAEAtJ,QAAA,CAQA6iD,KAAAsE,WAAAtE,IAAAuE,aAAAP,gBAAA1S,QACA0O,IAAAwE,WAAAxE,IAAAuE,aAAAP,gBAAA/mD,MAAA4mD,MAEAG,gBAAA5xB,aAAA,GAQA,QAAAsyB,gBAAA93D,SAAAi3D,MAEA,GAAAn6C,GAAAzgB,EAAA0kB,EAAAstB,OAAA99B,OAAAnQ,MAoBAmB,EAAAklB,GACAywC,GAAAC,IAAA/pD,MACAgqD,gBApBAhvC,SAAApoB,SAAAooB,SACA0f,OAAA9nC,SAAA8nC,OACA4F,cAAA1tC,SAAA0tC,cAEAmB,GAAAzmB,SAAA5mB,OACAo/C,GAAA9Y,OAAAtmC,OACAu2D,GAAArqB,cAAAlsC,OAEA61D,YAAAr3D,SAAAi1D,cACAqC,WAAAt3D,SAAAk1D,aACA8C,kBAAAh4D,SAAAq1D,oBAEAkC,cAAAv3D,SAAA6tC,mBACA2pB,YAAAx3D,SAAAkuC,iBACA+pB,mBAAAj4D,SAAAmuC,wBAEAspB,iBAAAz3D,SAAA40D,2BAMA,IAAA2C,cAAA,CAEA,IAAAz6C,EAAA,EAAe+xB,GAAA/xB,EAAQA,IAEvBuxB,OAAAjmB,SAAAtL,GAEAvM,OAAA,EAAAuM,EAEAu6C,YAAA9mD,QAAA89B,OAAAttC,EACAs2D,YAAA9mD,OAAA,GAAA89B,OAAArtC,EACAq2D,YAAA9mD,OAAA,GAAA89B,OAAAtuC,CAIAqzD,KAAAsE,WAAAtE,IAAAuE,aAAA33D,SAAAmzD,qBACAC,IAAAwE,WAAAxE,IAAAuE,aAAAN,YAAAJ,MAIA,GAAAO,YAAA,CAEA,IAAAn7D,EAAA,EAAeukD,GAAAvkD,EAAQA,IAEvB+D,MAAA0nC,OAAAzrC,GAEAkU,OAAA,EAAAlU,EAEAi7D,WAAA/mD,QAAAnQ,MAAA6M,EACAqqD,WAAA/mD,OAAA,GAAAnQ,MAAA8M,EACAoqD,WAAA/mD,OAAA,GAAAnQ,MAAA+M,CAIAimD,KAAAsE,WAAAtE,IAAAuE,aAAA33D,SAAAszD,oBACAF,IAAAwE,WAAAxE,IAAAuE,aAAAL,WAAAL,MAIA,GAAAgB,mBAAA,CAEA,IAAAl3C,EAAA,EAAeg3C,GAAAh3C,EAAQA,IAEvBi3C,kBAAAj3C,GAAA2sB,cAAA3sB,EAIAqyC,KAAAsE,WAAAtE,IAAAuE,aAAA33D,SAAA2zD,2BACAP,IAAAwE,WAAAxE,IAAAuE,aAAAK,kBAAAf,MAIA,GAAAQ,iBAEA,IAAAl2D,EAAA,EAAAklB,GAAAgxC,iBAAAj2D,OAA6CilB,GAAAllB,EAAQA,IAIrD,GAFA61D,gBAAAK,iBAAAl2D,GAEA61D,gBAAA5xB,cAAA/+B,SAAA2wD,gBAAAS,SAAA,aAAAT,gBAAAS,SAAA,CAMA,GAJAtnD,OAAA,EAEA4mD,IAAAC,gBAAAhqD,MAAA5L,OAEA,IAAA41D,gBAAAxwC,KAEA,IAAAswC,GAAA,EAAmBC,IAAAD,GAAUA,KAE7BE,gBAAA/mD,MAAA6mD,IAAAE,gBAAAhqD,MAAA8pD,QAIM,QAAAE,gBAAAxwC,KAEN,IAAAswC,GAAA,EAAmBC,IAAAD,GAAUA,KAE7B9pD,MAAAgqD,gBAAAhqD,MAAA8pD,IAEAE,gBAAA/mD,MAAAE,QAAAnD,MAAArM,EACAq2D,gBAAA/mD,MAAAE,OAAA,GAAAnD,MAAApM,EAEAuP,QAAA,MAIM,QAAA6mD,gBAAAxwC,KAEN,SAAAwwC,gBAAAn0D,KAEA,IAAAi0D,GAAA,EAAoBC,IAAAD,GAAUA,KAE9B9pD,MAAAgqD,gBAAAhqD,MAAA8pD,IAEAE,gBAAA/mD,MAAAE,QAAAnD,MAAAH,EACAmqD,gBAAA/mD,MAAAE,OAAA,GAAAnD,MAAAF,EACAkqD,gBAAA/mD,MAAAE,OAAA,GAAAnD,MAAAD,EAEAoD,QAAA,MAMA,KAAA2mD,GAAA,EAAoBC,IAAAD,GAAUA,KAE9B9pD,MAAAgqD,gBAAAhqD,MAAA8pD,IAEAE,gBAAA/mD,MAAAE,QAAAnD,MAAArM,EACAq2D,gBAAA/mD,MAAAE,OAAA,GAAAnD,MAAApM,EACAo2D,gBAAA/mD,MAAAE,OAAA,GAAAnD,MAAArN,EAEAwQ,QAAA,MAMM,QAAA6mD,gBAAAxwC,KAEN,IAAAswC,GAAA,EAAmBC,IAAAD,GAAUA,KAE7B9pD,MAAAgqD,gBAAAhqD,MAAA8pD,IAEAE,gBAAA/mD,MAAAE,QAAAnD,MAAArM,EACAq2D,gBAAA/mD,MAAAE,OAAA,GAAAnD,MAAApM,EACAo2D,gBAAA/mD,MAAAE,OAAA,GAAAnD,MAAArN,EACAq3D,gBAAA/mD,MAAAE,OAAA,GAAAnD,MAAAyM,EAEAtJ,QAAA,CAMA6iD,KAAAsE,WAAAtE,IAAAuE,aAAAP,gBAAA1S,QACA0O,IAAAwE,WAAAxE,IAAAuE,aAAAP,gBAAA/mD,MAAA4mD,MAEAG,gBAAA5xB,aAAA,GAUA,QAAA0yB,gBAAArE,cAAA/rC,OAAAmvC,KAAA7pB,QAAAltC,UAEA,GAAA2zD,cAAAiD,gBAAA,CAMA,GAEAptC,GAAAilB,GAAA+Q,GAAAra,KACAH,cAAAiK,WACAhK,aAAAgzB,UACA/yB,eACAsF,GAAA2d,IAAAlsC,GAAAgE,GAAA+a,GAAA5H,GAAAkH,GAAAC,GAAA29B,GAAA7tB,GAAA8tB,GACA79C,GAAAE,GAAAC,GACA29C,IAAAC,IAAAC,IACAC,IAAAC,IAAAC,IACAp3D,EAAAklB,GACAmyC,GAAAC,IAAAC,KACAC,GAAAC,IAAAC,IACAC,IAAAC,IAAA5oB,kBAgBAnjC,MAgBAgqD,gBA7CAgC,iBAAArC,yBAAA72D,UAeAwvC,YAAA,EAEAn/B,OAAA,EACA8oD,UAAA,EACAC,WAAA,EACAC,YAAA,EACAC,cAAA,EACAC,eAAA,EACAC,YAAA,EACAC,aAAA,EACAC,YAAA,EACAC,mBAAA,EACAC,cAAA,EAIAzC,YAAAxD,cAAAoB,cACA8E,QAAAlG,cAAAgC,UACAmE,SAAAnG,cAAAiC,WACAmE,YAAApG,cAAA+B,cACAsE,aAAArG,cAAAkC,eACAuB,WAAAzD,cAAAqB,aAEAiF,eAAAtG,cAAAmC,iBACAoE,gBAAAvG,cAAAoC,kBAEAoE,mBAAAxG,cAAA2C,qBACA8D,mBAAAzG,cAAA4C,qBAEAgB,iBAAA5D,cAAAe,4BAGA2F,UAAA1G,cAAAyC,YACAkE,UAAA3G,cAAA0C,YAEAv2D,SAAA8nB,OAAA9nB,SAEAu3D,cAAAv3D,SAAA6tC,mBACA4sB,cAAAz6D,SAAA8tC,mBACA4sB,SAAA16D,SAAA+tC,cACA4sB,aAAA36D,SAAAguC,kBACA4sB,cAAA56D,SAAAiuC,mBACAupB,YAAAx3D,SAAAkuC,iBACA2sB,kBAAA76D,SAAA86D,uBAEA1yC,SAAApoB,SAAAooB,SACA2yC,aAAAlH,cAAA2B,OACAwF,UAAAh7D,SAAAynC,MAEAwzB,QAAAj7D,SAAA0nC,cAAA,GACAwzB,SAAAl7D,SAAA0nC,cAAA,GAEAyzB,gBAAAn7D,SAAAytC,YACA2tB,gBAAAp7D,SAAAwtC,YAEAH,aAAArtC,SAAAqtC,aACAE,aAAAvtC,SAAAutC,YAEA,IAAAgqB,cAAA,CAEA,IAAA7tC,EAAA,EAAAilB,GAAAosB,aAAAv5D,OAAyCmtC,GAAAjlB,EAAQA,IAEjD2b,KAAA21B,UAAAD,aAAArxC,IAEAvN,GAAAiM,SAAAid,KAAApoB,GACAkD,GAAAiI,SAAAid,KAAAl4B,GACA+tB,GAAA9S,SAAAid,KAAAhpC,GAEAg7D,YAAA9mD,QAAA4L,GAAApb,EACAs2D,YAAA9mD,OAAA,GAAA4L,GAAAnb,EACAq2D,YAAA9mD,OAAA,GAAA4L,GAAApc,EAEAs3D,YAAA9mD,OAAA,GAAA4P,GAAApf,EACAs2D,YAAA9mD,OAAA,GAAA4P,GAAAnf,EACAq2D,YAAA9mD,OAAA,GAAA4P,GAAApgB,EAEAs3D,YAAA9mD,OAAA,GAAA2qB,GAAAn6B,EACAs2D,YAAA9mD,OAAA,GAAA2qB,GAAAl6B,EACAq2D,YAAA9mD,OAAA,GAAA2qB,GAAAn7B,EAEAwQ,QAAA,CAIA6iD,KAAAsE,WAAAtE,IAAAuE,aAAA9D,cAAAV,qBACAC,IAAAwE,WAAAxE,IAAAuE,aAAAN,YAAAJ,MAIA,GAAA4D,kBAEA,IAAA9B,GAAA,EAAAC,IAAA3rB,aAAA7rC,OAA2Cw3D,IAAAD,GAAUA,KAAA,CAIrD,IAFAc,mBAAA,EAEAnwC,EAAA,EAAAilB,GAAAosB,aAAAv5D,OAA0CmtC,GAAAjlB,EAAQA,IAElDyvC,IAAA4B,aAAArxC,GACA2b,KAAA21B,UAAA7B,KAIAh9C,GAAAkxB,aAAA0rB,IAAA3wC,SAAAid,KAAApoB,GACAkD,GAAAktB,aAAA0rB,IAAA3wC,SAAAid,KAAAl4B,GACA+tB,GAAAmS,aAAA0rB,IAAA3wC,SAAAid,KAAAhpC,GAEA48D,IAAAoB,mBAAAtB,IAEAE,IAAAY,oBAAA19C,GAAApb,EACAk4D,IAAAY,mBAAA,GAAA19C,GAAAnb,EACAi4D,IAAAY,mBAAA,GAAA19C,GAAApc,EAEAk5D,IAAAY,mBAAA,GAAA15C,GAAApf,EACAk4D,IAAAY,mBAAA,GAAA15C,GAAAnf,EACAi4D,IAAAY,mBAAA,GAAA15C,GAAApgB,EAEAk5D,IAAAY,mBAAA,GAAA3+B,GAAAn6B,EACAk4D,IAAAY,mBAAA,GAAA3+B,GAAAl6B,EACAi4D,IAAAY,mBAAA,GAAA3+B,GAAAn7B,EAIAG,SAAAqtC,eAEA6rB,kBAEAhB,GAAA7qB,aAAAwrB,IAAA7pB,YAAAiqB,KACA5uB,GAAA6tB,GACAC,GAAAD,KAIA7nB,kBAAAhD,aAAAwrB,IAAA7zB,cAAAi0B,KAEAf,GAAA7nB,kBAAAtzB,EACAstB,GAAAgG,kBAAApjC,EACAkrD,GAAA9nB,kBAAAl0C,GAIA68D,IAAAoB,mBAAAvB,IAEAG,IAAAW,oBAAAzB,GAAAr3D,EACAm4D,IAAAW,mBAAA,GAAAzB,GAAAp3D,EACAk4D,IAAAW,mBAAA,GAAAzB,GAAAr4D,EAEAm5D,IAAAW,mBAAA,GAAAtvB,GAAAxpC,EACAm4D,IAAAW,mBAAA,GAAAtvB,GAAAvpC,EACAk4D,IAAAW,mBAAA,GAAAtvB,GAAAxqC,EAEAm5D,IAAAW,mBAAA,GAAAxB,GAAAt3D,EACAm4D,IAAAW,mBAAA,GAAAxB,GAAAr3D,EACAk4D,IAAAW,mBAAA,GAAAxB,GAAAt4D,GAMA85D,oBAAA,CAIAzG,KAAAsE,WAAAtE,IAAAuE,aAAA9D,cAAAU,2BAAAwE,KACA3F,IAAAwE,WAAAxE,IAAAuE,aAAA0C,mBAAAtB,IAAA9B,MAEA/2D,SAAAqtC,eAEA6lB,IAAAsE,WAAAtE,IAAAuE,aAAA9D,cAAAY,2BAAAsE,KACA3F,IAAAwE,WAAAxE,IAAAuE,aAAA2C,mBAAAvB,IAAA9B,OAQA,GAAAmE,gBAAA55D,OAAA,CAEA,IAAAkoB,EAAA,EAAAilB,GAAAosB,aAAAv5D,OAAyCmtC,GAAAjlB,EAAQA,IAEjD2b,KAAA21B,UAAAD,aAAArxC,IAIA4uC,IAAA8C,gBAAA/1B,KAAApoB,GACAs7C,IAAA6C,gBAAA/1B,KAAAl4B,GACAqrD,IAAA4C,gBAAA/1B,KAAAhpC,GAEA+9D,gBAAAR,aAAAtB,IAAAv3D,EACAq5D,gBAAAR,YAAA,GAAAtB,IAAAt3D,EACAo5D,gBAAAR,YAAA,GAAAtB,IAAAv4D,EACAq6D,gBAAAR,YAAA,GAAAtB,IAAAz+C,EAEAugD,gBAAAR,YAAA,GAAArB,IAAAx3D,EACAq5D,gBAAAR,YAAA,GAAArB,IAAAv3D,EACAo5D,gBAAAR,YAAA,GAAArB,IAAAx4D,EACAq6D,gBAAAR,YAAA,GAAArB,IAAA1+C,EAEAugD,gBAAAR,YAAA,GAAApB,IAAAz3D,EACAq5D,gBAAAR,YAAA,GAAApB,IAAAx3D,EACAo5D,gBAAAR,YAAA,IAAApB,IAAAz4D,EACAq6D,gBAAAR,YAAA,IAAApB,IAAA3+C,EAIA4+C,IAAA0C,gBAAA91B,KAAApoB,GACAy7C,IAAAyC,gBAAA91B,KAAAl4B,GACAwrD,IAAAwC,gBAAA91B,KAAAhpC,GAEA89D,eAAAP,aAAAnB,IAAA13D,EACAo5D,eAAAP,YAAA,GAAAnB,IAAAz3D,EACAm5D,eAAAP,YAAA,GAAAnB,IAAA14D,EACAo6D,eAAAP,YAAA,GAAAnB,IAAA5+C,EAEAsgD,eAAAP,YAAA,GAAAlB,IAAA33D,EACAo5D,eAAAP,YAAA,GAAAlB,IAAA13D,EACAm5D,eAAAP,YAAA,GAAAlB,IAAA34D,EACAo6D,eAAAP,YAAA,GAAAlB,IAAA7+C,EAEAsgD,eAAAP,YAAA,GAAAjB,IAAA53D,EACAo5D,eAAAP,YAAA,GAAAjB,IAAA33D,EACAm5D,eAAAP,YAAA,IAAAjB,IAAA54D,EACAo6D,eAAAP,YAAA,IAAAjB,IAAA9+C,EAEA+/C,aAAA,EAIAA,aAAA,IAEAxG,IAAAsE,WAAAtE,IAAAuE,aAAA9D,cAAAK,0BACAd,IAAAwE,WAAAxE,IAAAuE,aAAAwC,eAAAlD,MAEA7D,IAAAsE,WAAAtE,IAAAuE,aAAA9D,cAAAM,0BACAf,IAAAwE,WAAAxE,IAAAuE,aAAAyC,gBAAAnD,OAMA,GAAAO,YAAA,CAEA,IAAA9tC,EAAA,EAAAilB,GAAAosB,aAAAv5D,OAAyCmtC,GAAAjlB,EAAQA,IAEjD2b,KAAA21B,UAAAD,aAAArxC,IAEAyb,aAAAE,KAAAF,aACAgzB,UAAA9yB,KAAAjlC,MAEA,IAAA+kC,aAAA3jC,QAAAtB,SAAAilC,eAAA5+B,MAAA4B,cAEAqS,GAAA2qB,aAAA,GACAzqB,GAAAyqB,aAAA,GACAxqB,GAAAwqB,aAAA,KAIA3qB,GAAA29C,UACAz9C,GAAAy9C,UACAx9C,GAAAw9C,WAIAb,WAAAqC,cAAAn/C,GAAAvN,EACAqqD,WAAAqC,aAAA,GAAAn/C,GAAAtN,EACAoqD,WAAAqC,aAAA,GAAAn/C,GAAArN,EAEAmqD,WAAAqC,aAAA,GAAAj/C,GAAAzN,EACAqqD,WAAAqC,aAAA,GAAAj/C,GAAAxN,EACAoqD,WAAAqC,aAAA,GAAAj/C,GAAAvN,EAEAmqD,WAAAqC,aAAA,GAAAh/C,GAAA1N,EACAqqD,WAAAqC,aAAA,GAAAh/C,GAAAzN,EACAoqD,WAAAqC,aAAA,GAAAh/C,GAAAxN,EAEAwsD,cAAA,CAIAA,cAAA,IAEAvG,IAAAsE,WAAAtE,IAAAuE,aAAA9D,cAAAP,oBACAF,IAAAwE,WAAAxE,IAAAuE,aAAAL,WAAAL,OAMA,GAAA2D,eAAA56D,SAAA2tC,YAAA,CAEA,IAAAjkB,EAAA,EAAAilB,GAAAosB,aAAAv5D,OAAyCmtC,GAAAjlB,EAAQA,IAEjD2b,KAAA21B,UAAAD,aAAArxC,IAEA0b,eAAAC,KAAAD,eAEA9R,GAAA8R,eAAA,GACA5K,GAAA4K,eAAA,GACA3K,GAAA2K,eAAA,GAEA80B,aAAAT,gBAAAnmC,GAAAvyB,EACAm5D,aAAAT,eAAA,GAAAnmC,GAAAtyB,EACAk5D,aAAAT,eAAA,GAAAnmC,GAAAvzB,EACAm6D,aAAAT,eAAA,GAAAnmC,GAAAzZ,EAEAqgD,aAAAT,eAAA,GAAAj/B,GAAAz5B,EACAm5D,aAAAT,eAAA,GAAAj/B,GAAAx5B,EACAk5D,aAAAT,eAAA,GAAAj/B,GAAAz6B,EACAm6D,aAAAT,eAAA,GAAAj/B,GAAA3gB,EAEAqgD,aAAAT,eAAA,GAAAh/B,GAAA15B,EACAm5D,aAAAT,eAAA,GAAAh/B,GAAAz5B,EACAk5D,aAAAT,eAAA,IAAAh/B,GAAA16B,EACAm6D,aAAAT,eAAA,IAAAh/B,GAAA5gB,EAEA4/C,gBAAA,EAIArG,KAAAsE,WAAAtE,IAAAuE,aAAA9D,cAAAE,sBACAX,IAAAwE,WAAAxE,IAAAuE,aAAAuC,aAAAjD,MAIA,GAAA0D,aAAA,CAEA,IAAAjxC,EAAA,EAAAilB,GAAAosB,aAAAv5D,OAAyCmtC,GAAAjlB,EAAQA,IAOjD,GALA2b,KAAA21B,UAAAD,aAAArxC,IAEAwb,cAAAG,KAAAH,cACAiK,WAAA9J,KAAA1iB,OAEA,IAAAuiB,cAAA1jC,QAAA43D,oBAAA,EAEA,IAAA73D,EAAA,EAAiB,EAAAA,EAAOA,IAExBq3D,GAAA1zB,cAAA3jC,GAEA04D,YAAAT,eAAAZ,GAAA73D,EACAk5D,YAAAT,cAAA,GAAAZ,GAAA53D,EACAi5D,YAAAT,cAAA,GAAAZ,GAAA74D,EAEAy5D,eAAA,MAMA,KAAAj4D,EAAA,EAAiB,EAAAA,EAAOA,IAExB04D,YAAAT,eAAArqB,WAAApuC,EACAk5D,YAAAT,cAAA,GAAArqB,WAAAnuC,EACAi5D,YAAAT,cAAA,GAAArqB,WAAApvC,EAEAy5D,eAAA,CAQApG,KAAAsE,WAAAtE,IAAAuE,aAAA9D,cAAAC,qBACAV,IAAAwE,WAAAxE,IAAAuE,aAAAsC,YAAAhD,MAIA,GAAAyD,UAAAO,QAAA,CAEA,IAAAvxC,EAAA,EAAAilB,GAAAosB,aAAAv5D,OAAyCmtC,GAAAjlB,EAAQA,IAMjD,GAJAg2B,GAAAqb,aAAArxC,GAEAghB,GAAAuwB,QAAAvb,IAEAj5C,SAAAikC,GAEA,IAAAnpC,EAAA,EAAgB,EAAAA,EAAOA,IAEvBs3D,IAAAnuB,GAAAnpC,GAEAw4D,QAAAV,WAAAR,IAAA93D,EACAg5D,QAAAV,UAAA,GAAAR,IAAA73D,EAEAq4D,WAAA,CAMAA,WAAA,IAEAjG,IAAAsE,WAAAtE,IAAAuE,aAAA9D,cAAAG,iBACAZ,IAAAwE,WAAAxE,IAAAuE,aAAAoC,QAAA9C,OAMA,GAAAyD,UAAAQ,SAAA,CAEA,IAAAxxC,EAAA,EAAAilB,GAAAosB,aAAAv5D,OAAyCmtC,GAAAjlB,EAAQA,IAMjD,GAJAg2B,GAAAqb,aAAArxC,GAEA2+B,IAAA6S,SAAAxb,IAEAj5C,SAAA4hD,IAEA,IAAA9mD,EAAA,EAAgB,EAAAA,EAAOA,IAEvBu3D,KAAAzQ,IAAA9mD,GAEAy4D,SAAAV,YAAAR,KAAA/3D,EACAi5D,SAAAV,WAAA,GAAAR,KAAA93D,EAEAs4D,YAAA,CAMAA,YAAA,IAEAlG,IAAAsE,WAAAtE,IAAAuE,aAAA9D,cAAAI,kBACAb,IAAAwE,WAAAxE,IAAAuE,aAAAqC,SAAA/C,OAMA,GAAAwD,cAAA,CAEA,IAAA/wC,EAAA,EAAAilB,GAAAosB,aAAAv5D,OAAyCmtC,GAAAjlB,EAAQA,IAEjD6wC,UAAAhB,aAAA7pB,YACA6qB,UAAAhB,YAAA,GAAA7pB,YAAA,EACA6qB,UAAAhB,YAAA,GAAA7pB,YAAA,EAEA6pB,aAAA,EAEAiB,UAAAd,aAAAhqB,YACA8qB,UAAAd,YAAA,GAAAhqB,YAAA,EAEA8qB,UAAAd,YAAA,GAAAhqB,YACA8qB,UAAAd,YAAA,GAAAhqB,YAAA,EAEA8qB,UAAAd,YAAA,GAAAhqB,YAAA,EACA8qB,UAAAd,YAAA,GAAAhqB,YAAA,EAEAgqB,aAAA,EAEAhqB,aAAA,CAIA0jB,KAAAsE,WAAAtE,IAAAiI,qBAAAxH,cAAAO,mBACAhB,IAAAwE,WAAAxE,IAAAiI,qBAAAd,UAAAtD,MAEA7D,IAAAsE,WAAAtE,IAAAiI,qBAAAxH,cAAAQ,mBACAjB,IAAAwE,WAAAxE,IAAAiI,qBAAAb,UAAAvD,MAIA,GAAAQ,iBAEA,IAAAl2D,EAAA,EAAAklB,GAAAgxC,iBAAAj2D,OAA6CilB,GAAAllB,EAAQA,IAIrD,GAFA61D,gBAAAK,iBAAAl2D,GAEA61D,gBAAAP,WAAArxB,YAAA,CAIA,GAFAs0B,cAAA,EAEA,IAAA1C,gBAAAxwC,MAEA,GAAAngB,SAAA2wD,gBAAAS,SAAA,aAAAT,gBAAAS,QAEA,IAAAnuC,EAAA,EAAAilB,GAAAosB,aAAAv5D,OAA4CmtC,GAAAjlB,EAAQA,IAEpD2b,KAAA21B,UAAAD,aAAArxC,IAEA0tC,gBAAA/mD,MAAAypD,eAAA1C,gBAAAhqD,MAAAi4B,KAAApoB,GACAm6C,gBAAA/mD,MAAAypD,cAAA,GAAA1C,gBAAAhqD,MAAAi4B,KAAAl4B,GACAiqD,gBAAA/mD,MAAAypD,cAAA,GAAA1C,gBAAAhqD,MAAAi4B,KAAAhpC,GAEAy9D,eAAA,MAIM,cAAA1C,gBAAAS,QAEN,IAAAnuC,EAAA,EAAAilB,GAAAosB,aAAAv5D,OAA4CmtC,GAAAjlB,EAAQA,IAEpDtc,MAAAgqD,gBAAAhqD,MAAA2tD,aAAArxC,IAEA0tC,gBAAA/mD,MAAAypD,eAAA1sD,MACAgqD,gBAAA/mD,MAAAypD,cAAA,GAAA1sD,MACAgqD,gBAAA/mD,MAAAypD,cAAA,GAAA1sD,MAEA0sD,eAAA,MAMK,QAAA1C,gBAAAxwC,MAEL,GAAAngB,SAAA2wD,gBAAAS,SAAA,aAAAT,gBAAAS,QAEA,IAAAnuC,EAAA,EAAAilB,GAAAosB,aAAAv5D,OAA4CmtC,GAAAjlB,EAAQA,IAEpD2b,KAAA21B,UAAAD,aAAArxC,IAEAvN,GAAAi7C,gBAAAhqD,MAAAi4B,KAAApoB,GACAkD,GAAAi3C,gBAAAhqD,MAAAi4B,KAAAl4B,GACA+tB,GAAAk8B,gBAAAhqD,MAAAi4B,KAAAhpC,GAEA+6D,gBAAA/mD,MAAAypD,eAAA39C,GAAApb,EACAq2D,gBAAA/mD,MAAAypD,cAAA,GAAA39C,GAAAnb,EAEAo2D,gBAAA/mD,MAAAypD,cAAA,GAAA35C,GAAApf,EACAq2D,gBAAA/mD,MAAAypD,cAAA,GAAA35C,GAAAnf,EAEAo2D,gBAAA/mD,MAAAypD,cAAA,GAAA5+B,GAAAn6B,EACAq2D,gBAAA/mD,MAAAypD,cAAA,GAAA5+B,GAAAl6B,EAEA84D,eAAA,MAIM,cAAA1C,gBAAAS,QAEN,IAAAnuC,EAAA,EAAAilB,GAAAosB,aAAAv5D,OAA4CmtC,GAAAjlB,EAAQA,IAEpDtc,MAAAgqD,gBAAAhqD,MAAA2tD,aAAArxC,IAEAvN,GAAA/O,MACA+S,GAAA/S,MACA8tB,GAAA9tB,MAEAgqD,gBAAA/mD,MAAAypD,eAAA39C,GAAApb,EACAq2D,gBAAA/mD,MAAAypD,cAAA,GAAA39C,GAAAnb,EAEAo2D,gBAAA/mD,MAAAypD,cAAA,GAAA35C,GAAApf,EACAq2D,gBAAA/mD,MAAAypD,cAAA,GAAA35C,GAAAnf,EAEAo2D,gBAAA/mD,MAAAypD,cAAA,GAAA5+B,GAAAn6B,EACAq2D,gBAAA/mD,MAAAypD,cAAA,GAAA5+B,GAAAl6B,EAEA84D,eAAA,MAMK,QAAA1C,gBAAAxwC,KAAA,CAEL,GAAA00C,GAYA,IARAA,GAFA,MAAAlE,gBAAAn0D,MAEA,cAIA,aAIAwD,SAAA2wD,gBAAAS,SAAA,aAAAT,gBAAAS,QAEA,IAAAnuC,EAAA,EAAAilB,GAAAosB,aAAAv5D,OAA4CmtC,GAAAjlB,EAAQA,IAEpD2b,KAAA21B,UAAAD,aAAArxC,IAEAvN,GAAAi7C,gBAAAhqD,MAAAi4B,KAAApoB,GACAkD,GAAAi3C,gBAAAhqD,MAAAi4B,KAAAl4B,GACA+tB,GAAAk8B,gBAAAhqD,MAAAi4B,KAAAhpC,GAEA+6D,gBAAA/mD,MAAAypD,eAAA39C,GAAAm/C,GAAA,IACAlE,gBAAA/mD,MAAAypD,cAAA,GAAA39C,GAAAm/C,GAAA,IACAlE,gBAAA/mD,MAAAypD,cAAA,GAAA39C,GAAAm/C,GAAA,IAEAlE,gBAAA/mD,MAAAypD,cAAA,GAAA35C,GAAAm7C,GAAA,IACAlE,gBAAA/mD,MAAAypD,cAAA,GAAA35C,GAAAm7C,GAAA,IACAlE,gBAAA/mD,MAAAypD,cAAA,GAAA35C,GAAAm7C,GAAA,IAEAlE,gBAAA/mD,MAAAypD,cAAA,GAAA5+B,GAAAogC,GAAA,IACAlE,gBAAA/mD,MAAAypD,cAAA,GAAA5+B,GAAAogC,GAAA,IACAlE,gBAAA/mD,MAAAypD,cAAA,GAAA5+B,GAAAogC,GAAA,IAEAxB,eAAA,MAIM,cAAA1C,gBAAAS,QAEN,IAAAnuC,EAAA,EAAAilB,GAAAosB,aAAAv5D,OAA4CmtC,GAAAjlB,EAAQA,IAEpDtc,MAAAgqD,gBAAAhqD,MAAA2tD,aAAArxC,IAEAvN,GAAA/O,MACA+S,GAAA/S,MACA8tB,GAAA9tB,MAEAgqD,gBAAA/mD,MAAAypD,eAAA39C,GAAAm/C,GAAA,IACAlE,gBAAA/mD,MAAAypD,cAAA,GAAA39C,GAAAm/C,GAAA,IACAlE,gBAAA/mD,MAAAypD,cAAA,GAAA39C,GAAAm/C,GAAA,IAEAlE,gBAAA/mD,MAAAypD,cAAA,GAAA35C,GAAAm7C,GAAA,IACAlE,gBAAA/mD,MAAAypD,cAAA,GAAA35C,GAAAm7C,GAAA,IACAlE,gBAAA/mD,MAAAypD,cAAA,GAAA35C,GAAAm7C,GAAA,IAEAlE,gBAAA/mD,MAAAypD,cAAA,GAAA5+B,GAAAogC,GAAA,IACAlE,gBAAA/mD,MAAAypD,cAAA,GAAA5+B,GAAAogC,GAAA,IACAlE,gBAAA/mD,MAAAypD,cAAA,GAAA5+B,GAAAogC,GAAA,IAEAxB,eAAA,MAIM,qBAAA1C,gBAAAS,QAEN,IAAAnuC,EAAA,EAAAilB,GAAAosB,aAAAv5D,OAA4CmtC,GAAAjlB,EAAQA,IAEpDtc,MAAAgqD,gBAAAhqD,MAAA2tD,aAAArxC,IAEAvN,GAAA/O,MAAA,GACA+S,GAAA/S,MAAA,GACA8tB,GAAA9tB,MAAA,GAEAgqD,gBAAA/mD,MAAAypD,eAAA39C,GAAAm/C,GAAA,IACAlE,gBAAA/mD,MAAAypD,cAAA,GAAA39C,GAAAm/C,GAAA,IACAlE,gBAAA/mD,MAAAypD,cAAA,GAAA39C,GAAAm/C,GAAA,IAEAlE,gBAAA/mD,MAAAypD,cAAA,GAAA35C,GAAAm7C,GAAA,IACAlE,gBAAA/mD,MAAAypD,cAAA,GAAA35C,GAAAm7C,GAAA,IACAlE,gBAAA/mD,MAAAypD,cAAA,GAAA35C,GAAAm7C,GAAA,IAEAlE,gBAAA/mD,MAAAypD,cAAA,GAAA5+B,GAAAogC,GAAA,IACAlE,gBAAA/mD,MAAAypD,cAAA,GAAA5+B,GAAAogC,GAAA,IACAlE,gBAAA/mD,MAAAypD,cAAA,GAAA5+B,GAAAogC,GAAA,IAEAxB,eAAA,MAMK,QAAA1C,gBAAAxwC,KAEL,GAAAngB,SAAA2wD,gBAAAS,SAAA,aAAAT,gBAAAS,QAEA,IAAAnuC,EAAA,EAAAilB,GAAAosB,aAAAv5D,OAA4CmtC,GAAAjlB,EAAQA,IAEpD2b,KAAA21B,UAAAD,aAAArxC,IAEAvN,GAAAi7C,gBAAAhqD,MAAAi4B,KAAApoB,GACAkD,GAAAi3C,gBAAAhqD,MAAAi4B,KAAAl4B,GACA+tB,GAAAk8B,gBAAAhqD,MAAAi4B,KAAAhpC,GAEA+6D,gBAAA/mD,MAAAypD,eAAA39C,GAAApb,EACAq2D,gBAAA/mD,MAAAypD,cAAA,GAAA39C,GAAAnb,EACAo2D,gBAAA/mD,MAAAypD,cAAA,GAAA39C,GAAApc,EACAq3D,gBAAA/mD,MAAAypD,cAAA,GAAA39C,GAAAtC,EAEAu9C,gBAAA/mD,MAAAypD,cAAA,GAAA35C,GAAApf,EACAq2D,gBAAA/mD,MAAAypD,cAAA,GAAA35C,GAAAnf,EACAo2D,gBAAA/mD,MAAAypD,cAAA,GAAA35C,GAAApgB,EACAq3D,gBAAA/mD,MAAAypD,cAAA,GAAA35C,GAAAtG,EAEAu9C,gBAAA/mD,MAAAypD,cAAA,GAAA5+B,GAAAn6B,EACAq2D,gBAAA/mD,MAAAypD,cAAA,GAAA5+B,GAAAl6B,EACAo2D,gBAAA/mD,MAAAypD,cAAA,IAAA5+B,GAAAn7B,EACAq3D,gBAAA/mD,MAAAypD,cAAA,IAAA5+B,GAAArhB,EAEAigD,eAAA,OAIM,cAAA1C,gBAAAS,QAEN,IAAAnuC,EAAA,EAAAilB,GAAAosB,aAAAv5D,OAA4CmtC,GAAAjlB,EAAQA,IAEpDtc,MAAAgqD,gBAAAhqD,MAAA2tD,aAAArxC,IAEAvN,GAAA/O,MACA+S,GAAA/S,MACA8tB,GAAA9tB,MAEAgqD,gBAAA/mD,MAAAypD,eAAA39C,GAAApb,EACAq2D,gBAAA/mD,MAAAypD,cAAA,GAAA39C,GAAAnb,EACAo2D,gBAAA/mD,MAAAypD,cAAA,GAAA39C,GAAApc,EACAq3D,gBAAA/mD,MAAAypD,cAAA,GAAA39C,GAAAtC,EAEAu9C,gBAAA/mD,MAAAypD,cAAA,GAAA35C,GAAApf,EACAq2D,gBAAA/mD,MAAAypD,cAAA,GAAA35C,GAAAnf,EACAo2D,gBAAA/mD,MAAAypD,cAAA,GAAA35C,GAAApgB,EACAq3D,gBAAA/mD,MAAAypD,cAAA,GAAA35C,GAAAtG,EAEAu9C,gBAAA/mD,MAAAypD,cAAA,GAAA5+B,GAAAn6B,EACAq2D,gBAAA/mD,MAAAypD,cAAA,GAAA5+B,GAAAl6B,EACAo2D,gBAAA/mD,MAAAypD,cAAA,IAAA5+B,GAAAn7B,EACAq3D,gBAAA/mD,MAAAypD,cAAA,IAAA5+B,GAAArhB,EAEAigD,eAAA,OAIM,qBAAA1C,gBAAAS,QAEN,IAAAnuC,EAAA,EAAAilB,GAAAosB,aAAAv5D,OAA4CmtC,GAAAjlB,EAAQA,IAEpDtc,MAAAgqD,gBAAAhqD,MAAA2tD,aAAArxC,IAEAvN,GAAA/O,MAAA,GACA+S,GAAA/S,MAAA,GACA8tB,GAAA9tB,MAAA,GAEAgqD,gBAAA/mD,MAAAypD,eAAA39C,GAAApb,EACAq2D,gBAAA/mD,MAAAypD,cAAA,GAAA39C,GAAAnb,EACAo2D,gBAAA/mD,MAAAypD,cAAA,GAAA39C,GAAApc,EACAq3D,gBAAA/mD,MAAAypD,cAAA,GAAA39C,GAAAtC,EAEAu9C,gBAAA/mD,MAAAypD,cAAA,GAAA35C,GAAApf,EACAq2D,gBAAA/mD,MAAAypD,cAAA,GAAA35C,GAAAnf,EACAo2D,gBAAA/mD,MAAAypD,cAAA,GAAA35C,GAAApgB,EACAq3D,gBAAA/mD,MAAAypD,cAAA,GAAA35C,GAAAtG,EAEAu9C,gBAAA/mD,MAAAypD,cAAA,GAAA5+B,GAAAn6B,EACAq2D,gBAAA/mD,MAAAypD,cAAA,GAAA5+B,GAAAl6B,EACAo2D,gBAAA/mD,MAAAypD,cAAA,IAAA5+B,GAAAn7B,EACAq3D,gBAAA/mD,MAAAypD,cAAA,IAAA5+B,GAAArhB,EAEAigD,eAAA,EAQA1G,KAAAsE,WAAAtE,IAAAuE,aAAAP,gBAAA1S,QACA0O,IAAAwE,WAAAxE,IAAAuE,aAAAP,gBAAA/mD,MAAA4mD,MAMA7pB,gBAEAymB,eAAAiD,sBACAjD,eAAAqB,mBACArB,eAAA+B,oBACA/B,eAAAkC,qBACAlC,eAAAgC,gBACAhC,eAAAiC,iBACAjC,eAAAyC,kBACAzC,eAAAoB,oBACApB,eAAA0C,kBACA1C,eAAAmC,uBACAnC,eAAAoC,oBAkHA,QAAAsF,uBAAAr7D,SAAAs7D,QAAAx7D,SAAAy7D,YAOA,OALAC,oBAAA17D,SAAAsoB,WAEAqzC,kBAAAH,QAAAlzC,WACAszC,sBAAAJ,QAAA30B,eAEAtlC,EAAA,EAAAsM,EAAA+tD,sBAAAp6D,OAAoDqM,EAAAtM,EAAOA,IAAA,CAE3D,GAAAvD,KAAA49D,sBAAAr6D,GACAs6D,iBAAAF,kBAAA39D,IAEA,IAAA69D,kBAAA,GAEA,GAAAC,mBAAAJ,mBAAA19D,IAEA,IAAAyI,SAAAq1D,kBAAA,CAEA,GAAAl1C,MAAAk1C,kBAAAx7C,QAEA8yC,KAAAsE,WAAAtE,IAAAuE,aAAAmE,kBAAApX,QAEAqX,MAAAC,gBAAAH,kBAEAzI,IAAA6I,oBAAAJ,iBAAAj1C,KAAAwsC,IAAA8I,OAAA,IAAAT,WAAA70C,KAAA,OAEKngB,UAAAvG,SAAAkoD,yBAEL,IAAAloD,SAAAkoD,uBAAApqD,KAAAwD,OAEA4xD,IAAA+I,gBAAAN,iBAAA37D,SAAAkoD,uBAAApqD,MAEM,IAAAkC,SAAAkoD,uBAAApqD,KAAAwD,QAEN4xD,IAAAgJ,gBAAAP,iBAAA37D,SAAAkoD,uBAAApqD,QAUA+9D,MAAAM,0BAilBA,QAAAC,mBAAAp8D,SAAA2zD,cAAA/rC,QAIA,GAAAQ,YAAApoB,SAAAs7D,QAAAlzC,UAoBA,IAlBA,KAAAR,OAAA6iC,iBAAAriC,WAAAxoB,UAAA,GAEAszD,IAAAsE,WAAAtE,IAAAuE,aAAA9D,cAAAU,2BAAAzsC,OAAA6iC,kBAEAoR,MAAAC,gBAAA1zC,WAAAxoB,UAEAszD,IAAA6I,oBAAA3zC,WAAAxoB,SAAA,EAAAszD,IAAA8I,OAAA,QAEG5zC,WAAAxoB,UAAA,IAEHszD,IAAAsE,WAAAtE,IAAAuE,aAAA9D,cAAAV,qBAEA4I,MAAAC,gBAAA1zC,WAAAxoB,UAEAszD,IAAA6I,oBAAA3zC,WAAAxoB,SAAA,EAAAszD,IAAA8I,OAAA,QAIAp0C,OAAA8iC,uBAAAppD,OAUA,IANA,GAIA6e,WAJAjkB,EAAA,EACA4e,MAAA8M,OAAA8iC,uBACAgE,WAAA9mC,OAAA+iC,sBAIAzuD,EAAA8D,SAAAq8D,0BAAAngE,EAAA4e,MAAAxZ,QAEA6e,UAAAiI,WAAA,cAAAlsB,GAEAikB,WAAA,IAEA+yC,IAAAsE,WAAAtE,IAAAuE,aAAA9D,cAAAU,2BAAAv5C,MAAA5e,KAEA2/D,MAAAC,gBAAA37C,WAEA+yC,IAAA6I,oBAAA57C,UAAA,EAAA+yC,IAAA8I,OAAA,QAIA77C,UAAAiI,WAAA,cAAAlsB,GAEAikB,WAAA,GAAAngB,SAAAqtC,eAEA6lB,IAAAsE,WAAAtE,IAAAuE,aAAA9D,cAAAY,2BAAAz5C,MAAA5e,KAEA2/D,MAAAC,gBAAA37C,WAEA+yC,IAAA6I,oBAAA57C,UAAA,EAAA+yC,IAAA8I,OAAA,QAIAp0C,OAAA00C,6BAAApgE,GAAAwyD,WAAA5zC,MAAA5e,IAEAA,QAIG,CAIH,GAAAqgE,2BACA7N,WAAA9mC,OAAA+iC,sBACAxd,aAAAvlB,OAAA9nB,SAAAqtC,YAEAuhB,YAAAptD,OAAA6rC,aAAA7rC,SAEAxE,QAAA4J,KAAA,4EACAgoD,WAAAptD,OAAA6rC,aAAA7rC,OAIA,QAAAD,GAAA,EAAAklB,GAAAmoC,WAAAptD,OAA2CilB,GAAAllB,EAAQA,IAAA,CAEnD,GAAA+pD,WAAAsD,WAAArtD,EAEAk7D,wBAAAt7D,MAAAmqD,UAAA/pD,IAIAk7D,uBAAAj7D,OAAAtB,SAAAq8D,0BAEAE,uBAAAn8B,KAAAo8B,eACAD,uBAAAj7D,OAAAtB,SAAAq8D,0BAEIE,uBAAAj7D,OAAAtB,SAAAy8D,yBAEJF,uBAAAn8B,KAAAo8B,eAEI,IAAAD,uBAAAj7D,QAEJi7D,uBAAAt7D,MAAA,KAMA,QAFAkf,WAEAjkB,EAAA,EAAA2uD,GAAA7qD,SAAAq8D,yBAA2DxR,GAAA3uD,EAAQA,IAEnE,GAAAqgE,uBAAArgE,GAAA,CAEA,GAAAwgE,gBAAAH,uBAAArgE,GAAA,EAEAikB,WAAAiI,WAAA,cAAAlsB,GAEAikB,WAAA,IAEA+yC,IAAAsE,WAAAtE,IAAAuE,aAAA9D,cAAAU,2BAAAqI,iBAEAb,MAAAC,gBAAA37C,WAEA+yC,IAAA6I,oBAAA57C,UAAA,EAAA+yC,IAAA8I,OAAA,QAIA77C,UAAAiI,WAAA,cAAAlsB,GAEAikB,WAAA,GAAAngB,SAAAqtC,eAEA6lB,IAAAsE,WAAAtE,IAAAuE,aAAA9D,cAAAY,2BAAAmI,iBAEAb,MAAAC,gBAAA37C,WAEA+yC,IAAA6I,oBAAA57C,UAAA,EAAA+yC,IAAA8I,OAAA,QAIAp0C,OAAA00C,6BAAApgE,GAAAwyD,WAAAgO,oBAcA90C,QAAA00C,6BAAApgE,GAAA,EAUA,OAAA8D,SAAAs7D,QAAApa,SAAAyJ,uBAEAuI,IAAAyJ,WAAA38D,SAAAs7D,QAAApa,SAAAyJ,sBAAA/iC,OAAA00C,8BAQA,QAAAM,mBAAA7/C,EAAA9P,GAEA,MAAA8P,GAAA6K,OAAA6Z,cAAAx0B,EAAA2a,OAAA6Z,YAEA1kB,EAAA6K,OAAA6Z,YAAAx0B,EAAA2a,OAAA6Z,YAEG1kB,EAAA/c,SAAAjE,KAAAkR,EAAAjN,SAAAjE,GAEHghB,EAAA/c,SAAAjE,GAAAkR,EAAAjN,SAAAjE,GAEGghB,EAAAld,IAAAoN,EAAApN,EAEHkd,EAAAld,EAAAoN,EAAApN,EAIAkd,EAAAhhB,GAAAkR,EAAAlR,GAMA,QAAA8gE,0BAAA9/C,EAAA9P,GAEA,MAAA8P,GAAA6K,OAAA6Z,cAAAx0B,EAAA2a,OAAA6Z,YAEA1kB,EAAA6K,OAAA6Z,YAAAx0B,EAAA2a,OAAA6Z,YAEG1kB,EAAAld,IAAAoN,EAAApN,EAEHoN,EAAApN,EAAAkd,EAAAld,EAIAkd,EAAAhhB,GAAAkR,EAAAlR,GAMA,QAAAygE,eAAAz/C,EAAA9P,GAEA,MAAAA,GAAA,GAAA8P,EAAA,GAsJA,QAAA+/C,eAAAl1C,QAEA,GAAAA,OAAAyZ,WAAA,GAEA,GAAAzZ,iBAAAvhB,OAAA5J,OAAAmrB,iBAAAvhB,OAAA69C,WAQA,IAFA6Y,WAAAn1C,QAEAA,iBAAAvhB,OAAA6tC,MAEA+T,OAAAhnD,KAAA2mB,YAEI,IAAAA,iBAAAvhB,OAAA+4B,OAEJ49B,QAAA/7D,KAAA2mB,YAEI,IAAAA,iBAAAvhB,OAAA0oD,UAEJC,WAAA/tD,KAAA2mB,YAEI,CAEJ,GAAAq1C,cAAAC,cAAAt1C,OAAA7rB,GAEA,IAAAkhE,eAAAr1C,OAAA4Z,iBAAA,GAAA27B,SAAAlmC,iBAAArP,WAAA,GAEA,OAAAvmB,GAAA,EAAAsM,EAAAsvD,aAAA37D,OAA8CqM,EAAAtM,EAAOA,IAAA,CAErD,GAAA+7D,aAAAH,aAAA57D,EAEAg8D,sBAAAD,aAEAA,YAAAx+D,QAAA,EAEAy0D,MAAA/zD,eAAA,IAEAg+D,SAAAt6C,sBAAA4E,OAAAjG,aACA27C,SAAA18C,gBAAA28C,mBAEAH,YAAAv9D,EAAAy9D,SAAAz9D,IAYA,OAAAwB,GAAA,EAAAsM,EAAAia,OAAAmY,SAAAz+B,OAA8CqM,EAAAtM,EAAOA,IAErDy7D,cAAAl1C,OAAAmY,SAAA1+B,KAMA,QAAAm8D,eAAAC,WAAAj+D,OAAAyoD,OAAAlB,IAAAyI,kBAIA,OAFAxvD,UAEAqB,EAAA,EAAAsM,EAAA8vD,WAAAn8D,OAAyCqM,EAAAtM,EAAOA,IAAA,CAEhD,GAAA+7D,aAAAK,WAAAp8D,GAEAumB,OAAAw1C,YAAAx1C,OACA48B,OAAA4Y,YAAA5Y,MAIA,IAFAkZ,cAAA91C,OAAApoB,QAEAgwD,iBAEAxvD,SAAAwvD,qBAEI,CAIJ,GAFAxvD,SAAAo9D,YAAAp9D,UAEAA,SAAA,QAEA29D,aAAA39D,UAIAqzD,MAAAuK,iBAAA59D,UAEAwkD,iBAAAn+C,OAAA8hB,eAEAkrC,MAAAwK,mBAAAr+D,OAAAyoD,OAAAlB,IAAA/mD,SAAAwkD,OAAA58B,QAIAyrC,MAAAyK,aAAAt+D,OAAAyoD,OAAAlB,IAAA/mD,SAAAwkD,OAAA58B,SAQA,QAAAm2C,wBAAAN,WAAAO,aAAAx+D,OAAAyoD,OAAAlB,IAAAyI,kBAIA,OAFAxvD,UAEAqB,EAAA,EAAAsM,EAAA8vD,WAAAn8D,OAAyCqM,EAAAtM,EAAOA,IAAA,CAEhD,GAAA+7D,aAAAK,WAAAp8D,GACAumB,OAAAw1C,YAAAx1C,MAEA,IAAAA,OAAAyZ,QAAA,CAEA,GAAAmuB,iBAEAxvD,SAAAwvD,qBAEK,CAIL,GAFAxvD,SAAAo9D,YAAAY,eAEAh+D,SAAA,QAEA29D,aAAA39D,UAIAqzD,MAAA4K,sBAAAz+D,OAAAyoD,OAAAlB,IAAA/mD,SAAA4nB,UA4BA,QAAAs2C,+BAAAC,UAEA,GAAAv2C,QAAAu2C,SAAAv2C,OACA5nB,SAAA4nB,OAAA5nB,QAEAA,UAAAo6C,aAEA+jB,SAAA/jB,YAAAp6C,SACAm+D,SAAAC,OAAA,OAIAD,SAAAC,OAAAp+D,SACAm+D,SAAA/jB,YAAA,MAMA,QAAAijB,sBAAAc,UAEA,GAAAv2C,QAAAu2C,SAAAv2C,OACA48B,OAAA2Z,SAAA3Z,OAEA1kD,SAAA8nB,OAAA9nB,SACAE,SAAA4nB,OAAA5nB,QAEA,IAAAA,mBAAAqG,OAAAwhD,iBAAA,CAEA,GAAA9iB,eAAAjlC,mBAAAuG,OAAA8hB,eAAA,EAAAq8B,OAAAzf,aAEA/kC,mBAAA+jC,UAAAgB,eAEAo5B,SAAAn+D,kBAEAA,SAAAo6C,YAEAikB,mBAAAp9D,KAAAk9D,UAIAG,cAAAr9D,KAAAk9D,cAIGn+D,YAEHm+D,SAAAn+D,kBAEAA,SAAAo6C,YAEAikB,mBAAAp9D,KAAAk9D,UAIAG,cAAAr9D,KAAAk9D,WAQA,QAAApB,YAAAn1C,QAEArhB,SAAAqhB,OAAA22C,cAEA32C,OAAA22C,aAAA,EACA32C,OAAA42C,iBAAA,GAAAn4D,OAAAkb,QACAqG,OAAA62C,cAAA,GAAAp4D,OAAAoiB,QAEAb,OAAAroB,iBAAA,UAAAm/D,iBAIA,IAAA5+D,UAAA8nB,OAAA9nB,QAgDA,IA9CAyG,SAAAzG,UAIGyG,SAAAzG,SAAAy+D,cAEHz+D,SAAAy+D,aAAA,EACAz+D,SAAAP,iBAAA,UAAAo/D,mBAEA7+D,mBAAAuG,OAAA8hB,eAEAkrC,MAAAC,KAAAC,OAAA3vB,aAEIhc,iBAAAvhB,OAAAhG,KAEJu+D,mBAAAh3C,OAAA9nB,UAEI8nB,iBAAAvhB,OAAAm5B,KAEJj5B,SAAAzG,SAAAmzD,sBAEAO,kBAAA1zD,UACAo1D,gBAAAp1D,SAAA8nB,QAEA9nB,SAAA6tC,oBAAA,EACA7tC,SAAAkuC,kBAAA,EACAluC,SAAAmuC,yBAAA,GAIIrmB,iBAAAvhB,OAAAg5B,YAEJ94B,SAAAzG,SAAAmzD,sBAEAD,sBAAAlzD,UACAg1D,oBAAAh1D,SAAA8nB,QAEA9nB,SAAA6tC,oBAAA,EACA7tC,SAAAkuC,kBAAA,IAQAznC,SAAAqhB,OAAAi3C,cAIA,GAFAj3C,OAAAi3C,eAAA,EAEAj3C,iBAAAvhB,OAAAhG,MAEA,GAAAP,mBAAAuG,OAAA8hB,eAEA22C,UAAA5B,cAAAp9D,SAAA8nB,YAEK,IAAA9nB,mBAAAuG,OAAA4hB,SAIL,OAFA82C,oBAAAC,eAAAl/D,SAAA/D,IAEAsF,EAAA,EAAAsM,EAAAoxD,mBAAAz9D,OAAmDqM,EAAAtM,EAAOA,IAE1Dy9D,UAAA5B,cAAA6B,mBAAA19D,GAAAumB,YAMIA,kBAAAvhB,OAAAm5B,MAAA5X,iBAAAvhB,OAAAg5B,WAEJy/B,UAAA5B,cAAAp9D,SAAA8nB,SAEIA,iBAAAvhB,OAAA44D,uBAAAr3C,OAAAs3C,0BAEJC,mBAAAC,uBAAAx3C,QAaA,QAAAy3C,YAAAv/D,SAAAw/D,kBAaA,OATAC,WAKAC,MAPAC,mBAAAxJ,WAAA3f,IAAA,2CAEAopB,YAEAtL,gBAAAt0D,SAAAqtC,aAAA7rC,OACAgzD,gBAAAx0D,SAAAutC,aAAA/rC,OAGAq+D,UACAC,cAEAp2C,EAAA,EAAAilB,GAAA3uC,SAAAynC,MAAAjmC,OAA8CmtC,GAAAjlB,EAAQA,IAAA,CAEtD,GAAA2b,MAAArlC,SAAAynC,MAAA/d,GACAub,cAAAu6B,iBAAAn6B,KAAAJ,cAAA,CAEAA,iBAAA26B,YAEAA,SAAA36B,gBAAiCqM,KAAArM,cAAA86B,QAAA,IAIjCN,UAAAG,SAAA36B,eAAAqM,KAAA,IAAAsuB,SAAA36B,eAAA86B;AAEAN,YAAAI,UAEAH,OACAzjE,GAAA+jE,uBACAxK,UACAvwB,4BACA7c,SAAA,EACAksC,gCACAE,iCAGAqL,OAAAJ,WAAAC,MACAI,WAAA3+D,KAAAu+D,QAIAG,OAAAJ,WAAAr3C,SAAA,EAAAu3C,qBAEAC,SAAA36B,eAAA86B,SAAA,EACAN,UAAAG,SAAA36B,eAAAqM,KAAA,IAAAsuB,SAAA36B,eAAA86B,QAEAN,YAAAI,UAEAH,OACAzjE,GAAA+jE,uBACAxK,UACAvwB,4BACA7c,SAAA,EACAksC,gCACAE,iCAGAqL,OAAAJ,WAAAC,MACAI,WAAA3+D,KAAAu+D,SAMAG,OAAAJ,WAAAjK,OAAAr0D,KAAAuoB,GACAm2C,OAAAJ,WAAAr3C,UAAA,EAIA,MAAA03C,YAIA,QAAAhB,oBAAAh3C,OAAA9nB,UAEA,GAAAE,UAAA4nB,OAAA5nB,SAAA+/D,YAAA,GAEAx5D,SAAAy4D,eAAAl/D,SAAA/D,KAAA+D,SAAAouC,oBAAA,WAEAgvB,eAAAt1C,OAAA7rB,IAEAijE,eAAAl/D,SAAA/D,IAAAsjE,WAAAv/D,SAAAE,mBAAAqG,OAAAwhD,kBAEA/nD,SAAAouC,kBAAA,EAQA,QAJA6wB,oBAAAC,eAAAl/D,SAAA/D,IAIAsF,EAAA,EAAAklB,GAAAw4C,mBAAAz9D,OAAkDilB,GAAAllB,EAAQA,IAAA,CAE1D,GAAAsyD,eAAAoL,mBAAA19D,EAIAkF,UAAAotD,cAAAV,qBAEAS,kBAAAC,eACA0B,gBAAA1B,cAAA/rC,QAEA9nB,SAAA6tC,oBAAA,EACA7tC,SAAA86D,wBAAA,EACA96D,SAAA8tC,oBAAA,EACA9tC,SAAA+tC,eAAA,EACA/tC,SAAAguC,mBAAA,EACAhuC,SAAAiuC,oBAAA,EACAjuC,SAAAkuC,kBAAA,EAEA+xB,YAAA,GAIAA,YAAA,GAIAA,YAAAx5D,SAAAqhB,OAAAi3C,gBAEAC,UAAA5B,cAAAvJ,cAAA/rC,QAMAA,OAAAi3C,eAAA,EAIA,QAAAC,WAAAkB,QAAAxb,OAAA58B,QAEA,GAAA7rB,IAAA6rB,OAAA7rB,EACAikE,SAAAjkE,IAAAikE,QAAAjkE,QACAikE,QAAAjkE,IAAAkF,MAEAlF,MACAyoD,cACA58B,cACA5nB,SAAA,KACAH,EAAA,IAMA,QAAAs/D,oBAAAa,QAAAp4C,QAEAo4C,QAAA/+D,MAEAlF,GAAA,KACA6rB,cACAw2C,OAAA,KACAhkB,YAAA,KACAv6C,EAAA,IAQA,QAAAogE,cAAAr4C,QAEA,GAAA9nB,UAAA8nB,OAAA9nB,QAEA,IAAAA,mBAAAuG,OAAA8hB,eAKA,OAHAC,YAAAtoB,SAAAsoB,WACAue,eAAA7mC,SAAA6mC,eAEAtlC,EAAA,EAAAsM,EAAAg5B,eAAArlC,OAA8CqM,EAAAtM,EAAOA,IAAA,CAErD,GAAAvD,KAAA6oC,eAAAtlC,GACA8e,UAAAiI,WAAAtqB,KACAoiE,WAAA,UAAApiE,IAAAo1D,IAAAiI,qBAAAjI,IAAAuE,YAEAlxD,UAAA4Z,UAAAqkC,QAEArkC,UAAAqkC,OAAA0O,IAAAC,eACAD,IAAAsE,WAAA0I,WAAA//C,UAAAqkC,QACA0O,IAAAwE,WAAAwI,WAAA//C,UAAAhQ,MAAAgQ,oBAAA9Z,OAAAigC,uBAAA4sB,IAAAiN,aAAAjN,IAAAkN,aAEAjgD,UAAAmlB,aAAA,GAEKnlB,UAAAmlB,eAAA,IAEL4tB,IAAAsE,WAAA0I,WAAA//C,UAAAqkC,QAEAj+C,SAAA4Z,UAAAomB,aAAA,KAAApmB,UAAAomB,YAAAC,MAEA0sB,IAAAmN,cAAAH,WAAA,EAAA//C,UAAAhQ,OAEM,IAAAgQ,UAAAomB,YAAAC,MAEN1pC,QAAA6J,MAAA,0LAIAusD,IAAAmN,cAAAH,WAAA//C,UAAAomB,YAAAl2B,OAAA8P,UAAAhQ,MAAAmwD,kBACAngD,UAAAhQ,MAAAowD,SAAApgD,UAAAomB,YAAAl2B,OAAA8P,UAAAomB,YAAAl2B,OAAA8P,UAAAomB,YAAAC,QAEArmB,UAAAomB,YAAAC,MAAA,GAIArmB,UAAAmlB,aAAA,OAMG,IAAA1d,iBAAAvhB,OAAAhG,KAAA,CAIHP,SAAAouC,oBAAA,GAEA0wB,mBAAAh3C,OAAA9nB,SAMA,QAFAi/D,oBAAAC,eAAAl/D,SAAA/D,IAEAsF,EAAA,EAAAklB,GAAAw4C,mBAAAz9D,OAAmDilB,GAAAllB,EAAQA,IAAA,CAE3D,GAAAsyD,eAAAoL,mBAAA19D,GACArB,SAAAy1D,kBAAA7tC,OAAA+rC,eAEA6M,sBAAAxgE,SAAAooB,YAAAq4C,yBAAAzgE,WAEAF,SAAA6tC,oBAAA7tC,SAAA86D,wBAAA96D,SAAA8tC,oBACA9tC,SAAA+tC,eAAA/tC,SAAAguC,mBACAhuC,SAAAkuC,kBAAAluC,SAAAiuC,oBAAAyyB,wBAEAxI,eAAArE,cAAA/rC,OAAAsrC,IAAAiN,cAAArgE,SAAA4tC,QAAA1tC,UAMAF,SAAA6tC,oBAAA,EACA7tC,SAAA86D,wBAAA,EACA96D,SAAA8tC,oBAAA,EACA9tC,SAAA+tC,eAAA,EACA/tC,SAAAguC,mBAAA,EACAhuC,SAAAkuC,kBAAA,EACAluC,SAAAiuC,oBAAA,EAEA/tC,SAAAooB,YAAAs4C,sBAAA1gE,cAEG,IAAA4nB,iBAAAvhB,OAAAm5B,KAAA,CAEH,GAAAx/B,UAAAy1D,kBAAA7tC,OAAA9nB,UACA0gE,sBAAAxgE,SAAAooB,YAAAq4C,yBAAAzgE,WAEAF,SAAA6tC,oBAAA7tC,SAAAkuC,kBAAAluC,SAAAmuC,yBAAAuyB,wBAEA5I,eAAA93D,SAAAozD,IAAAiN,cAIArgE,SAAA6tC,oBAAA,EACA7tC,SAAAkuC,kBAAA,EACAluC,SAAAmuC,yBAAA,EAEAjuC,SAAAooB,YAAAs4C,sBAAA1gE,cAEG,IAAA4nB,iBAAAvhB,OAAAg5B,WAAA,CAEH,GAAAr/B,UAAAy1D,kBAAA7tC,OAAA9nB,UACA0gE,sBAAAxgE,SAAAooB,YAAAq4C,yBAAAzgE,WAEAF,SAAA6tC,oBAAA7tC,SAAAkuC,kBAAAwyB,wBAEA1J,mBAAAh3D,SAAAozD,IAAAiN,aAAAv4C,QAIA9nB,SAAA6tC,oBAAA,EACA7tC,SAAAkuC,kBAAA,EAEAhuC,SAAAooB,YAAAs4C,sBAAA1gE,WAQA,QAAAygE,0BAAAzgE,UAEA,OAAA2gC,QAAA3gC,UAAAooB,WAEA,GAAApoB,SAAAooB,WAAAuY,MAAA2E,YAAA,QAIA,UAIA,QAAAo7B,uBAAA1gE,UAEA,OAAA2gC,QAAA3gC,UAAAooB,WAEApoB,SAAAooB,WAAAuY,MAAA2E,aAAA,EAQA,QAAAq7B,cAAA/4C,QAEAA,iBAAAvhB,OAAAhG,MACAunB,iBAAAvhB,OAAAg5B,YACAzX,iBAAAvhB,OAAAm5B,WAEA09B,eAAAt1C,OAAA7rB,KAEG6rB,iBAAAvhB,OAAA44D,uBAAAr3C,OAAAs3C,0BAEH0B,gBAAAxB,uBAAAx3C,cAIAA,QAAA22C,kBACA32C,QAAA42C,uBACA52C,QAAA62C,oBAEA72C,QAAAi3C,cAIA,QAAA+B,iBAAAZ,QAAAp4C,QAEA,OAAAi5C,GAAAb,QAAA1+D,OAAA,EAAmCu/D,GAAA,EAAQA,IAE3Cb,QAAAa,GAAAj5C,iBAEAo4C,QAAAhhC,OAAA6hC,EAAA,GAqBA,QAAAC,cAAA9gE,SAAAioD,OAAAlB,IAAAn/B,QAEA5nB,SAAAT,iBAAA,UAAAwhE,kBAEA,IAAAC,UAAAC,UAAAjhE,SAAA+C,KAEA,IAAAi+D,SAAA,CAEA,GAAAE,QAAA76D,MAAA4rD,UAAA+O,SAEAhhE,UAAAmhE,eACAjgB,SAAA76C,MAAAgiD,cAAA/3C,MAAA4wD,OAAAhgB,UACAC,aAAA+f,OAAA/f,aACAC,eAAA8f,OAAA9f,oBAKAphD,UAAAmhE,eACAjgB,SAAAlhD,SAAAkhD,SACAC,aAAAnhD,SAAAmhD,aACAC,eAAAphD,SAAAohD,eAQA,IAAAggB,eAAAC,eAAApZ,QACAqZ,WAAAC,gBAAAtZ,QACAuZ,SAAAC,cAAA75C,QAEA8pB,YAEA1R,UAAA0hC,WACAC,uBAAAC,wBAEA9nB,MAAA95C,SAAA85C,IACA8J,SAAA5jD,SAAA4jD,OACAie,WAAA7hE,SAAA4jD,QAAA5jD,SAAA4jD,OAAA2E,QACAxO,WAAA/5C,SAAA+5C,SACAE,UAAAj6C,SAAAi6C,QACAD,YAAAh6C,SAAAg6C,UACA6J,cAAA7jD,SAAA6jD,YACAF,WAAA3jD,SAAA2jD,SAEAwD,QAAAnnD,SAAAmnD,QAEAliB,aAAAjlC,SAAAilC,aAEA8hB,QACA+a,OAAA9hE,SAAA+mD,IACAgb,OAAAhb,cAAA1gD,OAAAspD,QAEAqS,YAAAhiE,SAAAk6C,UAAA7zC,MAAAwB,YAEAw5C,gBAAArhD,SAAAqhD,gBACA4gB,uBAAAC,wBAEAza,SAAAznD,SAAAynD,SACA+Z,kBACA9V,iBAAAyW,uBAAAv6C,eAAAklC,UAAAllC,OAAAklC,SAAApB,iBAEAve,aAAAntC,SAAAmtC,aACAE,aAAArtC,SAAAqtC,aACA+0B,gBAAA/O,MAAA+O,gBACAC,gBAAAhP,MAAAgP,gBAEAC,aAAAlB,cAAAmB,YACAC,eAAApB,cAAAv7C,MACA48C,cAAArB,cAAAsB,KACAC,cAAAvB,cAAAwB,KAEAtB,sBACAliE,iBAAAi0D,MAAAj0D,kBAAAwoB,OAAA2Z,eAAA+/B,WAAA,EACAuB,cAAAxP,MAAAwP,cACAC,eAAAzP,MAAAyP,eACAC,iBAAA1P,MAAA0P,iBAEAld,UAAA7lD,SAAA6lD,UACA+B,MAAA5nD,SAAA4nD,MACAF,WAAA1nD,SAAA0nD,WACAjN,YAAAz6C,SAAAw6C,OAAAn0C,MAAAsB,WACA4yC,UAAAv6C,SAAAw6C,OAAAn0C,MAAAqB,UAMAo0B,SAaA,IAXAklC,SAEAllC,OAAA76B,KAAA+/D,WAIAllC,OAAA76B,KAAAjB,SAAAohD,gBACAtlB,OAAA76B,KAAAjB,SAAAmhD,eAIA56C,SAAAvG,SAAAgoD,QAEA,OAAArnB,QAAA3gC,UAAAgoD,QAEAlsB,OAAA76B,KAAA0/B,MACA7E,OAAA76B,KAAAjB,SAAAgoD,QAAArnB,MAMA,QAAAA,QAAA+Q,YAEA5V,OAAA76B,KAAA0/B,MACA7E,OAAA76B,KAAAywC,WAAA/Q,MAUA,QAJA26B,SAFA0H,KAAAlnC,OAAAt6B,OAMApF,EAAA,EAAA6mE,GAAAC,UAAA5hE,OAAyC2hE,GAAA7mE,EAAQA,IAAA,CAEjD,GAAA+mE,aAAAD,UAAA9mE,EAEA,IAAA+mE,YAAAH,YAAA,CAEA1H,QAAA6H,YACA7H,QAAA8H,WAEA,QAMA78D,SAAA+0D,UAEAA,QAAA,GAAAj1D,OAAAg9D,aAAAhQ,MAAA2P,KAAAhjE,SAAA0xC,YACAwxB,UAAAjiE,KAAAq6D,SAEAjI,MAAAC,KAAAC,OAAA+P,SAAAJ,UAAA5hE,QAIAtB,SAAAs7D,eAEA,IAAAlzC,YAAAkzC,QAAAlzC,UAEA,IAAApoB,SAAAmtC,aAAA,CAEAntC,SAAAq8D,yBAAA,CAIA,QAFAtgE,IAAAwnE,KAAA,cAEAliE,EAAA,EAAmBA,EAAAgyD,MAAA+O,gBAA2B/gE,IAE9CtF,GAAAwnE,KAAAliE,EAEA+mB,WAAArsB,KAAA,GAEAiE,SAAAq8D,2BAQA,GAAAr8D,SAAAqtC,aAAA,CAEArtC,SAAAy8D,yBAAA,CAEA,IAAA1gE,IAAAwnE,KAAA,aAEA,KAAAliE,EAAA,EAAeA,EAAAgyD,MAAAgP,gBAA2BhhE,IAE1CtF,GAAAwnE,KAAAliE,EAEA+mB,WAAArsB,KAAA,GAEAiE,SAAAy8D,2BAQAz8D,SAAAwjE,eAEA,QAAAtmC,KAAAl9B,UAAAmhE,cAAAjgB,SAAA,CAEA,GAAAuiB,UAAAzjE,SAAAs7D,QAAApa,SAAAhkB,EAEAumC,WACAzjE,SAAAwjE,aAAAviE,MAAAjB,SAAAmhE,cAAAjgB,SAAAhkB,GAAAumC,YAOA,QAAA9F,aAAA39D,UAEAA,SAAAo6C,eAAA,EAEAyhB,MAAA6H,YAAA1jE,SAAAm6C,SAAAn6C,SAAAqlD,cAAArlD,SAAAmlD,SAAAnlD,SAAAolD,SAAAplD,SAAAwlD,mBAAAxlD,SAAAslD,cAAAtlD,SAAAulD,eAIAsW,MAAA6H,YAAAr9D,MAAA6B,YAIA2zD,MAAA8H,aAAA3jE,SAAAq6C,WACAwhB,MAAA+H,cAAA5jE,SAAAs6C,YACAuhB,MAAAgI,cAAA7jE,SAAAylD,YACAoW,MAAAiI,iBAAA9jE,SAAA0lD,cAAA1lD,SAAA2lD,oBAAA3lD,SAAA4lD,oBAIA,QAAAme,YAAAvkE,OAAAyoD,OAAAlB,IAAA/mD,SAAA4nB,QAEAo8C,kBAAA,EAEAhkE,SAAAslC,cAEAtlC,SAAAs7D,SAAA2I,mBAAAjkE,UAEA8gE,aAAA9gE,SAAAioD,OAAAlB,IAAAn/B,QACA5nB,SAAAslC,aAAA,GAIAtlC,SAAAmtC,eAEAvlB,OAAA00C,+BAEA10C,OAAA00C,6BAAA,GAAA5zC,cAAA2qC,MAAA+O,kBAMA,IAAA8B,iBAAA,EACAC,iBAAA,EACAC,eAAA,EAEA9I,QAAAt7D,SAAAs7D,QACA+I,WAAA/I,QAAApa,SACAojB,WAAAtkE,SAAAmhE,cAAAjgB,QAuEA,IArEAoa,QAAAv/D,KAAAwoE,kBAEArR,IAAAsR,WAAAlJ,iBACAiJ,gBAAAjJ,QAAAv/D,GAEAmoE,gBAAA,EACAC,iBAAA,EACAC,eAAA,GAIApkE,SAAAjE,KAAA0oE,qBAEA,KAAAA,qBAAAL,eAAA,GACAK,mBAAAzkE,SAAAjE,GAEAooE,iBAAA,IAIAD,gBAAA1kE,SAAAklE,kBAEAxR,IAAAyR,iBAAAN,WAAA5iD,kBAAA,EAAAjiB,OAAAiiB,iBAAApG,UAEA6mD,yBAEAhP,IAAA0R,UAAAP,WAAAQ,cAAA,GAAAr+D,KAAAzJ,IAAAyC,OAAAsxB,IAAA,GAAAtqB,KAAA4xC,MAKA54C,SAAAklE,gCAAAllE,SAKAQ,mBAAAqG,OAAA6xC,gBACAl4C,mBAAAqG,OAAAigD,mBACAtmD,SAAA4jD,SAEA,OAAAygB,WAAAS,iBAEAxH,SAAAt6C,sBAAAxjB,OAAAmiB,aACAuxC,IAAA6R,UAAAV,WAAAS,eAAAxH,SAAAz8D,EAAAy8D,SAAAx8D,EAAAw8D,SAAAz9D,KAMAG,mBAAAqG,OAAAigD,mBACAtmD,mBAAAqG,OAAAggD,qBACArmD,mBAAAqG,OAAApG,mBACAD,mBAAAqG,OAAA6xC,gBACAl4C,SAAAynD,WAEA,OAAA4c,WAAAW,YAEA9R,IAAAyR,iBAAAN,WAAAW,YAAA,EAAAxlE,OAAA6yC,mBAAAh3B,WAYArb,SAAAynD,SAcA,GAZA7/B,OAAA2kC,YAAA,OAAA8X,WAAA9X,YAEA2G,IAAAyR,iBAAAN,WAAA9X,YAAA,EAAA3kC,OAAA2kC,WAAAlxC,UAIAuM,OAAA4kC,mBAAA,OAAA6X,WAAA7X,mBAEA0G,IAAAyR,iBAAAN,WAAA7X,mBAAA,EAAA5kC,OAAA4kC,kBAAAnxC,UAIA8mD,uBAAAv6C,OAAAklC,UAAAllC,OAAAklC,SAAApB,iBAAA,CAEA,UAAA2Y,WAAAtY,YAAA,CAEA,GAAAkZ,aAAAC,gBAEAhS,KAAAiS,UAAAd,WAAAtY,YAAAkZ,aACA5R,MAAA+R,WAAAx9C,OAAAklC,SAAAf,YAAAkZ,aAIA,OAAAZ,WAAAzY,kBAEAsH,IAAAiS,UAAAd,WAAAzY,iBAAAhkC,OAAAklC,SAAAlB,kBAIA,OAAAyY,WAAAxY,mBAEAqH,IAAAiS,UAAAd,WAAAxY,kBAAAjkC,OAAAklC,SAAAjB,uBAIIjkC,QAAAklC,UAAAllC,OAAAklC,SAAAhB,cAEJ,OAAAuY,WAAAgB,oBAEAnS,IAAAyR,iBAAAN,WAAAgB,oBAAA,EAAAz9C,OAAAklC,SAAAhB,aAqGA,OA7FAqY,mBAIApd,KAAA/mD,SAAA+mD,KAEAue,mBAAAhB,WAAAvd,MAIA/mD,mBAAAqG,OAAAigD,mBACAtmD,mBAAAqG,OAAAggD,qBACArmD,SAAAioD,UAEAsd,oBAEAnB,eAAA,EACAoB,YAAAvd,QACAsd,mBAAA,GAGAnB,eACAqB,sBAAAnB,WAAAoB,SACAC,8BAAArB,YAAA,IAEAqB,8BAAArB,YAAA,KAKAtkE,mBAAAqG,OAAApG,mBACAD,mBAAAqG,OAAAggD,qBACArmD,mBAAAqG,OAAAigD,oBAEAsf,sBAAAtB,WAAAtkE,UAMAA,mBAAAqG,OAAAsgD,kBAEAkf,oBAAAvB,WAAAtkE,UAEIA,mBAAAqG,OAAA2gD,oBAEJ6e,oBAAAvB,WAAAtkE,UACA8lE,oBAAAxB,WAAAtkE,WAEIA,mBAAAqG,OAAAogD,mBAEJsf,wBAAAzB,WAAAtkE,UAEIA,mBAAAqG,OAAAigD,kBAEJ0f,qBAAA1B,WAAAtkE,UAEIA,mBAAAqG,OAAAggD,oBAEJ4f,uBAAA3B,WAAAtkE,UAEIA,mBAAAqG,OAAAmgD,mBAEJ8d,WAAA9R,MAAAtlD,MAAA1N,OAAAqxB,KACAyzC,WAAA7R,KAAAvlD,MAAA1N,OAAAsxB,IACAwzC,WAAAzqB,QAAA3sC,MAAAlN,SAAA65C,SAEI75C,mBAAAqG,OAAAkgD,qBAEJ+d,WAAAzqB,QAAA3sC,MAAAlN,SAAA65C,SAIAjyB,OAAA2Z,gBAAAvhC,SAAAkmE,aAEAC,sBAAA7B,WAAArc,QAMAme,oBAAApmE,SAAAwjE,eAIA6C,qBAAAhC,WAAAz8C,QAEA,OAAAy8C,WAAAiC,aAEApT,IAAAyR,iBAAAN,WAAAiC,aAAA,EAAA1+C,OAAAjG,YAAAtG,UAIAigD,QAMA,QAAAsK,uBAAA1kB,SAAAlhD,UAEAkhD,SAAArH,QAAA3sC,MAAAlN,SAAA65C,QAEAqH,SAAAkP,QAAAljD,MAAAlN,SAAAE,MAEAghD,SAAApH,IAAA5sC,MAAAlN,SAAA85C,IACAoH,SAAAnH,SAAA7sC,MAAAlN,SAAA+5C,SACAmH,SAAA2C,YAAA32C,MAAAlN,SAAA6jD,YACA3C,SAAAyC,SAAAz2C,MAAAlN,SAAA2jD,SAEA3jD,SAAAi6C,UAEAiH,SAAAjH,QAAA/sC,MAAAlN,SAAAi6C,QACAiH,SAAAhE,UAAAhwC,MAAAlN,SAAAk9C,WAIAl9C,SAAAg6C,YAEAkH,SAAAlH,UAAA9sC,MAAAlN,SAAAg6C,UACAkH,SAAA9D,YAAAlwC,MAAAC,KAAAnN,SAAAo9C,aAWA,IAAAmpB,WAwBA,IAtBAvmE,SAAA85C,IAEAysB,WAAAvmE,SAAA85C,IAEG95C,SAAA6jD,YAEH0iB,WAAAvmE,SAAA6jD,YAEG7jD,SAAAg6C,UAEHusB,WAAAvmE,SAAAg6C,UAEGh6C,SAAAi6C,QAEHssB,WAAAvmE,SAAAi6C,QAEGj6C,SAAA2jD,WAEH4iB,WAAAvmE,SAAA2jD,UAIAp9C,SAAAggE,WAAA,CAEA,GAAAl2D,QAAAk2D,WAAAl2D,OACAmoC,OAAA+tB,WAAA/tB,MAEA0I,UAAAmP,aAAAnjD,MAAAJ,IAAAuD,OAAAxP,EAAAwP,OAAAvP,EAAA03C,OAAA33C,EAAA23C,OAAA13C,GAIAogD,SAAA0C,OAAA12C,MAAAlN,SAAA4jD,OACA1C,SAAAoP,WAAApjD,MAAAlN,SAAA4jD,iBAAAv9C,OAAA0sC,sBAAA,KAEAmO,SAAAkG,aAAAl6C,MAAAlN,SAAAonD,aACAlG,SAAAmG,gBAAAn6C,MAAAlN,SAAAqnD,gBAIA,QAAAwe,qBAAA3kB,SAAAlhD,UAEAkhD,SAAAkP,QAAAljD,MAAAlN,SAAAE,MACAghD,SAAArH,QAAA3sC,MAAAlN,SAAA65C,QAIA,QAAAisB,qBAAA5kB,SAAAlhD,UAEAkhD,SAAA+F,SAAA/5C,MAAAlN,SAAAinD,SACA/F,SAAAqR,UAAArlD,MAAAlN,SAAAinD,SAAAjnD,SAAAknD,QACAhG,SAAA5xB,MAAApiB,MAAAlN,SAAAsvB,MAIA,QAAAy2C,yBAAA7kB,SAAAlhD,UASA,GAPAkhD,SAAA6Q,QAAA7kD,MAAAlN,SAAAE,MACAghD,SAAArH,QAAA3sC,MAAAlN,SAAA65C,QACAqH,SAAAx6B,KAAAxZ,MAAAlN,SAAA0mB,KACAw6B,SAAA5xB,MAAApiB,MAAAs5D,QAAAvyB,OAAA,EAEAiN,SAAApH,IAAA5sC,MAAAlN,SAAA85C,IAEA,OAAA95C,SAAA85C,IAAA,CAEA,GAAAzpC,QAAArQ,SAAA85C,IAAAzpC,OACAmoC,OAAAx4C,SAAA85C,IAAAtB,MAEA0I,UAAAmP,aAAAnjD,MAAAJ,IAAAuD,OAAAxP,EAAAwP,OAAAvP,EAAA03C,OAAA33C,EAAA23C,OAAA13C,IAMA,QAAAwkE,oBAAApkB,SAAA6F,KAEA7F,SAAA0P,SAAA1jD,MAAA65C,IAAA7mD,MAEA6mD,cAAA1gD,OAAAqpD,KAEAxO,SAAAwP,QAAAxjD,MAAA65C,IAAAl2B,KACAqwB,SAAAyP,OAAAzjD,MAAA65C,IAAAj2B,KAEGi2B,cAAA1gD,OAAAspD,UAEHzO,SAAAuP,WAAAvjD,MAAA65C,IAAA6I,SAMA,QAAAoW,sBAAA9kB,SAAAlhD,UAEAkhD,SAAAhG,UAAAhuC,MAAAlN,SAAAk7C,UAEAgG,SAAAnG,SAAA7tC,MAAAlN,SAAA+6C,SACAmG,SAAArG,SAAA3tC,MAAAlN,SAAA66C,SAEA76C,SAAA0nD,YAEAxG,SAAAyG,QAAAz6C,MAAAC,KAAAnN,SAAA2nD,SAMA,QAAAse,wBAAA/kB,SAAAlhD,UAEAkhD,SAAAnG,SAAA7tC,MAAAlN,SAAA+6C,SAEA/6C,SAAA0nD,YAEAxG,SAAAyG,QAAAz6C,MAAAC,KAAAnN,SAAA2nD,SAMA,QAAA8d,uBAAAvkB,SAAA+G,QAEA/G,SAAA2P,kBAAA3jD,MAAA+6C,OAAAwe,QAEAvlB,SAAA6P,sBAAA7jD,MAAA+6C,OAAAsa,YAAA36B,OACAsZ,SAAA4P,0BAAA5jD,MAAA+6C,OAAAsa,YAAAl6C,UAEA64B,SAAAiQ,gBAAAjkD,MAAA+6C,OAAApiC,MAAA+hB,OACAsZ,SAAAkQ,mBAAAlkD,MAAA+6C,OAAApiC,MAAAwC,UACA64B,SAAAmQ,mBAAAnkD,MAAA+6C,OAAApiC,MAAA6gD,UACAxlB,SAAAoQ,gBAAApkD,MAAA+6C,OAAApiC,MAAA8gD,OAEAzlB,SAAAqQ,eAAArkD,MAAA+6C,OAAAya,KAAA96B,OACAsZ,SAAAsQ,kBAAAtkD,MAAA+6C,OAAAya,KAAAr6C,UACA64B,SAAAwQ,kBAAAxkD,MAAA+6C,OAAAya,KAAAgE,UACAxlB,SAAAuQ,mBAAAvkD,MAAA+6C,OAAAya,KAAAkE,WACA1lB,SAAAyQ,kBAAAzkD,MAAA+6C,OAAAya,KAAAmE,UACA3lB,SAAA0Q,kBAAA1kD,MAAA+6C,OAAAya,KAAAoE,UACA5lB,SAAA2Q,eAAA3kD,MAAA+6C,OAAAya,KAAAiE,OAEAzlB,SAAA+P,wBAAA/jD,MAAA+6C,OAAA2a,KAAAmE,UACA7lB,SAAAgQ,2BAAAhkD,MAAA+6C,OAAA2a,KAAAoE,aACA9lB,SAAA8P,yBAAA9jD,MAAA+6C,OAAA2a,KAAAv6C,UAMA,QAAAs9C,+BAAAzkB,SAAAh0C,OAEAg0C,SAAA2P,kBAAAvrB,YAAAp4B,MAEAg0C,SAAA6P,sBAAAzrB,YAAAp4B,MACAg0C,SAAA4P,0BAAAxrB,YAAAp4B,MAEAg0C,SAAAiQ,gBAAA7rB,YAAAp4B,MACAg0C,SAAAkQ,mBAAA9rB,YAAAp4B,MACAg0C,SAAAmQ,mBAAA/rB,YAAAp4B,MACAg0C,SAAAoQ,gBAAAhsB,YAAAp4B,MAEAg0C,SAAAqQ,eAAAjsB,YAAAp4B,MACAg0C,SAAAsQ,kBAAAlsB,YAAAp4B,MACAg0C,SAAAwQ,kBAAApsB,YAAAp4B,MACAg0C,SAAAuQ,mBAAAnsB,YAAAp4B,MACAg0C,SAAAyQ,kBAAArsB,YAAAp4B,MACAg0C,SAAA0Q,kBAAAtsB,YAAAp4B,MACAg0C,SAAA2Q,eAAAvsB,YAAAp4B,MAEAg0C,SAAA+P,wBAAA3rB,YAAAp4B,MACAg0C,SAAAgQ,2BAAA5rB,YAAAp4B,MACAg0C,SAAA8P,yBAAA1rB,YAAAp4B,MAIA,QAAAi5D,uBAAAjlB,SAAA+G,QAEA,GAAA/G,SAAAlL,aAIA,OAFA/zC,GAAA,EAEAZ,EAAA,EAAAklB,GAAA0hC,OAAA3mD,OAAuCilB,GAAAllB,EAAQA,IAAA,CAE/C,GAAA8yC,OAAA8T,OAAA5mD,EAEA8yC,OAAA7S,aAEA6S,gBAAA9tC,OAAAm+B,WAAA2P,gBAAA9tC,OAAA+9B,mBAAA+P,MAAAiB,iBAEA8L,SAAArL,UAAA3oC,MAAAjL,GAAAkyC,MAAA0B,UACAqL,SAAApL,cAAA5oC,MAAAjL,GAAAkyC,MAAA2B,cAEAoL,SAAAlL,aAAA9oC,MAAAjL,GAAAkyC,MAAA6B,aAEAkL,SAAAjM,eAAA/nC,MAAAjL,GAAAkyC,MAAAc,eACAiM,SAAAlM,WAAA9nC,MAAAjL,GAAAkyC,MAAAa,WAEA/yC,MAYA,QAAAokE,sBAAAnlB,SAAAt5B,QAEAsrC,IAAAyR,iBAAAzjB,SAAA+lB,iBAAA,EAAAr/C,OAAA42C,iBAAAnjD,UAEA6lC,SAAA7oB,cAEA66B,IAAAgU,iBAAAhmB,SAAA7oB,cAAA,EAAAzQ,OAAA62C,cAAApjD,UAMA,QAAA6pD,kBAEA,GAAAD,aAAAjB,iBAUA,OARAiB,cAAAkC,cAEA9gE,MAAAK,KAAA,gCAAAu+D,YAAA,+CAAAkC,cAIAnD,mBAAA,EAEAiB,YAIA,QAAAmB,qBAAAllB,UAIA,OAFAvI,SAAAssB,YAAA50D,OAEApO,EAAA,EAAAqnC,GAAA4X,SAAA5/C,OAAwCgoC,GAAArnC,EAAQA,IAAA,CAEhD,GAAAmlE,SAAAlmB,SAAAj/C,GAAA,EAGA,IAAAmlE,QAAA9hC,eAAA,GAEA,GAAAviC,MAAAqkE,QAAArkE,KACAmK,MAAAk6D,QAAAl6D,MACAu2D,SAAAviB,SAAAj/C,GAAA,EAEA,QAAAc,MAEA,SACAmwD,IAAAiS,UAAA1B,SAAAv2D,MACA,MAEA,UACAgmD,IAAA0R,UAAAnB,SAAAv2D,MACA,MAEA,UACAgmD,IAAAmU,UAAA5D,SAAAv2D,MAAA,GAAAA,MAAA,GACA,MAEA,UACAgmD,IAAA6R,UAAAtB,SAAAv2D,MAAA,GAAAA,MAAA,GAAAA,MAAA,GACA,MAEA,UACAgmD,IAAAoU,UAAA7D,SAAAv2D,MAAA,GAAAA,MAAA,GAAAA,MAAA,GAAAA,MAAA,GACA,MAEA,WACAgmD,IAAAqU,WAAA9D,SAAAv2D,MACA,MAEA,WACAgmD,IAAAsU,WAAA/D,SAAAv2D,MACA,MAEA,WACAgmD,IAAAyJ,WAAA8G,SAAAv2D,MACA,MAEA,WACAgmD,IAAAuU,WAAAhE,SAAAv2D,MACA,MAEA,WACAgmD,IAAAwU,WAAAjE,SAAAv2D,MACA,MAEA,WACAgmD,IAAAyU,WAAAlE,SAAAv2D,MACA,MAEA,iBACAgmD,IAAAgU,iBAAAzD,UAAA,EAAAv2D,MACA,MAEA,iBACAgmD,IAAAyR,iBAAAlB,UAAA,EAAAv2D,MACA,MAIA,SAGAgmD,IAAAiS,UAAA1B,SAAAv2D,MAEA,MAEA,SAGAgmD,IAAA0R,UAAAnB,SAAAv2D,MAEA,MAEA,UAGAgmD,IAAAmU,UAAA5D,SAAAv2D,MAAArM,EAAAqM,MAAApM,EAEA,MAEA,UAGAoyD,IAAA6R,UAAAtB,SAAAv2D,MAAArM,EAAAqM,MAAApM,EAAAoM,MAAArN,EAEA,MAEA,UAGAqzD,IAAAoU,UAAA7D,SAAAv2D,MAAArM,EAAAqM,MAAApM,EAAAoM,MAAArN,EAAAqN,MAAAyM,EAEA,MAEA,SAGAu5C,IAAA6R,UAAAtB,SAAAv2D,MAAAH,EAAAG,MAAAF,EAAAE,MAAAD,EAEA,MAEA,WAGAimD,IAAAqU,WAAA9D,SAAAv2D,MAEA,MAEA,UAGAgmD,IAAAsU,WAAA/D,SAAAv2D,MAEA,MAEA,WAGAgmD,IAAAyJ,WAAA8G,SAAAv2D,MAEA,MAEA,UAGAgmD,IAAAwU,WAAAjE,SAAAv2D,MAEA,MAEA,WAIA3G,SAAA6gE,QAAAQ,SAEAR,QAAAQ,OAAA,GAAAl/C,cAAA,EAAAxb,MAAA5L,QAIA,QAAAD,GAAA,EAAAklB,GAAArZ,MAAA5L,OAAwCilB,GAAAllB,EAAQA,IAEhDgP,OAAA,EAAAhP,EAEA+lE,QAAAQ,OAAAv3D,QAAAnD,MAAA7L,GAAAR,EACAumE,QAAAQ,OAAAv3D,OAAA,GAAAnD,MAAA7L,GAAAP,CAIAoyD,KAAAuU,WAAAhE,SAAA2D,QAAAQ,OAEA,MAEA,WAIArhE,SAAA6gE,QAAAQ,SAEAR,QAAAQ,OAAA,GAAAl/C,cAAA,EAAAxb,MAAA5L,QAIA,QAAAD,GAAA,EAAAklB,GAAArZ,MAAA5L,OAAwCilB,GAAAllB,EAAQA,IAEhDgP,OAAA,EAAAhP,EAEA+lE,QAAAQ,OAAAv3D,QAAAnD,MAAA7L,GAAAR,EACAumE,QAAAQ,OAAAv3D,OAAA,GAAAnD,MAAA7L,GAAAP,EACAsmE,QAAAQ,OAAAv3D,OAAA,GAAAnD,MAAA7L,GAAAxB,CAIAqzD,KAAAwU,WAAAjE,SAAA2D,QAAAQ,OAEA,MAEA,WAIArhE,SAAA6gE,QAAAQ,SAEAR,QAAAQ,OAAA,GAAAl/C,cAAA,EAAAxb,MAAA5L,QAIA,QAAAD,GAAA,EAAAklB,GAAArZ,MAAA5L,OAAwCilB,GAAAllB,EAAQA,IAEhDgP,OAAA,EAAAhP,EAEA+lE,QAAAQ,OAAAv3D,QAAAnD,MAAA7L,GAAAR,EACAumE,QAAAQ,OAAAv3D,OAAA,GAAAnD,MAAA7L,GAAAP,EACAsmE,QAAAQ,OAAAv3D,OAAA,GAAAnD,MAAA7L,GAAAxB,EACAunE,QAAAQ,OAAAv3D,OAAA,GAAAnD,MAAA7L,GAAAsY,CAIAu5C,KAAAyU,WAAAlE,SAAA2D,QAAAQ,OAEA,MAEA,UAGA1U,IAAAgU,iBAAAzD,UAAA,EAAAv2D,MAAAmO,SAEA,MAEA,WAIA9U,SAAA6gE,QAAAQ,SAEAR,QAAAQ,OAAA,GAAAl/C,cAAA,EAAAxb,MAAA5L,QAIA,QAAAD,GAAA,EAAAklB,GAAArZ,MAAA5L,OAAwCilB,GAAAllB,EAAQA,IAEhD6L,MAAA7L,GAAAyoB,qBAAAs9C,QAAAQ,OAAA,EAAAvmE,EAIA6xD,KAAAgU,iBAAAzD,UAAA,EAAA2D,QAAAQ,OAEA,MAEA,UAGA1U,IAAAyR,iBAAAlB,UAAA,EAAAv2D,MAAAmO,SAEA,MAEA,WAIA9U,SAAA6gE,QAAAQ,SAEAR,QAAAQ,OAAA,GAAAl/C,cAAA,GAAAxb,MAAA5L,QAIA,QAAAD,GAAA,EAAAklB,GAAArZ,MAAA5L,OAAwCilB,GAAAllB,EAAQA,IAEhD6L,MAAA7L,GAAAyoB,qBAAAs9C,QAAAQ,OAAA,GAAAvmE,EAIA6xD,KAAAyR,iBAAAlB,UAAA,EAAA2D,QAAAQ,OAEA,MAEA,SASA,GALAjvB,QAAAzrC,MACA+3D,YAAAC,iBAEAhS,IAAAiS,UAAA1B,SAAAwB,cAEAtsB,QAAA,QAEAA,mBAAAtyC,OAAA0iD,aACApQ,QAAAM,gBAAArgB,QAAA,IAAA+f,QAAAM,MAAA33C,OAEAumE,eAAAlvB,QAAAssB,aAEMtsB,kBAAAtyC,OAAA0sC,sBAEN+0B,sBAAAnvB,QAAAssB,aAIA5R,MAAA+R,WAAAzsB,QAAAssB,YAIA,MAEA,UAIA1+D,SAAA6gE,QAAAQ,SAEAR,QAAAQ,UAIA,QAAAvmE,GAAA,EAAAklB,GAAA6gD,QAAAl6D,MAAA5L,OAAgDilB,GAAAllB,EAAQA,IAExD+lE,QAAAQ,OAAAvmE,GAAA6jE,gBAIAhS,KAAAqU,WAAA9D,SAAA2D,QAAAQ,OAEA,QAAAvmE,GAAA,EAAAklB,GAAA6gD,QAAAl6D,MAAA5L,OAAgDilB,GAAAllB,EAAQA,IAExDs3C,QAAAyuB,QAAAl6D,MAAA7L,GACA4jE,YAAAmC,QAAAQ,OAAAvmE,GAEAs3C,SAEA0a,MAAA+R,WAAAzsB,QAAAssB,YAIA,MAEA,SAEA5+D,MAAAK,KAAA,8CAAA3D,SAQA,QAAA26D,eAAA91C,OAAApoB,QAEAooB,OAAA42C,iBAAAh9C,iBAAAhiB,OAAA6yC,mBAAAzqB,OAAAjG,aACAiG,OAAA62C,cAAA10C,gBAAAnC,OAAA42C,kBAIA,QAAAuJ,gBAAA53D,MAAAE,OAAAnQ,MAAAmkC,WAEAl0B,MAAAE,QAAAnQ,MAAA6M,EAAAs3B,UACAl0B,MAAAE,OAAA,GAAAnQ,MAAA8M,EAAAq3B,UACAl0B,MAAAE,OAAA,GAAAnQ,MAAA+M,EAAAo3B,UAIA,QAAAmhC,aAAAvd,QAEA,GAAAt6C,GAAAq6D,GAAA7zB,MAEAj0C,MAAA+1C,SAAAtR,YACAN,UACA7e,SAHAzY,EAAA,EAAAC,EAAA,EAAAC,EAAA,EAKAg7D,QAAAvC,QAEAwC,UAAAD,QAAA1F,YAAA36B,OACAugC,aAAAF,QAAA1F,YAAAl6C,UAEA+/C,YAAAH,QAAApiD,MAAA+hB,OACAygC,eAAAJ,QAAApiD,MAAAwC,UACAigD,eAAAL,QAAApiD,MAAA6gD,UACA6B,YAAAN,QAAApiD,MAAA8gD,OAEA6B,WAAAP,QAAAvF,KAAA96B,OACA6gC,cAAAR,QAAAvF,KAAAr6C,UACAqgD,cAAAT,QAAAvF,KAAAgE,UACAiC,eAAAV,QAAAvF,KAAAkE,WACAgC,cAAAX,QAAAvF,KAAAmE,UACAgC,cAAAZ,QAAAvF,KAAAoE,UACAgC,WAAAb,QAAAvF,KAAAiE,OAEAoC,cAAAd,QAAArF,KAAAmE,UACAiC,iBAAAf,QAAArF,KAAAoE,aACAiC,cAAAhB,QAAArF,KAAAv6C,UAEA6gD,UAAA,EACAC,YAAA,EACAC,WAAA,EACAC,WAAA,EAEAC,SAAA,EACA3f,WAAA,EACA4f,UAAA,EACAC,UAAA,EAEAC,UAAA,EACAC,YAAA,EACAC,WAAA,EACAC,WAAA,CAEA,KAAAj8D,EAAA,EAAAq6D,GAAA/f,OAAA3mD,OAAkC0mE,GAAAr6D,EAAQA,IAI1C,GAFAwmC,MAAA8T,OAAAt6C,IAEAwmC,MAAAK,WAMA,GAJAt0C,MAAAi0C,MAAAj0C,MACAmkC,UAAA8P,MAAA9P,UACA7e,SAAA2uB,MAAA3uB,SAEA2uB,gBAAA9tC,OAAA89B,aAAA,CAEA,IAAAgQ,MAAA9S,QAAA,QAEAt0B,IAAA7M,MAAA6M,EACAC,GAAA9M,MAAA8M,EACAC,GAAA/M,MAAA+M,MAEI,IAAAknC,gBAAA9tC,OAAA+9B,iBAAA,CAIJ,GAFAklC,UAAA,GAEAn1B,MAAA9S,QAAA,QAEAwoC,YAAA7mD,sBAAAmxB,MAAAxyB,aACA27C,SAAAt6C,sBAAAmxB,MAAA1nB,OAAA9K,aACAkoD,WAAA1sE,IAAAmgE,UACAuM,WAAAptD,YAEAgtD,UAAA,EAAAP,UAEAf,aAAAsB,WAAAI,WAAAhpE,EACAsnE,aAAAsB,UAAA,GAAAI,WAAA/oE,EACAqnE,aAAAsB,UAAA,GAAAI,WAAAhqE,EAEAkoE,eAAAG,UAAAuB,UAAAvpE,MAAAmkC,WAEA6kC,WAAA,MAEI,IAAA/0B,gBAAA9tC,OAAAi+B,WAAA,CAIJ,GAFAqlB,YAAA,GAEAxV,MAAA9S,QAAA,QAEAqoC,aAAA,EAAAP,YAEApB,eAAAK,YAAAsB,YAAAxpE,MAAAmkC,WAEAi5B,SAAAt6C,sBAAAmxB,MAAAxyB,aAEA0mD,eAAAqB,aAAApM,SAAAz8D,EACAwnE,eAAAqB,YAAA,GAAApM,SAAAx8D,EACAunE,eAAAqB,YAAA,GAAApM,SAAAz9D,EAGAyoE,eAAAa,aAAA3jD,SACA+iD,YAAAY,aAAA,IAAAh1B,MAAA3uB,SAAA,EAAA2uB,MAAA5P,MAEA4kC,aAAA,MAEI,IAAAh1B,gBAAA9tC,OAAAm+B,UAAA,CAIJ,GAFA+kC,WAAA,GAEAp1B,MAAA9S,QAAA,QAEAsoC,YAAA,EAAAP,WAEArB,eAAAS,WAAAmB,WAAAzpE,MAAAmkC,WAEAwlC,WAAA7mD,sBAAAmxB,MAAAxyB,aAEA8mD,cAAAkB,YAAAE,WAAAhpE,EACA4nE,cAAAkB,WAAA,GAAAE,WAAA/oE,EACA2nE,cAAAkB,WAAA,GAAAE,WAAAhqE,EAEA6oE,cAAAU,YAAA5jD,SAEA83C,SAAAt6C,sBAAAmxB,MAAA1nB,OAAA9K,aACAkoD,WAAA1sE,IAAAmgE,UACAuM,WAAAptD,YAEAksD,eAAAgB,YAAAE,WAAAhpE,EACA8nE,eAAAgB,WAAA,GAAAE,WAAA/oE,EACA6nE,eAAAgB,WAAA,GAAAE,WAAAhqE,EAEA+oE,cAAAQ,YAAA5iE,KAAA+T,IAAA45B,MAAAl5B,OACA4tD,cAAAO,YAAAj1B,MAAA1P,SACAqkC,WAAAM,YAAA,IAAAj1B,MAAA3uB,SAAA,EAAA2uB,MAAA5P,MAEA6kC,YAAA,MAEI,IAAAj1B,gBAAA9tC,OAAAq+B,gBAAA,CAIJ,GAFA8kC,WAAA,GAEAr1B,MAAA9S,QAAA,QAEAwoC,YAAA7mD,sBAAAmxB,MAAAxyB,aACAkoD,WAAAptD,YAEAmtD,WAAA,EAAAP,WAEAJ,cAAAW,YAAAC,WAAAhpE,EACAooE,cAAAW,WAAA,GAAAC,WAAA/oE,EACAmoE,cAAAW,WAAA,GAAAC,WAAAhqE,EAEAo2C,SAAA9B,MAAAj0C,MACAykC,YAAAwP,MAAAxP,YAEAojC,eAAAgB,cAAAa,WAAA3zB,SAAA5R,WACA0jC,eAAAiB,iBAAAY,WAAAjlC,YAAAN,WAEAglC,YAAA,EASA,IAAA17D,EAAA,EAAAu7D,UAAAlB,GAAAxhE,KAAA4I,IAAA84D,UAAA5mE,OAAA,EAAAgoE,UAA2EtB,GAAAr6D,EAAQA,IAAAu6D,UAAAv6D,GAAA,CACnF,KAAAA,EAAA,EAAAw7D,YAAAnB,GAAAxhE,KAAA4I,IAAAg5D,YAAA9mE,OAAA,EAAAqoD,YAAiFqe,GAAAr6D,EAAQA,IAAAy6D,YAAAz6D,GAAA,CACzF,KAAAA,EAAA,EAAAy7D,WAAApB,GAAAxhE,KAAA4I,IAAAo5D,WAAAlnE,OAAA,EAAAioE,WAA8EvB,GAAAr6D,EAAQA,IAAA66D,WAAA76D,GAAA,CACtF,KAAAA,EAAA,EAAA07D,WAAArB,GAAAxhE,KAAA4I,IAAA25D,cAAAznE,OAAA,EAAAkoE,WAAiFxB,GAAAr6D,EAAQA,IAAAo7D,cAAAp7D,GAAA,CACzF,KAAAA,EAAA,EAAA07D,WAAArB,GAAAxhE,KAAA4I,IAAA45D,iBAAA1nE,OAAA,EAAAkoE,WAAoFxB,GAAAr6D,EAAQA,IAAAq7D,iBAAAr7D,GAAA,CAE5Fs6D,SAAA1F,YAAAjhE,OAAA4nE,UACAjB,QAAApiD,MAAAvkB,OAAA6nE,YACAlB,QAAAvF,KAAAphE,OAAA8nE,WACAnB,QAAArF,KAAAthE,OAAA+nE,WAEApB,QAAAxB,QAAA,GAAA15D,EACAk7D,QAAAxB,QAAA,GAAAz5D,EACAi7D,QAAAxB,QAAA,GAAAx5D,EAqDA,QAAA68D,sBAAAC,YAAApxB,QAAAqxB,mBAEA,GAAAC,UAEAD,oBAEA9W,IAAAgX,cAAAH,YAAA7W,IAAAiX,eAAAC,eAAAzxB,QAAAU,QACA6Z,IAAAgX,cAAAH,YAAA7W,IAAAmX,eAAAD,eAAAzxB,QAAAW,QAEA4Z,IAAAgX,cAAAH,YAAA7W,IAAAoX,mBAAAF,eAAAzxB,QAAA1F,YACAigB,IAAAgX,cAAAH,YAAA7W,IAAAqX,mBAAAH,eAAAzxB,QAAAzF,cAIAggB,IAAAgX,cAAAH,YAAA7W,IAAAiX,eAAAjX,IAAAsX,eACAtX,IAAAgX,cAAAH,YAAA7W,IAAAmX,eAAAnX,IAAAsX,gBAEA7xB,QAAAU,QAAAhzC,MAAA6D,qBAAAyuC,QAAAW,QAAAjzC,MAAA6D,sBAEA7D,MAAAK,KAAA,mIAAAiyC,QAAAJ,WAAA,MAIA2a,IAAAgX,cAAAH,YAAA7W,IAAAoX,mBAAAG,eAAA9xB,QAAA1F,YACAigB,IAAAgX,cAAAH,YAAA7W,IAAAqX,mBAAAE,eAAA9xB,QAAAzF,YAEAyF,QAAAzF,YAAA7sC,MAAA+D,eAAAuuC,QAAAzF,YAAA7sC,MAAAkE,cAEAlE,MAAAK,KAAA,qIAAAiyC,QAAAJ,WAAA,OAMA0xB,UAAAhU,WAAA3f,IAAA,kCAEA2zB,WAAAtxB,QAAA51C,OAAAsD,MAAA2E,WAAA2tC,QAAA51C,OAAAsD,MAAA4E,gBAEA0tC,QAAAD,WAAA,GAAAC,QAAA+xB,uBAEAxX,IAAAyX,cAAAZ,YAAAE,UAAAW,2BAAApkE,KAAAyH,IAAA0qC,QAAAD,WAAA2a,MAAAwX,qBACAlyB,QAAA+xB,oBAAA/xB,QAAAD,YAyIA,QAAAoyB,gBAAA7xB,MAAA8xB,SAEA,GAAA9xB,MAAAjF,MAAA+2B,SAAA9xB,MAAAhF,OAAA82B,QAAA,CAKA,GAAAz7C,OAAAy7C,QAAAvkE,KAAA4I,IAAA6pC,MAAAjF,MAAAiF,MAAAhF,QAEAiF,OAAA14C,SAAAoC,cAAA,SACAs2C,QAAAlF,MAAAxtC,KAAA+G,MAAA0rC,MAAAjF,MAAA1kB,OACA4pB,OAAAjF,OAAAztC,KAAA+G,MAAA0rC,MAAAhF,OAAA3kB,MAEA,IAAA8f,SAAA8J,OAAAC,WAAA,KAKA,OAJA/J,SAAAgK,UAAAH,MAAA,IAAAA,MAAAjF,MAAAiF,MAAAhF,OAAA,IAAAiF,OAAAlF,MAAAkF,OAAAjF,QAEA5tC,MAAAK,KAAA,0CAAAuyC,MAAAjF,MAAA,IAAAiF,MAAAhF,OAAA,iBAAAiF,OAAAlF,MAAA,IAAAkF,OAAAjF,OAAAgF,OAEAC,OAIA,MAAAD,OAIA,QAAA4uB,gBAAAlvB,QAAAqyB,MAEA,OAAAryB,QAAAM,MAAA33C,OAEA,GAAAq3C,QAAArT,YAAA,CAEAqT,QAAAM,MAAAgyB,qBAEAtyB,QAAAp5C,iBAAA,UAAA2rE,kBAEAvyB,QAAAM,MAAAgyB,mBAAA/X,IAAAiY,gBAEA9X,MAAAC,KAAAC,OAAA1R,YAIAqR,IAAAkY,cAAAlY,IAAAmY,SAAAL,MACA9X,IAAAoY,YAAApY,IAAAqY,iBAAA5yB,QAAAM,MAAAgyB,oBAEA/X,IAAAsY,YAAAtY,IAAAuY,oBAAA9yB,QAAAiQ,MAOA,QALA8iB,cAAA/yB,kBAAAtyC,OAAAw+C,kBACA8mB,cAAAhzB,QAAAM,MAAA,YAAA5yC,OAAAk+C,YAEAqnB,aAEAvqE,EAAA,EAAoB,EAAAA,EAAOA,KAE3BgyD,MAAAwY,mBAAAH,cAAAC,cAMAC,UAAAvqE,GAAAsqE,cAAAhzB,QAAAM,MAAA53C,GAAA43C,MAAAN,QAAAM,MAAA53C,GAJAuqE,UAAAvqE,GAAAypE,eAAAnyB,QAAAM,MAAA53C,GAAAyqE,gBAUA,IAAA7yB,OAAA2yB,UAAA,GACA5B,kBAAA3jE,MAAAG,KAAA0zB,aAAA+e,MAAAjF,QAAA3tC,MAAAG,KAAA0zB,aAAA+e,MAAAhF,QACA83B,SAAA3B,eAAAzxB,QAAA3F,QACAg5B,OAAA5B,eAAAzxB,QAAA51C,KAEA+mE,sBAAA5W,IAAAqY,iBAAA5yB,QAAAqxB,kBAEA,QAAA3oE,GAAA,EAAoB,EAAAA,EAAOA,IAE3B,GAAAqqE,aAgBA,OAFAO,QAAAvnB,QAAAknB,UAAAvqE,GAAAqjD,QAEAziD,EAAA,EAAAqnC,GAAAob,QAAApjD,OAA2CgoC,GAAArnC,EAAQA,IAEnDgqE,OAAAvnB,QAAAziD,GAEA02C,QAAA3F,SAAA3sC,MAAAkF,YAAAotC,QAAA3F,SAAA3sC,MAAAiF,UAEA4gE,8BAAAptC,QAAAitC,UAAA,GAEA7Y,IAAAiZ,qBAAAjZ,IAAAkZ,4BAAA/qE,EAAAY,EAAA8pE,SAAAE,OAAAj4B,MAAAi4B,OAAAh4B,OAAA,EAAAg4B,OAAA/nC,MAIA79B,MAAAK,KAAA,mGAMAwsD,IAAAmZ,WAAAnZ,IAAAkZ,4BAAA/qE,EAAAY,EAAA8pE,SAAAE,OAAAj4B,MAAAi4B,OAAAh4B,OAAA,EAAA83B,SAAAC,OAAAC,OAAA/nC,UAhCAynC,eAEAzY,IAAAmZ,WAAAnZ,IAAAkZ,4BAAA/qE,EAAA,EAAA0qE,SAAAH,UAAAvqE,GAAA2yC,MAAA43B,UAAAvqE,GAAA4yC,OAAA,EAAA83B,SAAAC,OAAAJ,UAAAvqE,GAAA6iC,MAIAgvB,IAAAmZ,WAAAnZ,IAAAkZ,4BAAA/qE,EAAA,EAAA0qE,kBAAAC,OAAAJ,UAAAvqE,GAoCAs3C,SAAAvF,iBAAA42B,mBAEA9W,IAAAoZ,eAAApZ,IAAAqY,kBAIA5yB,QAAArT,aAAA,EAEAqT,QAAAmQ,UAAAnQ,QAAAmQ,eAIAoK,KAAAkY,cAAAlY,IAAAmY,SAAAL,MACA9X,IAAAoY,YAAApY,IAAAqY,iBAAA5yB,QAAAM,MAAAgyB,oBAQA,QAAAnD,uBAAAnvB,QAAAqyB,MAEA9X,IAAAkY,cAAAlY,IAAAmY,SAAAL,MACA9X,IAAAoY,YAAApY,IAAAqY,iBAAA5yB,QAAA4zB,gBAMA,QAAAC,kBAAAC,YAAA35B,aAAA45B,eAEAxZ,IAAAyZ,gBAAAzZ,IAAA0Z,YAAAH,aACAvZ,IAAA2Z,qBAAA3Z,IAAA0Z,YAAA1Z,IAAA4Z,kBAAAJ,cAAA55B,aAAAy5B,eAAA,GAIA,QAAAQ,mBAAAC,aAAAl6B,cAEAogB,IAAA+Z,iBAAA/Z,IAAAga,aAAAF,cAEAl6B,aAAAq6B,cAAAr6B,aAAAs6B,eAEAla,IAAAma,oBAAAna,IAAAga,aAAAha,IAAAoa,kBAAAx6B,aAAAkB,MAAAlB,aAAAmB,QACAif,IAAAqa,wBAAAra,IAAA0Z,YAAA1Z,IAAAsa,iBAAAta,IAAAga,aAAAF,eAQGl6B,aAAAq6B,aAAAr6B,aAAAs6B,eAEHla,IAAAma,oBAAAna,IAAAga,aAAAha,IAAAua,cAAA36B,aAAAkB,MAAAlB,aAAAmB;AACAif,IAAAqa,wBAAAra,IAAA0Z,YAAA1Z,IAAAwa,yBAAAxa,IAAAga,aAAAF,eAIA9Z,IAAAma,oBAAAna,IAAAga,aAAAha,IAAAya,MAAA76B,aAAAkB,MAAAlB,aAAAmB,QA2MA,QAAA25B,0BAAA96B,cAEAA,uBAAAzsC,OAAA0sC,uBAEAmgB,IAAAoY,YAAApY,IAAAqY,iBAAAz4B,aAAAy5B,gBACArZ,IAAAoZ,eAAApZ,IAAAqY,kBACArY,IAAAoY,YAAApY,IAAAqY,iBAAA,QAIArY,IAAAoY,YAAApY,IAAA2a,WAAA/6B,aAAAy5B,gBACArZ,IAAAoZ,eAAApZ,IAAA2a,YACA3a,IAAAoY,YAAApY,IAAA2a,WAAA,OAQA,QAAApD,gBAAAjhD,GAEA,MAAAA,KAAAnjB,MAAA+D,eAAAof,IAAAnjB,MAAAgE,4BAAAmf,IAAAnjB,MAAAiE,0BAEA4oD,IAAA4a,QAIA5a,IAAA6a,OAMA,QAAA3D,gBAAAhuE,GAEA,GAAA6tE,UAEA,IAAA7tE,IAAAiK,MAAA4D,eAAA,MAAAipD,KAAA8a,MACA,IAAA5xE,IAAAiK,MAAA6D,oBAAA,MAAAgpD,KAAAsX,aACA,IAAApuE,IAAAiK,MAAA8D,uBAAA,MAAA+oD,KAAA+a,eAEA,IAAA7xE,IAAAiK,MAAA+D,cAAA,MAAA8oD,KAAA4a,OACA,IAAA1xE,IAAAiK,MAAAgE,2BAAA,MAAA6oD,KAAAgb,sBACA,IAAA9xE,IAAAiK,MAAAiE,0BAAA,MAAA4oD,KAAAib,qBAEA,IAAA/xE,IAAAiK,MAAAkE,aAAA,MAAA2oD,KAAA6a,MACA,IAAA3xE,IAAAiK,MAAAmE,0BAAA,MAAA0oD,KAAAkb,qBACA,IAAAhyE,IAAAiK,MAAAoE,yBAAA,MAAAyoD,KAAAmb,oBAEA,IAAAjyE,IAAAiK,MAAAqE,iBAAA,MAAAwoD,KAAAob,aACA,IAAAlyE,IAAAiK,MAAA6E,sBAAA,MAAAgoD,KAAAqb,sBACA,IAAAnyE,IAAAiK,MAAA8E,sBAAA,MAAA+nD,KAAAsb,sBACA,IAAApyE,IAAAiK,MAAA+E,qBAAA,MAAA8nD,KAAAub,oBAEA,IAAAryE,IAAAiK,MAAAsE,SAAA,MAAAuoD,KAAAwb,IACA,IAAAtyE,IAAAiK,MAAAuE,UAAA,MAAAsoD,KAAAyb,KACA,IAAAvyE,IAAAiK,MAAAwE,kBAAA,MAAAqoD,KAAA0b,cACA,IAAAxyE,IAAAiK,MAAAyE,QAAA,MAAAooD,KAAA2b,GACA,IAAAzyE,IAAAiK,MAAA0E,gBAAA,MAAAmoD,KAAA4b,YACA,IAAA1yE,IAAAiK,MAAA2E,UAAA,MAAAkoD,KAAA8I,KAIA,IAFAiO,UAAAhU,WAAA3f,IAAA,0BAEA,OAAA2zB,WAEA7tE,IAAAiK,MAAA4E,cAAA,MAAAg/D,WAAA8E,cAIA,IAAA3yE,IAAAiK,MAAAgF,YAAA,MAAA6nD,KAAA8b,KACA,IAAA5yE,IAAAiK,MAAAiF,UAAA,MAAA4nD,KAAA+b,GACA,IAAA7yE,IAAAiK,MAAAkF,WAAA,MAAA2nD,KAAAgc,IACA,IAAA9yE,IAAAiK,MAAAmF,gBAAA,MAAA0nD,KAAAic,SACA,IAAA/yE,IAAAiK,MAAAoF,qBAAA,MAAAynD,KAAAkc,eAEA,IAAAhzE,IAAAiK,MAAAmC,YAAA,MAAA0qD,KAAAmc,QACA,IAAAjzE,IAAAiK,MAAAoC,iBAAA,MAAAyqD,KAAAoc,aACA,IAAAlzE,IAAAiK,MAAAqC,wBAAA,MAAAwqD,KAAAqc,qBAEA,IAAAnzE,IAAAiK,MAAAwC,WAAA,MAAAqqD,KAAAsc,IACA,IAAApzE,IAAAiK,MAAAyC,UAAA,MAAAoqD,KAAAuc,GACA,IAAArzE,IAAAiK,MAAA0C,eAAA,MAAAmqD,KAAAwc,SACA,IAAAtzE,IAAAiK,MAAA2C,uBAAA,MAAAkqD,KAAAyc,mBACA,IAAAvzE,IAAAiK,MAAA4C,eAAA,MAAAiqD,KAAA0c,SACA,IAAAxzE,IAAAiK,MAAA6C,uBAAA,MAAAgqD,KAAA2c,mBACA,IAAAzzE,IAAAiK,MAAA8C,eAAA,MAAA+pD,KAAA4c,SACA,IAAA1zE,IAAAiK,MAAA+C,uBAAA,MAAA8pD,KAAA6c,mBAEA,IAAA3zE,IAAAiK,MAAAgD,eAAA,MAAA6pD,KAAA8c,SACA,IAAA5zE,IAAAiK,MAAAiD,uBAAA,MAAA4pD,KAAA+c,mBACA,IAAA7zE,IAAAiK,MAAAkD,uBAAA,MAAA2pD,KAAAgd,kBAIA,IAFAjG,UAAAhU,WAAA3f,IAAA,iCAEA,OAAA2zB,UAAA,CAEA,GAAA7tE,IAAAiK,MAAAsF,qBAAA,MAAAs+D,WAAAkG,4BACA,IAAA/zE,IAAAiK,MAAAuF,sBAAA,MAAAq+D,WAAAmG,6BACA,IAAAh0E,IAAAiK,MAAAwF,sBAAA,MAAAo+D,WAAAoG,6BACA,IAAAj0E,IAAAiK,MAAAyF,sBAAA,MAAAm+D,WAAAqG,8BAMA,GAFArG,UAAAhU,WAAA3f,IAAA,kCAEA,OAAA2zB,UAAA,CAEA,GAAA7tE,IAAAiK,MAAA0F,wBAAA,MAAAk+D,WAAAsG,+BACA,IAAAn0E,IAAAiK,MAAA2F,wBAAA,MAAAi+D,WAAAuG,+BACA,IAAAp0E,IAAAiK,MAAA4F,yBAAA,MAAAg+D,WAAAwG,gCACA,IAAAr0E,IAAAiK,MAAA6F,yBAAA,MAAA+9D,WAAAyG,iCAMA,GAFAzG,UAAAhU,WAAA3f,IAAA,oBAEA,OAAA2zB,UAAA,CAEA,GAAA7tE,IAAAiK,MAAAsC,YAAA,MAAAshE,WAAA0G,OACA,IAAAv0E,IAAAiK,MAAAuC,YAAA,MAAAqhE,WAAA2G,QAIA,SAMA,QAAAnP,eAAA75C,QAEA,GAAAu6C,uBAAAv6C,eAAAklC,UAAAllC,OAAAklC,SAAApB,iBAEA,WAYA,IAAAmlB,iBAAA3d,IAAAhsC,aAAAgsC,IAAA4d,4BACAC,gBAAAvqE,KAAA+G,OAAAsjE,gBAAA,OAEArP,SAAAuP,eAcA,OAZAxqE,UAAAqhB,yBAAAvhB,OAAAgmD,cAEAmV,SAAAh7D,KAAAyH,IAAA2Z,OAAAklC,SAAA1M,MAAA9+C,OAAAkgE,UAEAA,SAAA55C,OAAAklC,SAAA1M,MAAA9+C,QAEA+E,MAAAK,KAAA,mCAAAkhB,OAAAklC,SAAA1M,MAAA9+C,OAAA,4BAAAkgE,SAAA,mCAMAA,SAMA,QAAAH,gBAAApZ,QAOA,OALA+oB,WAAA,EACAC,YAAA,EACAC,WAAA,EACAC,WAAA,EAEAxjE,EAAA,EAAAq6D,GAAA/f,OAAA3mD,OAAsC0mE,GAAAr6D,EAAQA,IAAA,CAE9C,GAAAwmC,OAAA8T,OAAAt6C,EAEAwmC,OAAAK,YAAAL,MAAA9S,WAAA,IAEA8S,gBAAA9tC,OAAA+9B,kBAAA4sC,YACA78B,gBAAA9tC,OAAAi+B,YAAA2sC,cACA98B,gBAAA9tC,OAAAm+B,WAAA0sC,aACA/8B,gBAAA9tC,OAAAq+B,iBAAAysC,cAIA,OAAU5O,YAAAyO,UAAAnrD,MAAAorD,YAAAvO,KAAAwO,WAAAtO,KAAAuO,YAIV,QAAA5P,iBAAAtZ,QAIA,OAFAqZ,YAAA,EAEA3zD,EAAA,EAAAq6D,GAAA/f,OAAA3mD,OAAsC0mE,GAAAr6D,EAAQA,IAAA,CAE9C,GAAAwmC,OAAA8T,OAAAt6C,EAEAwmC,OAAA7S,aAEA6S,gBAAA9tC,OAAAm+B,WAAA88B,aACAntB,gBAAA9tC,OAAA+9B,mBAAA+P,MAAAiB,eAAAksB,cAIA,MAAAA,YAziMAxkE,QAAAC,IAAA,sBAAAsJ,MAAAC,UAEAorC,yBAEA,IAAA80B,SAAAjgE,SAAAmrC,WAAAwH,OAAAxH,WAAAwH,OAAA14C,SAAAoC,cAAA,UACAwuE,SAAA7qE,SAAAmrC,WAAAtC,QAAAsC,WAAAtC,QAAA,KAEAiiC,WAAA,EAEA3P,WAAAn7D,SAAAmrC,WAAA1R,UAAA0R,WAAA1R,UAAA,QAEAsxC,OAAA/qE,SAAAmrC,WAAA1hC,MAAA0hC,WAAA1hC,OAAA,EACAuhE,OAAAhrE,SAAAmrC,WAAA0Q,MAAA1Q,WAAA0Q,OAAA,EACAovB,SAAAjrE,SAAAmrC,WAAA+/B,QAAA//B,WAAA+/B,SAAA,EACAC,WAAAnrE,SAAAmrC,WAAA3yC,UAAA2yC,WAAA3yC,WAAA,EACA4yE,oBAAAprE,SAAAmrC,WAAAkgC,mBAAAlgC,WAAAkgC,oBAAA,EACAC,uBAAAtrE,SAAAmrC,WAAAogC,sBAAApgC,WAAAogC,uBAAA,EACA5P,wBAAA37D,SAAAmrC,WAAAuwB,uBAAAvwB,WAAAuwB,wBAAA,EAEA8P,YAAA,GAAA1rE,OAAAuG,MAAA,GACAolE,YAAA,EAEA/pB,UAEAiV,iBACAkC,0BAEAd,iBACAD,sBAEArB,WACAhO,aAIAryD,MAAA4D,WAAAimE,QACA7pE,KAAAyyC,QAAA,KAIAzyC,KAAAs1E,WAAA,EACAt1E,KAAAu1E,gBAAA,EACAv1E,KAAAw1E,gBAAA,EACAx1E,KAAAy1E,kBAAA,EAIAz1E,KAAA2C,aAAA,EAIA3C,KAAA0R,YAAA,EACA1R,KAAA01E,YAAA,EACA11E,KAAA21E,aAAA,EAIA31E,KAAAyC,kBAAA,EACAzC,KAAAkmE,cAAAx8D,MAAAkB,aACA5K,KAAA41E,kBAAAlsE,MAAAa,cACAvK,KAAAmmE,gBAAA,EACAnmE,KAAAomE,kBAAA,EAIApmE,KAAAylE,gBAAA,EACAzlE,KAAA0lE,gBAAA,EAIA1lE,KAAAkvE,mBAAA,EAIAlvE,KAAA22D,MAEAC,QAEA+P,SAAA,EACA1/B,WAAA,EACAie,SAAA,GAIAjjD,QAEA4zE,MAAA,EACAtqD,SAAA,EACAqf,MAAA,EACAlhB,OAAA,GAQA,IAiDA6sC,KAjDAG,MAAA12D,KAEAumE,aAIAqB,gBAAA,KACAkO,oBAAA,KACAhO,mBAAA,GACAiO,wBAAA,GACAhO,eAAA,KAEAV,kBAAA,EAEA2O,WAAA,EACAC,WAAA,EACAC,eAAArM,QAAAxyB,MACA8+B,gBAAAtM,QAAAvyB,OACA8+B,cAAA,EACAC,eAAA,EAIA7V,SAAA,GAAA92D,OAAAgvB,QAIAkoC,kBAAA,GAAAl3D,OAAAkb,QAEA+7C,SAAA,GAAAj3D,OAAAgW,QAIAwtD,WAAA,GAAAxjE,OAAAgW,QAEAkpD,mBAAA,EAEAG,SAEAe,SAAA,OACAlE,aAAgBjhE,OAAA,EAAAsmC,UAAAvf,cAChBxC,OAAUvkB,OAAA,EAAAsmC,UAAAvf,aAAAq+C,aAAAC,WACVjE,MAASphE,OAAA,EAAAsmC,UAAAvf,aAAAq+C,aAAAE,cAAAC,aAAAC,aAAAH,WACT/D,MAASthE,OAAA,EAAAylE,aAAAC,gBAAA3+C,cAQT,KAEA,GAAAD,aACApY,MAAAshE,OACAlvB,MAAAmvB,OACAE,QAAAD,SACAzyE,UAAA2yE,WACAE,mBAAAD,oBACAG,sBAAAD,uBAKA,IAFA3e,IAAAke,UAAA5K,QAAArtB,WAAA,QAAA/wB,aAAAo+C,QAAArtB,WAAA,qBAAA/wB,YAEA,OAAA8qC,IAEA,aAAAsT,QAAArtB,WAAA,SAEA,8DAIA,+BAMAqtB,SAAAjnE,iBAAA,4BAAA0/B,OAEAA,MAAAg0C,iBAEAC,eACAC,oBAEAjW,mBAEG,GAED,MAAAv2D,OAEFN,MAAAM,MAAA,wBAAAA,OAIA,GAAAk1D,OAAA,GAAAx1D,OAAA+sE,WAAAlgB,IAAAkX,eAEA7jE,UAAA2sD,IAAAmgB,2BAEAngB,IAAAmgB,yBAAA,WAEA,OACAC,SAAA,EACAC,SAAA,EACAvzC,UAAA,IAOA,IAAAi2B,YAAA,GAAA5vD,OAAAmtE,gBAAAtgB,IAEA+C,YAAA3f,IAAA,qBACA2f,WAAA3f,IAAA,4BACA2f,WAAA3f,IAAA,0BACA2f,WAAA3f,IAAA,iCACA2f,WAAA3f,IAAA,4BAEA4rB,yBAEAjM,WAAA3f,IAAA,iBAMA,IAAAm9B,cAAA,SAAA1mE,EAAAC,EAAAC,EAAA8P,GAEA40D,uBAAA,IAEA5kE,GAAAgQ,EAAU/P,GAAA+P,EAAQ9P,GAAA8P,GAIlBm2C,IAAAwgB,WAAA3mE,EAAAC,EAAAC,EAAA8P,IAIAo2D,kBAAA,WAEAjgB,IAAAwgB,WAAA,SACAxgB,IAAAygB,WAAA,GACAzgB,IAAA0gB,aAAA,GAEA1gB,IAAA2gB,OAAA3gB,IAAA4gB,YACA5gB,IAAA6gB,UAAA7gB,IAAA8gB,QAEA9gB,IAAA+gB,UAAA/gB,IAAAghB,KACAhhB,IAAAihB,SAAAjhB,IAAAkhB,MACAlhB,IAAA2gB,OAAA3gB,IAAAmhB,WAEAnhB,IAAA2gB,OAAA3gB,IAAAohB,OACAphB,IAAA7N,cAAA6N,IAAAmc,UACAnc,IAAAqhB,UAAArhB,IAAA0c,UAAA1c,IAAA2c,qBAEA3c,IAAAshB,SAAA7B,WAAAC,WAAAC,eAAAC,iBAEAW,aAAA1B,YAAAhlE,EAAAglE,YAAA/kE,EAAA+kE,YAAA9kE,EAAA+kE,cAIAkB,aAAA,WAEA3O,gBAAA,KACAG,eAAA,KAEAgO,wBAAA,GACAjO,mBAAA,GAEAc,mBAAA,EAEA1J,MAAA4Y,QAIAtB,qBAEAx2E,KAAAyyC,QAAA8jB,IACAv2D,KAAAk/D,WAIA,IAAAsL,cAAAjU,IAAAhsC,aAAAgsC,IAAAwhB,yBACAC,mBAAAzhB,IAAAhsC,aAAAgsC,IAAA0hB,gCACAC,gBAAA3hB,IAAAhsC,aAAAgsC,IAAA4hB,kBACAhJ,gBAAA5Y,IAAAhsC,aAAAgsC,IAAA6hB,2BAEAnT,wBAAA+S,mBAAA,EACAxS,sBAAAP,yBAAA3L,WAAA3f,IAAA,qBAIA0+B,iCAAA9hB,IAAAmgB,yBAAAngB,IAAA+hB,cAAA/hB,IAAAgiB,YACAC,mCAAAjiB,IAAAmgB,yBAAAngB,IAAA+hB,cAAA/hB,IAAAkiB,cAEAC,mCAAAniB,IAAAmgB,yBAAAngB,IAAAoiB,gBAAApiB,IAAAgiB,YACAK,qCAAAriB,IAAAmgB,yBAAAngB,IAAAoiB,gBAAApiB,IAAAkiB,cAEAlJ,4BAAA,WAEA,GAAA/7D,MAEA,mBAEA,GAAA5J,SAAA4J,MAEA,MAAAA,MAMA,IAFAA,SAEA8lD,WAAA3f,IAAA,mCAAA2f,WAAA3f,IAAA,iCAIA,OAFAk/B,SAAAtiB,IAAAhsC,aAAAgsC,IAAAuiB,4BAEAp0E,EAAA,EAAoBA,EAAAm0E,QAAAl0E,OAAoBD,IAExC8O,MAAAlP,KAAAu0E,QAAAn0E,GAMA,OAAA8O,WAQAulE,eAAAV,iCAAAh1C,UAAA,GAAAq1C,mCAAAr1C,UAAA,EACA21C,iBAAAR,mCAAAn1C,UAAA,GAAAu1C,qCAAAv1C,UAAA,CAEA,WAAA0hC,YAAAgU,iBAEAC,kBAEAjU,WAAA,UACAr7D,MAAAK,KAAA,8DAIAg7D,WAAA,OACAr7D,MAAAK,KAAA,uEAMA,YAAAg7D,YAAAiU,mBAEAjU,WAAA,OACAr7D,MAAAK,KAAA,2DAMA,IAAAkvE,iBAAA,GAAAvvE,OAAAwvE,gBAAAl5E,KAAAsrD,OAAAiV,cAAAkC,wBAEA0W,aAAA,GAAAzvE,OAAA0vE,aAAAp5E,KAAAqgE,SACAgZ,gBAAA,GAAA3vE,OAAA4vE,gBAAAt5E,KAAAqyD,WAIAryD,MAAAw8C,WAAA,WAEA,MAAA+Z,MAIAv2D,KAAAu5E,iBAAA,WAEAjgB,WAAA3f,IAAA,sBAAA6/B,eAIAx5E,KAAAglE,uBAAA,WAEA,MAAAC,0BAIAjlE,KAAAy5E,sBAAA,WAEA,MAAAngB,YAAA3f,IAAA,sBAIA35C,KAAA05E,0BAAA,WAEA,MAAApgB,YAAA3f,IAAA,2BAIA35C,KAAA25E,4BAAA,WAEA,MAAArgB,YAAA3f,IAAA,6BAIA35C,KAAA45E,8BAAA,WAEA,MAAAtgB,YAAA3f,IAAA,kCAIA35C,KAAA65E,+BAAA,WAEA,MAAAvgB,YAAA3f,IAAA,mCAIA35C,KAAA85E,oBAAA,WAEA,MAAAxgB,YAAA3f,IAAA,qBAIA35C,KAAAkuE,iBAAA,WAEA,GAAA39D,MAEA,mBAEA,GAAA3G,SAAA2G,MAEA,MAAAA,MAIA,IAAA+8D,WAAAhU,WAAA3f,IAAA,iCAIA,OAFAppC,OAAA,OAAA+8D,UAAA/W,IAAAhsC,aAAA+iD,UAAAyM,gCAAA,MAQA/5E,KAAAg6E,aAAA,WAEA,MAAAjV,aAIA/kE,KAAAi6E,cAAA,WAEA,MAAAvF,aAIA10E,KAAAk6E,cAAA,SAAA3pE,OAEAmkE,WAAAnkE,OAIAvQ,KAAAqC,QAAA,SAAAg1C,MAAAC,OAAA6iC,aAEAtQ,QAAAxyB,YAAAq9B,WACA7K,QAAAvyB,cAAAo9B,WAEAyF,eAAA,IAEAtQ,QAAAz4D,MAAAimC,YAAA,KACAwyB,QAAAz4D,MAAAkmC,cAAA,MAIAt3C,KAAAo6E,YAAA,IAAA/iC,MAAAC,SAIAt3C,KAAAo6E,YAAA,SAAAl2E,EAAAC,EAAAkzC,MAAAC,QAEA0+B,WAAA9xE,EAAAwwE,WACAuB,WAAA9xE,EAAAuwE,WAEAwB,eAAA7+B,MAAAq9B,WACAyB,gBAAA7+B,OAAAo9B,WAEAne,IAAAshB,SAAA7B,WAAAC,WAAAC,eAAAC,kBAIAn2E,KAAAq6E,WAAA,SAAAn2E,EAAAC,EAAAkzC,MAAAC,QAEAif,IAAA+jB,QACAp2E,EAAAwwE,WACAvwE,EAAAuwE,WACAr9B,MAAAq9B,WACAp9B,OAAAo9B,aAKA10E,KAAAu6E,kBAAA,SAAArD,QAEAA,OAAA3gB,IAAA2gB,OAAA3gB,IAAAikB,cAAAjkB,IAAAkkB,QAAAlkB,IAAAikB,eAMAx6E,KAAA06E,cAAA,WAEA,MAAAtF,cAIAp1E,KAAAgQ,cAAA,SAAAzM,MAAA8P,OAEA+hE,YAAAjlE,IAAA5M,OAEA8xE,YAAAzrE,SAAAyJ,YAAA,EAEAyjE,aAAA1B,YAAAhlE,EAAAglE,YAAA/kE,EAAA+kE,YAAA9kE,EAAA+kE,cAIAr1E,KAAA26E,cAAA,WAEA,MAAAtF,cAIAr1E,KAAA46E,cAAA,SAAAvnE,OAEAgiE,YAAAhiE,MAEAyjE,aAAA1B,YAAAhlE,EAAAglE,YAAA/kE,EAAA+kE,YAAA9kE,EAAA+kE,cAIAr1E,KAAA2B,MAAA,SAAA4B,MAAAkiD,MAAAqvB,SAEA,GAAA+F,MAAA,GAEAjxE,SAAArG,gBAAAs3E,MAAAtkB,IAAAukB,mBACAlxE,SAAA67C,gBAAAo1B,MAAAtkB,IAAAwkB,mBACAnxE,SAAAkrE,oBAAA+F,MAAAtkB,IAAAykB,oBAEAzkB,IAAA50D,MAAAk5E,OAIA76E,KAAA+2E,WAAA,WAEAxgB,IAAA50D,MAAA40D,IAAAukB,mBAIA96E,KAAAg3E,WAAA,WAEAzgB,IAAA50D,MAAA40D,IAAAwkB,mBAIA/6E,KAAAi3E,aAAA,WAEA1gB,IAAA50D,MAAA40D,IAAAykB,qBAIAh7E,KAAAi7E,YAAA,SAAA9kC,aAAA5yC,MAAAkiD,MAAAqvB,SAEA90E,KAAAk7E,gBAAA/kC,cACAn2C,KAAA2B,MAAA4B,MAAAkiD,MAAAqvB,UAMA90E,KAAAu2E,yBAwEA,IAAAxU,iBAAA,SAAAz/B,OAEA,GAAArX,QAAAqX,MAAAxS,MAEA7E,QAAAG,SAAA,SAAA8a,OAEAA,MAAApE,oBAAA,SAAAigC,iBAEAiC,aAAA99B,UAMA87B,kBAAA,SAAA1/B,OAEA,GAAAn/B,UAAAm/B,MAAAxS,MAEA3sB,UAAA2+B,oBAAA,UAAAkgC,mBAEAmZ,mBAAAh4E,WAIAorE,iBAAA,SAAAjsC,OAEA,GAAA0Z,SAAA1Z,MAAAxS,MAEAksB,SAAAla,oBAAA,UAAAysC,kBAEA6M,kBAAAp/B,SAEA0a,MAAAC,KAAAC,OAAA1R,YAKAm2B,sBAAA,SAAA/4C,OAEA,GAAA6T,cAAA7T,MAAAxS,MAEAqmB,cAAArU,oBAAA,UAAAu5C,uBAEAC,uBAAAnlC,cAEAugB,MAAAC,KAAAC,OAAA1R,YAIAkf,kBAAA,SAAA9hC,OAEA,GAAAj/B,UAAAi/B,MAAAxS,MAEAzsB,UAAAy+B,oBAAA,UAAAsiC,mBAEAkD,mBAAAjkE,WAMAk4E,cAAA,SAAAp4E,UAmBA,OAjBAq4E,UACA,sBACA,sBACA,uBACA,qBACA,kBACA,mBAEA,2BACA,2BAEA,oBACA,oBAEA,6BAGA92E,EAAA,EAAAsM,EAAAwqE,QAAA72E,OAAsCqM,EAAAtM,EAAOA,IAAA,CAE7C,GAAAs/B,MAAAw3C,QAAA92E,EAEAkF,UAAAzG,SAAA6gC,QAEAuyB,IAAAklB,aAAAt4E,SAAA6gC,aAEA7gC,UAAA6gC,OAQA,GAAAp6B,SAAAzG,SAAA40D,4BAAA,CAEA,OAAA/zB,QAAA7gC,UAAA40D,4BAEAxB,IAAAklB,aAAAt4E,SAAA40D,4BAAA/zB,MAAA6jB,cAIA1kD,UAAA40D,4BAIArB,MAAAC,KAAAC,OAAA3vB,cAIAk0C,mBAAA,SAAAh4E,UAIA,SAFAA,UAAAy+D,YAEAz+D,mBAAAuG,OAAA8hB,eAAA,CAEA,OAAAwY,QAAA7gC,UAAAsoB,WAAA,CAEA,GAAAjI,WAAArgB,SAAAsoB,WAAAuY,KAEAp6B,UAAA4Z,UAAAqkC,SAEA0O,IAAAklB,aAAAj4D,UAAAqkC,cAEArkC,WAAAqkC,QAMA6O,MAAAC,KAAAC,OAAA3vB,iBAEG,CAEH,GAAAm7B,oBAAAC,eAAAl/D,SAAA/D,GAEA,IAAAwK,SAAAw4D,mBAAA,CAEA,OAAA19D,GAAA,EAAAsM,EAAAoxD,mBAAAz9D,OAAmDqM,EAAAtM,EAAOA,IAAA,CAE1D,GAAAsyD,eAAAoL,mBAAA19D,EAEA,IAAAkF,SAAAotD,cAAAS,gBAAA,CAEA,OAAAl4D,GAAA,EAAA2uD,GAAA8I,cAAAS,gBAA0DvJ,GAAA3uD,EAAQA,IAElEg3D,IAAAklB,aAAAzkB,cAAAU,2BAAAn4D,UAIAy3D,eAAAU,2BAIA,GAAA9tD,SAAAotD,cAAAW,gBAAA,CAEA,OAAAp4D,GAAA,EAAA2uD,GAAA8I,cAAAW,gBAA0DzJ,GAAA3uD,EAAQA,IAElEg3D,IAAAklB,aAAAzkB,cAAAY,2BAAAr4D,UAIAy3D,eAAAY,2BAIA2jB,cAAAvkB,qBAIAqL,gBAAAl/D,SAAA/D,QAIAm8E,eAAAp4E,UAQA4yE,wBAAA,IAIAqF,kBAAA,SAAAp/B,SAEA,GAAAA,QAAAM,OAAAN,QAAAM,MAAAgyB,mBAIA/X,IAAAmlB,cAAA1/B,QAAAM,MAAAgyB,0BAEAtyB,SAAAM,MAAAgyB,uBAEG,CAIH,GAAA1kE,SAAAoyC,QAAA4lB,YAAA,MAEArL,KAAAmlB,cAAA1/B,QAAA4zB,sBAEA5zB,SAAA4zB,qBACA5zB,SAAA4lB,cAMA0Z,uBAAA,SAAAnlC,cAEA,GAAAA,cAAAvsC,SAAAusC,aAAAy5B,eAAA,CAMA,GAJArZ,IAAAmlB,cAAAvlC,aAAAy5B,sBAEAz5B,cAAAy5B,eAEAz5B,uBAAAzsC,OAAA0sC,sBAEA,OAAA1xC,GAAA,EAAmB,EAAAA,EAAOA,IAE1B6xD,IAAAolB,kBAAAxlC,aAAAylC,mBAAAl3E,IACA6xD,IAAAslB,mBAAA1lC,aAAA2lC,oBAAAp3E,QAMA6xD,KAAAolB,kBAAAxlC,aAAAylC,oBACArlB,IAAAslB,mBAAA1lC,aAAA2lC,2BAIA3lC,cAAAylC,yBACAzlC,cAAA2lC,sBAIAxU,mBAAA,SAAAjkE,UAEA,GAAAs7D,SAAAt7D,SAAAs7D,eAEA,IAAA/0D,SAAA+0D,QAAA,CAEAt7D,SAAAs7D,QAAA/0D,MAMA,IAAAlF,GAAAklB,GAAA48C,YACAuV,eAAA,CAEA,KAAAr3E,EAAA,EAAAklB,GAAA28C,UAAA5hE,OAAqCilB,GAAAllB,EAAQA,IAI7C,GAFA8hE,YAAAD,UAAA7hE,GAEA8hE,YAAA7H,kBAAA,CAEA6H,YAAAC,YAEA,IAAAD,YAAAC,YAEAsV,eAAA,EAIA,OAMA,GAAAA,iBAAA,GAIA,GAAAC,eAEA,KAAAt3E,EAAA,EAAAklB,GAAA28C,UAAA5hE,OAAsCilB,GAAAllB,EAAQA,IAE9C8hE,YAAAD,UAAA7hE,GAEA8hE,YAAA7H,mBAEAqd,YAAA13E,KAAAkiE,YAMAD,WAAAyV,YAEAzlB,IAAAwlB,cAAApd,SAEAjI,MAAAC,KAAAC,OAAA+P,aAu0CA3mE,MAAAi8E,sBAAA,SAAAhxD,OAAA0zC,QAAAt7D,UAoBA,GAlBA67D,MAAAgd,iBAEAjxD,OAAAkxD,eAAAlxD,OAAAqrC,sBAAArrC,OAAAqrC,oBAAAC,IAAAC,gBACAvrC,OAAAmxD,aAAAnxD,OAAAgsC,sBAAAhsC,OAAAgsC,oBAAAV,IAAAC,gBACAvrC,OAAAoxD,SAAApxD,OAAAqxD,kBAAArxD,OAAAqxD,gBAAA/lB,IAAAC,gBACAvrC,OAAAsxD,YAAAtxD,OAAAwrC,qBAAAxrC,OAAAwrC,mBAAAF,IAAAC,gBAEAvrC,OAAAkxD,eAEA5lB,IAAAsE,WAAAtE,IAAAuE,aAAA7vC,OAAAqrC,qBACAC,IAAAwE,WAAAxE,IAAAuE,aAAA7vC,OAAAuxD,cAAAjmB,IAAAiN,cAEAtE,MAAAC,gBAAAR,QAAAlzC,WAAAxoB,UAEAszD,IAAA6I,oBAAAT,QAAAlzC,WAAAxoB,SAAA,EAAAszD,IAAA8I,OAAA,QAIAp0C,OAAAmxD,WAAA,CAIA,GAFA7lB,IAAAsE,WAAAtE,IAAAuE,aAAA7vC,OAAAgsC,qBAEA5zD,mBAAAqG,OAAAigD,oBAAA,GACAtmD,SAAAk6C,UAAA7zC,MAAAwB,YAAA,CAEA,GAAAuxE,IAAAC,GAAAC,GACAC,IAAAC,IAAAC,IAAAC,IAAAC,IAAAC,IAAAC,IAAAC,IAAAC,IACAhgB,YACA14D,EAAAklB,GAAA,EAAAqB,OAAA4e,KAEA,KAAAnlC,EAAA,EAAgBklB,GAAAllB,EAAQA,GAAA,EAExB04D,YAAAnyC,OAAAmyC,YAEAwf,IAAAxf,YAAA14D,GACAq4E,IAAA3f,YAAA14D,EAAA,GACAw4E,IAAA9f,YAAA14D,EAAA,GAEAm4E,IAAAzf,YAAA14D,EAAA,GACAs4E,IAAA5f,YAAA14D,EAAA,GACAy4E,IAAA/f,YAAA14D,EAAA,GAEAo4E,IAAA1f,YAAA14D,EAAA,GACAu4E,IAAA7f,YAAA14D,EAAA,GACA04E,IAAAhgB,YAAA14D,EAAA,GAEA+3E,IAAAG,IAAAC,IAAAC,KAAA,EACAJ,IAAAK,IAAAC,IAAAC,KAAA,EACAN,IAAAO,IAAAC,IAAAC,KAAA,EAEAhgB,YAAA14D,GAAA+3E,GACArf,YAAA14D,EAAA,GAAAg4E,GACAtf,YAAA14D,EAAA,GAAAi4E,GAEAvf,YAAA14D,EAAA,GAAA+3E,GACArf,YAAA14D,EAAA,GAAAg4E,GACAtf,YAAA14D,EAAA,GAAAi4E,GAEAvf,YAAA14D,EAAA,GAAA+3E,GACArf,YAAA14D,EAAA,GAAAg4E,GACAtf,YAAA14D,EAAA,GAAAi4E,GAMApmB,IAAAwE,WAAAxE,IAAAuE,aAAA7vC,OAAAmyC,YAAA7G,IAAAiN,cAEAtE,MAAAC,gBAAAR,QAAAlzC,WAAA3F,QAEAywC,IAAA6I,oBAAAT,QAAAlzC,WAAA3F,OAAA,EAAAywC,IAAA8I,OAAA,OAIAp0C,OAAAoxD,QAAAh5E,SAAA85C,MAEAoZ,IAAAsE,WAAAtE,IAAAuE,aAAA7vC,OAAAqxD,iBACA/lB,IAAAwE,WAAAxE,IAAAuE,aAAA7vC,OAAAiyC,QAAA3G,IAAAiN,cAEAtE,MAAAC,gBAAAR,QAAAlzC,WAAAoiB,IAEA0oB,IAAA6I,oBAAAT,QAAAlzC,WAAAoiB,GAAA,EAAA0oB,IAAA8I,OAAA,QAIAp0C,OAAAsxD,WAAAl5E,SAAAilC,eAAA5+B,MAAA0B,WAEAmrD,IAAAsE,WAAAtE,IAAAuE,aAAA7vC,OAAAwrC,oBACAF,IAAAwE,WAAAxE,IAAAuE,aAAA7vC,OAAAwvC,WAAAlE,IAAAiN,cAEAtE,MAAAC,gBAAAR,QAAAlzC,WAAAloB,OAEAgzD,IAAA6I,oBAAAT,QAAAlzC,WAAAloB,MAAA,EAAAgzD,IAAA8I,OAAA,QAIAH,MAAAM,0BAEAjJ,IAAA8mB,WAAA9mB,IAAA+mB,UAAA,EAAAryD,OAAA4e,OAEA5e,OAAA4e,MAAA,GAoDA7pC,KAAAkhE,mBAAA,SAAAr+D,OAAAyoD,OAAAlB,IAAA/mD,SAAAF,SAAA8nB,QAEA,GAAA5nB,SAAAqhC,WAAA,GAEA4+B,aAAAr4C,OAEA,IAAA0zC,SAAAyI,WAAAvkE,OAAAyoD,OAAAlB,IAAA/mD,SAAA4nB,QAEAsyD,eAAA,EACAC,aAAAn6E,SAAAG,UAAA,IACAi6E,gBAAA,UAAAt6E,SAAA/D,GAAA,IAAAu/D,QAAAv/D,GAAA,IAAAo+E,YAiBA,IAfAC,kBAAA1H,0BAEAA,wBAAA0H,gBACAF,eAAA,GAIAA,eAEAre,MAAAgd,iBAMAjxD,iBAAAvhB,OAAAhG,KAAA,CAEA,GAAAukC,MAAA5kC,SAAAG,aAAA,EAAA+yD,IAAAmnB,MAAAnnB,IAAA+mB,UAEA51E,MAAAvE,SAAAsoB,WAAA/jB,KAEA,IAAAA,MAAA,CAIA,GAAAtB,MAAA2jB,IAEAriB,OAAA8L,gBAAA+lD,cAAAD,WAAA3f,IAAA,2BAEAvzC,KAAAmwD,IAAA4b,aACApoD,KAAA,IAIA3jB,KAAAmwD,IAAA0b,eACAloD,KAAA,EAIA,IAAAmgB,SAAA/mC,SAAA+mC,OAEA,QAAAA,QAAAvlC,OAEA44E,gBAEA7e,sBAAAr7D,SAAAs7D,QAAAx7D,SAAA,GACAozD,IAAAsE,WAAAtE,IAAAiI,qBAAA92D,MAAAmgD,SAIA0O,IAAAonB,aAAA11C,KAAAvgC,MAAA8L,MAAA7O,OAAAyB,KAAA,GAEAswD,MAAAC,KAAA10D,OAAA4zE,QACAnf,MAAAC,KAAA10D,OAAAspB,UAAA7jB,MAAA8L,MAAA7O,OACA+xD,MAAAC,KAAA10D,OAAA2oC,OAAAljC,MAAA8L,MAAA7O,OAAA,MAEK,CAML44E,eAAA,CAEA,QAAA74E,GAAA,EAAAklB,GAAAsgB,QAAAvlC,OAA0CilB,GAAAllB,EAAQA,IAAA,CAElD,GAAAk6D,YAAA10B,QAAAxlC,GAAAgD,KAEA61E,iBAEA7e,sBAAAr7D,SAAAs7D,QAAAx7D,SAAAy7D,YACArI,IAAAsE,WAAAtE,IAAAiI,qBAAA92D,MAAAmgD,SAMA0O,IAAAonB,aAAA11C,KAAAiC,QAAAxlC,GAAAmlC,MAAAzjC,KAAA8jC,QAAAxlC,GAAA8jB,MAAAuB,MAEA2sC,MAAAC,KAAA10D,OAAA4zE,QACAnf,MAAAC,KAAA10D,OAAAspB,UAAA2e,QAAAxlC,GAAAmlC,MACA6sB,MAAAC,KAAA10D,OAAA2oC,OAAAV,QAAAxlC,GAAAmlC,MAAA,QAMI,CAIJ0zC,eAEA7e,sBAAAr7D,SAAAs7D,QAAAx7D,SAAA,EAIA,IAAAF,UAAAE,SAAAsoB,WAAA,QAIA8qC,KAAA8mB,WAAAp1C,KAAA,EAAAhlC,SAAAuQ,MAAA7O,OAAA1B,SAAAwgB,UAEAizC,MAAAC,KAAA10D,OAAA4zE,QACAnf,MAAAC,KAAA10D,OAAAspB,UAAAtoB,SAAAuQ,MAAA7O,OAAA1B,SAAAwgB,SACAizC,MAAAC,KAAA10D,OAAA2oC,OAAA3nC,SAAAuQ,MAAA7O,QAAA,EAAA1B,SAAAwgB,eAIG,IAAAwH,iBAAAvhB,OAAAg5B,WAAA,CAIH,GAAAuF,MAAAsuB,IAAAqnB,OAEAl2E,MAAAvE,SAAAsoB,WAAA/jB,KAEA,IAAAA,MAAA,CAIA,GAAAtB,MAAA2jB,IAEAriB,OAAA8L,gBAAA+lD,cAAAD,WAAA3f,IAAA,2BAEAvzC,KAAAmwD,IAAA4b,aACApoD,KAAA,IAIA3jB,KAAAmwD,IAAA0b,eACAloD,KAAA,EAIA,IAAAmgB,SAAA/mC,SAAA+mC,OAEA,QAAAA,QAAAvlC,OAEA44E,gBAEA7e,sBAAAr7D,SAAAs7D,QAAAx7D,SAAA,GACAozD,IAAAsE,WAAAtE,IAAAiI,qBAAA92D,MAAAmgD,SAIA0O,IAAAonB,aAAA11C,KAAAvgC,MAAA8L,MAAA7O,OAAAyB,KAAA,GAEAswD,MAAAC,KAAA10D,OAAA4zE,QACAnf,MAAAC,KAAA10D,OAAAynB,QAAAhiB,MAAA8L,MAAA7O,WAEK,CAMLulC,QAAAvlC,OAAA,IAAA44E,eAAA,EAEA,QAAA74E,GAAA,EAAAklB,GAAAsgB,QAAAvlC,OAA0CilB,GAAAllB,EAAQA,IAAA,CAElD,GAAAk6D,YAAA10B,QAAAxlC,GAAAgD,KAEA61E,iBAEA7e,sBAAAr7D,SAAAs7D,QAAAx7D,SAAAy7D,YACArI,IAAAsE,WAAAtE,IAAAiI,qBAAA92D,MAAAmgD,SAMA0O,IAAAonB,aAAA11C,KAAAiC,QAAAxlC,GAAAmlC,MAAAzjC,KAAA8jC,QAAAxlC,GAAA8jB,MAAAuB,MAEA2sC,MAAAC,KAAA10D,OAAA4zE,QACAnf,MAAAC,KAAA10D,OAAAynB,QAAAwgB,QAAAxlC,GAAAmlC,YAMI,CAIJ0zC,eAEA7e,sBAAAr7D,SAAAs7D,QAAAx7D,SAAA,EAIA,IAAAF,UAAAE,SAAAsoB,WAAAxoB,SACAinC,QAAA/mC,SAAA+mC,OAEA,QAAAA,QAAAvlC,OAEA4xD,IAAA8mB,WAAAp1C,KAAA,EAAAhlC,SAAAuQ,MAAA7O,OAAA,GAEA+xD,MAAAC,KAAA10D,OAAA4zE,QACAnf,MAAAC,KAAA10D,OAAAynB,QAAAzmB,SAAAuQ,MAAA7O,OAAA,MAIA,QAAAD,GAAA,EAAAklB,GAAAsgB,QAAAvlC,OAA0CilB,GAAAllB,EAAQA,IAElD6xD,IAAA8mB,WAAAp1C,KAAAiC,QAAAxlC,GAAAgD,MAAAwiC,QAAAxlC,GAAAmlC,OAEA6sB,MAAAC,KAAA10D,OAAA4zE,QACAnf,MAAAC,KAAA10D,OAAAynB,QAAAwgB,QAAAxlC,GAAAmlC,WAQG,IAAA5e,iBAAAvhB,OAAAm5B,KAAA,CAEH,GAAAoF,MAAAhd,OAAAgd,OAAAv+B,MAAAwjD,UAAAqJ,IAAAsnB,WAAAtnB,IAAAmnB,KAEAxe,OAAA4e,aAAAz6E,SAAA4mD,UAAAyqB,WAEA,IAAAhtE,OAAAvE,SAAAsoB,WAAA/jB,KAEA,IAAAA,MAAA,CAIA,GAAAtB,MAAA2jB,IAEAriB,OAAA8L,gBAAA+lD,cAEAnzD,KAAAmwD,IAAA4b,aACApoD,KAAA,IAIA3jB,KAAAmwD,IAAA0b,eACAloD,KAAA,EAIA,IAAAmgB,SAAA/mC,SAAA+mC,OAEA,QAAAA,QAAAvlC,OAEA44E,gBAEA7e,sBAAAr7D,SAAAs7D,QAAAx7D,SAAA,GACAozD,IAAAsE,WAAAtE,IAAAiI,qBAAA92D,MAAAmgD,SAIA0O,IAAAonB,aAAA11C,KAAAvgC,MAAA8L,MAAA7O,OAAAyB,KAAA,GAEAswD,MAAAC,KAAA10D,OAAA4zE,QACAnf,MAAAC,KAAA10D,OAAAspB,UAAA7jB,MAAA8L,MAAA7O,WAEK,CAMLulC,QAAAvlC,OAAA,IAAA44E,eAAA,EAEA,QAAA74E,GAAA,EAAAklB,GAAAsgB,QAAAvlC,OAA0CilB,GAAAllB,EAAQA,IAAA,CAElD,GAAAk6D,YAAA10B,QAAAxlC,GAAAgD,KAEA61E,iBAEA7e,sBAAAr7D,SAAAs7D,QAAAx7D,SAAAy7D,YACArI,IAAAsE,WAAAtE,IAAAiI,qBAAA92D,MAAAmgD,SAMA0O,IAAAonB,aAAA11C,KAAAiC,QAAAxlC,GAAAmlC,MAAAzjC,KAAA8jC,QAAAxlC,GAAA8jB,MAAAuB,MAEA2sC,MAAAC,KAAA10D,OAAA4zE,QACAnf,MAAAC,KAAA10D,OAAAspB,UAAA2e,QAAAxlC,GAAAmlC,YAMI,CAIJ0zC,eAEA7e,sBAAAr7D,SAAAs7D,QAAAx7D,SAAA,EAIA,IAAAF,UAAAE,SAAAsoB,WAAAxoB,SACAinC,QAAA/mC,SAAA+mC,OAEA,QAAAA,QAAAvlC,OAEA4xD,IAAA8mB,WAAAp1C,KAAA,EAAAhlC,SAAAuQ,MAAA7O,OAAA,GAEA+xD,MAAAC,KAAA10D,OAAA4zE,QACAnf,MAAAC,KAAA10D,OAAAspB,UAAAtoB,SAAAuQ,MAAA7O,OAAA,MAIA,QAAAD,GAAA,EAAAklB,GAAAsgB,QAAAvlC,OAA0CilB,GAAAllB,EAAQA,IAElD6xD,IAAA8mB,WAAAp1C,KAAAiC,QAAAxlC,GAAAgD,MAAAwiC,QAAAxlC,GAAAmlC,OAEA6sB,MAAAC,KAAA10D,OAAA4zE,QACAnf,MAAAC,KAAA10D,OAAAspB,UAAA2e,QAAAxlC,GAAAmlC,UAYA7pC,KAAAmhE,aAAA,SAAAt+D,OAAAyoD,OAAAlB,IAAA/mD,SAAA2zD,cAAA/rC,QAEA,GAAA5nB,SAAAqhC,WAAA,GAEA4+B,aAAAr4C,OAEA,IAAA0zC,SAAAyI,WAAAvkE,OAAAyoD,OAAAlB,IAAA/mD,SAAA4nB,QAEAQ,WAAAkzC,QAAAlzC,WAEA8xD,eAAA,EACAC,aAAAn6E,SAAAG,UAAA,IACAi6E,gBAAAzmB,cAAA53D,GAAA,IAAAu/D,QAAAv/D,GAAA,IAAAo+E,YAwCA,IAtCAC,kBAAA1H,0BAEAA,wBAAA0H,gBACAF,eAAA,GAIAA,eAEAre,MAAAgd,kBAMA74E,SAAAmtC,cAAA/kB,WAAAxoB,UAAA,EAEAs6E,gBAEAhnB,IAAAsE,WAAAtE,IAAAuE,aAAA9D,cAAAV,qBAEA4I,MAAAC,gBAAA1zC,WAAAxoB,UAEAszD,IAAA6I,oBAAA3zC,WAAAxoB,SAAA,EAAAszD,IAAA8I,OAAA,QAMAp0C,OAAA6iC,iBAEA2R,kBAAAp8D,SAAA2zD,cAAA/rC,QAOAsyD,cAAA,CAMA,GAAAvmB,cAAAe,4BAEA,OAAArzD,GAAA,EAAAklB,GAAAotC,cAAAe,4BAAApzD,OAA2EilB,GAAAllB,EAAQA,IAAA,CAEnF,GAAA8e,WAAAwzC,cAAAe,4BAAArzD,EAEA+mB,YAAAjI,UAAAqkC,OAAAqQ,qBAAA,IAEA3B,IAAAsE,WAAAtE,IAAAuE,aAAAt3C,UAAAqkC,QAEAqX,MAAAC,gBAAA1zC,WAAAjI,UAAAqkC,OAAAqQ,qBAEA3B,IAAA6I,oBAAA3zC,WAAAjI,UAAAqkC,OAAAqQ,oBAAA10C,UAAAuG,KAAAwsC,IAAA8I,OAAA,QAWA5zC,WAAAloB,OAAA,IAEA0nB,OAAA9nB,SAAA8nC,OAAAtmC,OAAA,GAAAsmB,OAAA9nB,SAAAynC,MAAAjmC,OAAA,GAEA4xD,IAAAsE,WAAAtE,IAAAuE,aAAA9D,cAAAP,oBAEAyI,MAAAC,gBAAA1zC,WAAAloB,OAEAgzD,IAAA6I,oBAAA3zC,WAAAloB,MAAA,EAAAgzD,IAAA8I,OAAA,QAEKz1D,SAAAvG,SAAAkoD,wBAGLgL,IAAAgJ,gBAAA9zC,WAAAloB,MAAAF,SAAAkoD,uBAAAhoD,QAQAkoB,WAAA3F,QAAA,IAEAywC,IAAAsE,WAAAtE,IAAAuE,aAAA9D,cAAAC,qBAEAiI,MAAAC,gBAAA1zC,WAAA3F,QAEAywC,IAAA6I,oBAAA3zC,WAAA3F,OAAA,EAAAywC,IAAA8I,OAAA,QAMA5zC,WAAAsiB,SAAA,IAEAwoB,IAAAsE,WAAAtE,IAAAuE,aAAA9D,cAAAE,sBAEAgI,MAAAC,gBAAA1zC,WAAAsiB,SAEAwoB,IAAA6I,oBAAA3zC,WAAAsiB,QAAA,EAAAwoB,IAAA8I,OAAA,QAMA5zC,WAAAoiB,IAAA,IAEA5iB,OAAA9nB,SAAA0nC,cAAA,IAEA0rB,IAAAsE,WAAAtE,IAAAuE,aAAA9D,cAAAG,iBAEA+H,MAAAC,gBAAA1zC,WAAAoiB,IAEA0oB,IAAA6I,oBAAA3zC,WAAAoiB,GAAA,EAAA0oB,IAAA8I,OAAA,QAEKz1D,SAAAvG,SAAAkoD,wBAGLgL,IAAA+I,gBAAA7zC,WAAAoiB,GAAAxqC,SAAAkoD,uBAAA1d,KAMApiB,WAAA+/B,KAAA,IAEAvgC,OAAA9nB,SAAA0nC,cAAA,IAEA0rB,IAAAsE,WAAAtE,IAAAuE,aAAA9D,cAAAI,kBAEA8H,MAAAC,gBAAA1zC,WAAA+/B,KAEA+K,IAAA6I,oBAAA3zC,WAAA+/B,IAAA,EAAA+K,IAAA8I,OAAA,QAEKz1D,SAAAvG,SAAAkoD,wBAGLgL,IAAA+I,gBAAA7zC,WAAA+/B,IAAAnoD,SAAAkoD,uBAAAC,MAMAnoD,SAAAynD,UACAr/B,WAAAsyD,WAAA,GAAAtyD,WAAAuyD,YAAA,IAEAznB,IAAAsE,WAAAtE,IAAAuE,aAAA9D,cAAAK,0BAEA6H,MAAAC,gBAAA1zC,WAAAsyD,WAEAxnB,IAAA6I,oBAAA3zC,WAAAsyD,UAAA,EAAAxnB,IAAA8I,OAAA,OAEA9I,IAAAsE,WAAAtE,IAAAuE,aAAA9D,cAAAM,0BAEA4H,MAAAC,gBAAA1zC,WAAAuyD,YAEAznB,IAAA6I,oBAAA3zC,WAAAuyD,WAAA,EAAAznB,IAAA8I,OAAA,QAMA5zC,WAAAwyD,cAAA,IAEA1nB,IAAAsE,WAAAtE,IAAAuE,aAAA9D,cAAAF,2BAEAoI,MAAAC,gBAAA1zC,WAAAwyD,cAEA1nB,IAAA6I,oBAAA3zC,WAAAwyD,aAAA,EAAA1nB,IAAA8I,OAAA,QAUA,GAJAH,MAAAM,0BAIAv0C,iBAAAvhB,OAAAhG,KAAA,CAEA,GAAA0C,MAAA4wD,cAAAwC,cAAAD,YAAAhD,IAAA4b,aAAA5b,IAAA0b,cAIA5uE,UAAAG,WAEA07D,MAAA4e,aAAAz6E,SAAAsnD,mBAAA+pB,YAEA6I,eAAAhnB,IAAAsE,WAAAtE,IAAAiI,qBAAAxH,cAAAQ,mBACAjB,IAAAonB,aAAApnB,IAAAmnB,MAAA1mB,cAAAyB,iBAAAryD,KAAA,KAMAm3E,eAAAhnB,IAAAsE,WAAAtE,IAAAiI,qBAAAxH,cAAAO,mBACAhB,IAAAonB,aAAApnB,IAAA+mB,UAAAtmB,cAAA6C,iBAAAzzD,KAAA,IAIAswD,MAAAC,KAAA10D,OAAA4zE,QACAnf,MAAAC,KAAA10D,OAAAspB,UAAAyrC,cAAA6C,iBACAnD,MAAAC,KAAA10D,OAAA2oC,OAAAosB,cAAA6C,iBAAA,MAIG,IAAA5uC,iBAAAvhB,OAAAm5B,KAAA,CAEH,GAAAoF,MAAAhd,OAAAgd,OAAAv+B,MAAAwjD,UAAAqJ,IAAAsnB,WAAAtnB,IAAAmnB,KAEAxe,OAAA4e,aAAAz6E,SAAA4mD,UAAAyqB,YAEAne,IAAA8mB,WAAAp1C,KAAA,EAAA+uB,cAAAyB,kBAEA/B,MAAAC,KAAA10D,OAAA4zE,YAIG5qD,kBAAAvhB,OAAAg5B,aAEH6zB,IAAA8mB,WAAA9mB,IAAAqnB,OAAA,EAAA5mB,cAAAsB,sBAEA5B,MAAAC,KAAA10D,OAAA4zE,QACAnf,MAAAC,KAAA10D,OAAAynB,QAAAstC,cAAAsB,wBAgOAt4D,KAAAiC,OAAA,SAAA/B,MAAA2C,OAAAszC,aAAA+nC,YAEA,GAAAr7E,iBAAA6G,OAAA+rC,SAAA,EAGA,WADA/rC,OAAAM,MAAA,yEAKA,IAAAogD,KAAAlqD,MAAAkqD,GAIA2rB,yBAAA,GACAjO,mBAAA,GACAC,eAAA,KACAa,mBAAA,EAIA1oE,MAAA4yD,cAAA,GAAA5yD,MAAAirB,oBAIAvhB,SAAA/G,OAAAohC,QAAAphC,OAAAsoB,oBAIAjrB,MAAAkrB,SAAA,SAAAH,QAEAA,iBAAAvhB,OAAAgmD,aAEAzkC,OAAAklC,SAAA3pD,WAMA3D,OAAA6yC,mBAAA3wB,WAAAliB,OAAAmiB,aAEA47C,kBAAA/7C,iBAAAhiB,OAAAiiB,iBAAAjiB,OAAA6yC,oBACA8qB,SAAApnC,cAAAwnC,mBAEAtV,OAAA3mD,OAAA,EACAg9D,cAAAh9D,OAAA,EACA+8D,mBAAA/8D,OAAA,EAEA07D,QAAA17D,OAAA,EACA0tD,WAAA1tD,OAAA,EAEAw7D,cAAAjgE,OAEAw2D,MAAA/zD,eAAA,IAEAg/D,cAAAl+B,KAAAw8B,mBACAyB,mBAAAj+B,KAAAy8B,2BAMA+Y,gBAAAh3E,OAAA/B,MAAA2C,QAIA6zD,MAAAC,KAAA10D,OAAA4zE,MAAA,EACAnf,MAAAC,KAAA10D,OAAAspB,SAAA,EACAmrC,MAAAC,KAAA10D,OAAA2oC,MAAA,EACA8rB,MAAAC,KAAA10D,OAAAynB,OAAA,EAEA1pB,KAAAk7E,gBAAA/kC,eAEAn2C,KAAAs1E,WAAA4I,aAEAl+E,KAAA2B,MAAA3B,KAAAu1E,eAAAv1E,KAAAw1E,eAAAx1E,KAAAy1E,iBAMA,QAAA/wE,GAAA,EAAAklB,GAAA64C,uBAAA99D,OAAsDilB,GAAAllB,EAAQA,IAAA,CAE9D,GAAA+7D,aAAAgC,uBAAA/9D,GACAumB,OAAAw1C,YAAAx1C,MAEAA,QAAAyZ,UAEAq8B,cAAA91C,OAAApoB,QAEA0+D,8BAAAd,cAMA,GAAAvgE,MAAA2yD,iBAAA,CAEA,GAAAA,kBAAA3yD,MAAA2yD,gBAEAmO,aAAAnO,kBAEAgO,cAAAc,cAAA9+D,OAAAyoD,OAAAlB,IAAAyI,kBACAgO,cAAAa,mBAAA7+D,OAAAyoD,OAAAlB,IAAAyI,kBACAuO,uBAAAqB,uBAAA,GAAA5/D,OAAAyoD,OAAAlB,IAAAyI,sBAMAqM,OAAA6H,YAAAr9D,MAAA6B,YAEAs1D,cAAAc,cAAA9+D,OAAAyoD,OAAAlB,IAAA,MACAgX,uBAAAqB,uBAAA,SAAA5/D,OAAAyoD,OAAAlB,IAAA,MAIAyW,cAAAa,mBAAA7+D,OAAAyoD,OAAAlB,IAAA,MACAgX,uBAAAqB,uBAAA,cAAA5/D,OAAAyoD,OAAAlB,IAAA,KAMA+uB,cAAAl3E,OAAA/B,MAAA2C,QACAw2E,gBAAAp3E,OAAA/B,MAAA2C,OAAAuzE,cAAAC,gBAIAlgC,2BAAAM,iBAAAN,aAAAI,YAAA7sC,MAAA+D,eAAA0oC,aAAAI,YAAA7sC,MAAAkE,cAEAqjE,yBAAA96B,cAMA+oB,MAAA8H,cAAA,GACA9H,MAAA+H,eAAA,GACA/H,MAAAgI,eAAA,IAiJAlnE,KAAAshE,sBAAA,SAAAz+D,OAAAyoD,OAAAlB,IAAA/mD,SAAA4nB;AAEA,GAAA0zC,SAAAyI,WAAAvkE,OAAAyoD,OAAAlB,IAAA/mD,SAAA4nB,OAEA8qD,yBAAA,GAEArf,MAAAuK,iBAAA59D,UAEA4nB,OAAAs3C,wBAEAt3C,OAAAs3C,wBAAA5D,QAAApI,IAAAiK,UAIAv1C,OAAAhpB,OAAA,SAAAgpB,QAAuCyrC,MAAAulB,sBAAAhxD,OAAA0zC,QAAAt7D,YAuKvC,IAAAg/D,mBACAc,qBAAA,EAmWAmB,WACAza,kBAAA,QACAD,mBAAA,SACAtmD,kBAAA,QACAomD,oBAAA,UACAC,kBAAA,QACAK,kBAAA,QACAK,mBAAA,SACAP,mBAAA,iBAqwCA9pD,MAAAm+E,eAAA,SAAA3G,SAAA4G,oBAEA5G,WAAA9tE,MAAAW,aAEAksD,IAAAkkB,QAAAlkB,IAAAmhB,YAIA0G,qBAAA10E,MAAAe,qBAEA8rD,IAAA+gB,UAAA/gB,IAAA8nB,IAIA9nB,IAAA+gB,UAAA/gB,IAAAghB,KAIAC,WAAA9tE,MAAAY,aAEAisD,IAAAihB,SAAAjhB,IAAAkhB,MAEID,WAAA9tE,MAAAa,cAEJgsD,IAAAihB,SAAAjhB,IAAA+nB,OAIA/nB,IAAAihB,SAAAjhB,IAAAgoB,gBAIAhoB,IAAA2gB,OAAA3gB,IAAAmhB,aAMA13E,KAAAihE,iBAAA,SAAA59D,UAEA67D,MAAAsf,eAAAn7E,SAAAw6C,OAAAn0C,MAAAsB,YACAk0D,MAAAuf,aAAAp7E,SAAAw6C,OAAAn0C,MAAAqB,WAuDA/K,KAAA0+E,cAAA,SAAA1iC,SAEApyC,SAAAoyC,QAAA4lB,cAEA5lB,QAAA4lB,aAAA,EAEA5lB,QAAAp5C,iBAAA,UAAA2rE,kBAEAvyB,QAAA4zB,eAAArZ,IAAAiY,gBAEA9X,MAAAC,KAAAC,OAAA1R,YAIAqR,IAAAoY,YAAApY,IAAA2a,WAAAl1B,QAAA4zB,gBAEArZ,IAAAsY,YAAAtY,IAAAuY,oBAAA9yB,QAAAiQ,OACAsK,IAAAsY,YAAAtY,IAAAooB,+BAAA3iC,QAAAgQ,kBACAuK,IAAAsY,YAAAtY,IAAAqoB,iBAAA5iC,QAAAkQ,iBAEAlQ,QAAAM,MAAA6xB,eAAAnyB,QAAAM,MAAA47B,gBAEA,IAAA57B,OAAAN,QAAAM,MACA+wB,kBAAA3jE,MAAAG,KAAA0zB,aAAA+e,MAAAjF,QAAA3tC,MAAAG,KAAA0zB,aAAA+e,MAAAhF,QACA83B,SAAA3B,eAAAzxB,QAAA3F,QACAg5B,OAAA5B,eAAAzxB,QAAA51C,KAEA+mE,sBAAA5W,IAAA2a,WAAAl1B,QAAAqxB,kBAEA,IAAAiC,QAAAvnB,QAAA/L,QAAA+L,OAEA,IAAA/L,kBAAAtyC,OAAAk+C,YAMA,GAAAG,QAAApjD,OAAA,GAAA0oE,kBAAA,CAEA,OAAA3oE,GAAA,EAAAklB,GAAAm+B,QAAApjD,OAAyCilB,GAAAllB,EAAQA,IAEjD4qE,OAAAvnB,QAAArjD,GACA6xD,IAAAmZ,WAAAnZ,IAAA2a,WAAAxsE,EAAA0qE,SAAAE,OAAAj4B,MAAAi4B,OAAAh4B,OAAA,EAAA83B,SAAAC,OAAAC,OAAA/nC,KAIAyU,SAAAvF,iBAAA,MAIA8f,KAAAmZ,WAAAnZ,IAAA2a,WAAA,EAAA9B,SAAA9yB,MAAAjF,MAAAiF,MAAAhF,OAAA,EAAA83B,SAAAC,OAAA/yB,MAAA/U,UAIG,IAAAyU,kBAAAtyC,OAAAw+C,kBAEH,OAAAxjD,GAAA,EAAAklB,GAAAm+B,QAAApjD,OAAwCilB,GAAAllB,EAAQA,IAEhD4qE,OAAAvnB,QAAArjD,GAEAs3C,QAAA3F,SAAA3sC,MAAAkF,YAAAotC,QAAA3F,SAAA3sC,MAAAiF,UAEA4gE,8BAAAptC,QAAAitC,UAAA,GAEA7Y,IAAAiZ,qBAAAjZ,IAAA2a,WAAAxsE,EAAA0qE,SAAAE,OAAAj4B,MAAAi4B,OAAAh4B,OAAA,EAAAg4B,OAAA/nC,MAIA79B,MAAAK,KAAA,kGAMAwsD,IAAAmZ,WAAAnZ,IAAA2a,WAAAxsE,EAAA0qE,SAAAE,OAAAj4B,MAAAi4B,OAAAh4B,OAAA,EAAA83B,SAAAC,OAAAC,OAAA/nC,UAYA,IAAAwgB,QAAApjD,OAAA,GAAA0oE,kBAAA,CAEA,OAAA3oE,GAAA,EAAAklB,GAAAm+B,QAAApjD,OAAyCilB,GAAAllB,EAAQA,IAEjD4qE,OAAAvnB,QAAArjD,GACA6xD,IAAAmZ,WAAAnZ,IAAA2a,WAAAxsE,EAAA0qE,kBAAAC,OAAAC,OAIAtzB,SAAAvF,iBAAA,MAIA8f,KAAAmZ,WAAAnZ,IAAA2a,WAAA,EAAA9B,kBAAAC,OAAArzB,QAAAM,MAMAN,SAAAvF,iBAAA42B,mBAAA9W,IAAAoZ,eAAApZ,IAAA2a,YAEAl1B,QAAArT,aAAA,EAEAqT,QAAAmQ,UAAAnQ,QAAAmQ,YAIAnsD,KAAAyoE,WAAA,SAAAzsB,QAAAqyB,MAEA9X,IAAAkY,cAAAlY,IAAAmY,SAAAL,MAEAryB,QAAArT,YAEA+tB,MAAAgoB,cAAA1iC,SAIAua,IAAAoY,YAAApY,IAAA2a,WAAAl1B,QAAA4zB,iBA8LA5vE,KAAAk7E,gBAAA,SAAA/kC,cAEA,GAAA0oC,QAAA1oC,uBAAAzsC,OAAA0sC,qBAEA,IAAAD,cAAAvsC,SAAAusC,aAAAylC,mBAAA,CAEAhyE,SAAAusC,aAAAq6B,cAAAr6B,aAAAq6B,aAAA,GACA5mE,SAAAusC,aAAAs6B,gBAAAt6B,aAAAs6B,eAAA,GAEAt6B,aAAAvzC,iBAAA,UAAAy4E,uBAEAllC,aAAAy5B,eAAArZ,IAAAiY,gBAEA9X,MAAAC,KAAAC,OAAA1R,UAIA,IAAA45B,oBAAAp1E,MAAAG,KAAA0zB,aAAA4Y,aAAAkB,QAAA3tC,MAAAG,KAAA0zB,aAAA4Y,aAAAmB,QACA83B,SAAA3B,eAAAt3B,aAAAE,QACAg5B,OAAA5B,eAAAt3B,aAAA/vC,KAEA,IAAAy4E,OAAA,CAEA1oC,aAAAylC,sBACAzlC,aAAA2lC,uBAEAvlB,IAAAoY,YAAApY,IAAAqY,iBAAAz4B,aAAAy5B,gBACAzC,qBAAA5W,IAAAqY,iBAAAz4B,aAAA2oC,mBAEA,QAAAp6E,GAAA,EAAoB,EAAAA,EAAOA,IAE3ByxC,aAAAylC,mBAAAl3E,GAAA6xD,IAAAwoB,oBACA5oC,aAAA2lC,oBAAAp3E,GAAA6xD,IAAAyoB,qBAEAzoB,IAAAmZ,WAAAnZ,IAAAkZ,4BAAA/qE,EAAA,EAAA0qE,SAAAj5B,aAAAkB,MAAAlB,aAAAmB,OAAA,EAAA83B,SAAAC,OAAA,MAEAQ,iBAAA15B,aAAAylC,mBAAAl3E,GAAAyxC,aAAAogB,IAAAkZ,4BAAA/qE,GACA0rE,kBAAAj6B,aAAA2lC,oBAAAp3E,GAAAyxC,aAIA2oC,qBAAAvoB,IAAAoZ,eAAApZ,IAAAqY,sBAIAz4B,cAAAylC,mBAAArlB,IAAAwoB,oBAEA5oC,aAAA8oC,eAEA9oC,aAAA2lC,oBAAA3lC,aAAA8oC,eAAAnD,oBAIA3lC,aAAA2lC,oBAAAvlB,IAAAyoB,qBAIAzoB,IAAAoY,YAAApY,IAAA2a,WAAA/6B,aAAAy5B,gBACAzC,qBAAA5W,IAAA2a,WAAA/6B,aAAA2oC,oBAEAvoB,IAAAmZ,WAAAnZ,IAAA2a,WAAA,EAAA9B,SAAAj5B,aAAAkB,MAAAlB,aAAAmB,OAAA,EAAA83B,SAAAC,OAAA,MAEAQ,iBAAA15B,aAAAylC,mBAAAzlC,aAAAogB,IAAA2a,YAEA/6B,aAAA8oC,eAEA9oC,aAAAq6B,cAAAr6B,aAAAs6B,cAEAla,IAAAqa,wBAAAra,IAAA0Z,YAAA1Z,IAAAsa,iBAAAta,IAAAga,aAAAp6B,aAAA2lC,qBAEM3lC,aAAAq6B,aAAAr6B,aAAAs6B,eAENla,IAAAqa,wBAAAra,IAAA0Z,YAAA1Z,IAAAwa,yBAAAxa,IAAAga,aAAAp6B,aAAA2lC,qBAMA1L,kBAAAj6B,aAAA2lC,oBAAA3lC,cAIA2oC,oBAAAvoB,IAAAoZ,eAAApZ,IAAA2a,WAMA2N,QAEAtoB,IAAAoY,YAAApY,IAAAqY,iBAAA,MAIArY,IAAAoY,YAAApY,IAAA2a,WAAA,MAIA3a,IAAA+Z,iBAAA/Z,IAAAga,aAAA,MACAha,IAAAyZ,gBAAAzZ,IAAA0Z,YAAA,MAIA,GAAAH,aAAAz4B,MAAAC,OAAA4nC,GAAAC,EAEAhpC,eAIA25B,YAFA+O,OAEA1oC,aAAAylC,mBAAAzlC,aAAAO,gBAIAP,aAAAylC,mBAIAvkC,MAAAlB,aAAAkB,MACAC,OAAAnB,aAAAmB,OAEA4nC,GAAA,EACAC,GAAA,IAIArP,YAAA,KAEAz4B,MAAA6+B,eACA5+B,OAAA6+B,gBAEA+I,GAAAlJ,WACAmJ,GAAAlJ,YAIAnG,cAAAgG,sBAEAvf,IAAAyZ,gBAAAzZ,IAAA0Z,YAAAH,aACAvZ,IAAAshB,SAAAqH,GAAAC,GAAA9nC,MAAAC,QAEAw+B,oBAAAhG,aAIAsG,cAAA/+B,MACAg/B,eAAA/+B,QAIAt3C,KAAAo/E,uBAAA,SAAAjpC,aAAAjyC,EAAAC,EAAAkzC,MAAAC,OAAAuQ,QAEA,KAAA1R,uBAAAzsC,OAAA21E,mBAGA,WADAl/E,SAAA6J,MAAA,2FAKA,IAAAmsC,aAAAylC,mBAAA,CAEA,GAAAzlC,aAAAE,SAAA3sC,MAAAkF,WAGA,WADAzO,SAAA6J,MAAA,wHAKA,IAAAs1E,UAAA,CAEAnpC,cAAAylC,qBAAA9F,sBAEAvf,IAAAyZ,gBAAAzZ,IAAA0Z,YAAA95B,aAAAylC,oBAEA0D,SAAA,GAIA/oB,IAAAgpB,uBAAAhpB,IAAA0Z,eAAA1Z,IAAAipB,qBAEAjpB,IAAAkpB,WAAAv7E,EAAAC,EAAAkzC,MAAAC,OAAAif,IAAAgc,KAAAhc,IAAAob,cAAA9pB,QAIA1nD,QAAA6J,MAAA,8GAIAs1E,SAEA/oB,IAAAyZ,gBAAAzZ,IAAA0Z,YAAA6F,uBA8NA91E,KAAAmkE,aAAA,WAEAz6D,MAAAK,KAAA,2DAIA/J,KAAA0/E,aAAA,WAEAh2E,MAAAK,KAAA,2DAIA/J,KAAA2/E,cAAA,WAEAj2E,MAAAK,KAAA,4DAIA/J,KAAA4/E,gBAAA,WAEAl2E,MAAAK,KAAA,+DAaAL,MAAA21E,kBAAA,SAAAhoC,MAAAC,OAAApyC,SAEAlF,KAAAq3C,YACAr3C,KAAAs3C,cAEApyC,oBAEAlF,KAAA08C,MAAA9yC,SAAA1E,QAAAw3C,MAAAx3C,QAAAw3C,MAAAhzC,MAAA6D,oBACAvN,KAAA28C,MAAA/yC,SAAA1E,QAAAy3C,MAAAz3C,QAAAy3C,MAAAjzC,MAAA6D,oBAEAvN,KAAAs2C,UAAA1sC,SAAA1E,QAAAoxC,UAAApxC,QAAAoxC,UAAA5sC,MAAAkE,aACA5N,KAAAu2C,UAAA3sC,SAAA1E,QAAAqxC,UAAArxC,QAAAqxC,UAAA7sC,MAAAoE,yBAEA9N,KAAA+7C,WAAAnyC,SAAA1E,QAAA62C,WAAA72C,QAAA62C,WAAA,EAEA/7C,KAAA0T,OAAA,GAAAhK,OAAAiY,QAAA,KACA3hB,KAAA67C,OAAA,GAAAnyC,OAAAiY,QAAA,KAEA3hB,KAAAq2C,OAAAzsC,SAAA1E,QAAAmxC,OAAAnxC,QAAAmxC,OAAA3sC,MAAAkF,WACA5O,KAAAoG,KAAAwD,SAAA1E,QAAAkB,KAAAlB,QAAAkB,KAAAsD,MAAAqE,iBAEA/N,KAAAwwE,YAAA5mE,SAAA1E,QAAAsrE,YAAAtrE,QAAAsrE,aAAA,EACAxwE,KAAAywE,cAAA7mE,SAAA1E,QAAAurE,cAAAvrE,QAAAurE,eAAA,EAEAzwE,KAAAy2C,iBAAA,EAEAz2C,KAAAi/E,eAAAr1E,SAAA1E,QAAA+5E,eAAA/5E,QAAA+5E,eAAA,MAIAv1E,MAAA21E,kBAAA/+E,WAEAM,YAAA8I,MAAA21E,kBAEAh9E,QAAA,SAAAg1C,MAAAC,QAEAt3C,KAAAq3C,YACAr3C,KAAAs3C,eAIA3jC,MAAA,WAEA,GAAAuZ,KAAA,GAAAxjB,OAAA21E,kBAAAr/E,KAAAq3C,MAAAr3C,KAAAs3C,OAuBA,OArBApqB,KAAAwvB,MAAA18C,KAAA08C,MACAxvB,IAAAyvB,MAAA38C,KAAA28C,MAEAzvB,IAAAopB,UAAAt2C,KAAAs2C,UACAppB,IAAAqpB,UAAAv2C,KAAAu2C,UAEArpB,IAAA6uB,WAAA/7C,KAAA+7C,WAEA7uB,IAAAxZ,OAAAlD,KAAAxQ,KAAA0T,QACAwZ,IAAA2uB,OAAArrC,KAAAxQ,KAAA67C,QAEA3uB,IAAAmpB,OAAAr2C,KAAAq2C,OACAnpB,IAAA9mB,KAAApG,KAAAoG,KAEA8mB,IAAAsjD,YAAAxwE,KAAAwwE,YACAtjD,IAAAujD,cAAAzwE,KAAAywE,cAEAvjD,IAAAupB,gBAAAz2C,KAAAy2C,gBAEAvpB,IAAA+xD,eAAAj/E,KAAAi/E,eAEA/xD,KAIAqjB,QAAA,WAEAvwC,KAAA+hC,eAAuB37B,KAAA,cAMvBsD,MAAAk4B,gBAAAthC,UAAAiB,MAAAmI,MAAA21E,kBAAA/+E,WAQAoJ,MAAA0sC,sBAAA,SAAAiB,MAAAC,OAAApyC,SAEAwE,MAAA21E,kBAAA//E,KAAAU,KAAAq3C,MAAAC,OAAApyC,SAEAlF,KAAA02C,eAAA,GAIAhtC,MAAA0sC,sBAAA91C,UAAAujC,OAAAiG,OAAApgC,MAAA21E,kBAAA/+E,WACAoJ,MAAA0sC,sBAAA91C,UAAAM,YAAA8I,MAAA0sC,sBAQA1sC,MAAAmtE,gBAAA,SAAAgJ,IAEA,GAAAvmB,cAEAt5D,MAAA25C,IAAA,SAAA3V,MAEA,GAAAp6B,SAAA0vD,WAAAt1B,MAEA,MAAAs1B,YAAAt1B,KAIA,IAAAspC,UAEA,QAAAtpC,MAEA,qCACAspC,UAAAuS,GAAAC,aAAA,mCAAAD,GAAAC,aAAA,uCAAAD,GAAAC,aAAA,wCACA,MAEA,qCACAxS,UAAAuS,GAAAC,aAAA,kCAAAD,GAAAC,aAAA,sCAAAD,GAAAC,aAAA,uCACA,MAEA,sCACAxS,UAAAuS,GAAAC,aAAA,mCAAAD,GAAAC,aAAA,wCACA,MAEA,SACAxS,UAAAuS,GAAAC,aAAA97C,MAYA,MARA,QAAAspC,WAEA5jE,MAAAK,KAAA,wBAAAi6B,KAAA,6BAIAs1B,WAAAt1B,MAAAspC,UAEAA,YAQA5jE,MAAAg9D,aAAA,WAEA,GAAAqZ,gBAAA,EAEAC,gBAAA,SAAA30B,SAEA,GAAA96C,OAAA0vE,MAAA9gD,SAEA,QAAAjb,KAAAmnC,SAEA96C,MAAA86C,QAAAnnC,GACA3T,SAAA,IAEA0vE,MAAA,WAAA/7D,EAAA,IAAA3T,MACA4uB,OAAA76B,KAAA27E,OAIA,OAAA9gD,QAAAt6B,KAAA,OAIAq7E,sBAAA,SAAAL,GAAAlhB,QAAAwhB,aAIA,OAFA57B,aAEA7/C,EAAA,EAAAsM,EAAAmvE,YAAAx7E,OAA0CqM,EAAAtM,EAAOA,IAAA,CAEjD,GAAAtF,IAAA+gF,YAAAz7E,EACA6/C,UAAAnlD,IAAAygF,GAAAO,mBAAAzhB,QAAAv/D,IAIA,MAAAmlD,WAIA87B,wBAAA,SAAAR,GAAAlhB,QAAAwhB,aAIA,OAFA10D,eAEA/mB,EAAA,EAAAsM,EAAAmvE,YAAAx7E,OAA0CqM,EAAAtM,EAAOA,IAAA,CAEjD,GAAAtF,IAAA+gF,YAAAz7E,EACA+mB,YAAArsB,IAAAygF,GAAAS,kBAAA3hB,QAAAv/D,IAIA,MAAAqsB,YAIA,iBAAA5rB,SAAAwmE,KAAAhjE,SAAA0xC,YAEA,GAAA2hB,OAAA72D,SACA02D,IAAAG,MAAAjkB,QAEA4Y,QAAAhoD,SAAAgoD,QACA9G,SAAAlhD,SAAAmhE,cAAAjgB,SACA94B,WAAApoB,SAAAooB,WAEA+4B,aAAAnhD,SAAAmhE,cAAAhgB,aACAC,eAAAphD,SAAAmhE,cAAA/f,eAEAgH,oBAAApoD,SAAAooD,mBAEA7hD,UAAA6hD,qBAAA1W,WAAAvE,gBAAA,IAIAib,oBAAA,WAIA,IAAA80B,qBAAA,sBAEAxrC,YAAAmxB,gBAAAx8D,MAAAkB,aAEA21E,oBAAA,qBAEGxrC,WAAAmxB,gBAAAx8D,MAAAmB,mBAEH01E,oBAAA,0BAIA,IAAAC,kBAAA,mBACAC,iBAAA,yBACAC,qBAAA,0BAEA,IAAA3rC,WAAAkS,OAAA,CAEA,OAAA5jD,SAAA4jD,OAAA2E,SAEA,IAAAliD,OAAAuD,sBACA,IAAAvD,OAAAwD,sBACAszE,iBAAA,kBACA,MAEA,KAAA92E,OAAAyD,iCACA,IAAAzD,OAAA0D,iCACAozE,iBAAA,qBACA,MAEA,KAAA92E,OAAA2D,2BACAmzE,iBAAA,qBAKA,OAAAn9E,SAAA4jD,OAAA2E,SAEA,IAAAliD,OAAAwD,sBACA,IAAAxD,OAAA0D,iCACAqzE,iBAAA,yBAKA,OAAAp9E,SAAAmnD,SAEA,IAAA9gD,OAAAmD,kBACA6zE,qBAAA,0BACA,MAEA,KAAAh3E,OAAAoD,aACA4zE,qBAAA,qBACA,MAEA,KAAAh3E,OAAAqD,aACA2zE,qBAAA,uBAOA,GAYAC,eAAAC,gBAZAC,kBAAAhhF,SAAA6R,YAAA,EAAA7R,SAAA6R,YAAA,EAMAovE,cAAAd,gBAAA30B,SAIAsT,QAAApI,IAAAwqB,eAIA19E,oBAAAqG,OAAAiiD,mBAEAg1B,cAAA,GACAC,gBAAA,KAIAD,eAEA,aAAA5rC,WAAA1R,UAAA,UACA,aAAA0R,WAAA1R,UAAA,QAEAy9C,cAEA/rC,WAAAiwB,uBAAA,6BAEAtO,MAAAgf,WAAA,yBACAhf,MAAAif,YAAA,0BACA,wBAAAkL,kBAEA,0BAAA9rC,WAAA4wB,aACA,4BAAA5wB,WAAA8wB,eACA,2BAAA9wB,WAAA+wB,cACA,2BAAA/wB,WAAAixB,cAEA,uBAAAjxB,WAAA4vB,WAEA,qBAAA5vB,WAAA8vB,SAEA9vB,WAAAoI,IAAA,qBACApI,WAAAkS,OAAA,wBACAlS,WAAAkS,OAAA,WAAAw5B,iBAAA,GACA1rC,WAAAqI,SAAA,0BACArI,WAAAuI,QAAA,yBACAvI,WAAAsI,UAAA,2BACAtI,WAAAmS,YAAA,6BACAnS,WAAAiS,SAAA,0BACAjS,WAAAzM,aAAA,uBAEAyM,WAAAswB,YAAA,yBAEAtwB,WAAA+V,SAAA,0BACA/V,WAAAga,iBAAA,0BAEAha,WAAAvE,aAAA,8BACAuE,WAAArE,aAAA,8BACAqE,WAAAgW,WAAA,yBACAhW,WAAA+I,YAAA,0BACA/I,WAAA6I,UAAA,wBAEA7I,WAAAtyC,iBAAA,2BACAsyC,WAAAtyC,iBAAA,WAAA89E,oBAAA,GACAxrC,WAAAoxB,eAAA,6BACApxB,WAAAqxB,iBAAA,+BAEArxB,WAAA2P,gBAAA,iCAEA3P,WAAAuwB,uBAAA,6BAIA,4BACA,gCACA,iCACA,2BACA,6BACA,+BAEA,2BACA,yBACA,qBACA,sBAEA,mBAEA,yBAEA,SAEA,0BAEA,gCACA,gCACA,gCACA,gCAEA,2BAEA,iCACA,iCACA,iCACA,iCAEA,SAEA,iCACA,iCACA,iCACA,iCAEA,UAEA,SAEA,sBAEA,6BACA,8BAEA,SAEA,IAEAzgE,KAAA,MAEA+7E,iBAEA,aAAA7rC,WAAA1R,UAAA,UACA,aAAA0R,WAAA1R,UAAA,QAEA0R,WAAAuI,SAAAvI,WAAAsI,WAAAtI,WAAAswB,YAAA,qDAEAyb,cAEA,0BAAA/rC,WAAA4wB,aACA,4BAAA5wB,WAAA8wB,eACA,2BAAA9wB,WAAA+wB,cACA,2BAAA/wB,WAAAixB,cAEA,uBAAAjxB,WAAA4vB,WAEA5vB,WAAAmU,UAAA,qBAAAnU,WAAAmU,UAAA,GAEAwN,MAAAgf,WAAA,yBACAhf,MAAAif,YAAA,0BACA,wBAAAkL,kBAEA9rC,WAAAowB,QAAApwB,WAAAqV,IAAA,qBACArV,WAAAowB,QAAApwB,WAAAqwB,OAAA,sBAEArwB,WAAAoI,IAAA,qBACApI,WAAAkS,OAAA,wBACAlS,WAAAkS,OAAA,WAAAu5B,iBAAA,GACAzrC,WAAAkS,OAAA,WAAAw5B,iBAAA,GACA1rC,WAAAkS,OAAA,WAAAy5B,qBAAA,GACA3rC,WAAAqI,SAAA,0BACArI,WAAAuI,QAAA,yBACAvI,WAAAsI,UAAA,2BACAtI,WAAAmS,YAAA,6BACAnS,WAAAiS,SAAA,0BACAjS,WAAAzM,aAAA,uBAEAyM,WAAAswB,YAAA,yBAEAtwB,WAAAkW,MAAA,mBACAlW,WAAAgW,WAAA,yBACAhW,WAAA+I,YAAA,0BACA/I,WAAA6I,UAAA,wBAEA7I,WAAAtyC,iBAAA,2BACAsyC,WAAAtyC,iBAAA,WAAA89E,oBAAA,GACAxrC,WAAAoxB,eAAA,6BACApxB,WAAAqxB,iBAAA,+BAEArxB,WAAAuwB,uBAAA,6BAGA,2BACA,+BACA,IAEAzgE,KAAA,MAIA,IAAAm8E,gBAAA,GAAAt3E,OAAAu3E,YAAA1qB,QAAA+hB,cAAAqI,cAAAn8B,cACA08B,iBAAA,GAAAx3E,OAAAu3E,YAAA1qB,QAAAoiB,gBAAAiI,gBAAAn8B,eAEA8R,KAAA4qB,aAAAxiB,QAAAqiB,gBACAzqB,IAAA4qB,aAAAxiB,QAAAuiB,kBAEAt3E,SAAA6hD,qBAMA8K,IAAA6qB,mBAAAziB,QAAA,EAAAlT,qBAIA8K,IAAA8qB,YAAA1iB,QAEA,IAAA2iB,gBAAA/qB,IAAAgrB,kBAAA5iB,QAEApI,KAAAirB,oBAAA7iB,QAAApI,IAAAkrB,gBAAA,GAEA/3E,MAAAM,MAAA,qCAAAusD,IAAAmrB,WAAA,qBAAAnrB,IAAAirB,oBAAA7iB,QAAApI,IAAAorB,iBAAA,uBAAAL,gBAIA,KAAAA,gBAEA53E,MAAAK,KAAA,6CAAAu3E,gBAQA/qB,IAAAqrB,aAAAZ,gBACAzqB,IAAAqrB,aAAAV,iBAIA,IAAAf,cAEA,aACA,kBACA,mBACA,eACA,cACA,iBACA,wBACA,aACA,oBAIAprC,YAAAga,kBAEAoxB,YAAA77E,KAAA,eACA67E,YAAA77E,KAAA,oBACA67E,YAAA77E,KAAA,sBAIA67E,YAAA77E,KAAA,sBAIAywC,WAAAuwB,wBAEA6a,YAAA77E,KAAA,gBAKA,QAAAi8B,KAAAgkB,UAEA47B,YAAA77E,KAAAi8B,EAIAvgC,MAAAukD,SAAA27B,sBAAA3pB,IAAAoI,QAAAwhB,aAIAA,aAEA,WACA,SACA,KACA,MACA,UACA,QACA,YACA,aACA,eAIA,QAAAz7E,GAAA,EAAkBA,EAAAqwC,WAAA0wB,gBAAgC/gE,IAElDy7E,YAAA77E,KAAA,cAAAI,EAIA,QAAAA,GAAA,EAAkBA,EAAAqwC,WAAA2wB,gBAAgChhE,IAElDy7E,YAAA77E,KAAA,cAAAI,EAIA,QAAA0b,KAAAqL,YAEA00D,YAAA77E,KAAA8b,EAgBA,OAZApgB,MAAAyrB,WAAA40D,wBAAA9pB,IAAAoI,QAAAwhB,aACAngF,KAAAgqC,eAAAnG,OAAAwG,KAAArqC,KAAAyrB,YAIAzrB,KAAAZ,GAAA2gF,iBACA//E,KAAAqmE,UACArmE,KAAAymE,UAAA,EACAzmE,KAAA2+D,gBACA3+D,KAAAwkD,aAAAw8B,eACAhhF,KAAAykD,eAAAy8B,iBAEAlhF,SAQA0J,MAAAu3E,YAAA,WAEA,GAAAY,gBAAA,SAAAC,QAIA,OAFAC,OAAAD,OAAA/lD,MAAA,MAEAr3B,EAAA,EAAkBA,EAAAq9E,MAAAp9E,OAAkBD,IAEpCq9E,MAAAr9E,KAAA,OAAAq9E,MAAAr9E,EAIA,OAAAq9E,OAAAl9E,KAAA,MAIA,iBAAAg7E,GAAAz5E,KAAA07E,QAEA,GAAAvd,QAAAsb,GAAAmC,aAAA57E,KAoBA,OAlBAy5E,IAAAoC,aAAA1d,OAAAud,QACAjC,GAAAqC,cAAA3d,QAEAsb,GAAAsC,mBAAA5d,OAAAsb,GAAAuC,mBAAA,GAEA14E,MAAAM,MAAA,+CAIA,KAAA61E,GAAAwC,iBAAA9d,SAEA76D,MAAAK,KAAA,2CAAA81E,GAAAwC,iBAAA9d,QAAAsd,eAAAC,SAOAvd,WAYA76D,MAAA+sE,WAAA,SAAAoJ,GAAApS,gBAEA,GAAA6U,eAAA,GAAAC,YAAA,IACAC,kBAAA,GAAAD,YAAA,IAEAE,gBAAA,KACAC,qBAAA,KACAC,gBAAA,KACAC,gBAAA,KACAC,0BAAA,KACAC,qBAAA,KACAC,qBAAA,KAEAC,iBAAA,KACAC,kBAAA,KAEAC,kBAAA,KAEAC,mBAAA,KACAC,iBAAA,KAEAC,iBAAA,KAEAC,qBAAA,KACAC,2BAAA,KACAC,0BAAA,IAEAxjF,MAAAk8E,eAAA,WAEA,OAAAx3E,GAAA,EAAAsM,EAAAsxE,cAAA39E,OAA4CqM,EAAAtM,EAAOA,IAEnD49E,cAAA59E,GAAA,GAMA1E,KAAAm/D,gBAAA,SAAA37C,WAEA8+D,cAAA9+D,WAAA,EAEA,IAAAg/D,kBAAAh/D,aAEAq8D,GAAA4D,wBAAAjgE,WACAg/D,kBAAAh/D,WAAA,IAMAxjB,KAAAw/D,wBAAA,WAEA,OAAA96D,GAAA,EAAAsM,EAAAwxE,kBAAA79E,OAAgDqM,EAAAtM,EAAOA,IAEvD89E,kBAAA99E,KAAA49E,cAAA59E,KAEAm7E,GAAA6D,yBAAAh/E,GACA89E,kBAAA99E,GAAA,IAQA1E,KAAA+mE,YAAA,SAAAvpB,SAAAkL,cAAAF,SAAAC,SAAAI,mBAAAF,cAAAC,eAEApL,WAAAilC,kBAEAjlC,WAAA9zC,MAAA6B,WAEAs0E,GAAApF,QAAAoF,GAAAlI,OAEIn6B,WAAA9zC,MAAA+B,kBAEJo0E,GAAA3I,OAAA2I,GAAAlI,OACAkI,GAAAn3B,cAAAm3B,GAAAnN,UACAmN,GAAAjI,UAAAiI,GAAA5M,UAAA4M,GAAA/M,MAEIt1B,WAAA9zC,MAAAgC,qBAGJm0E,GAAA3I,OAAA2I,GAAAlI,OACAkI,GAAAn3B,cAAAm3B,GAAAnN,UACAmN,GAAAjI,UAAAiI,GAAAhN,KAAAgN,GAAA7M,sBAEIx1B,WAAA9zC,MAAAiC,kBAGJk0E,GAAA3I,OAAA2I,GAAAlI,OACAkI,GAAAn3B,cAAAm3B,GAAAnN,UACAmN,GAAAjI,UAAAiI,GAAAhN,KAAAgN,GAAA9M,YAEIv1B,WAAA9zC,MAAAkC,eAEJi0E,GAAA3I,OAAA2I,GAAAlI,QAIAkI,GAAA3I,OAAA2I,GAAAlI,OACAkI,GAAA8D,sBAAA9D,GAAAnN,SAAAmN,GAAAnN,UACAmN,GAAA+D,kBAAA/D,GAAA5M,UAAA4M,GAAA3M,oBAAA2M,GAAA/M,IAAA+M,GAAA3M,sBAIAuP,gBAAAjlC,UAIAA,WAAA9zC,MAAAkC,gBAEAi9C,uCAAAH,cACAC,6BAAAH,SACAI,6BAAAH,UAEAC,gBAAAg6B,sBAAA75B,qBAAAg6B,6BAEAhD,GAAA8D,sBAAAlW,eAAA/kB,eAAA+kB,eAAA5kB,qBAEA65B,qBAAAh6B,cACAm6B,0BAAAh6B,qBAIAL,WAAAm6B,iBAAAl6B,WAAAm6B,iBAAAj6B,gBAAAm6B,sBAAAl6B,gBAAAm6B,wBAEAlD,GAAA+D,kBAAAnW,eAAAjlB,UAAAilB,eAAAhlB,UAAAglB,eAAA9kB,eAAA8kB,eAAA7kB,gBAEA+5B,gBAAAn6B,SACAo6B,gBAAAn6B,SACAq6B,qBAAAn6B,cACAo6B,qBAAAn6B,iBAMA85B,qBAAA,KACAC,gBAAA,KACAC,gBAAA,KACAC,0BAAA,KACAC,qBAAA,KACAC,qBAAA,OAMA/iF,KAAAgnE,aAAA,SAAAtpB,WAEAslC,mBAAAtlC,YAEAA,UAEAmiC,GAAA3I,OAAA2I,GAAA1I,YAIA0I,GAAApF,QAAAoF,GAAA1I,YAIA6L,iBAAAtlC,YAMA19C,KAAAinE,cAAA,SAAAtpB,YAEAslC,oBAAAtlC,aAEAkiC,GAAAgE,UAAAlmC,YACAslC,kBAAAtlC,aAMA39C,KAAAknE,cAAA,SAAApe,YAEAo6B,oBAAAp6B,aAEA+2B,GAAAiE,UAAAh7B,6CACAo6B,kBAAAp6B,aAMA9oD,KAAAw+E,eAAA,SAAA1gC,aAEAqlC,qBAAArlC,cAEAA,YAEA+hC,GAAApF,QAAAoF,GAAAnI,WAIAmI,GAAA3I,OAAA2I,GAAAnI,WAIAyL,mBAAArlC,cAMA99C,KAAAy+E,aAAA,SAAA7gC,WAEAwlC,mBAAAxlC,YAEAA,UAEAiiC,GAAAvI,UAAAuI,GAAAxB,IAIAwB,GAAAvI,UAAAuI,GAAAtI,KAIA6L,iBAAAxlC,YAMA59C,KAAA89E,aAAA,SAAAzmC,OAEAA,QAAAgsC,mBAEAxD,GAAAkE,UAAA1sC,OAEAgsC,iBAAAhsC,QAMAr3C,KAAAmnE,iBAAA,SAAA6c,cAAAC,OAAAC,OAEAZ,uBAAAU,gBAEAA,cAEAnE,GAAA3I,OAAA2I,GAAAsE,qBAIAtE,GAAApF,QAAAoF,GAAAsE,qBAIAb,qBAAAU,gBAIAA,eAAAT,6BAAAU,QAAAT,4BAAAU,QAEArE,GAAA92B,cAAAk7B,OAAAC,OAEAX,2BAAAU,OACAT,0BAAAU,QAMAlkF,KAAA83E,MAAA,WAEA,OAAApzE,GAAA,EAAkBA,EAAA89E,kBAAA79E,OAA8BD,IAEhD89E,kBAAA99E,GAAA,CAIA+9E,iBAAA,KACAO,iBAAA,KACAC,kBAAA,KACAC,kBAAA,KACAC,mBAAA,KACAC,iBAAA,OAaA15E,MAAA4vE,gBAAA,SAAAz5E,SAAAukF,QAubA,QAAArD,eAAAxc,QAEA,GAAA5F,SAAAkhB,GAAAkB,gBAEAt8B,eAAAo7B,GAAAmC,aAAAnC,GAAAlH,iBACAn0B,aAAAq7B,GAAAmC,aAAAnC,GAAAvH,eAEA+L,OAAA,aAAAxkF,SAAAm6E,eAAA,WAaA,OAXA6F,IAAAoC,aAAAx9B,eAAA4/B,OAAA9f,OAAA9f,gBACAo7B,GAAAoC,aAAAz9B,aAAA6/B,OAAA9f,OAAA/f,cAEAq7B,GAAAqC,cAAAz9B,gBACAo7B,GAAAqC,cAAA19B,cAEAq7B,GAAAsB,aAAAxiB,QAAAla,gBACAo7B,GAAAsB,aAAAxiB,QAAAna,cAEAq7B,GAAAwB,YAAA1iB,SAEAA,QAzcA,GAEA2lB,cAAAC,cACA5lB,QAAAlzC,WAAA84B,SACAigC,iBAEAC,YAAAC,iBANA7E,GAAAhgF,SAAA4yC,QAQAkyC,KAAA,WAEA,GAAAp5D,UAAA,GAAAQ,eACA,UACA,SACA,QACA,WAGA6e,MAAA,GAAA0D,cACA,MACA,OAKAg2C,cAAAzE,GAAArpB,eACA+tB,cAAA1E,GAAArpB,eAEAqpB,GAAAhlB,WAAAglB,GAAA/kB,aAAAwpB,cACAzE,GAAA9kB,WAAA8kB,GAAA/kB,aAAAvvC,SAAAs0D,GAAApc,aAEAoc,GAAAhlB,WAAAglB,GAAArhB,qBAAA+lB,eACA1E,GAAA9kB,WAAA8kB,GAAArhB,qBAAA5zB,MAAAi1C,GAAApc,aAIAghB,YAAA5E,GAAArR,gBACAkW,iBAAA7E,GAAArR,gBAEAqR,GAAAlR,YAAAkR,GAAA3O,WAAAuT,aACA5E,GAAAnQ,WAAAmQ,GAAA3O,WAAA,EAAA2O,GAAAvN,IAAA,QAAAuN,GAAAvN,IAAAuN,GAAAlO,cAAA,MACAkO,GAAAtS,cAAAsS,GAAA3O,WAAA2O,GAAArS,eAAAqS,GAAAhS,eACAgS,GAAAtS,cAAAsS,GAAA3O,WAAA2O,GAAAnS,eAAAmS,GAAAhS,eACAgS,GAAAtS,cAAAsS,GAAA3O,WAAA2O,GAAAlS,mBAAAkS,GAAA1O,SACA0O,GAAAtS,cAAAsS,GAAA3O,WAAA2O,GAAAjS,mBAAAiS,GAAA1O,SAEA0O,GAAAlR,YAAAkR,GAAA3O,WAAAwT,kBACA7E,GAAAnQ,WAAAmQ,GAAA3O,WAAA,EAAA2O,GAAAtN,KAAA,QAAAsN,GAAAtN,KAAAsN,GAAAlO,cAAA,MACAkO,GAAAtS,cAAAsS,GAAA3O,WAAA2O,GAAArS,eAAAqS,GAAAhS,eACAgS,GAAAtS,cAAAsS,GAAA3O,WAAA2O,GAAAnS,eAAAmS,GAAAhS,eACAgS,GAAAtS,cAAAsS,GAAA3O,WAAA2O,GAAAlS,mBAAAkS,GAAA1O,SACA0O,GAAAtS,cAAAsS,GAAA3O,WAAA2O,GAAAjS,mBAAAiS,GAAA1O,SAEAqT,iBAAA3E,GAAAt1D,aAAAs1D,GAAA5H,gCAAA,CAEA,IAAA1T,OAIAA,QAFAigB,kBAIAhgC,cAEA,+BAEA,+BACA,sBACA,0BAEA,kCAEA,2BACA,qBAEA,oBACA,6BAEA,gBAEA,YAEA,uBAEA,0BAEA,iEACA,6DACA,6DACA,6DACA,6DACA,6DACA,6DACA,6DACA,6DAEA,2CACA,2CACA,2CACA,2CAEA,uEACA,uEAEA,IAEA,uFAEA,KAEA3/C,KAAA,MAEA4/C,gBAEA,+BAEA,yBACA,yBACA,sBAEA,oBACA,6BAEA,gBAIA,0BAEA,6CAIA,iCAEA,wCAIA,WAEA,wCACA,sCACA,0BACA,6BAEA,IAEA,KAEA5/C,KAAA,QAQA2/C,cAEA,+BAEA,+BACA,sBACA,0BAEA,2BACA,qBAEA,oBAEA,gBAEA,YAEA,uBAEA,0BAEA,uEACA,uEAEA,IAEA,uFAEA,KAEA3/C,KAAA,MAEA4/C,gBAEA,2BAEA,+BAEA,yBACA,kCACA,yBACA,sBAEA,oBAEA,gBAIA,0BAEA,yDAIA,iCAEA,wCAIA,WAEA,oEACA,+DACA,+DACA,+DACA,2CAEA,wCACA,qCACA,0BACA,6BAEA,IAEA,KAEA5/C,KAAA,OAMA85D,QAAAoiB,cAAAxc,QAEA94C,YACA+lB,OAAAquC,GAAAS,kBAAA3hB,QAAA,YACA9wB,GAAAgyC,GAAAS,kBAAA3hB,QAAA,OAGApa,UACAqgC,WAAA/E,GAAAO,mBAAAzhB,QAAA,cACAxhB,IAAA0iC,GAAAO,mBAAAzhB,QAAA,OACAkmB,aAAAhF,GAAAO,mBAAAzhB,QAAA,gBACAzhB,QAAA2iC,GAAAO,mBAAAzhB,QAAA,WACAp7D,MAAAs8E,GAAAO,mBAAAzhB,QAAA,SACAhsC,MAAAktD,GAAAO,mBAAAzhB,QAAA,SACA16D,SAAA47E,GAAAO,mBAAAzhB,QAAA,YACAmmB,eAAAjF,GAAAO,mBAAAzhB,QAAA,mBAWA3+D,MAAAiC,OAAA,SAAA/B,MAAA2C,OAAAkiF,cAAAC,gBAEA,OAAAZ,OAAAz/E,OAAA,CAEA,GAAAsgF,cAAA,GAAAv7E,OAAAgW,QAEAwlE,UAAAF,eAAAD,cACAI,kBAAA,GAAAJ,cACAK,mBAAA,GAAAJ,eAEAj7D,KAAA,GAAAi7D,eACAryD,MAAA,GAAAjpB,OAAAiY,QAAAoI,KAAAm7D,UAAAn7D,MAEA+6D,eAAA,GAAAp7E,OAAAgW,QAAA,OACA2lE,qBAAA,GAAA37E,OAAAiY,QAAA,IAEA/X,UAAA+0D,SAEAgmB,OAIA9E,GAAAhY,WAAAlJ,SAEAkhB,GAAA4D,wBAAAh4D,WAAA+lB,QACAquC,GAAA4D,wBAAAh4D,WAAAoiB,IAKAgyC,GAAArX,UAAAjkB,SAAAsgC,aAAA,GACAhF,GAAArX,UAAAjkB,SAAApH,IAAA,GAEA0iC,GAAAhlB,WAAAglB,GAAA/kB,aAAAwpB,cACAzE,GAAAzgB,oBAAA3zC,WAAA+lB,OAAA,EAAAquC,GAAAxgB,OAAA,QACAwgB,GAAAzgB,oBAAA3zC,WAAAoiB,GAAA,EAAAgyC,GAAAxgB,OAAA,QAEAwgB,GAAAhlB,WAAAglB,GAAArhB,qBAAA+lB,eAEA1E,GAAApF,QAAAoF,GAAAnI,WACAmI,GAAAgE,WAAA,EAEA,QAAAn/E,GAAA,EAAAsM,EAAAozE,OAAAz/E,OAAqCqM,EAAAtM,EAAOA,IAAA,CAE5CqlB,KAAA,GAAAi7D,eACAryD,MAAAxiB,IAAA4Z,KAAAm7D,UAAAn7D,KAIA,IAAA0oC,OAAA2xB,OAAA1/E,EAgBA,IAdAugF,aAAA90E,IAAAsiD,MAAAztC,YAAAtG,SAAA,IAAA+zC,MAAAztC,YAAAtG,SAAA,IAAA+zC,MAAAztC,YAAAtG,SAAA,KAEAumE,aAAAjhE,aAAAnhB,OAAA6yC,oBACAuvC,aAAAhhE,gBAAAphB,OAAAiiB,kBAIAggE,eAAAt0E,KAAAy0E,cAEAI,qBAAAnhF,EAAA4gF,eAAA5gF,EAAAihF,oCACAE,qBAAAlhF,EAAA2gF,eAAA3gF,EAAAihF,sCAIAZ,kBACAa,qBAAAnhF,EAAA,GACAmhF,qBAAAnhF,EAAA6gF,eACAM,qBAAAlhF,EAAA,GACAkhF,qBAAAlhF,EAAA6gF,eAAA,CAIAnF,GAAApR,cAAAoR,GAAAyF,UACAzF,GAAAlR,YAAAkR,GAAA3O,WAAAuT,aACA5E,GAAA0F,eAAA1F,GAAA3O,WAAA,EAAA2O,GAAAvN,IAAA+S,qBAAAnhF,EAAA,EAAAmhF,qBAAAlhF,EAAA,WAKA07E,GAAArX,UAAAjkB,SAAAqgC,WAAA,GACA/E,GAAAnV,UAAAnmB,SAAA5xB,YAAAzuB,EAAAyuB,MAAAxuB,GACA07E,GAAAzX,UAAA7jB,SAAAugC,8BAAA5gF,EAAA4gF,eAAA3gF,EAAA2gF,eAAA5hF;AAEA28E,GAAApF,QAAAoF,GAAAlI,OACAkI,GAAA3I,OAAA2I,GAAA1I,YAEA0I,GAAAlC,aAAAkC,GAAAvC,UAAA,EAAAuC,GAAA5N,eAAA,GAKA4N,GAAApR,cAAAoR,GAAAnR,UACAmR,GAAAlR,YAAAkR,GAAA3O,WAAAwT,kBACA7E,GAAA0F,eAAA1F,GAAA3O,WAAA,EAAA2O,GAAAtN,KAAA8S,qBAAAnhF,EAAA,EAAAmhF,qBAAAlhF,EAAA,WAKA07E,GAAArX,UAAAjkB,SAAAqgC,WAAA,GACA/E,GAAApF,QAAAoF,GAAA1I,YAEA0I,GAAApR,cAAAoR,GAAAyF,UACAzF,GAAAlR,YAAAkR,GAAA3O,WAAAuT,aACA5E,GAAAlC,aAAAkC,GAAAvC,UAAA,EAAAuC,GAAA5N,eAAA,GAKAxf,MAAAH,eAAA9hD,KAAAs0E,gBAEAryB,MAAAF,qBAEAE,MAAAF,qBAAAE,OAIAA,MAAAD,mBAMAqtB,GAAArX,UAAAjkB,SAAAqgC,WAAA,GACA/E,GAAA3I,OAAA2I,GAAAlI,MAEA,QAAAryE,GAAA,EAAAqnC,GAAA8lB,MAAAJ,WAAA1tD,OAAkDgoC,GAAArnC,EAAQA,IAAA,CAE1D,GAAAkgF,QAAA/yB,MAAAJ,WAAA/sD,EAEAkgF,QAAAtoC,QAAA,MAAAsoC,OAAA7yD,MAAA,OAEAmyD,eAAA5gF,EAAAshF,OAAAthF,EACA4gF,eAAA3gF,EAAAqhF,OAAArhF,EACA2gF,eAAA5hF,EAAAsiF,OAAAtiF,EAEA6mB,KAAAy7D,OAAAz7D,KAAAy7D,OAAA7yD,MAAAqyD,eAEAryD,MAAAzuB,EAAA6lB,KAAAm7D,UACAvyD,MAAAxuB,EAAA4lB,KAEA81D,GAAAzX,UAAA7jB,SAAAugC,8BAAA5gF,EAAA4gF,eAAA3gF,EAAA2gF,eAAA5hF,GACA28E,GAAAnV,UAAAnmB,SAAA5xB,YAAAzuB,EAAAyuB,MAAAxuB,GACA07E,GAAA5X,UAAA1jB,SAAAtgD,SAAAuhF,OAAAvhF,UAEA47E,GAAA5X,UAAA1jB,SAAArH,QAAAsoC,OAAAtoC,SACA2iC,GAAAzX,UAAA7jB,SAAAhhD,MAAAiiF,OAAAjiF,MAAA6M,EAAAo1E,OAAAjiF,MAAA8M,EAAAm1E,OAAAjiF,MAAA+M,GAEAzQ,SAAAq/D,MAAA6H,YAAAye,OAAAhoC,SAAAgoC,OAAA98B,cAAA88B,OAAAh9B,SAAAg9B,OAAA/8B,UACA5oD,SAAA4oE,WAAA+c,OAAAxpC,QAAA,GAEA6jC,GAAAlC,aAAAkC,GAAAvC,UAAA,EAAAuC,GAAA5N,eAAA,MAYA4N,GAAA3I,OAAA2I,GAAAnI,WACAmI,GAAA3I,OAAA2I,GAAA1I,YACA0I,GAAAgE,WAAA,GAEAhkF,SAAA02E,kBAoCA7sE,MAAAwvE,gBAAA,SAAAuM,UAAA1c,QAAAxI,cAAAkC,wBA0VA,QAAAtC,eAAAjgE,MAAA+qB,OAAAmuB,cAEA,GAAAnuB,OAAAyZ,QAAA,CAEA,GAAA47B,cAAAC,cAAAt1C,OAAA7rB,GAEA,IAAAkhE,cAAAr1C,OAAA0Z,aAAA1Z,OAAA4Z,iBAAA,GAAA27B,SAAAlmC,iBAAArP,WAAA,GAEA,OAAAvmB,GAAA,EAAAsM,EAAAsvD,aAAA37D,OAA6CqM,EAAAtM,EAAOA,IAAA,CAEpD,GAAA+7D,aAAAH,aAAA57D,EAEAumB,QAAA42C,iBAAAh9C,iBAAAu0B,aAAA1D,mBAAAzqB,OAAAjG,aACA0gE,YAAAphF,KAAAm8D,aAMA,OAAA/7D,GAAA,EAAAsM,EAAAia,OAAAmY,SAAAz+B,OAA+CqM,EAAAtM,EAAOA,IAEtDy7D,cAAAjgE,MAAA+qB,OAAAmY,SAAA1+B,GAAA00C,eAQA,QAAAusC,oBAAAnuC,MAAAouC,SAEA,GAAAC,cAAA,GAAAn8E,OAAA+9B,gBAEAo+C,cAAAC,WAAA,EAEAD,aAAAhuC,YAAA,EACAguC,aAAAlhD,YAAA,EAEAkhD,aAAA/tC,iBAAAN,MAAAM,iBACA+tC,aAAA9tC,gBAAAP,MAAAO,gBAEA8tC,aAAA7tC,iBAAAR,MAAAQ,iBACA6tC,aAAA5tC,kBAAAT,MAAAS,kBACA4tC,aAAA1tC,mBAAAX,MAAAW,mBACA0tC,aAAA3tC,gBAAAV,MAAAU,gBAEA2tC,aAAAztC,oBAAAZ,MAAAY,oBAEAytC,aAAAvtC,eAAAd,MAAAc,eAEAutC,aAAAxtC,WAAAb,MAAAoB,kBAAAgtC,SACAC,aAAAttC,eAAAf,MAAAqB,mBAAA+sC,SACAC,aAAArtC,gBAAAhB,MAAAsB,oBAAA8sC,SAEAC,aAAAE,eACAF,aAAAG,gBAKA,QAHAD,aAAAF,aAAAE,YACAC,cAAAH,aAAAG,cAEAthF,EAAA,EAAkB,EAAAA,EAAOA,IAEzBqhF,YAAArhF,GAAA,GAAAgF,OAAAgW,QACAsmE,cAAAthF,GAAA,GAAAgF,OAAAgW,OAIA,IAAAumE,OAAAzuC,MAAAuB,mBAAA6sC,SACAM,KAAA1uC,MAAAwB,kBAAA4sC,QAYA,OAVAI,eAAA,GAAA71E,IAAA,MAAA81E,OACAD,cAAA,GAAA71E,IAAA,KAAA81E,OACAD,cAAA,GAAA71E,IAAA,KAAA81E,OACAD,cAAA,GAAA71E,IAAA,IAAA81E,OAEAD,cAAA,GAAA71E,IAAA,MAAA+1E,MACAF,cAAA,GAAA71E,IAAA,KAAA+1E,MACAF,cAAA,GAAA71E,IAAA,KAAA+1E,MACAF,cAAA,GAAA71E,IAAA,IAAA+1E,MAEAL,aAMA,QAAAM,oBAAA3uC,MAAAouC,SAEA,GAAAC,cAAAruC,MAAAyB,mBAAA2sC,QAEAC,cAAA5iF,SAAAuN,KAAAgnC,MAAAv0C,UACA4iF,aAAA/1D,OAAA7sB,SAAAuN,KAAAgnC,MAAA1nB,OAAA7sB,UACA4iF,aAAAj2D,OAAAi2D,aAAA/1D,QAEA+1D,aAAAztC,oBAAAZ,MAAAY,oBACAytC,aAAAvtC,eAAAd,MAAAc,eAEAutC,aAAAxtC,WAAAb,MAAAoB,kBAAAgtC,QAEA,IAAAK,OAAAzuC,MAAAuB,mBAAA6sC,SACAM,KAAA1uC,MAAAwB,kBAAA4sC,SAEAI,cAAAH,aAAAG,aAEAA,eAAA,GAAA9iF,EAAA+iF,MACAD,cAAA,GAAA9iF,EAAA+iF,MACAD,cAAA,GAAA9iF,EAAA+iF,MACAD,cAAA,GAAA9iF,EAAA+iF,MAEAD,cAAA,GAAA9iF,EAAAgjF,KACAF,cAAA,GAAA9iF,EAAAgjF,KACAF,cAAA,GAAA9iF,EAAAgjF,KACAF,cAAA,GAAA9iF,EAAAgjF,KAMA,QAAAE,oBAAAvjF,OAAA20C,OAEA,GAAA4B,cAAA5B,MAAA4B,aACA4sC,cAAAxuC,MAAAwuC,cACAD,YAAAvuC,MAAAuuC,WAEAM,MAAAl2E,IAAAqZ,aACA88D,KAAAn2E,MAAAqZ,mBAEA,QAAA9kB,GAAA,EAAkB,EAAAA,EAAOA,IAAA,CAEzB,GAAAjF,GAAAsmF,YAAArhF,EAEAjF,GAAA+Q,KAAAw1E,cAAAthF,IACAjF,EAAAoQ,UAAAhN,QAEApD,EAAAukB,aAAAo1B,aAAA1D,oBAEAj2C,EAAAyE,EAAAmiF,KAAAniF,IAAAmiF,KAAAniF,EAAAzE,EAAAyE,GACAzE,EAAAyE,EAAAoiF,KAAApiF,IAAAoiF,KAAApiF,EAAAzE,EAAAyE,GAEAzE,EAAA0E,EAAAkiF,KAAAliF,IAAAkiF,KAAAliF,EAAA1E,EAAA0E,GACA1E,EAAA0E,EAAAmiF,KAAAniF,IAAAmiF,KAAAniF,EAAA1E,EAAA0E,GAEA1E,EAAAyD,EAAAmjF,KAAAnjF,IAAAmjF,KAAAnjF,EAAAzD,EAAAyD,GACAzD,EAAAyD,EAAAojF,KAAApjF,IAAAojF,KAAApjF,EAAAzD,EAAAyD,GAIAk2C,aAAAtlB,KAAAuyD,KAAAniF,EACAk1C,aAAArlB,MAAAuyD,KAAApiF,EACAk1C,aAAAnlB,IAAAqyD,KAAAniF,EACAi1C,aAAAplB,OAAAqyD,KAAAliF,EAMAi1C,aAAAr2C,yBAOA,QAAAwjF,mBAAAt7D,QAEA,MAAAA,QAAA5nB,mBAAAqG,OAAAwhD,iBACAjgC,OAAA5nB,SAAA+jC,UAAA,GACAnc,OAAA5nB,SA/fA,GAEAmjF,gBAAAC,oBAAAC,mBAAAC,wBAFApwB,IAAAkvB,UAAAhzC,QAIA+tB,SAAA,GAAA92D,OAAAgvB,QACAkoC,kBAAA,GAAAl3D,OAAAkb,QAEAyhE,KAAA,GAAA38E,OAAAgW,QACA4mE,KAAA,GAAA58E,OAAAgW,QAEAknE,gBAAA,GAAAl9E,OAAAgW,QAEAgmE,eAIAmB,YAAAn9E,MAAA4rD,UAAA,UACAwxB,cAAAp9E,MAAAgiD,cAAA/3C,MAAAkzE,YAAAtiC,SAEAiiC,gBAAA,GAAA98E,OAAA6xC,gBACAgJ,SAAAuiC,cACAtiC,aAAAqiC,YAAAriC,aACAC,eAAAoiC,YAAApiC,iBAGAgiC,oBAAA,GAAA/8E,OAAA6xC,gBACAgJ,SAAAuiC,cACAtiC,aAAAqiC,YAAAriC,aACAC,eAAAoiC,YAAApiC,eACAjU,cAAA,IAGAk2C,mBAAA,GAAAh9E,OAAA6xC,gBACAgJ,SAAAuiC,cACAtiC,aAAAqiC,YAAAriC,aACAC,eAAAoiC,YAAApiC,eACAqG,UAAA,IAGA67B,wBAAA,GAAAj9E,OAAA6xC,gBACAgJ,SAAAuiC,cACAtiC,aAAAqiC,YAAAriC,aACAC,eAAAoiC,YAAApiC,eACAjU,cAAA,EACAsa,UAAA,IAGA07B,eAAAjd,aAAA,EACAkd,oBAAAld,aAAA,EACAmd,mBAAAnd,aAAA,EACAod,wBAAApd,aAAA,EAEAvpE,KAAAiC,OAAA,SAAA/B,MAAA2C,QAEA,GAAA4iF,UAAAhjF,oBAAA,GAEA,GAAAiC,GAAAklB,GAAAtkB,EAAAqnC,GAAA3c,EAEAkpB,UAAAG,aAAAD,aACAyO,OAAAxkD,SACAo9D,YAAAx1C,OAAAusB,MAEA8T,UACA9sB,EAAA,EAEA4rB,IAAA,IA0BA,KAtBAmM,IAAAwgB,WAAA,SACAxgB,IAAAkkB,QAAAlkB,IAAAohB,OAEAphB,IAAA2gB,OAAA3gB,IAAAmhB,WACAnhB,IAAA+gB,UAAA/gB,IAAAghB,KAEAkO,UAAA7P,oBAAAlsE,MAAAa,cAEAgsD,IAAAihB,SAAAjhB,IAAA+nB,OAIA/nB,IAAAihB,SAAAjhB,IAAAkhB,MAIAgO,UAAAvmB,MAAA8H,cAAA,GAMAtiE,EAAA,EAAAklB,GAAAm/C,QAAApkE,OAAmCilB,GAAAllB,EAAQA,IAI3C,GAFA8yC,MAAAuxB,QAAArkE,GAEA8yC,MAAA7S,WAEA,GAAA6S,gBAAA9tC,OAAA+9B,kBAAA+P,MAAAiB,cAEA,IAAAzoB,EAAA,EAAgBA,EAAAwnB,MAAAmB,mBAA8B3oB,IAAA,CAE9C,GAAA61D,aAEA,IAAAruC,MAAAyB,mBAAAjpB,GAmBA61D,aAAAruC,MAAAyB,mBAAAjpB,OAnBA,CAEA61D,aAAAF,mBAAAnuC,MAAAxnB,GACA61D,aAAAkB,eAAAlkF,MAEA,IAAAmkF,MAAA,GAAAt9E,OAAAu9E,SACAD,MAAA/jF,SAAAuN,KAAAgnC,MAAAkB,qBAEAsuC,KAAArjF,IAAAkiF,cACAmB,KAAArjF,IAAAkiF,aAAA/1D,QAEAjtB,OAAAc,IAAAqjF,MAEAxvC,MAAAyB,mBAAAjpB,GAAA61D,aAUAM,mBAAA3uC,MAAAxnB,GAEAs7B,OAAA9sB,GAAAqnD,aACArnD,QAMA8sB,QAAA9sB,GAAAgZ,MACAhZ,GAQA,KAAA95B,EAAA,EAAAklB,GAAA0hC,OAAA3mD,OAAkCilB,GAAAllB,EAAQA,IAAA,CAI1C,GAFA8yC,MAAA8T,OAAA5mD,IAEA8yC,MAAA0B,UAAA,CAEA,GAAAguC,cAAAx9E,MAAAkE,YAEA63E,WAAAvf,gBAAAx8D,MAAAmB,mBAEAq8E,aAAAx9E,MAAA+D,cAIA,IAAA05E,OAAgB5wC,UAAA2wC,aAAA5wC,UAAA4wC,aAAA7wC,OAAA3sC,MAAAkF,WAEhB4oC,OAAA0B,UAAA,GAAAxvC,OAAA21E,kBAAA7nC,MAAAe,eAAAf,MAAAgB,gBAAA2uC,MACA3vC,MAAA2B,cAAA,GAAAzvC,OAAAiY,QAAA61B,MAAAe,eAAAf,MAAAgB,iBAEAhB,MAAA6B,aAAA,GAAA3vC,OAAAkb,QAIA,IAAA4yB,MAAA4B,aAAA,CAEA,GAAA5B,gBAAA9tC,OAAAm+B,UAEA2P,MAAA4B,aAAA,GAAA1vC,OAAA1G,kBAAAw0C,MAAA+B,gBAAA/B,MAAAe,eAAAf,MAAAgB,gBAAAhB,MAAAM,iBAAAN,MAAAO,qBAEK,MAAAP,gBAAA9tC,OAAA+9B,kBAIA,CAEL/9B,MAAAM,MAAA,2DAAAwtC,MACA,UALAA,MAAA4B,aAAA,GAAA1vC,OAAA85B,mBAAAgU,MAAAQ,iBAAAR,MAAAS,kBAAAT,MAAAU,gBAAAV,MAAAW,mBAAAX,MAAAM,iBAAAN,MAAAO,iBASA73C,MAAAyD,IAAA6zC,MAAA4B,cAEAl5C,MAAA4yD,cAAA,GAAA5yD,MAAAirB,oBAIAqsB,MAAAY,sBAAAZ,MAAA4vC,eAEA5vC,MAAA4vC,aAAA,GAAA19E,OAAA29E,aAAA7vC,MAAA4B,cACAl5C,MAAAyD,IAAA6zC,MAAA4vC,eAIA5vC,MAAAsuC,WAAAD,aAAAkB,gBAAAlkF,QAEAujF,mBAAAvjF,OAAA20C,OAIA0B,UAAA1B,MAAA0B,UACAG,aAAA7B,MAAA6B,aACAD,aAAA5B,MAAA4B,aAIAA,aAAAn2C,SAAAojB,sBAAAmxB,MAAAxyB,aACA4hE,gBAAAvgE,sBAAAmxB,MAAA1nB,OAAA9K,aACAo0B,aAAAxpB,OAAAg3D,iBACAxtC,aAAAjuB,oBAEAiuB,aAAA1D,mBAAA3wB,WAAAq0B,aAAAp0B,aAIAwyB,MAAA4vC,eAAA5vC,MAAA4vC,aAAA1iD,QAAA8S,MAAAY,qBACAZ,MAAAY,qBAAAZ,MAAA4vC,aAAA5gF,SAIA6yC,aAAAlpC,IACA,UACA,UACA,UACA,SAGAkpC,aAAAnmC,SAAAkmC,aAAAt0B,kBACAu0B,aAAAnmC,SAAAkmC,aAAA1D,oBAIAkrB,kBAAA/7C,iBAAAu0B,aAAAt0B,iBAAAs0B,aAAA1D,oBACA8qB,SAAApnC,cAAAwnC,mBAIA6kB,UAAAvK,gBAAAhiC,WACAusC,UAAA9jF,QAIA+jF,YAAA/gF,OAAA,EAEAw7D,cAAAjgE,YAAAk5C,aAKA,IAAAkuC,gBAAAC,YAAAC,WAEA,KAAAliF,EAAA,EAAAqnC,GAAA+4C,YAAA/gF,OAAwCgoC,GAAArnC,EAAQA,IAEhDm7D,YAAAilB,YAAApgF,GAEA2lB,OAAAw1C,YAAAx1C,OACA48B,OAAA4Y,YAAA5Y,OAWAy/B,eAAAf,kBAAAt7D,QAEAs8D,YAAA39E,SAAAqhB,OAAA9nB,SAAAqtC,cAAAvlB,OAAA9nB,SAAAqtC,aAAA7rC,OAAA,GAAA2iF,eAAA92C,aACAg3C,YAAAv8D,iBAAAvhB,OAAAgmD,aAAA43B,eAAAx8B,SAIAznD,SAFA4nB,OAAAw8D,oBAEAx8D,OAAAw8D,oBAEKD,YAELD,YAAAZ,wBAAAD,mBAEKa,YAELd,oBAIAD,eAIAf,UAAAxkB,iBAAAqmB,gBAEAz/B,iBAAAn+C,OAAA8hB,eAEAi6D,UAAAvkB,mBAAA9nB,aAAA2vB,QAAA3e,IAAA/mD,SAAAwkD,OAAA58B,QAIAw6D,UAAAtkB,aAAA/nB,aAAA2vB,QAAA3e,IAAA/mD,SAAAwkD,OAAA58B,OAQA,KAAA3lB,EAAA,EAAAqnC,GAAA81B,uBAAA99D,OAAmDgoC,GAAArnC,EAAQA,IAE3Dm7D,YAAAgC,uBAAAn9D,GACA2lB,OAAAw1C,YAAAx1C,OAEAA,OAAAyZ,SAAAzZ,OAAA0Z,aAEA1Z,OAAA42C,iBAAAh9C,iBAAAu0B,aAAA1D,mBAAAzqB,OAAAjG,aAEAygE,UAAAnkB,sBAAAloB,aAAA2vB,QAAA3e,IAAAo8B,eAAAv7D,SAUA,GAAA8rD,YAAA0O,UAAA/K,gBACAgN,WAAAjC,UAAA9K,eAEApkB,KAAAwgB,sBAAA3mE,EAAA2mE,WAAA1mE,EAAA0mE,WAAAzmE,EAAAo3E,YACAnxB,IAAA2gB,OAAA3gB,IAAAohB,OAEA8N,UAAA7P,oBAAAlsE,MAAAa,eAEAgsD,IAAAihB,SAAAjhB,IAAAkhB,MAIAgO,UAAAlP,kBAwLA7sE,MAAA0vE,aAAA,SAAAv5E,SAAAwgE,SA6OA,QAAA0gB,iBAEA,GAAApiB,SAAAkhB,GAAAkB,gBAEAv8B,aAAAq7B,GAAAmC,aAAAnC,GAAAvH,eACA7zB,eAAAo7B,GAAAmC,aAAAnC,GAAAlH,gBAkGA,OAhGAkH,IAAAoC,aAAAz9B,cAEA,aAAA3kD,SAAAm6E,eAAA,UAEA,gCACA,iCACA,0BACA,sBACA,yBACA,wBAEA,2BACA,qBAEA,oBAEA,gBAEA,iCAEA,2CAEA,wBACA,iGACA,iGAEA,sBAEA,gEACA,uCACA,oDAEA,+BAEA,KAEAn1E,KAAA,OAEAg7E,GAAAoC,aAAAx9B,gBAEA,aAAA5kD,SAAAm6E,eAAA,UAEA,sBACA,yBACA,yBAEA,uBACA,yBACA,4BACA,yBACA,wBACA,2BAEA,oBAEA,gBAEA,wCAEA,wCAEA,mEAEA,uBAEA,iDACA,yBAEA,wBAEA,oDAEA,WAEA,+BACA,8EACA,kDAEA,IAEA,mFAEA,IAEA,KAEAn1E,KAAA,OAEAg7E,GAAAqC,cAAA19B,cACAq7B,GAAAqC,cAAAz9B,gBAEAo7B,GAAAsB,aAAAxiB,QAAAna,cACAq7B,GAAAsB,aAAAxiB,QAAAla,gBAEAo7B,GAAAwB,YAAA1iB,SAEAA,QAIA,QAAAsB,mBAAA7/C,EAAA9P,GAEA,MAAA8P,GAAAld,IAAAoN,EAAApN,EAEAoN,EAAApN,EAAAkd,EAAAld,EAIAoN,EAAAlR,GAAAghB,EAAAhhB,GA9VA,GAEAklF,cAAAC,cACA5lB,QAAAlzC,WAAA84B,SAEAvI,QALA6jC,GAAAhgF,SAAA4yC,QASAk1C,eAAA,GAAAj+E,OAAAgW,QACAkoE,eAAA,GAAAl+E,OAAAqT,WACA8qE,YAAA,GAAAn+E,OAAAgW,QAEAilE,KAAA,WAEA,GAAAp5D,UAAA,GAAAQ,gBACA,WACA,WACA,WACA,YAGA6e,MAAA,GAAA0D,cACA,MACA,OAGAg2C,cAAAzE,GAAArpB,eACA+tB,cAAA1E,GAAArpB,eAEAqpB,GAAAhlB,WAAAglB,GAAA/kB,aAAAwpB,cACAzE,GAAA9kB,WAAA8kB,GAAA/kB,aAAAvvC,SAAAs0D,GAAApc,aAEAoc,GAAAhlB,WAAAglB,GAAArhB,qBAAA+lB,eACA1E,GAAA9kB,WAAA8kB,GAAArhB,qBAAA5zB,MAAAi1C,GAAApc,aAEA9E,QAAAoiB,gBAEAt1D,YACAxoB,SAAA48E,GAAAS,kBAAA3hB,QAAA,YACA9wB,GAAAgyC,GAAAS,kBAAA3hB,QAAA,OAGApa,UACAujC,SAAAjI,GAAAO,mBAAAzhB,QAAA,YACAopB,QAAAlI,GAAAO,mBAAAzhB,QAAA,WAEA16D,SAAA47E,GAAAO,mBAAAzhB,QAAA,YACAhsC,MAAAktD,GAAAO,mBAAAzhB,QAAA,SAEAp7D,MAAAs8E,GAAAO,mBAAAzhB,QAAA,SACAxhB,IAAA0iC,GAAAO,mBAAAzhB,QAAA,OACAzhB,QAAA2iC,GAAAO,mBAAAzhB,QAAA,WAEA2L,gBAAAuV,GAAAO,mBAAAzhB,QAAA,mBACA75C,iBAAA+6D,GAAAO,mBAAAzhB,QAAA,oBAEAqpB,QAAAnI,GAAAO,mBAAAzhB,QAAA,WACA7K,WAAA+rB,GAAAO,mBAAAzhB,QAAA,cACA5K,QAAA8rB,GAAAO,mBAAAzhB,QAAA,WACA3K,OAAA6rB,GAAAO,mBAAAzhB,QAAA,UACA1K,SAAA4rB,GAAAO,mBAAAzhB,QAAA,YAEAzV,UAAA22B,GAAAO,mBAAAzhB,QAAA,aAGA,IAAApiB,QAAA14C,SAAAoC,cAAA,SACAs2C,QAAAlF,MAAA,EACAkF,OAAAjF,OAAA,CAEA,IAAA7E,SAAA8J,OAAAC,WAAA,KACA/J,SAAAw1C,UAAA,QACAx1C,QAAAy1C,SAAA,SAEAlsC,QAAA,GAAAtyC,OAAA2yC,QAAAE,QACAP,QAAArT,aAAA,EAIA3oC,MAAAiC,OAAA,SAAA/B,MAAA2C,QAEA,OAAAw9D,QAAA17D,OAAA,CAIAiF,SAAA+0D,SAEAgmB,OAIA9E,GAAAhY,WAAAlJ,SAEAkhB,GAAA4D,wBAAAh4D,WAAAxoB,UACA48E,GAAA4D,wBAAAh4D,WAAAoiB,IAEAgyC,GAAApF,QAAAoF,GAAAnI,WACAmI,GAAA3I,OAAA2I,GAAAlI,OAEAkI,GAAAhlB,WAAAglB,GAAA/kB,aAAAwpB,cACAzE,GAAAzgB,oBAAA3zC,WAAAxoB,SAAA,EAAA48E,GAAAxgB,OAAA,QACAwgB,GAAAzgB,oBAAA3zC,WAAAoiB,GAAA,EAAAgyC,GAAAxgB,OAAA,QAEAwgB,GAAAhlB,WAAAglB,GAAArhB,qBAAA+lB,eAEA1E,GAAA7X,iBAAAzjB,SAAAz/B,kBAAA,EAAAjiB,OAAAiiB,iBAAApG,UAEAmhE,GAAApR,cAAAoR,GAAAnR,UACAmR,GAAArX,UAAAjkB,SAAApH,IAAA,EAEA,IAAAgrC,YAAA,EACAC,aAAA,EACAh+B,IAAAlqD,MAAAkqD,GAEAA,MAEAy1B,GAAAzX,UAAA7jB,SAAA0P,SAAA7J,IAAA7mD,MAAA6M,EAAAg6C,IAAA7mD,MAAA8M,EAAA+5C,IAAA7mD,MAAA+M,GAEA85C,cAAA1gD,OAAAqpD,KAEA8sB,GAAA5X,UAAA1jB,SAAAwP,QAAA3J,IAAAl2B,MACA2rD,GAAA5X,UAAA1jB,SAAAyP,OAAA5J,IAAAj2B,KAEA0rD,GAAArX,UAAAjkB,SAAAyjC,QAAA,GACAG,WAAA,EACAC,aAAA,GAEIh+B,cAAA1gD,OAAAspD,UAEJ6sB,GAAA5X,UAAA1jB,SAAAuP,WAAA1J,IAAA6I,SAEA4sB,GAAArX,UAAAjkB,SAAAyjC,QAAA,GACAG,WAAA,EACAC,aAAA,KAMAvI,GAAArX,UAAAjkB,SAAAyjC,QAAA,GACAG,WAAA,EACAC,aAAA,EAOA,QAAA1jF,GAAA,EAAAsM,EAAAqvD,QAAA17D,OAAsCqM,EAAAtM,EAAOA,IAAA,CAE7C,GAAA8gF,QAAAnlB,QAAA37D,EAEA8gF,QAAA3jB,iBAAAh9C,iBAAAhiB,OAAA6yC,mBAAA8vC,OAAAxgE,aACAwgE,OAAAtiF,GAAAsiF,OAAA3jB,iBAAAnjD,SAAA,IAIA2hD,QAAA58B,KAAAw8B,kBAMA,QAFAttC,UAEAjuB,EAAA,EAAAsM,EAAAqvD,QAAA17D,OAAsCqM,EAAAtM,EAAOA,IAAA,CAE7C,GAAA8gF,QAAAnlB,QAAA37D,GACArB,SAAAmiF,OAAAniF,QAEAw8E,IAAA5X,UAAA1jB,SAAA2E,UAAA7lD,SAAA6lD,WACA22B,GAAA7X,iBAAAzjB,SAAA+lB,iBAAA,EAAAkb,OAAA3jB,iBAAAnjD,UAEA8mE,OAAAxgE,YAAAyO,UAAAk0D,eAAAC,eAAAC,aAEAl1D,MAAA,GAAAk1D,YAAA3jF,EACAyuB,MAAA,GAAAk1D,YAAA1jF,CAEA,IAAA6jF,SAAA,CAEA9nF,OAAAkqD,KAAA/mD,SAAA+mD,MAEA49B,QAAAI,cAIAD,aAAAH,UAEAnI,GAAArX,UAAAjkB,SAAAyjC,iBACAG,WAAAH,SAIA,OAAA3kF,SAAA85C,KAEA0iC,GAAAnV,UAAAnmB,SAAAujC,SAAAzkF,SAAA85C,IAAAzpC,OAAAxP,EAAAb,SAAA85C,IAAAzpC,OAAAvP,GACA07E,GAAAnV,UAAAnmB,SAAAwjC,QAAA1kF,SAAA85C,IAAAtB,OAAA33C,EAAAb,SAAA85C,IAAAtB,OAAA13C,KAIA07E,GAAAnV,UAAAnmB,SAAAujC,SAAA,KACAjI,GAAAnV,UAAAnmB,SAAAwjC,QAAA,MAIAlI,GAAA5X,UAAA1jB,SAAArH,QAAA75C,SAAA65C,SACA2iC,GAAAzX,UAAA7jB,SAAAhhD,MAAAF,SAAAE,MAAA6M,EAAA/M,SAAAE,MAAA8M,EAAAhN,SAAAE,MAAA+M,GAEAuvE,GAAA5X,UAAA1jB,SAAAtgD,SAAAZ,SAAAY,UACA47E,GAAA/U,WAAAvmB,SAAA5xB,aAEA9yB,SAAAq/D,MAAA6H,YAAA1jE,SAAAm6C,SAAAn6C,SAAAqlD,cAAArlD,SAAAmlD,SAAAnlD,SAAAolD,UACA5oD,SAAAq/D,MAAA8H,aAAA3jE,SAAAq6C,WACA79C,SAAAq/D,MAAA+H,cAAA5jE,SAAAs6C,YAEAt6C,SAAA85C,KAAA95C,SAAA85C,IAAAb,OAAAj5C,SAAA85C,IAAAb,MAAAjF,MAEAx3C,SAAA4oE,WAAAplE,SAAA85C,IAAA,GAIAt9C,SAAA4oE,WAAAzsB,QAAA,GAIA6jC,GAAAlC,aAAAkC,GAAAvC,UAAA,EAAAuC,GAAA5N,eAAA,GAMA4N,GAAA3I,OAAA2I,GAAAnI,WAEA73E,SAAA02E,kBAqIA7sE,MAAA2+E,eAEA/4C,MAAA,SAAAg5C,UAAAC,UAAAv1C,qBAEAtpC,MAAAK,KAAA,kIAEA,IAAA4a,OAEA4jE,qBAAA7+E,OAAAhG,OAEA6kF,UAAA/jD,kBAAA+jD,UAAA7hD,eAEA/hB,OAAA4jE,UAAA5jE,OACA4jE,oBAAAplF,UAIAmlF,UAAAh5C,MAAAi5C,UAAA5jE,OAAAquB,sBAIArqB,OAAA,SAAAxlB,UAGA,MADAuG,OAAAK,KAAA,6FACA5G,SAAAwlB,WAcAjf,MAAA8+E,YAEAnuC,YAAAzwC,OAEAu+C,YAAA,SAAAlN,IAAA2Q,QAAA5K,OAAAE,SAEA,GAAAhF,QAAA,GAAAxyC,OAAAuwC,WACAiC,QAAA7B,YAAAr6C,KAAAq6C,WAEA,IAAA2B,SAAA,GAAAtyC,OAAA2yC,QAAAzyC,OAAAgiD,QAiBA,OAfA1P,QAAAE,KAAAnB,IAAA,SAAAqB,OAEAN,QAAAM,YACAN,QAAArT,aAAA,EAEAqY,eAAAhF,UAEGpyC,OAAA,SAAA04B,OAEH4e,iBAAA5e,SAIA0Z,QAAAJ,WAAAX,IAEAe,SAIAysC,gBAAA,SAAAj1E,MAAAo4C,QAAA5K,OAAAE,SAEA,GAAA8D,WAEA9I,OAAA,GAAAxyC,OAAAuwC,WACAiC,QAAA7B,YAAAr6C,KAAAq6C,WAEA,IAAA2B,SAAA,GAAAtyC,OAAA0iD,YAAApH,OAAA4G,QAIA5P,SAAAiQ,OAAA,CAwBA,QAtBA5sD,QAAA,EAEA8oD,YAAA,SAAAzjD,GAEAw3C,OAAAE,KAAA5oC,MAAA9O,GAAA,SAAA43C,OAEAN,QAAAgJ,OAAAtgD,GAAA43C,MAEAj9C,QAAA,EAEA,IAAAA,SAEA28C,QAAArT,aAAA,EAEAqY,eAAAhF,WAIIpyC,OAAAs3C,UAIJx8C,EAAA,EAAAklB,GAAApW,MAAA7O,OAAqCilB,GAAAllB,IAAQA,EAE7CyjD,YAAAzjD,EAIA,OAAAs3C,UAIA0sC,sBAAA,WAEAh/E,MAAAM,MAAA,0FAIA2+E,0BAAA,WAEAj/E,MAAAM,MAAA,8FAIA4+E,aAAA,SAAAtsC,MAAAmJ,OAIA,GAAAtgC,OAAA,SAAA/E,EAAA9P,GAEA,OAAA8P,EAAA,GAAA9P,EAAA,GAAA8P,EAAA,GAAA9P,EAAA,GAAA8P,EAAA,GAAA9P,EAAA,GAAA8P,EAAA,GAAA9P,EAAA,GAAA8P,EAAA,GAAA9P,EAAA,GAAA8P,EAAA,GAAA9P,EAAA,KAIAu4E,SAAA,SAAAzoE,EAAA9P,GAEA,OAAA8P,EAAA,GAAA9P,EAAA,GAAA8P,EAAA,GAAA9P,EAAA,GAAA8P,EAAA,GAAA9P,EAAA,KAIAwP,UAAA,SAAAM,GAEA,GAAApP,GAAAnH,KAAAmI,KAAAoO,EAAA,GAAAA,EAAA,GAAAA,EAAA,GAAAA,EAAA,GAAAA,EAAA,GAAAA,EAAA,GACA,QAAAA,EAAA,GAAApP,EAAAoP,EAAA,GAAApP,EAAAoP,EAAA,GAAApP,GAIAy0C,OAAA,EAAAA,KAEA,IAAApO,OAAAiF,MAAAjF,MACAC,OAAAgF,MAAAhF,OAEAiF,OAAA14C,SAAAoC,cAAA,SACAs2C,QAAAlF,YACAkF,OAAAjF,aAEA,IAAA7E,SAAA8J,OAAAC,WAAA,KACA/J,SAAAgK,UAAAH,MAAA,IAMA,QAJA/U,MAAAkL,QAAAq2C,aAAA,IAAAzxC,MAAAC,QAAA/P,KACAwhD,UAAAt2C,QAAAu2C,gBAAA3xC,MAAAC,QACAzQ,OAAAkiD,UAAAxhD,KAEArjC,EAAA,EAAkBmzC,MAAAnzC,EAAWA,IAE7B,OAAAC,GAAA,EAAmBmzC,OAAAnzC,EAAYA,IAAA,CAE/B,GAAA8kF,IAAA,EAAA9kF,EAAA,IAAAA,EAAA,EACA+kF,GAAA/kF,EAAA,EAAAmzC,OAAA,EAAAA,OAAA,EAAAnzC,EAAA,EACAglF,GAAA,EAAAjlF,EAAA,IAAAA,EAAA,EACAklF,GAAAllF,EAAA,EAAAmzC,MAAA,EAAAA,MAAA,EAAAnzC,EAAA,EAEAwlB,UACAmL,QAAA,IAAA0S,KAAA,GAAApjC,EAAAkzC,MAAAnzC,IAAA,IAAAuhD,MACA/7B,QAAAplB,MAAA,KAAAijC,KAAA,GAAApjC,EAAAkzC,MAAA8xC,KAAA,IAAA1jC,QACA/7B,OAAAplB,MAAA,MAAAijC,KAAA,GAAA0hD,GAAA5xC,MAAA8xC,KAAA,IAAA1jC,QACA/7B,OAAAplB,MAAA,KAAAijC,KAAA,GAAA0hD,GAAA5xC,MAAAnzC,IAAA,IAAAuhD,QACA/7B,OAAAplB,MAAA,KAAAijC,KAAA,GAAA0hD,GAAA5xC,MAAA+xC,KAAA,IAAA3jC,QACA/7B,OAAAplB,MAAA,IAAAijC,KAAA,GAAApjC,EAAAkzC,MAAA+xC,KAAA,IAAA3jC,QACA/7B,OAAAplB,MAAA,IAAAijC,KAAA,GAAA2hD,GAAA7xC,MAAA+xC,KAAA,IAAA3jC,QACA/7B,OAAAplB,MAAA,IAAAijC,KAAA,GAAA2hD,GAAA7xC,MAAAnzC,IAAA,IAAAuhD,QACA/7B,OAAAplB,MAAA,KAAAijC,KAAA,GAAA2hD,GAAA7xC,MAAA8xC,KAAA,IAAA1jC,OAKA,QAHAza,YACAq+C,WAAA3/D,OAAA/kB,OAEAD,EAAA,EAAoB2kF,WAAA3kF,EAAgBA,IAAA,CAEpC,GAAA4a,IAAAoK,OAAAhlB,GACA4e,GAAAoG,QAAAhlB,EAAA,GAAA2kF,WACA/pE,IAAAupE,SAAAvpE,GAAAuV,QACAvR,GAAAulE,SAAAvlE,GAAAuR,QACAmW,QAAA1mC,KAAAwb,UAAAqF,MAAA7F,GAAAgE,MAMA,OAFAwC,SAAA,OAEAphB,EAAA,EAAoBA,EAAAsmC,QAAArmC,OAAoBD,IAExCohB,OAAA,IAAAklB,QAAAtmC,GAAA,GACAohB,OAAA,IAAAklB,QAAAtmC,GAAA,GACAohB,OAAA,IAAAklB,QAAAtmC,GAAA,EAIAohB,QAAA,IAAAklB,QAAArmC,OACAmhB,OAAA,IAAAklB,QAAArmC,OACAmhB,OAAA,IAAAklB,QAAArmC,MAEA,IAAA0vC,KAAA,GAAAlwC,EAAAkzC,MAAAnzC,EAEA2iC,QAAAwN,MAAAvuB,OAAA,cACA+gB,OAAAwN,IAAA,IAAAvuB,OAAA,cACA+gB,OAAAwN,IAAA,OAAAvuB,OAAA,KACA+gB,OAAAwN,IAAA,OAQA,MAFA5B,SAAA62C,aAAAP,UAAA,KAEAxsC,QAIAgtC,oBAAA,SAAAlyC,MAAAC,OAAA/zC,OASA,OAPAwmB,MAAAstB,MAAAC,OACA/P,KAAA,GAAAg7C,YAAA,EAAAx4D,MAEA3Z,EAAAvG,KAAA+G,MAAA,IAAArN,MAAA6M,GACAC,EAAAxG,KAAA+G,MAAA,IAAArN,MAAA8M,GACAC,EAAAzG,KAAA+G,MAAA,IAAArN,MAAA+M,GAEA5L,EAAA,EAAkBqlB,KAAArlB,EAAUA,IAE5B6iC,KAAA,EAAA7iC,GAAA0L,EACAm3B,KAAA,EAAA7iC,EAAA,GAAA2L,EACAk3B,KAAA,EAAA7iC,EAAA,GAAA4L,CAIA,IAAA0rC,SAAA,GAAAtyC,OAAAk+C,YAAArgB,KAAA8P,MAAAC,OAAA5tC,MAAAiF,UAGA,OAFAqtC,SAAArT,aAAA,EAEAqT,UAYAtyC,MAAA8/E,YAEAC,0BAAA,SAAAtmF,SAAAikC,WAIA,OAFAy7B,OAAA,GAAAn5D,OAAAk6B,SAEAl/B,EAAA,EAAAsM,EAAAo2B,UAAAziC,OAAwCqM,EAAAtM,EAAOA,IAE/Cm+D,MAAAl/D,IAAA,GAAA+F,OAAAhG,KAAAP,SAAAikC,UAAA1iC,IAIA,OAAAm+D,QAIA6mB,OAAA,SAAAxjD,MAAAjC,OAAA/jC,OAEAgmC,MAAAhB,YAAAjB,OAAAjf,aACAif,OAAAx9B,OAAAy/B,OACAhmC,MAAAyD,IAAAuiC,QAIAyjD,OAAA,SAAAzjD,MAAAhmC,MAAA+jC,QAEA,GAAAyR,oBAAA,GAAAhsC,OAAAkb,OACA8wB,oBAAA3wB,WAAAkf,OAAAjf,aACAkhB,MAAAhB,YAAAwQ,oBAEAx1C,MAAAuG,OAAAy/B,OACAjC,OAAAtgC,IAAAuiC,SA6BAx8B,MAAAkgF,WAEAh/C,SAIApC,KAAA,aACA1K,OAAA,SACA1sB,MAAA,SACA2Y,KAAA,IACA8/D,UAAA,GAEAC,QAAA,WAEA,IAEA,MAAA9pF,MAAA4qC,MAAA5qC,KAAAwoC,MAAAxoC,KAAA89B,QAAA99B,KAAAoR,OAEG,MAAA2S,GAEH,iBAAA/jB,KAAAwoC,KAAA,SAAAxoC,KAAA89B,OAAA,eAAA99B,KAAAoR,MAAA,uBAMA24E,SAAA,SAAAxiD,MAEA,GAAAyiD,QAAAziD,KAAA0iD,WAAAhhF,cAEAihF,UAAAlqF,IASA,OAPAkqF,WAAAt/C,MAAAo/C,QAAAE,UAAAt/C,MAAAo/C,YAEAE,UAAAt/C,MAAAo/C,QAAAziD,KAAA4iD,eAAAD,UAAAt/C,MAAAo/C,QAAAziD,KAAA4iD,mBACAD,UAAAt/C,MAAAo/C,QAAAziD,KAAA4iD,eAAA5iD,KAAA6iD,cAAA7iD,KAEA2iD,UAAAt/C,MAAAo/C,QAAAziD,KAAA4iD,eAAA5iD,KAAA6iD,cAAA7iD,KAEAA,MAIA8iD,SAAA,SAAAjmC,MAIA,GAAA1/C,GACA8jC,KAAAxoC,KAAA8pF,UACAn3D,MAAA3yB,KAAA+pB,KAAAye,KAAA8hD,WACA52E,OAAA,EACAooB,MAAAyuD,OAAAnmC,MAAAroB,MAAA,IACAp3B,OAAAm3B,MAAAn3B,OAEA6lF,YAEA,KAAA9lF,EAAA,EAAcC,OAAAD,EAAYA,IAAA,CAE1B,GAAA0iD,MAAA,GAAA19C,OAAA+gF,KAEAC,IAAA1qF,KAAA2qF,mBAAA7uD,MAAAp3B,GAAA8jC,KAAA7V,MAAAjf,OAAA0zC,KACA1zC,SAAAg3E,IAAAh3E,OAEA82E,UAAAlmF,KAAAomF,IAAAtjC,MAMA,GAAA/P,OAAA3jC,OAAA,CAcA,QAAUk3E,MAAAJ,UAAA92E,OAAA2jC,QAOVszC,mBAAA,SAAAnrF,EAAAgpC,KAAA7V,MAAAjf,OAAA0zC,MAEA,GAEA1iD,GAAAi8B,GAAAkpD,UACAgB,QAAAC,OAAAnmF,OACA0pB,OAAAC,OACApqB,EAAAC,EAAA4mF,IAAAC,IAAAC,KAAAC,KAAAC,KAAAC,KAAAC,KAAAC,KACAC,MANAC,OAOAC,MAAAjjD,KAAAkjD,OAAAlsF,IAAAgpC,KAAAkjD,OAAA,IAEA,IAAAD,MAAA,CAEA,GAAAA,MAAAvnB,EAQA,IANA2mB,QAAAY,MAAAE,iBAAAF,MAAAE,eAAAF,MAAAvnB,EAAAnoC,MAAA,MACAp3B,OAAAkmF,QAAAlmF,OAEA0pB,OAAAsE,MACArE,OAAAqE,MAEAjuB,EAAA,EAAeC,OAAAD,GAMf,OAJAomF,OAAAD,QAAAnmF,MAMA,QAIAR,EAAA2mF,QAAAnmF,KAAA2pB,OAAA3a,OACAvP,EAAA0mF,QAAAnmF,KAAA4pB,OAEA84B,KAAAwkC,OAAA1nF,EAAAC,EACA,MAEA,SAIAD,EAAA2mF,QAAAnmF,KAAA2pB,OAAA3a,OACAvP,EAAA0mF,QAAAnmF,KAAA4pB,OACA84B,KAAAykC,OAAA3nF,EAAAC,EACA,MAEA,SAaA,GATA4mF,IAAAF,QAAAnmF,KAAA2pB,OAAA3a,OACAs3E,IAAAH,QAAAnmF,KAAA4pB,OACA68D,KAAAN,QAAAnmF,KAAA2pB,OAAA3a,OACA03E,KAAAP,QAAAnmF,KAAA4pB,OAEA84B,KAAA0kC,iBAAAX,KAAAC,KAAAL,IAAAC,KAEAO,MAAAC,QAAA7mF,OAAA,GAOA,IAHAsmF,KAAAM,MAAArnF,EACAgnF,KAAAK,MAAApnF,EAEAw8B,GAAA,EAAAkpD,UAAA7pF,KAAA6pF,UAA+CA,WAAAlpD,GAAiBA,KAAA,CAEhE,GAAAxvB,GAAAwvB,GAAAkpD,SACAngF,OAAAqiF,MAAAC,MAAAxvD,GAAArrB,EAAA85E,KAAAE,KAAAJ,KACArhF,MAAAqiF,MAAAC,MAAAxvD,GAAArrB,EAAA+5E,KAAAE,KAAAJ,KAKA,KAEA,SAeA,GAXAD,IAAAF,QAAAnmF,KAAA2pB,OAAA3a,OACAs3E,IAAAH,QAAAnmF,KAAA4pB,OACA68D,KAAAN,QAAAnmF,KAAA2pB,OAAA3a,OACA03E,KAAAP,QAAAnmF,KAAA4pB,OACA+8D,KAAAR,QAAAnmF,KAAA2pB,OAAA3a,OACA43E,KAAAT,QAAAnmF,KAAA4pB,OAEA84B,KAAA6kC,cAAAd,KAAAC,KAAAC,KAAAC,KAAAP,IAAAC,KAEAO,MAAAC,QAAA7mF,OAAA,GAOA,IAHAsmF,KAAAM,MAAArnF,EACAgnF,KAAAK,MAAApnF,EAEAw8B,GAAA,EAAAkpD,UAAA7pF,KAAA6pF,UAA+CA,WAAAlpD,GAAiBA,KAAA,CAEhE,GAAAxvB,GAAAwvB,GAAAkpD,SACAngF,OAAAqiF,MAAAC,MAAAE,GAAA/6E,EAAA85E,KAAAE,KAAAE,KAAAN,KACArhF,MAAAqiF,MAAAC,MAAAE,GAAA/6E,EAAA+5E,KAAAE,KAAAE,KAAAN,MAeA,OAAUt3E,OAAA+3E,MAAAU,GAAAx5D,MAAAy0B,cAMV19C,MAAAkgF,UAAAwC,eAAA,SAAAhoC,KAAArP,YAIAA,yBAEA,IAAAhrB,MAAAngB,SAAAmrC,WAAAhrB,KAAAgrB,WAAAhrB,KAAA,IACAsiE,cAAAziF,SAAAmrC,WAAAs3C,cAAAt3C,WAAAs3C,cAAA,EAEAC,KAAA1iF,SAAAmrC,WAAAu3C,KAAAv3C,WAAAu3C,KAAA,aACAxuD,OAAAl0B,SAAAmrC,WAAAjX,OAAAiX,WAAAjX,OAAA,SACA1sB,MAAAxH,SAAAmrC,WAAA3jC,MAAA2jC,WAAA3jC,MAAA,QAEA1H,OAAAkgF,UAAA7/D,UACArgB,MAAAkgF,UAAAC,UAAAwC,cAEA3iF,MAAAkgF,UAAAphD,KAAA8jD,KACA5iF,MAAAkgF,UAAA9rD,cACAp0B,MAAAkgF,UAAAx4E,WASA,QALAm2B,MAAA79B,MAAAkgF,UAAAS,SAAAjmC,MAEAwmC,MAAArjD,KAAAqjD,MACA2B,UAEA9sF,EAAA,EAAA6mE,GAAAskB,MAAAjmF,OAAoC2hE,GAAA7mE,EAAQA,IAE5Cw8B,MAAA37B,UAAAgE,KAAA/C,MAAAgrF,OAAA3B,MAAAnrF,GAAA+sF,WAIA,OAAAD,SAoBA,SAAAE,WAEA,GAAAC,SAAA,MAIAC,QAAA,SAAAC,QAAAlgD,SAEA,GAAA1c,GAAA48D,QAAAjoF,MAEA,MAAAqrB,EAAA,WAEA,IAMAuQ,GAAAtgB,EAAAjD,EANAvY,UACAooF,SACAC,cAMA,IAAAjsD,KAAA+rD,SAAA,EAEA,IAAA3sE,EAAA,EAAe+P,EAAA/P,EAAOA,IAAA4sE,MAAA5sE,SAItB,KAAAA,EAAA,EAAe+P,EAAA/P,EAAOA,IAAA4sE,MAAA5sE,GAAA+P,EAAA,EAAA/P,CAItB,IAAA8sE,IAAA/8D,EAIA6Z,MAAA,EAAAkjD,EAEA,KAAA9sE,EAAA8sE,GAAA,EAAmBA,GAAA,GAAQ,CAI3B,GAAAljD,SAAA,EASA,MAFAngC,OAAAK,KAAA,qFAEA2iC,QAAAogD,YACAroF,MAUA,IAJA87B,EAAAtgB,EAASsgB,GAAAwsD,KAAAxsD,EAAA,GACTtgB,EAAAsgB,EAAA,EAAatgB,GAAA8sE,KAAA9sE,EAAA,GACbjD,EAAAiD,EAAA,EAAajD,GAAA+vE,KAAA/vE,EAAA,GAEbgwE,KAAAJ,QAAArsD,EAAAtgB,EAAAjD,EAAA+vE,GAAAF,OAAA,CAEA,GAAAzsE,GAAA9P,EAAA9Q,EAAAuR,EAAAI,CAmBA,KAfAiP,EAAAysE,MAAAtsD,GACAjwB,EAAAu8E,MAAA5sE,GACAzgB,EAAAqtF,MAAA7vE,GAIAvY,OAAAH,MAAAsoF,QAAAxsE,GACAwsE,QAAAt8E,GACAs8E,QAAAptF,KAGAstF,YAAAxoF,MAAAuoF,MAAAtsD,GAAAssD,MAAA5sE,GAAA4sE,MAAA7vE,KAIAjM,EAAAkP,EAAA9O,EAAA8O,EAAA,EAA2B8sE,GAAA57E,EAAQJ,IAAAI,IAEnC07E,MAAA97E,GAAA87E,MAAA17E,EAIA47E,MAIAljD,MAAA,EAAAkjD,IAMA,MAAArgD,SAAAogD,YACAroF,QAMAo8B,KAAA,SAAA+rD,SAKA,OAHA58D,GAAA48D,QAAAjoF,OACAyb,EAAA,EAEA3gB,EAAAuwB,EAAA,EAAA9e,EAAA,EAA6B8e,EAAA9e,EAAOzR,EAAAyR,IAEpCkP,GAAAwsE,QAAAntF,GAAAyE,EAAA0oF,QAAA17E,GAAA/M,EAAAyoF,QAAA17E,GAAAhN,EAAA0oF,QAAAntF,GAAA0E,CAIA,UAAAic,GAIA4sE,KAAA,SAAAJ,QAAArsD,EAAAtgB,EAAAjD,EAAAgT,EAAA68D,OAEA,GAAAptF,GACA2lB,GAAAC,GAAAE,GAAAC,GACAoxB,GAAAC,GAAAo2C,GAAAC,EAWA,IATA9nE,GAAAwnE,QAAAC,MAAAtsD,IAAAr8B,EACAmhB,GAAAunE,QAAAC,MAAAtsD,IAAAp8B,EAEAohB,GAAAqnE,QAAAC,MAAA5sE,IAAA/b,EACAshB,GAAAonE,QAAAC,MAAA5sE,IAAA9b,EAEAyyC,GAAAg2C,QAAAC,MAAA7vE,IAAA9Y,EACA2yC,GAAA+1C,QAAAC,MAAA7vE,IAAA7Y,EAEAuoF,SAAAnnE,GAAAH,KAAAyxB,GAAAxxB,KAAAG,GAAAH,KAAAuxB,GAAAxxB,IAAA,QAEA,IAAA+nE,IAAAC,GAAAC,GAAAC,GAAAC,GAAAC,GACAC,IAAAC,IAAAC,IAAAC,IAAA7C,IAAAC,IACA6C,SAAAC,SAAAC,QAMA,KAJAZ,GAAAv2C,GAAArxB,GAAe6nE,GAAAv2C,GAAArxB,GACf6nE,GAAAjoE,GAAAwxB,GAAe02C,GAAAjoE,GAAAwxB,GACf02C,GAAAhoE,GAAAH,GAAeooE,GAAAhoE,GAAAH,GAEf5lB,EAAA,EAAcuwB,EAAAvwB,EAAOA,IAKrB,GAHAwtF,GAAAL,QAAAC,MAAAptF,IAAAyE,EACAgpF,GAAAN,QAAAC,MAAAptF,IAAA0E,IAEA8oF,KAAA7nE,IAAA8nE,KAAA7nE,IACA4nE,KAAA1nE,IAAA2nE,KAAA1nE,IACAynE,KAAAr2C,IAAAs2C,KAAAr2C,MAEA42C,IAAAR,GAAA7nE,GAAiBsoE,IAAAR,GAAA7nE,GACjBsoE,IAAAV,GAAA1nE,GAAiBqoE,IAAAV,GAAA1nE,GACjBulE,IAAAkC,GAAAr2C,GAAiBo0C,IAAAkC,GAAAr2C,GAIjBk3C,SAAAZ,GAAAS,IAAAR,GAAAO,IACAE,SAAAN,GAAAG,IAAAF,GAAAC,IACAK,SAAAT,GAAArC,IAAAsC,GAAAvC,IAEAgD,WAAArB,SAAAoB,WAAApB,SAAAmB,WAAAnB,SAAA,QAIA,UAQA,OAHAD,WAAAuB,YAAArB,QACAF,UAAAuB,YAAAntD,UAEA4rD,WAEC/iF,MAAAkgF,WAGD7nF,KAAAksF,cAAqBrjD,MAAAlhC,MAAAkgF,UAAAh/C,MAAAm/C,SAAArgF,MAAAkgF,UAAAG,UACrBrgF,MAAAwkF,YAAAnsF,KAAAksF,aAQAvkF,MAAAykF,MAAA,SAAAnsD,UAEAt4B,MAAAk6B,SAAAtkC,KAAAU,MAEAA,KAAAoG,KAAA,QAEApG,KAAAyyC,QAAAzQ,SAAAyQ,QACAzyC,KAAAouF,OAAApuF,KAAAyyC,QAAA47C,qBACAruF,KAAAouF,OAAAE,QAAAtuF,KAAAuuF,QAAAxnF,KAAA/G,MAEAA,KAAAwuF,KAAAxuF,KAAAyyC,QAAAg8C,aACAzuF,KAAAwuF,KAAAE,QAAA1uF,KAAAyyC,QAAAk8C,aAEA3uF,KAAA4uF,OAAA5uF,KAAAyyC,QAAAo8C,eACA7uF,KAAA4uF,OAAAF,QAAA1uF,KAAAwuF,MAEAxuF,KAAA8uF,UAAA,EAEA9uF,KAAAihC,UAAA,EACAjhC,KAAA+uF,WAAA,GAIArlF,MAAAykF,MAAA7tF,UAAAujC,OAAAiG,OAAApgC,MAAAk6B,SAAAtjC,WACAoJ,MAAAykF,MAAA7tF,UAAAM,YAAA8I,MAAAykF,MAEAzkF,MAAAykF,MAAA7tF,UAAA87C,KAAA,SAAA1C,MAEA,GAAAxuB,OAAAlrB,KAEAohD,QAAA,GAAAC,eAgBA,OAfAD,SAAAE,KAAA,MAAA5H,MAAA,GACA0H,QAAAK,aAAA,cACAL,QAAA4tC,OAAA,SAAAjrE,GAEAmH,MAAAunB,QAAAw8C,gBAAAjvF,KAAAuhD,SAAA,SAAAsG,QAEA38B,MAAAkjE,OAAAvmC,cAEA38B,MAAA4jE,UAAA5jE,MAAAgkE,UAKA9tC,QAAAM,OAEA1hD,MAIA0J,MAAAykF,MAAA7tF,UAAA4uF,KAAA,WAEA,GAAAlvF,KAAA+uF,aAAA,EAGA,WADArlF,OAAAK,KAAA,yCAKA,IAAAqkF,QAAApuF,KAAAyyC,QAAA47C,oBAEAD,QAAAvmC,OAAA7nD,KAAAouF,OAAAvmC,OACAumC,OAAAe,KAAAnvF,KAAAouF,OAAAe,KACAf,OAAAE,QAAAtuF,KAAAouF,OAAAE,QACAF,OAAAM,QAAA1uF,KAAA4uF,QACAR,OAAA5lE,MAAA,EAAAxoB,KAAAihC,WAEAjhC,KAAA+uF,WAAA,EAEA/uF,KAAAouF,eAIA1kF,MAAAykF,MAAA7tF,UAAA8uF,MAAA,WAEApvF,KAAAouF,OAAA5sD,OACAxhC,KAAAihC,UAAAjhC,KAAAyyC,QAAA48C,aAIA3lF,MAAAykF,MAAA7tF,UAAAkhC,KAAA,WAEAxhC,KAAAouF,OAAA5sD,OACAxhC,KAAAihC,UAAA,GAIAv3B,MAAAykF,MAAA7tF,UAAAiuF,QAAA,WAEAvuF,KAAA+uF,WAAA,GAIArlF,MAAAykF,MAAA7tF,UAAAgvF,QAAA,SAAA/+E,OAEAvQ,KAAAouF,OAAAe,KAAA5+E,OAIA7G,MAAAykF,MAAA7tF,UAAAivF,eAAA,SAAAh/E,OAEAvQ,KAAA4uF,OAAAY,YAAAj/E,OAIA7G,MAAAykF,MAAA7tF,UAAAmvF,iBAAA,SAAAl/E,OAEAvQ,KAAA4uF,OAAAc,cAAAn/E,OAIA7G,MAAAykF,MAAA7tF,UAAAqvF,UAAA,SAAAp/E,OAEAvQ,KAAAwuF,UAAAj+E,aAIA7G,MAAAykF,MAAA7tF,UAAA6qB,kBAAA,WAEA,GAAAloB,UAAA,GAAAyG,OAAAgW,OAEA,iBAAAinB,OAEAj9B,MAAAk6B,SAAAtjC,UAAA6qB,kBAAA7rB,KAAAU,KAAA2mC,OAEA1jC,SAAAojB,sBAAArmB,KAAAglB,aAEAhlB,KAAA4uF,OAAAt8D,YAAArvB,SAAAiB,EAAAjB,SAAAkB,EAAAlB,SAAAC,OAYAwG,MAAAkmF,cAAA,WAEAlmF,MAAAk6B,SAAAtkC,KAAAU,MAEAA,KAAAoG,KAAA,gBAEApG,KAAAyyC,QAAA,IAAAnwC,OAAAutF,cAAAvtF,OAAAwtF,qBAIApmF,MAAAkmF,cAAAtvF,UAAAujC,OAAAiG,OAAApgC,MAAAk6B,SAAAtjC,WACAoJ,MAAAkmF,cAAAtvF,UAAAM,YAAA8I,MAAAkmF,cAEAlmF,MAAAkmF,cAAAtvF,UAAA6qB,kBAAA,WAEA,GAAAloB,UAAA,GAAAyG,OAAAgW,QACAnC,WAAA,GAAA7T,OAAAqT,WACA4V,MAAA,GAAAjpB,OAAAgW,QAEAqwE,YAAA,GAAArmF,OAAAgW,QACAswE,SAAA,GAAAtmF,OAAAgW,QAEAuwE,aAAA,GAAAvmF,OAAAgW,OAEA,iBAAAinB,OAEAj9B,MAAAk6B,SAAAtjC,UAAA6qB,kBAAA7rB,KAAAU,KAAA2mC,MAEA,IAAA3E,UAAAhiC,KAAAyyC,QAAAzQ,SACAjS,GAAA/vB,KAAA+vB,EAEA/vB,MAAAglB,YAAAyO,UAAAxwB,SAAAsa,WAAAoV,OAEAo9D,YAAA5/E,IAAA,QAAA2Q,gBAAAvD,YACAyyE,SAAA/tE,WAAAhf,SAAAgtF,cAEAjuD,SAAA1P,YAAArvB,SAAAiB,EAAAjB,SAAAkB,EAAAlB,SAAAC,GACA8+B,SAAAkuD,eAAAH,YAAA7rF,EAAA6rF,YAAA5rF,EAAA4rF,YAAA7sF,EAAA6sB,GAAA7rB,EAAA6rB,GAAA5rB,EAAA4rB,GAAA7sB,GACA8+B,SAAAmuD,YAAAH,SAAA9rF,EAAA8rF,SAAA7rF,EAAA6rF,SAAA9sF,GAEA+sF,aAAAz/E,KAAAvN,cA4CAyG,MAAA0mF,MAAA,aAOA1mF,MAAA0mF,MAAA9vF,UAAAi+B,SAAA,SAAAptB,GAGA,MADAzH,OAAAK,KAAA,qDACA,MAOAL,MAAA0mF,MAAA9vF,UAAA+vF,WAAA,SAAA9vD,GAEA,GAAApvB,GAAAnR,KAAAswF,eAAA/vD,EACA,OAAAvgC,MAAAu+B,SAAAptB,IAMAzH,MAAA0mF,MAAA9vF,UAAAiwF,UAAA,SAAA1G,WAEAA,sBAAA,EAEA,IAAA3lE,GAAAsnE,MAEA,KAAAtnE,EAAA,EAAa2lE,WAAA3lE,EAAgBA,IAE7BsnE,IAAAlnF,KAAAtE,KAAAu+B,SAAAra,EAAA2lE,WAIA,OAAA2B,MAMA9hF,MAAA0mF,MAAA9vF,UAAAkwF,gBAAA,SAAA3G,WAEAA,sBAAA,EAEA,IAAA3lE,GAAAsnE,MAEA,KAAAtnE,EAAA,EAAa2lE,WAAA3lE,EAAgBA,IAE7BsnE,IAAAlnF,KAAAtE,KAAAqwF,WAAAnsE,EAAA2lE,WAIA,OAAA2B,MAMA9hF,MAAA0mF,MAAA9vF,UAAAq+B,UAAA,WAEA,GAAA8xD,SAAAzwF,KAAA0wF,YACA,OAAAD,iBAAA9rF,OAAA,IAMA+E,MAAA0mF,MAAA9vF,UAAAowF,WAAA,SAAA7G,WAIA,GAFAA,sBAAA7pF,KAAA,qBAAAA,KAAA,0BAEAA,KAAA2wF,iBACA3wF,KAAA2wF,gBAAAhsF,QAAAklF,UAAA,IACA7pF,KAAA2oC,YAGA,MAAA3oC,MAAA2wF,eAIA3wF,MAAA2oC,aAAA,CAEA,IACAioD,SACAnxF,EAFAoxF,SACAC,KAAA9wF,KAAAu+B,SAAA,GACAwyD,IAAA,CAIA,KAFAF,MAAAvsF,KAAA,GAEA7E,EAAA,EAAaoqF,WAAApqF,EAAgBA,IAE7BmxF,QAAA5wF,KAAAu+B,SAAA9+B,EAAAoqF,WACAkH,KAAAH,QAAA7tE,WAAA+tE,MACAD,MAAAvsF,KAAAysF,KACAD,KAAAF,OAMA,OAFA5wF,MAAA2wF,gBAAAE,MAEAA,OAKAnnF,MAAA0mF,MAAA9vF,UAAA0wF,iBAAA,WACAhxF,KAAA2oC,aAAA,EACA3oC,KAAA0wF,cAKAhnF,MAAA0mF,MAAA9vF,UAAAgwF,eAAA,SAAA/vD,EAAA1X,UAEA,GAIAooE,iBAJAC,WAAAlxF,KAAA0wF,aAEAhsF,EAAA,EAAAklB,GAAAsnE,WAAAvsF,MAMAssF,iBAFApoE,SAEAA,SAIA0X,EAAA2wD,WAAAtnE,GAAA,EAUA,KAFA,GAAAunE,YAAAt0D,IAAA,EAAAC,KAAAlT,GAAA,EAEAkT,MAAAD,KAMA,GAJAn4B,EAAAmF,KAAA+G,MAAAisB,KAAAC,KAAAD,KAAA,GAEAs0D,WAAAD,WAAAxsF,GAAAusF,gBAEA,EAAAE,WAEAt0D,IAAAn4B,EAAA,MAEG,MAAAysF,WAAA,GAIA,CAEHr0D,KAAAp4B,CACA,OALAo4B,KAAAp4B,EAAA,EAiBA,GAJAA,EAAAo4B,KAIAo0D,WAAAxsF,IAAAusF,gBAAA,CAEA,GAAA9/E,GAAAzM,GAAAklB,GAAA,EACA,OAAAzY,GAMA,GAAAigF,cAAAF,WAAAxsF,GACA2sF,YAAAH,WAAAxsF,EAAA,GAEA4sF,cAAAD,YAAAD,aAIAG,iBAAAN,gBAAAG,cAAAE,cAIAngF,GAAAzM,EAAA6sF,kBAAA3nE,GAAA,EAEA,OAAAzY,IASAzH,MAAA0mF,MAAA9vF,UAAAkxF,WAAA,SAAArgF,GAEA,GAAAwB,OAAA,KACA8jB,GAAAtlB,EAAAwB,MACAgrB,GAAAxsB,EAAAwB,KAIA,GAAA8jB,QAAA,GACAkH,GAAA,IAAAA,GAAA,EAEA,IAAA8zD,KAAAzxF,KAAAu+B,SAAA9H,IACAi7D,IAAA1xF,KAAAu+B,SAAAZ,IAEAg0D,IAAAD,IAAA/9E,QAAAnT,IAAAixF,IACA,OAAAE,KAAA7xE,aAKApW,MAAA0mF,MAAA9vF,UAAAsxF,aAAA,SAAArxD,GAEA,GAAApvB,GAAAnR,KAAAswF,eAAA/vD,EACA,OAAAvgC,MAAAwxF,WAAArgF,IAYAzH,MAAA0mF,MAAApE,OAEA6F,uBAAA,SAAA1gF,EAAAwnB,GAAAC,GAAAC;AAEA,YAAA1nB,IAAAynB,GAAAD,IAAA,EAAAxnB,GAAA0nB,GAAAD,KAMAk5D,mBAAA,SAAA3gF,EAAAwnB,GAAAC,GAAAC,GAAAC,IAEA,SAAAH,IAAA,EAAAxnB,IAAA,EAAAA,GACA,EAAAynB,IAAA,EAAAznB,IAAA,EAAAA,GAAA,EAAAA,EAAAynB,IAAA,EAAAznB,GACA,EAAAA,EAAA0nB,IAAA,EAAA1nB,GAAA,EAAAA,IAAA0nB,GACA,EAAA1nB,IAAA2nB,IAIAi5D,cAAA,SAAA5gF,EAAAwnB,GAAAC,GAAAC,GAAAC,IAIA,GAAAk5D,KAAA,EAAA7gF,IAAA,EAAAA,EACA8gF,IAAA,EAAA9gF,IAAA,EAAAA,EAAA,EACA+gF,IAAA,GAAA/gF,IAAA,EAAAA,EACAghF,IAAA,EAAAhhF,IAAA,EAAAA,CAEA,OAAA6gF,KAAAC,IAAAC,IAAAC,KAMAz0D,YAAA,SAAA/E,GAAAC,GAAAC,GAAAC,GAAA3nB,GAEA,GAAAmkB,IAAA,IAAAuD,GAAAF,IACArZ,GAAA,IAAAwZ,GAAAF,IACA+E,GAAAxsB,IACAysB,GAAAzsB,EAAAwsB,EACA,UAAA/E,GAAA,EAAAC,GAAAvD,GAAAhW,IAAAse,IAAA,GAAAhF,GAAA,EAAAC,GAAA,EAAAvD,GAAAhW,IAAAqe,GAAArI,GAAAnkB,EAAAynB,KAeAlvB,MAAA0mF,MAAAtmD,OAAA,SAAAlpC,YAAAwxF,cAMA,MAJAxxF,aAAAN,UAAAujC,OAAAiG,OAAApgC,MAAA0mF,MAAA9vF,WACAM,YAAAN,UAAAM,wBACAA,YAAAN,UAAAi+B,SAAA6zD,aAEAxxF,aAgBA8I,MAAA2oF,UAAA,WAEAryF,KAAAsyF,UACAtyF,KAAAuyF,SAEAvyF,KAAAwyF,WAAA,GAGA9oF,MAAA2oF,UAAA/xF,UAAAujC,OAAAiG,OAAApgC,MAAA0mF,MAAA9vF,WACAoJ,MAAA2oF,UAAA/xF,UAAAM,YAAA8I,MAAA2oF,UAEA3oF,MAAA2oF,UAAA/xF,UAAAqD,IAAA,SAAA8uF,OAEAzyF,KAAAsyF,OAAAhuF,KAAAmuF,QAIA/oF,MAAA2oF,UAAA/xF,UAAAoyF,gBAAA,aAMAhpF,MAAA2oF,UAAA/xF,UAAAqyF,UAAA,WAIA,GAAAC,YAAA5yF,KAAAsyF,OAAA,GAAA/zD,SAAA,GACAs0D,SAAA7yF,KAAAsyF,OAAAtyF,KAAAsyF,OAAA3tF,OAAA,GAAA45B,SAAA,EAEAq0D,YAAAt/E,OAAAu/E,WACA7yF,KAAAsyF,OAAAhuF,KAAA,GAAAoF,OAAAopF,UAAAD,SAAAD,cAcAlpF,MAAA2oF,UAAA/xF,UAAAi+B,SAAA,SAAAptB,GAQA,IANA,GAEAkkB,MAAAo9D,MAFAvuE,EAAA/S,EAAAnR,KAAA2+B,YACAo0D,aAAA/yF,KAAAgzF,kBACAtuF,EAAA,EAIAA,EAAAquF,aAAApuF,QAAA,CAEA,GAAAouF,aAAAruF,IAAAwf,EAAA,CAEAmR,KAAA09D,aAAAruF,GAAAwf,EACAuuE,MAAAzyF,KAAAsyF,OAAA5tF,EAEA,IAAA67B,GAAA,EAAAlL,KAAAo9D,MAAA9zD,WAEA,OAAA8zD,OAAApC,WAAA9vD,GAIA77B,IAIA,aAeAgF,MAAA2oF,UAAA/xF,UAAAq+B,UAAA,WAEA,GAAAs0D,MAAAjzF,KAAAgzF,iBACA,OAAAC,WAAAtuF,OAAA,IAOA+E,MAAA2oF,UAAA/xF,UAAA0yF,gBAAA,WAIA,GAAAhzF,KAAAkzF,cAAAlzF,KAAAkzF,aAAAvuF,QAAA3E,KAAAsyF,OAAA3tF,OAEA,MAAA3E,MAAAkzF,YAOA,IACAxuF,GADA+rF,WAAA0C,KAAA,EACAvpE,GAAA5pB,KAAAsyF,OAAA3tF,MAEA,KAAAD,EAAA,EAAaklB,GAAAllB,EAAQA,IAErByuF,MAAAnzF,KAAAsyF,OAAA5tF,GAAAi6B,YACA8xD,QAAAnsF,KAAA6uF,KAMA,OAFAnzF,MAAAkzF,aAAAzC,QAEAA,SAQA/mF,MAAA2oF,UAAA/xF,UAAAm4B,eAAA,WAEA,GAEA26D,MAAAC,KAAAC,KACAC,KAAAC,KAAAC,KAHA/pE,OAAA1pB,KAAAuwF,WAKA6C,MAAAC,KAAA5pC,OAAAiqC,kBACAH,KAAAC,KAAA/pC,OAAAkqC,iBAEA,IAAAl0F,GAAAiF,EAAAklB,GAAAmnE,IAEA1yD,GAAA3U,OAAA,YAAAhgB,OAAAgW,OAIA,KAFAqxE,IAAA1yD,GAAA,GAAA30B,OAAAgW,QAAA,GAAAhW,OAAAiY,QAEAjd,EAAA,EAAAklB,GAAAF,OAAA/kB,OAAiCilB,GAAAllB,EAAQA,IAEzCjF,EAAAiqB,OAAAhlB,GAEAjF,EAAAyE,EAAAkvF,UAAA3zF,EAAAyE,EACAzE,EAAAyE,EAAAqvF,YAAA9zF,EAAAyE,GAEAzE,EAAA0E,EAAAkvF,UAAA5zF,EAAA0E,EACA1E,EAAA0E,EAAAqvF,YAAA/zF,EAAA0E,GAEAk6B,KAEA5+B,EAAAyD,EAAAowF,UAAA7zF,EAAAyD,EACAzD,EAAAyD,EAAAuwF,YAAAh0F,EAAAyD,IAIA6tF,IAAAptF,IAAAlE,EAIA,IAAAirF,MAEA6I,UACAC,UACAJ,UACAC,UAWA,OAPAh1D,MAEAqsD,IAAA4I,UACA5I,IAAA+I,WAIA/I,KAUAhhF,MAAA2oF,UAAA/xF,UAAAszF,qBAAA,SAAA/J,WAEA,GAAA2B,KAAAxrF,KAAAuwF,UAAA1G,WAAA,EACA,OAAA7pF,MAAA6zF,eAAArI,MAMA9hF,MAAA2oF,UAAA/xF,UAAAwzF,2BAAA,SAAAjK,WAEA,GAAA2B,KAAAxrF,KAAAwwF,gBAAA3G,WAAA,EACA,OAAA7pF,MAAA6zF,eAAArI,MAIA9hF,MAAA2oF,UAAA/xF,UAAAuzF,eAAA,SAAAnqE,QAIA,OAFAvmB,UAAA,GAAAuG,OAAA4hB,SAEA5mB,EAAA,EAAiBA,EAAAglB,OAAA/kB,OAAmBD,IAEpCvB,SAAAooB,SAAAjnB,KAAA,GAAAoF,OAAAgW,QAAAgK,OAAAhlB,GAAAR,EAAAwlB,OAAAhlB,GAAAP,EAAAulB,OAAAhlB,GAAAxB,GAAA,GAIA,OAAAC,WAWAuG,MAAA2oF,UAAA/xF,UAAAyzF,YAAA,SAAAC,UAEAh0F,KAAAuyF,MAAAjuF,KAAA0vF,WAIAtqF,MAAA2oF,UAAA/xF,UAAA2zF,qBAAA,SAAAruC,SAAA2sC,OAEA,GACA7tF,GAAAklB,GADAsqE,OAAAl0F,KAAAuwF,UAAA3qC,SASA,KANA2sC,QAEAA,MAAAvyF,KAAAuyF,OAIA7tF,EAAA,EAAAklB,GAAA2oE,MAAA5tF,OAAgCilB,GAAAllB,EAAQA,IAExCwvF,OAAAl0F,KAAAm0F,cAAAD,OAAA3B,MAAA7tF,GAIA,OAAAwvF,SAIAxqF,MAAA2oF,UAAA/xF,UAAA8zF,2BAAA,SAAAxuC,SAAA2sC,OAEA,GAEA7tF,GAAAklB,GAFAsqE,OAAAl0F,KAAAwwF,gBAAA5qC,SAUA,KANA2sC,QAEAA,MAAAvyF,KAAAuyF,OAIA7tF,EAAA,EAAAklB,GAAA2oE,MAAA5tF,OAAgCilB,GAAAllB,EAAQA,IAExCwvF,OAAAl0F,KAAAm0F,cAAAD,OAAA3B,MAAA7tF,GAIA,OAAAwvF,SAOAxqF,MAAA2oF,UAAA/xF,UAAA6zF,cAAA,SAAAD,OAAA9sC,MAEA,GAEA1iD,GAAAklB,GAAAnqB,EAAA40F,KAAAC,KAAAC,MAFAC,OAAAx0F,KAAAy4B,gBAIA,KAAA/zB,EAAA,EAAAklB,GAAAsqE,OAAAvvF,OAAiCilB,GAAAllB,EAAQA,IAAA,CAEzCjF,EAAAy0F,OAAAxvF,GAEA2vF,KAAA50F,EAAAyE,EACAowF,KAAA70F,EAAA0E,EAEAowF,MAAAF,KAAAG,OAAApB,KAKAmB,MAAAntC,KAAAkpC,eAAAiE,MAAAF,KAIA,IAAAI,QAAArtC,KAAA7oB,SAAAg2D,OACAzuE,OAAAshC,KAAAoqC,WAAA+C,MACAzuE,QAAA3V,KAAA2V,OAAA3hB,EAAA2hB,OAAA5hB,GAAAiP,eAAAmhF,MAEA70F,EAAAyE,EAAAuwF,OAAAvwF,EAAA4hB,OAAA5hB,EACAzE,EAAA0E,EAAAswF,OAAAtwF,EAAA2hB,OAAA3hB,EAIA,MAAA+vF,SAWAxqF,MAAAu9E,UAAA,WAEAv9E,MAAAk6B,SAAAtkC,KAAAU,OAIA0J,MAAAu9E,UAAA3mF,UAAAujC,OAAAiG,OAAApgC,MAAAk6B,SAAAtjC,WACAoJ,MAAAu9E,UAAA3mF,UAAAM,YAAA8I,MAAAu9E,UAEAv9E,MAAAu9E,UAAA3mF,UAAA6qB,kBAAA,WAEA,GAAAupE,mBAAA,GAAAhrF,OAAAgW,QACAi1E,iBAAA,GAAAjrF,OAAAqT,WACA63E,YAAA,GAAAlrF,OAAAgW,QAEAm1E,iBAAA,GAAAnrF,OAAAgW,QACAo1E,gBAAA,GAAAprF,OAAAqT,WACAg4E,WAAA,GAAArrF,OAAAgW,OAEA,iBAAAinB,OAEA3mC,KAAAwkC,kBAAAxkC,KAAA0mC,gBAIA1mC,KAAAykC,wBAAAkC,SAEA3mC,KAAAikC,QAEAjkC,KAAAglB,YAAAH,iBAAA7kB,KAAAikC,OAAAjf,YAAAhlB,KAAA2kB,QAEA3kB,KAAAglB,YAAAyO,UAAAohE,iBAAAC,gBAAAC,YACA/0F,KAAA2kB,OAAA8O,UAAAihE,kBAAAC,iBAAAC,aAEA50F,KAAAglB,YAAAwO,QAAAqhE,iBAAAF,iBAAAI,aAKA/0F,KAAAglB,YAAAxU,KAAAxQ,KAAA2kB,QAKA3kB,KAAAykC,wBAAA,EAEAkC,OAAA,EAMA,QAAAjiC,GAAA,EAAAsM,EAAAhR,KAAAojC,SAAAz+B,OAA4CqM,EAAAtM,EAAOA,IAEnD1E,KAAAojC,SAAA1+B,GAAAymB,kBAAAwb,WAgBAj9B,MAAA+gF,KAAA,SAAA/gE,QAEAhgB,MAAA2oF,UAAA/yF,KAAAU,MAEAA,KAAAg1F,WAEAtrE,QAEA1pB,KAAAi1F,WAAAvrE,SAMAhgB,MAAA+gF,KAAAnqF,UAAAujC,OAAAiG,OAAApgC,MAAA2oF,UAAA/xF,WACAoJ,MAAA+gF,KAAAnqF,UAAAM,YAAA8I,MAAA+gF,KAEA/gF,MAAAwrF,aAEAC,QAAA,SACAC,QAAA,SACAC,mBAAA,mBACAC,gBAAA,gBACAC,aAAA,aACAC,IAAA,MACAC,QAAA,WAQA/rF,MAAA+gF,KAAAnqF,UAAA20F,WAAA,SAAAS,SAEA11F,KAAA4rF,OAAA8J,QAAA,GAAAxxF,EAAAwxF,QAAA,GAAAvxF,EAEA,QAAA8b,GAAA,EAAA01E,KAAAD,QAAA/wF,OAAwCgxF,KAAA11E,EAAUA,IAElDjgB,KAAA6rF,OAAA6J,QAAAz1E,GAAA/b,EAAAwxF,QAAAz1E,GAAA9b,IAQAuF,MAAA+gF,KAAAnqF,UAAAsrF,OAAA,SAAA1nF,EAAAC,GAEA,GAAAyxF,MAAA35D,MAAA37B,UAAA6R,MAAA7S,KAAAkC,UACAxB,MAAAg1F,QAAA1wF,MAAqBwmF,OAAAphF,MAAAwrF,YAAAC,QAAAS,aAIrBlsF,MAAA+gF,KAAAnqF,UAAAurF,OAAA,SAAA3nF,EAAAC,GAEA,GAAAyxF,MAAA35D,MAAA37B,UAAA6R,MAAA7S,KAAAkC,WAEAq0F,SAAA71F,KAAAg1F,QAAAh1F,KAAAg1F,QAAArwF,OAAA,GAAAixF,KAEAE,GAAAD,kBAAAlxF,OAAA,GACAoxF,GAAAF,kBAAAlxF,OAAA,GAEA8tF,MAAA,GAAA/oF,OAAAopF,UAAA,GAAAppF,OAAAiY,QAAAm0E,GAAAC,IAAA,GAAArsF,OAAAiY,QAAAzd,EAAAC,GACAnE,MAAAsyF,OAAAhuF,KAAAmuF,OAEAzyF,KAAAg1F,QAAA1wF,MAAqBwmF,OAAAphF,MAAAwrF,YAAAE,QAAAQ,aAIrBlsF,MAAA+gF,KAAAnqF,UAAAwrF,iBAAA,SAAAkK,KAAAC,KAAA9I,GAAAC,IAEA,GAAAwI,MAAA35D,MAAA37B,UAAA6R,MAAA7S,KAAAkC,WAEAq0F,SAAA71F,KAAAg1F,QAAAh1F,KAAAg1F,QAAArwF,OAAA,GAAAixF,KAEAE,GAAAD,kBAAAlxF,OAAA,GACAoxF,GAAAF,kBAAAlxF,OAAA,GAEA8tF,MAAA,GAAA/oF,OAAAwsF,qBAAA,GAAAxsF,OAAAiY,QAAAm0E,GAAAC,IACA,GAAArsF,OAAAiY,QAAAq0E,KAAAC,MACA,GAAAvsF,OAAAiY,QAAAwrE,GAAAC,IACAptF,MAAAsyF,OAAAhuF,KAAAmuF,OAEAzyF,KAAAg1F,QAAA1wF,MAAqBwmF,OAAAphF,MAAAwrF,YAAAG,mBAAAO,aAIrBlsF,MAAA+gF,KAAAnqF,UAAA2rF,cAAA,SAAAkK,MAAAC,MACAC,MAAAC,MACAnJ,GAAAC,IAEA,GAAAwI,MAAA35D,MAAA37B,UAAA6R,MAAA7S,KAAAkC,WAEAq0F,SAAA71F,KAAAg1F,QAAAh1F,KAAAg1F,QAAArwF,OAAA,GAAAixF,KAEAE,GAAAD,kBAAAlxF,OAAA,GACAoxF,GAAAF,kBAAAlxF,OAAA,GAEA8tF,MAAA,GAAA/oF,OAAA6sF,iBAAA,GAAA7sF,OAAAiY,QAAAm0E,GAAAC,IACA,GAAArsF,OAAAiY,QAAAw0E,MAAAC,OACA,GAAA1sF,OAAAiY,QAAA00E,MAAAC,OACA,GAAA5sF,OAAAiY,QAAAwrE,GAAAC,IACAptF,MAAAsyF,OAAAhuF,KAAAmuF,OAEAzyF,KAAAg1F,QAAA1wF,MAAqBwmF,OAAAphF,MAAAwrF,YAAAI,gBAAAM,aAIrBlsF,MAAA+gF,KAAAnqF,UAAAk2F,WAAA,SAAAhL,KAEA,GAAAoK,MAAA35D,MAAA37B,UAAA6R,MAAA7S,KAAAkC,WACAq0F,SAAA71F,KAAAg1F,QAAAh1F,KAAAg1F,QAAArwF,OAAA,GAAAixF,KAEAE,GAAAD,kBAAAlxF,OAAA,GACAoxF,GAAAF,kBAAAlxF,OAAA,GAEA8xF,MAAA,GAAA/sF,OAAAiY,QAAAm0E,GAAAC,IACA95D,OAAA37B,UAAAgE,KAAA/C,MAAAk1F,KAAAjL,IAEA,IAAAiH,OAAA,GAAA/oF,OAAAgtF,YAAAD,KACAz2F,MAAAsyF,OAAAhuF,KAAAmuF,OAEAzyF,KAAAg1F,QAAA1wF,MAAqBwmF,OAAAphF,MAAAwrF,YAAAK,aAAAK,aAMrBlsF,MAAA+gF,KAAAnqF,UAAAsmD,IAAA,SAAAumC,GAAAC,GAAAuJ,QACAC,YAAAC,UAAAC,YAEA,GAAAjB,UAAA71F,KAAAg1F,QAAAh1F,KAAAg1F,QAAArwF,OAAA,GAAAixF,KACAE,GAAAD,kBAAAlxF,OAAA,GACAoxF,GAAAF,kBAAAlxF,OAAA,EAEA3E,MAAA+2F,OAAA5J,GAAA2I,GAAA1I,GAAA2I,GAAAY,QACAC,YAAAC,UAAAC,aAIAptF,MAAA+gF,KAAAnqF,UAAAy2F,OAAA,SAAA5J,GAAAC,GAAAuJ,QACAC,YAAAC,UAAAC,YACA92F,KAAAg3F,WAAA7J,GAAAC,GAAAuJ,gBAAAC,YAAAC,UAAAC,aAGAptF,MAAA+gF,KAAAnqF,UAAA22F,QAAA,SAAA9J,GAAAC,GAAA8J,QAAAC,QACAP,YAAAC,UAAAC,YAEA,GAAAjB,UAAA71F,KAAAg1F,QAAAh1F,KAAAg1F,QAAArwF,OAAA,GAAAixF,KACAE,GAAAD,kBAAAlxF,OAAA,GACAoxF,GAAAF,kBAAAlxF,OAAA,EAEA3E,MAAAg3F,WAAA7J,GAAA2I,GAAA1I,GAAA2I,GAAAmB,QAAAC,QACAP,YAAAC,UAAAC,aAKAptF,MAAA+gF,KAAAnqF,UAAA02F,WAAA,SAAA7J,GAAAC,GAAA8J,QAAAC,QACAP,YAAAC,UAAAC,YAEA,GAAAlB,MAAA35D,MAAA37B,UAAA6R,MAAA7S,KAAAkC,WACAixF,MAAA,GAAA/oF,OAAA0tF,aAAAjK,GAAAC,GAAA8J,QAAAC,QACAP,YAAAC,UAAAC,WACA92F,MAAAsyF,OAAAhuF,KAAAmuF,MAEA,IAAA4E,WAAA5E,MAAAl0D,SAAA,EACAq3D,MAAAtxF,KAAA+yF,UAAAnzF,GACA0xF,KAAAtxF,KAAA+yF,UAAAlzF,GAEAnE,KAAAg1F,QAAA1wF,MAAqBwmF,OAAAphF,MAAAwrF,YAAAO,QAAAG,aAIrBlsF,MAAA+gF,KAAAnqF,UAAAkwF,gBAAA,SAAA3G,UAAAyN,YAEAzN,sBAAA,GAIA,QAFAngE,WAEAhlB,EAAA,EAAiBmlF,UAAAnlF,EAAeA,IAEhCglB,OAAAplB,KAAAtE,KAAAu+B,SAAA75B,EAAAmlF,WAYA,OAAAngE,SAMAhgB,MAAA+gF,KAAAnqF,UAAAiwF,UAAA,SAAA1G,UAAAyN,YAEA,GAAAt3F,KAAAu3F,gBAEA,MADAp3F,SAAAC,IAAA,QACAJ,KAAAwwF,gBAAA3G,UAAAyN,WAGAzN,sBAAA,EAEA,IAEAnlF,GAAAklB,GAAAhlB,KAAAkmF,OAAA8K,KACA7K,IAAAC,IAAAK,KAAAC,KAAAH,KAAAC,KAAAH,KAAAC,KACAK,MAAAjmF,EACA6L,EAAAkiB,GAAAC,GALA5J,SAOA,KAAAhlB,EAAA,EAAAklB,GAAA5pB,KAAAg1F,QAAArwF,OAAuCilB,GAAAllB,EAAQA,IAO/C,OALAE,KAAA5E,KAAAg1F,QAAAtwF,GAEAomF,OAAAlmF,KAAAkmF,OACA8K,KAAAhxF,KAAAgxF,KAEA9K,QAEA,IAAAphF,OAAAwrF,YAAAC,QAEAzrE,OAAAplB,KAAA,GAAAoF,OAAAiY,QAAAi0E,KAAA,GAAAA,KAAA,IAEA,MAEA,KAAAlsF,OAAAwrF,YAAAE,QAEA1rE,OAAAplB,KAAA,GAAAoF,OAAAiY,QAAAi0E,KAAA,GAAAA,KAAA,IAEA,MAEA,KAAAlsF,OAAAwrF,YAAAG,mBAwBA,IAtBAtK,IAAA6K,KAAA,GACA5K,IAAA4K,KAAA,GAEAzK,KAAAyK,KAAA,GACAxK,KAAAwK,KAAA,GAEAlsE,OAAA/kB,OAAA,GAEA4mF,MAAA7hE,cAAA/kB,OAAA,GAEAsmF,KAAAM,MAAArnF,EACAgnF,KAAAK,MAAApnF,IAIAonF,MAAAvrF,KAAAg1F,QAAAtwF,EAAA,GAAAkxF,KAEA3K,KAAAM,YAAA5mF,OAAA,GACAumF,KAAAK,YAAA5mF,OAAA,IAIAW,EAAA,EAAeukF,WAAAvkF,EAAgBA,IAE/B6L,EAAA7L,EAAAukF,UAEAx2D,GAAA3pB,MAAAqiF,MAAAC,MAAAxvD,GAAArrB,EAAA85E,KAAAE,KAAAJ,KACAz3D,GAAA5pB,MAAAqiF,MAAAC,MAAAxvD,GAAArrB,EAAA+5E,KAAAE,KAAAJ,KAEAthE,OAAAplB,KAAA,GAAAoF,OAAAiY,QAAA0R,GAAAC,IAIA,MAEA,KAAA5pB,OAAAwrF,YAAAI,gBA4BA,IA1BAvK,IAAA6K,KAAA,GACA5K,IAAA4K,KAAA,GAEAzK,KAAAyK,KAAA,GACAxK,KAAAwK,KAAA,GAEAvK,KAAAuK,KAAA,GACAtK,KAAAsK,KAAA,GAEAlsE,OAAA/kB,OAAA,GAEA4mF,MAAA7hE,cAAA/kB,OAAA,GAEAsmF,KAAAM,MAAArnF,EACAgnF,KAAAK,MAAApnF,IAIAonF,MAAAvrF,KAAAg1F,QAAAtwF,EAAA,GAAAkxF,KAEA3K,KAAAM,YAAA5mF,OAAA,GACAumF,KAAAK,YAAA5mF,OAAA,IAKAW,EAAA,EAAeukF,WAAAvkF,EAAgBA,IAE/B6L,EAAA7L,EAAAukF,UAEAx2D,GAAA3pB,MAAAqiF,MAAAC,MAAAE,GAAA/6E,EAAA85E,KAAAE,KAAAE,KAAAN,KACAz3D,GAAA5pB,MAAAqiF,MAAAC,MAAAE,GAAA/6E,EAAA+5E,KAAAE,KAAAE,KAAAN,KAEAthE,OAAAplB,KAAA,GAAAoF,OAAAiY,QAAA0R,GAAAC,IAIA,MAEA,KAAA5pB,OAAAwrF,YAAAK,aAEAhK,MAAAvrF,KAAAg1F,QAAAtwF,EAAA,GAAAkxF,IAEA,IAAA9E,MAAA,GAAApnF,OAAAiY,QAAA4pE,YAAA5mF,OAAA,GAAA4mF,YAAA5mF,OAAA,IACA6yF,MAAA1G,MAEA9gE,EAAA65D,UAAA+L,KAAA,GAAAjxF,MAEA6yF,WAAAC,OAAA7B,KAAA,GAEA,IAAA8B,QAAA,GAAAhuF,OAAAgtF,YAAAc,KAEA,KAAAlyF,EAAA,EAAe0qB,GAAA1qB,EAAQA,IAEvBokB,OAAAplB,KAAAozF,OAAArH,WAAA/qF,EAAA0qB,GAIA,MAEA,KAAAtmB,OAAAwrF,YAAAM,IAEA,GAMAl3E,OANA6uE,GAAAyI,KAAA,GAAAxI,GAAAwI,KAAA,GACAe,QAAAf,KAAA,GACAgB,YAAAhB,KAAA,GAAAiB,UAAAjB,KAAA,GACAkB,aAAAlB,KAAA,GAEA+B,WAAAd,UAAAD,YAEAgB,WAAA,EAAA/N,SAEA,KAAAvkF,EAAA,EAAesyF,YAAAtyF,EAAiBA,IAEhC6L,EAAA7L,EAAAsyF,WAEAd,aAEA3lF,EAAA,EAAAA,GAIAmN,MAAAs4E,YAAAzlF,EAAAwmF,WAEAtkE,GAAA85D,GAAAwJ,QAAA9sF,KAAA+T,IAAAU,OACAgV,GAAA85D,GAAAuJ,QAAA9sF,KAAAmU,IAAAM,OAIAoL,OAAAplB,KAAA,GAAAoF,OAAAiY,QAAA0R,GAAAC,IAMA,MAEA,KAAA5pB,OAAAwrF,YAAAO,QAEA,GAQAn3E,OARA6uE,GAAAyI,KAAA,GAAAxI,GAAAwI,KAAA,GACAsB,QAAAtB,KAAA,GACAuB,QAAAvB,KAAA,GACAgB,YAAAhB,KAAA,GAAAiB,UAAAjB,KAAA,GACAkB,aAAAlB,KAAA,GAGA+B,WAAAd,UAAAD,YAEAgB,WAAA,EAAA/N,SAEA,KAAAvkF,EAAA,EAAesyF,YAAAtyF,EAAiBA,IAEhC6L,EAAA7L,EAAAsyF,WAEAd,aAEA3lF,EAAA,EAAAA,GAIAmN,MAAAs4E,YAAAzlF,EAAAwmF,WAEAtkE,GAAA85D,GAAA+J,QAAArtF,KAAA+T,IAAAU,OACAgV,GAAA85D,GAAA+J,QAAAttF,KAAAmU,IAAAM,OAIAoL,OAAAplB,KAAA,GAAAoF,OAAAiY,QAAA0R,GAAAC,KAeA,GAAA+jE,WAAA3tE,cAAA/kB,OAAA,GACA+nF,QAAA,KAUA,OATA7iF,MAAA+V,IAAAy3E,UAAAnzF,EAAAwlB,OAAA,GAAAxlB,GAAAwoF,SACA7iF,KAAA+V,IAAAy3E,UAAAlzF,EAAAulB,OAAA,GAAAvlB,GAAAuoF,SACAhjE,OAAA2Y,OAAA3Y,OAAA/kB,OAAA,KACA2yF,YAEA5tE,OAAAplB,KAAAolB,OAAA,IAIAA,QAgBAhgB,MAAA+gF,KAAAnqF,UAAAksF,SAAA,SAAAqL,MAAAC,SAEA,QAAAC,iBAAAC,WAEA,GAAAtzF,GAAAklB,GAAAhlB,KAAAkmF,OAAA8K,KAEAqC,YAAAC,SAAA,GAAAxuF,OAAA+gF,IAEA,KAAA/lF,EAAA,EAAAklB,GAAAouE,UAAArzF,OAAqCilB,GAAAllB,EAAQA,IAE7CE,KAAAozF,UAAAtzF,GAEAkxF,KAAAhxF,KAAAgxF,KACA9K,OAAAlmF,KAAAkmF,OAEAA,QAAAphF,MAAAwrF,YAAAC,SAEA,GAAA+C,SAAAlD,QAAArwF,SAEAszF,SAAA3zF,KAAA4zF,UACAA,SAAA,GAAAxuF,OAAA+gF,MAMAyN,SAAApN,QAAAvpF,MAAA22F,SAAAtC,KAYA,OARA,IAAAsC,SAAAlD,QAAArwF,QAEAszF,SAAA3zF,KAAA4zF,UAMAD,SAGA,QAAAE,iBAAAC,YAIA,OAFA7L,WAEA7nF,EAAA,EAAAklB,GAAAwuE,WAAAzzF,OAA0CilB,GAAAllB,EAAQA,IAAA,CAElD,GAAA2zF,SAAAD,WAAA1zF,GAEA4zF,SAAA,GAAA5uF,OAAAqiF,KACAuM,UAAAtD,QAAAqD,QAAArD,QACAsD,SAAAhG,OAAA+F,QAAA/F,OAEA/F,OAAAjoF,KAAAg0F,UAKA,MAAA/L,QAGA,QAAAgM,sBAAAC,KAAAC,WAUA,OATA/L,SAAA,MAEAgM,QAAAD,UAAA9zF,OAMAg0F,QAAA,EACAl5F,EAAAi5F,QAAA,EAAAxnF,EAAA,EAAmCwnF,QAAAxnF,EAAazR,EAAAyR,IAAA,CAChD,GAAA0nF,WAAAH,UAAAh5F,GACAo5F,WAAAJ,UAAAvnF,GAEA4nF,OAAAD,WAAA30F,EAAA00F,UAAA10F,EACA60F,OAAAF,WAAA10F,EAAAy0F,UAAAz0F,CAEA,IAAA0F,KAAA+V,IAAAm5E,QAAArM,QAAA,CAKA,GAJA,EAAAqM,SACAH,UAAAH,UAAAvnF,GAAiC4nF,eACjCD,WAAAJ,UAAAh5F,GAAiCs5F,gBAEjCP,KAAAr0F,EAAAy0F,UAAAz0F,GAAAq0F,KAAAr0F,EAAA00F,WAAA10F,EAAA,QAEA,IAAAq0F,KAAAr0F,GAAAy0F,UAAAz0F,GACA,GAAAq0F,KAAAt0F,GAAA00F,UAAA10F,EAAA,aAEK,CACL,GAAA80F,UAAAD,QAAAP,KAAAt0F,EAAA00F,UAAA10F,GAAA40F,QAAAN,KAAAr0F,EAAAy0F,UAAAz0F,EACA,OAAA60F,SAAA,QACA,MAAAA,SAAA,QACAL,qBAEI,CACJ,GAAAH,KAAAr0F,GAAAy0F,UAAAz0F,EAAA,QAEA,IAAA00F,WAAA30F,GAAAs0F,KAAAt0F,GAAAs0F,KAAAt0F,GAAA00F,UAAA10F,GACA00F,UAAA10F,GAAAs0F,KAAAt0F,GAAAs0F,KAAAt0F,GAAA20F,WAAA30F,EAAA,UAKA,MAAAy0F,QAIA,GAAAV,UAAAF,gBAAA/3F,KAAAg1F,QACA,OAAAiD,SAAAtzF,OAAA,QAEA,IAAAmzF,WAAA,QAAAK,iBAAAF,SAGA,IAAAgB,OAAAZ,QAAAC,SAAA/L,SAEA,OAAA0L,SAAAtzF,OAOA,MALA0zF,SAAAJ,SAAA,GACAK,SAAA,GAAA5uF,OAAAqiF,MACAuM,SAAAtD,QAAAqD,QAAArD,QACAsD,SAAAhG,OAAA+F,QAAA/F,OACA/F,OAAAjoF,KAAAg0F,UACA/L,MAIA,IAAA2M,aAAAxvF,MAAAqiF,MAAAC,MAAAmN,YAAAlB,SAAA,GAAA1H,YACA2I,YAAArB,OAAAqB,qBAIA,IAIAE,WAJAC,oBACAC,aACAC,iBACAC,QAAA,CAGAF,WAAAE,SAAA5vF,OACA2vF,cAAAC,WAEA,IAAA90F,GAAAklB,EAEA,KAAAllB,EAAA,EAAAklB,GAAAquE,SAAAtzF,OAAmCilB,GAAAllB,EAAQA,IAE3C2zF,QAAAJ,SAAAvzF,GACA00F,UAAAf,QAAA9H,YACA0I,MAAAvvF,MAAAqiF,MAAAC,MAAAmN,YAAAC,WACAH,MAAApB,OAAAoB,YAEAA,QAEAC,YAAAI,UAAAE,oBAEAF,UAAAE,UAAyBzoF,EAAA,GAAArH,OAAAqiF,MAAAtsF,EAAA25F,WACzBE,UAAAE,SAAAzoF,EAAAikF,QAAAqD,QAAArD,QACAsE,UAAAE,SAAAzoF,EAAAuhF,OAAA+F,QAAA/F,OAEA4G,YAAAM,UACAD,cAAAC,aAMAD,cAAAC,SAAAl1F,MAAiCwM,EAAAunF,QAAA54F,EAAA25F,UAAA,IASjC,KAAAE,UAAA,SAAAnB,iBAAAF,SAGA,IAAAqB,UAAA30F,OAAA,GAIA,OAHA80F,YAAA,EACAC,YAEAC,KAAA,EAAAC,KAAAN,UAAA30F,OAA6Ci1F,KAAAD,KAAaA,OAC1DN,iBAAAM,QAEA,QAAAA,MAAA,EAAAC,KAAAN,UAAA30F,OAA6Ci1F,KAAAD,KAAaA,OAE1D,OADAE,KAAAN,cAAAI,MACAG,KAAA,EAAqBA,KAAAD,IAAAl1F,OAAmBm1F,OAAA,CAGxC,OAFAC,IAAAF,IAAAC,MACAE,iBAAA,EACAC,MAAA,EAAuBA,MAAAX,UAAA30F,OAA0Bs1F,QACjD1B,qBAAAwB,GAAAt6F,EAAA65F,UAAAW,OAAAx6F,KACAk6F,MAAAM,OAAAP,SAAAp1F,MAA4C41F,MAAAP,KAAAQ,IAAAF,MAAAG,KAAAN,OAC5CE,iBACAA,iBAAA,EACAX,iBAAAY,OAAA31F,KAAAy1F,KAEAN,WAAA,EAIAO,kBAA4BX,iBAAAM,MAAAr1F,KAAAy1F,IAI5BL,SAAA/0F,OAAA,IAEA80F,YAAAF,cAAAF,mBAIA,GAAAgB,UAAA/0F,EAAAqnC,EACA,KAAAjoC,EAAA,EAAAklB,GAAA0vE,UAAA30F,OAAoCilB,GAAAllB,EAAQA,IAI5C,IAHA4zF,SAAAgB,UAAA50F,GAAAqM,EACAw7E,OAAAjoF,KAAAg0F,UACA+B,SAAAd,cAAA70F,GACAY,EAAA,EAAAqnC,GAAA0tD,SAAA11F,OAAoCgoC,GAAArnC,EAAQA,IAC5CgzF,SAAAgC,MAAAh2F,KAAA+1F,SAAA/0F,GAAAwL,EAMA,OAAAy7E,SAiBA7iF,MAAAqiF,MAAA,WAEAriF,MAAA+gF,KAAAlpF,MAAAvB,KAAAwB,WACAxB,KAAAs6F,UAIA5wF,MAAAqiF,MAAAzrF,UAAAujC,OAAAiG,OAAApgC,MAAA+gF,KAAAnqF,WACAoJ,MAAAqiF,MAAAzrF,UAAAM,YAAA8I,MAAAqiF,MAIAriF,MAAAqiF,MAAAzrF,UAAAi6F,QAAA,SAAAr1F,SAEA,GAAAs1F,UAAA,GAAA9wF,OAAA+wF,gBAAAz6F,KAAAkF,QACA,OAAAs1F,WAMA9wF,MAAAqiF,MAAAzrF,UAAAo6F,aAAA,SAAAx1F,SAEA,GAAA/B,UAAA,GAAAuG,OAAAixF,cAAA36F,KAAAkF,QACA,OAAA/B,WAMAuG,MAAAqiF,MAAAzrF,UAAAs6F,eAAA,SAAA/Q,WAEA,GAAAnlF,GAAAklB,GAAA5pB,KAAAs6F,MAAA31F,OAAAk2F,WAEA,KAAAn2F,EAAA,EAAaklB,GAAAllB,EAAQA,IAErBm2F,SAAAn2F,GAAA1E,KAAAs6F,MAAA51F,GAAAuvF,qBAAApK,UAAA7pF,KAAAuyF,MAIA,OAAAsI,WAMAnxF,MAAAqiF,MAAAzrF,UAAAw6F,qBAAA,SAAAjR,WAEA,GAAAnlF,GAAAklB,GAAA5pB,KAAAs6F,MAAA31F,OAAAk2F,WAEA,KAAAn2F,EAAA,EAAaklB,GAAAllB,EAAQA,IAErBm2F,SAAAn2F,GAAA1E,KAAAs6F,MAAA51F,GAAA0vF,2BAAAvK,UAAA7pF,KAAAuyF,MAIA,OAAAsI,WAOAnxF,MAAAqiF,MAAAzrF,UAAAy6F,iBAAA,SAAAlR,WAEA,OAEAmR,MAAAh7F,KAAAi0F,qBAAApK,WACAyQ,MAAAt6F,KAAA46F,eAAA/Q,aAMAngF,MAAAqiF,MAAAzrF,UAAA26F,cAAA,SAAApR,WAEA,MAAA7pF,MAAAu3F,gBACAv3F,KAAAk7F,uBAAArR,WAGA7pF,KAAA+6F,iBAAAlR,YAkBAngF,MAAAqiF,MAAAzrF,UAAA46F,uBAAA,SAAArR,WAEA,OAEAmR,MAAAh7F,KAAAo0F,2BAAAvK,WACAyQ,MAAAt6F,KAAA86F,qBAAAjR,aAUAngF,MAAAqiF,MAAAC,OAEAmP,iBAAA,SAAAvO,QAAA0N,OAEA,QAAAc,2BAAAC,SAAAC,SAAAC,WAEA,MAAAF,UAAAn3F,GAAAo3F,SAAAp3F,EACAm3F,SAAAn3F,EAAAo3F,SAAAp3F,EACAm3F,SAAAn3F,GAAAq3F,UAAAr3F,GAAAq3F,UAAAr3F,GAAAo3F,SAAAp3F,EAEAo3F,SAAAp3F,GAAAq3F,UAAAr3F,GAAAq3F,UAAAr3F,GAAAm3F,SAAAn3F,EAGAm3F,SAAAl3F,EAAAm3F,SAAAn3F,EACAk3F,SAAAl3F,GAAAo3F,UAAAp3F,GAAAo3F,UAAAp3F,GAAAm3F,SAAAn3F,EAEAm3F,SAAAn3F,GAAAo3F,UAAAp3F,GAAAo3F,UAAAp3F,GAAAk3F,SAAAl3F,EAKA,QAAAq3F,uBAAAC,UAAAC,UAAAC,UAAAC,UAAAC,uBACA,GAAAnP,SAAA,MAEAoP,OAAAJ,UAAAx3F,EAAAu3F,UAAAv3F,EAAA63F,OAAAL,UAAAv3F,EAAAs3F,UAAAt3F,EACA63F,OAAAJ,UAAA13F,EAAAy3F,UAAAz3F,EAAA+3F,OAAAL,UAAAz3F,EAAAw3F,UAAAx3F,EAEA+3F,WAAAT,UAAAv3F,EAAAy3F,UAAAz3F,EACAi4F,WAAAV,UAAAt3F,EAAAw3F,UAAAx3F,EAEAi4F,MAAAL,OAAAC,OAAAF,OAAAG,OACAI,SAAAN,OAAAG,WAAAJ,OAAAK,UAEA,IAAAtyF,KAAA+V,IAAAw8E,OAAA1P,QAAA,CAEA,GAAA4P,SACA,IAAAF,MAAA,GACA,KAAAC,mBAAAD,MAAA,QAEA,IADAE,SAAAL,OAAAC,WAAAF,OAAAG,WACA,EAAAG,mBAAAF,MAAA,aACK,CACL,GAAAC,SAAA,GAAAD,MAAAC,SAAA,QAEA,IADAC,SAAAL,OAAAC,WAAAF,OAAAG,WACAG,SAAA,GAAAF,MAAAE,SAAA,SAKA,MAAAA,SACA,8BACA,GAAAD,oBAAAD,OACAX,aAEA,IAAAa,UAAAF,MACA,8BACA,GAAAC,oBAAAD,OACAV,aAGA,OAAAW,SAAA,OAAAV,UACA,IAAAU,UAAAD,MAAA,OAAAR,UAGA,IAAAW,YAAAD,SAAAF,KACA,SAAcl4F,EAAAu3F,UAAAv3F,EAAAq4F,WAAAT,OACd33F,EAAAs3F,UAAAt3F,EAAAo4F,WAAAR,SAGA,MAAAM,UACAJ,OAAAC,YAAAF,OAAAG,WAAA,QAGA,IAAAK,QAAA,GAAAV,QAAA,GAAAC,OACAU,OAAA,GAAAT,QAAA,GAAAC,MAEA,IAAAO,QAAAC,OACA,MAAAhB,WAAAv3F,GAAAy3F,UAAAz3F,GACAu3F,UAAAt3F,GAAAw3F,UAAAx3F,MACAs3F,UAGA,IAAAe,OACA,MAAApB,2BAAAO,UAAAC,UAAAH,YACAA,aAGA,IAAAgB,OACA,MAAArB,2BAAAK,UAAAC,UAAAC,YACAA,aAIA,IAAAe,SAAAC,QAAAC,WAAAC,WACAC,QAAAC,QAAAC,WAAAC,UAgCA,OA/BA,IAAAnB,QACAL,UAAAv3F,EAAAw3F,UAAAx3F,GACAw4F,QAAAjB,UAA0BmB,WAAAnB,UAAAv3F,EAC1By4F,QAAAjB,UAA0BmB,WAAAnB,UAAAx3F,IAE1Bw4F,QAAAhB,UAA0BkB,WAAAlB,UAAAx3F,EAC1By4F,QAAAlB,UAA0BoB,WAAApB,UAAAv3F,GAE1By3F,UAAAz3F,EAAA03F,UAAA13F,GACA44F,QAAAnB,UAA0BqB,WAAArB,UAAAz3F,EAC1B64F,QAAAnB,UAA0BqB,WAAArB,UAAA13F,IAE1B44F,QAAAlB,UAA0BoB,WAAApB,UAAA13F,EAC1B64F,QAAApB,UAA0BsB,WAAAtB,UAAAz3F,KAG1Bu3F,UAAAt3F,EAAAu3F,UAAAv3F,GACAu4F,QAAAjB,UAA0BmB,WAAAnB,UAAAt3F,EAC1Bw4F,QAAAjB,UAA0BmB,WAAAnB,UAAAv3F,IAE1Bu4F,QAAAhB,UAA0BkB,WAAAlB,UAAAv3F,EAC1Bw4F,QAAAlB,UAA0BoB,WAAApB,UAAAt3F,GAE1Bw3F,UAAAx3F,EAAAy3F,UAAAz3F,GACA24F,QAAAnB,UAA0BqB,WAAArB,UAAAx3F,EAC1B44F,QAAAnB,UAA0BqB,WAAArB,UAAAz3F,IAE1B24F,QAAAlB,UAA0BoB,WAAApB,UAAAz3F,EAC1B44F,QAAApB,UAA0BsB,WAAAtB,UAAAx3F,IAG1B64F,YAAAJ,WACAI,WAAAH,cACAA,YAAAG,WACAnB,0BACAiB,SAEAG,YAAAJ,YAAAC,QAAAH,UACAG,QAAAC,SAEAH,WAAAK,cACAL,YAAAK,WACApB,0BACAa,SAEAO,YAAAJ,YAAAH,QAAAC,UACAD,QAAAK,SAKA,QAAAG,oBAAAC,SAAAC,YAAAC,UAAA9B,WAGA,GAAA7O,SAAA,MAGA4Q,WAAAF,YAAAl5F,EAAAi5F,SAAAj5F,EAAAq5F,WAAAH,YAAAj5F,EAAAg5F,SAAAh5F,EACAq5F,SAAAH,UAAAn5F,EAAAi5F,SAAAj5F,EAAAu5F,SAAAJ,UAAAl5F,EAAAg5F,SAAAh5F,EACAu5F,SAAAnC,UAAAr3F,EAAAi5F,SAAAj5F,EAAAy5F,SAAApC,UAAAp3F,EAAAg5F,SAAAh5F,EAGAy5F,aAAAN,WAAAG,SAAAF,WAAAC,SACAK,gBAAAP,WAAAK,SAAAJ,WAAAG,QAEA,IAAA7zF,KAAA+V,IAAAg+E,cAAAlR,QAAA,CAEA,GAAAoR,eAAAJ,SAAAD,SAAAE,SAAAH,QAGA,OAAAI,cAAA,EACAC,iBAAA,GAAAC,eAAA,EAEAD,iBAAA,GAAAC,eAAA,EAIA,MAAAD,iBAAA,EAKA,QAAAE,aAAAnR,QAAA0N,OAKA,QAAA0D,uBAAAC,WAAAC,WAEA,GAAAC,cAAAnD,MAAAr2F,OAAA,EAEAy5F,aAAAH,WAAA,CACA,GAAAG,4BAAAD,aAEA,IAAAE,cAAAJ,WAAA,CACAI,cAAAF,eAAAE,aAAA,EAEA,IAAAC,aAAApB,mBAAAlC,MAAAiD,YAAAjD,MAAAoD,cAAApD,MAAAqD,cAAAjE,KAAA8D,WACA,KAAAI,YAEA,QAIA,IAAAC,aAAAnE,KAAAz1F,OAAA,EAEA65F,YAAAN,UAAA,CACA,GAAAM,0BAAAD,YAEA,IAAAE,aAAAP,UAAA,CAIA,OAHAO,aAAAF,cAAAE,YAAA,GAEAH,YAAApB,mBAAA9C,KAAA8D,WAAA9D,KAAAoE,aAAApE,KAAAqE,aAAAzD,MAAAiD,aACAK,aAKA,GAHA,EAMA,QAAAI,qBAAAC,UAAAC,UAEA,GAAAjF,MAAAkF,QAAAC,YACA,KAAAnF,KAAA,EAAmBA,KAAAqB,MAAAr2F,OAAqBg1F,OAGxC,GAFAkF,QAAAlF,KAAA,EAAwBkF,SAAA7D,MAAAr2F,OACxBm6F,aAAAtD,sBAAAmD,UAAAC,SAAA5D,MAAArB,MAAAqB,MAAA6D,UAAA,GACAC,aAAAn6F,OAAA,UAGA,UAKA,QAAAo6F,oBAAAJ,UAAAC,UAEA,GAAAI,OAAAC,QACAnF,KAAA+E,QAAAC,YACA,KAAAE,MAAA,EAAoBA,MAAAE,WAAAv6F,OAA2Bq6F,QAE/C,IADAC,QAAA3E,MAAA4E,WAAAF,QACAlF,KAAA,EAAoBA,KAAAmF,QAAAt6F,OAAuBm1F,OAG3C,GAFA+E,QAAA/E,KAAA,EAAyB+E,SAAAI,QAAAt6F,OACzBm6F,aAAAtD,sBAAAmD,UAAAC,SAAAK,QAAAnF,MAAAmF,QAAAJ,UAAA,GACAC,aAAAn6F,OAAA,UAGA,UASA,OAvEAy1F,MAiEA+E,UAAAC,WACAC,QAAAC,OACAC,QAAAC,OACAC,UAAAC,UACAC,SAAAC,SAtEA5E,MAAApO,QAAA6K,SAiDAyH,cAmBAW,cAIA/uF,EAAA,EAAAgvF,GAAAxF,MAAA31F,OAAsCm7F,GAAAhvF,EAAQA,IAE9CouF,WAAA56F,KAAAwM,EAMA,KAFA,GAAAivF,eAAA,EACA78B,QAAA,EAAAg8B,WAAAv6F,OACAu6F,WAAAv6F,OAAA,IAEA,GADAu+D,UACA,EAAAA,QAAA,CACA/iE,QAAAC,IAAA,6BAAA8+F,WAAAv6F,OAAA,iCACA,OAKA,IAAAy6F,WAAAW,cAAqCX,WAAApE,MAAAr2F,OAA2By6F,aAAA,CAEhEC,QAAArE,MAAAoE,YACAD,UAAA,EAGA,QAAAruF,GAAA,EAAqBA,EAAAouF,WAAAv6F,OAAuBmM,IAK5C,GAJAyuF,QAAAL,WAAApuF,GAGA0uF,OAAAH,QAAAn7F,EAAA,IAAAm7F,QAAAl7F,EAAA,IAAAo7F,QACA31F,SAAAi2F,WAAAL,QAAA,CAEApF,KAAAE,MAAAiF,QACA,QAAAS,IAAA,EAAuBA,GAAA5F,KAAAz1F,OAAkBq7F,KAEzC,GADAV,OAAAlF,KAAA4F,IACAhC,sBAAAoB,WAAAY,MACAtB,oBAAAW,QAAAC,UACAP,mBAAAM,QAAAC,QAAA,CAEAH,UAAAa,GACAd,WAAA78D,OAAAvxB,EAAA,GAEA2uF,UAAAzE,MAAA7oF,MAAA,EAAAitF,WAAA,GACAM,UAAA1E,MAAA7oF,MAAAitF,YACAO,SAAAvF,KAAAjoF,MAAAgtF,WACAS,SAAAxF,KAAAjoF,MAAA,EAAAgtF,UAAA,GAEAnE,MAAAyE,UAAAhI,OAAAkI,UAAAlI,OAAAmI,UAAAnI,OAAAiI,WAEAK,cAAAX,UAKA,OAEA,GAAAD,WAAA,OAEAU,YAAAL,SAAA,EAEA,GAAAL,WAAA,SAIA,MAAAnE,OAYA,OARAt2F,GAAAklB,GAAAiD,EAAA2b,KACArnC,IAAAuG,MACAu4F,gBAIAC,UAAAtT,QAAA6K,SAEA3mF,EAAA,EAAAgvF,GAAAxF,MAAA31F,OAAqCm7F,GAAAhvF,EAAQA,IAE7CmrB,MAAA37B,UAAAgE,KAAA/C,MAAA2+F,UAAA5F,MAAAxpF,GAQA,KAAApM,EAAA,EAAAklB,GAAAs2E,UAAAv7F,OAAqCilB,GAAAllB,EAAQA,IAE7CvD,IAAA++F,UAAAx7F,GAAAR,EAAA,IAAAg8F,UAAAx7F,GAAAP,EAEAyF,SAAAq2F,aAAA9+F,MAEAuI,MAAAK,KAAA,+BAAA5I,KAIA8+F,aAAA9+F,KAAAuD,CAKA,IAAAy7F,mBAAApC,YAAAnR,QAAA0N,OAEA8F,UAAA12F,MAAAkgF,UAAAoE,YAAAmS,mBAAA,EAKA,KAAAz7F,EAAA,EAAAklB,GAAAw2E,UAAAz7F,OAAqCilB,GAAAllB,EAAQA,IAI7C,IAFA8jC,KAAA43D,UAAA17F,GAEAmoB,EAAA,EAAe,EAAAA,EAAOA,IAEtB1rB,IAAAqnC,KAAA3b,GAAA3oB,EAAA,IAAAskC,KAAA3b,GAAA1oB,EAEAuD,MAAAu4F,aAAA9+F,KAEAyI,SAAAlC,QAEA8gC,KAAA3b,GAAAnlB,MAQA,OAAA04F,WAAA3I,UAIA0B,YAAA,SAAA3N,KAEA,MAAA9hF,OAAAkgF,UAAAoE,YAAAntD,KAAA2qD,KAAA,GASA6U,KAAA,SAAAlvF,EAAA1R,GAEA,GAAA++B,GAAA,EAAArtB,CACA,OAAAqtB,KAAA/+B,GAIA6gG,KAAA,SAAAnvF,EAAA1R,GAEA,YAAA0R,KAAA1R,GAIA8gG,KAAA,SAAApvF,EAAA1R,GAEA,MAAA0R,KAAA1R,GAIA+8B,GAAA,SAAArrB,EAAAwnB,GAAAC,GAAAC,IAEA,MAAA74B,MAAAqgG,KAAAlvF,EAAAwnB,IAAA34B,KAAAsgG,KAAAnvF,EAAAynB,IAAA54B,KAAAugG,KAAApvF,EAAA0nB,KAMA2nE,KAAA,SAAArvF,EAAA1R,GAEA,GAAA++B,GAAA,EAAArtB,CACA,OAAAqtB,OAAA/+B,GAIAghG,KAAA,SAAAtvF,EAAA1R,GAEA,GAAA++B,GAAA,EAAArtB,CACA,UAAAqtB,IAAArtB,EAAA1R,GAIAihG,KAAA,SAAAvvF,EAAA1R,GAEA,GAAA++B,GAAA,EAAArtB,CACA,UAAAqtB,EAAArtB,IAAA1R,GAIAkhG,KAAA,SAAAxvF,EAAA1R,GAEA,MAAA0R,OAAA1R,GAIAysF,GAAA,SAAA/6E,EAAAwnB,GAAAC,GAAAC,GAAAC,IAEA,MAAA94B,MAAAwgG,KAAArvF,EAAAwnB,IAAA34B,KAAAygG,KAAAtvF,EAAAynB,IAAA54B,KAAA0gG,KAAAvvF,EAAA0nB,IAAA74B,KAAA2gG,KAAAxvF,EAAA2nB,MAaApvB,MAAAopF,UAAA,SAAAxzE,GAAAgE,IAEAtjB,KAAAsf,MACAtf,KAAAsjB,OAIA5Z,MAAAopF,UAAAxyF,UAAAujC,OAAAiG,OAAApgC,MAAA0mF,MAAA9vF,WACAoJ,MAAAopF,UAAAxyF,UAAAM,YAAA8I,MAAAopF,UAEAppF,MAAAopF,UAAAxyF,UAAAi+B,SAAA,SAAAptB,GAEA,GAAA+X,OAAAlpB,KAAAsjB,GAAA3P,QAAAnT,IAAAR,KAAAsf,GAGA,OAFA4J,OAAA/V,eAAAhC,GAAAxN,IAAA3D,KAAAsf,IAEA4J,OAMAxf,MAAAopF,UAAAxyF,UAAA+vF,WAAA,SAAA9vD,GAEA,MAAAvgC,MAAAu+B,SAAAgC,IAIA72B,MAAAopF,UAAAxyF,UAAAkxF,WAAA,SAAArgF,GAEA,GAAA48B,SAAA/tC,KAAAsjB,GAAA3P,QAAAnT,IAAAR,KAAAsf,GAEA,OAAAyuB,SAAAjuB,aAWApW,MAAAwsF,qBAAA,SAAA5gE,GAAAhW,GAAAgE,IAEAtjB,KAAAs1B,MACAt1B,KAAAsf,MACAtf,KAAAsjB,OAIA5Z,MAAAwsF,qBAAA51F,UAAAujC,OAAAiG,OAAApgC,MAAA0mF,MAAA9vF,WACAoJ,MAAAwsF,qBAAA51F,UAAAM,YAAA8I,MAAAwsF,qBAGAxsF,MAAAwsF,qBAAA51F,UAAAi+B,SAAA,SAAAptB,GAEA,GAAAzB,QAAA,GAAAhG,OAAAiY,OAKA,OAHAjS,QAAAxL,EAAAwF,MAAAqiF,MAAAC,MAAAxvD,GAAArrB,EAAAnR,KAAAs1B,GAAApxB,EAAAlE,KAAAsf,GAAApb,EAAAlE,KAAAsjB,GAAApf,GACAwL,OAAAvL,EAAAuF,MAAAqiF,MAAAC,MAAAxvD,GAAArrB,EAAAnR,KAAAs1B,GAAAnxB,EAAAnE,KAAAsf,GAAAnb,EAAAnE,KAAAsjB,GAAAnf,GAEAuL,QAKAhG,MAAAwsF,qBAAA51F,UAAAkxF,WAAA,SAAArgF,GAEA,GAAAzB,QAAA,GAAAhG,OAAAiY,OAOA,OALAjS,QAAAxL,EAAAwF,MAAA0mF,MAAApE,MAAA6F,uBAAA1gF,EAAAnR,KAAAs1B,GAAApxB,EAAAlE,KAAAsf,GAAApb,EAAAlE,KAAAsjB,GAAApf,GACAwL,OAAAvL,EAAAuF,MAAA0mF,MAAApE,MAAA6F,uBAAA1gF,EAAAnR,KAAAs1B,GAAAnxB,EAAAnE,KAAAsf,GAAAnb,EAAAnE,KAAAsjB,GAAAnf,GAIAuL,OAAAoQ,aAUApW,MAAA6sF,iBAAA,SAAAjhE,GAAAhW,GAAAgE,GAAA+a,IAEAr+B,KAAAs1B,MACAt1B,KAAAsf,MACAtf,KAAAsjB,MACAtjB,KAAAq+B,OAIA30B,MAAA6sF,iBAAAj2F,UAAAujC,OAAAiG,OAAApgC,MAAA0mF,MAAA9vF,WACAoJ,MAAA6sF,iBAAAj2F,UAAAM,YAAA8I,MAAA6sF,iBAEA7sF,MAAA6sF,iBAAAj2F,UAAAi+B,SAAA,SAAAptB,GAEA,GAAAkiB,IAAAC,EAKA,OAHAD,IAAA3pB,MAAAqiF,MAAAC,MAAAE,GAAA/6E,EAAAnR,KAAAs1B,GAAApxB,EAAAlE,KAAAsf,GAAApb,EAAAlE,KAAAsjB,GAAApf,EAAAlE,KAAAq+B,GAAAn6B,GACAovB,GAAA5pB,MAAAqiF,MAAAC,MAAAE,GAAA/6E,EAAAnR,KAAAs1B,GAAAnxB,EAAAnE,KAAAsf,GAAAnb,EAAAnE,KAAAsjB,GAAAnf,EAAAnE,KAAAq+B,GAAAl6B,GAEA,GAAAuF,OAAAiY,QAAA0R,GAAAC,KAIA5pB,MAAA6sF,iBAAAj2F,UAAAkxF,WAAA,SAAArgF,GAEA,GAAAkiB,IAAAC,EAEAD,IAAA3pB,MAAA0mF,MAAApE,MAAA8F,mBAAA3gF,EAAAnR,KAAAs1B,GAAApxB,EAAAlE,KAAAsf,GAAApb,EAAAlE,KAAAsjB,GAAApf,EAAAlE,KAAAq+B,GAAAn6B,GACAovB,GAAA5pB,MAAA0mF,MAAApE,MAAA8F,mBAAA3gF,EAAAnR,KAAAs1B,GAAAnxB,EAAAnE,KAAAsf,GAAAnb,EAAAnE,KAAAsjB,GAAAnf,EAAAnE,KAAAq+B,GAAAl6B,EAEA,IAAA4pC,SAAA,GAAArkC,OAAAiY,QAAA0R,GAAAC,GAGA,OAFAya,SAAAjuB,YAEAiuB,SAUArkC,MAAAgtF,YAAA,SAAAhtE,QAEA1pB,KAAA0pB,OAAA9f,QAAA8f,kBAIAhgB,MAAAgtF,YAAAp2F,UAAAujC,OAAAiG,OAAApgC,MAAA0mF,MAAA9vF,WACAoJ,MAAAgtF,YAAAp2F,UAAAM,YAAA8I,MAAAgtF,YAEAhtF,MAAAgtF,YAAAp2F,UAAAi+B,SAAA,SAAAptB,GAEA,GAAAuY,QAAA1pB,KAAA0pB,OACAR,OAAAQ,OAAA/kB,OAAA,GAAAwM,EAEA0sB,SAAAh0B,KAAA+G,MAAAsY,OACA4U,OAAA5U,MAAA2U,SAEA+iE,OAAAl3E,OAAA,GAAAmU,2BAAA,GACAgjE,OAAAn3E,OAAAmU,UACAijE,OAAAp3E,OAAAmU,SAAAnU,OAAA/kB,OAAA,EAAA+kB,OAAA/kB,OAAA,EAAAk5B,SAAA,GACAkjE,OAAAr3E,OAAAmU,SAAAnU,OAAA/kB,OAAA,EAAA+kB,OAAA/kB,OAAA,EAAAk5B,SAAA,GAEAnuB,OAAA,GAAAhG,OAAAiY,OAKA,OAHAjS,QAAAxL,EAAAwF,MAAA0mF,MAAApE,MAAAtuD,YAAAkjE,OAAA18F,EAAA28F,OAAA38F,EAAA48F,OAAA58F,EAAA68F,OAAA78F,EAAA45B,QACApuB,OAAAvL,EAAAuF,MAAA0mF,MAAApE,MAAAtuD,YAAAkjE,OAAAz8F,EAAA08F,OAAA18F,EAAA28F,OAAA38F,EAAA48F,OAAA58F,EAAA25B,QAEApuB,QAUAhG,MAAA0tF,aAAA,SAAAjK,GAAAC,GAAA8J,QAAAC,QAAAP,YAAAC,UAAAC,YAEA92F,KAAAmtF,MACAntF,KAAAotF,MAEAptF,KAAAk3F,gBACAl3F,KAAAm3F,gBAEAn3F,KAAA42F,wBACA52F,KAAA62F,oBAEA72F,KAAA82F,uBAIAptF,MAAA0tF,aAAA92F,UAAAujC,OAAAiG,OAAApgC,MAAA0mF,MAAA9vF,WACAoJ,MAAA0tF,aAAA92F,UAAAM,YAAA8I,MAAA0tF,aAEA1tF,MAAA0tF,aAAA92F,UAAAi+B,SAAA,SAAAptB,GAEA,GAAAwmF,YAAA33F,KAAA62F,UAAA72F,KAAA42F,WAEA,GAAAe,yBAAA,EAAA9tF,KAAAud,IACAuwE,WAAA,EAAA9tF,KAAAud,KAAAuwE,YAAA,EAAA9tF,KAAAud,GAEA,IAAA9I,MAIAA,OAFAte,KAAA82F,cAAA,EAEA92F,KAAA62F,WAAA,EAAA1lF,IAAA,EAAAtH,KAAAud,GAAAuwE,YAIA33F,KAAA42F,YAAAzlF,EAAAwmF,UAIA,IAAAjoF,QAAA,GAAAhG,OAAAiY,OAKA,OAHAjS,QAAAxL,EAAAlE,KAAAmtF,GAAAntF,KAAAk3F,QAAArtF,KAAA+T,IAAAU,OACA5O,OAAAvL,EAAAnE,KAAAotF,GAAAptF,KAAAm3F,QAAAttF,KAAAmU,IAAAM,OAEA5O,QAUAhG,MAAAs3F,SAAA,SAAA7T,GAAAC,GAAAuJ,QAAAC,YAAAC,UAAAC,YAEAptF,MAAA0tF,aAAA93F,KAAAU,KAAAmtF,GAAAC,GAAAuJ,gBAAAC,YAAAC,UAAAC,aAGAptF,MAAAs3F,SAAA1gG,UAAAujC,OAAAiG,OAAApgC,MAAA0tF,aAAA92F,WACAoJ,MAAAs3F,SAAA1gG,UAAAM,YAAA8I,MAAAs3F,SAQAt3F,MAAAu3F,WAAAv3F,MAAA0mF,MAAAtmD,OAEA,SAAAxqB,GAAAgE,IAEAtjB,KAAAsf,MACAtf,KAAAsjB,OAIA,SAAAnS,GAEA,GAAAzB,QAAA,GAAAhG,OAAAgW,OAMA,OAJAhQ,QAAAuS,WAAAjiB,KAAAsjB,GAAAtjB,KAAAsf,IACA5P,OAAAyD,eAAAhC,GACAzB,OAAA/L,IAAA3D,KAAAsf,IAEA5P,SAYAhG,MAAAw3F,sBAAAx3F,MAAA0mF,MAAAtmD,OAEA,SAAAxU,GAAAhW,GAAAgE,IAEAtjB,KAAAs1B,MACAt1B,KAAAsf,MACAtf,KAAAsjB,OAIA,SAAAnS,GAEA,GAAAzB,QAAA,GAAAhG,OAAAgW,OAMA,OAJAhQ,QAAAxL,EAAAwF,MAAAqiF,MAAAC,MAAAxvD,GAAArrB,EAAAnR,KAAAs1B,GAAApxB,EAAAlE,KAAAsf,GAAApb,EAAAlE,KAAAsjB,GAAApf,GACAwL,OAAAvL,EAAAuF,MAAAqiF,MAAAC,MAAAxvD,GAAArrB,EAAAnR,KAAAs1B,GAAAnxB,EAAAnE,KAAAsf,GAAAnb,EAAAnE,KAAAsjB,GAAAnf,GACAuL,OAAAxM,EAAAwG,MAAAqiF,MAAAC,MAAAxvD,GAAArrB,EAAAnR,KAAAs1B,GAAApyB,EAAAlD,KAAAsf,GAAApc,EAAAlD,KAAAsjB,GAAApgB,GAEAwM,SAYAhG,MAAAy3F,kBAAAz3F,MAAA0mF,MAAAtmD,OAEA,SAAAxU,GAAAhW,GAAAgE,GAAA+a,IAEAr+B,KAAAs1B,MACAt1B,KAAAsf,MACAtf,KAAAsjB,MACAtjB,KAAAq+B,OAIA,SAAAltB,GAEA,GAAAzB,QAAA,GAAAhG,OAAAgW,OAMA,OAJAhQ,QAAAxL,EAAAwF,MAAAqiF,MAAAC,MAAAE,GAAA/6E,EAAAnR,KAAAs1B,GAAApxB,EAAAlE,KAAAsf,GAAApb,EAAAlE,KAAAsjB,GAAApf,EAAAlE,KAAAq+B,GAAAn6B,GACAwL,OAAAvL,EAAAuF,MAAAqiF,MAAAC,MAAAE,GAAA/6E,EAAAnR,KAAAs1B,GAAAnxB,EAAAnE,KAAAsf,GAAAnb,EAAAnE,KAAAsjB,GAAAnf,EAAAnE,KAAAq+B,GAAAl6B,GACAuL,OAAAxM,EAAAwG,MAAAqiF,MAAAC,MAAAE,GAAA/6E,EAAAnR,KAAAs1B,GAAApyB,EAAAlD,KAAAsf,GAAApc,EAAAlD,KAAAsjB,GAAApgB,EAAAlD,KAAAq+B,GAAAn7B,GAEAwM,SAaAhG,MAAA03F,aAAA13F,MAAA0mF,MAAAtmD,OAEA,SAAApgB,QAEA1pB,KAAA0pB,OAAA9f,QAAA8f,kBAIA,SAAAvY,GAEA,GAAAuY,QAAA1pB,KAAA0pB,OACAR,OAAAQ,OAAA/kB,OAAA,GAAAwM,EAEA0sB,SAAAh0B,KAAA+G,MAAAsY,OACA4U,OAAA5U,MAAA2U,SAEA+iE,OAAAl3E,OAAA,GAAAmU,2BAAA,GACAgjE,OAAAn3E,OAAAmU,UACAijE,OAAAp3E,OAAAmU,SAAAnU,OAAA/kB,OAAA,EAAA+kB,OAAA/kB,OAAA,EAAAk5B,SAAA,GACAkjE,OAAAr3E,OAAAmU,SAAAnU,OAAA/kB,OAAA,EAAA+kB,OAAA/kB,OAAA,EAAAk5B,SAAA,GAEAnuB,OAAA,GAAAhG,OAAAgW,OAMA,OAJAhQ,QAAAxL,EAAAwF,MAAA0mF,MAAApE,MAAAtuD,YAAAkjE,OAAA18F,EAAA28F,OAAA38F,EAAA48F,OAAA58F,EAAA68F,OAAA78F,EAAA45B,QACApuB,OAAAvL,EAAAuF,MAAA0mF,MAAApE,MAAAtuD,YAAAkjE,OAAAz8F,EAAA08F,OAAA18F,EAAA28F,OAAA38F,EAAA48F,OAAA58F,EAAA25B,QACApuB,OAAAxM,EAAAwG,MAAA0mF,MAAApE,MAAAtuD,YAAAkjE,OAAA19F,EAAA29F,OAAA39F,EAAA49F,OAAA59F,EAAA69F,OAAA79F,EAAA46B,QAEApuB,SAaAhG,MAAA23F,mBAAA33F,MAAA0mF,MAAAtmD,OAEA,SAAApgB,QAEA1pB,KAAA0pB,OAAA9f,QAAA8f,kBAIA,SAAAvY,GAEA,GAAAuY,QAAA1pB,KAAA0pB,OACAR,OAAAQ,OAAA/kB,OAAA,GAAAwM,EAEA0sB,SAAAh0B,KAAA+G,MAAAsY,OACA4U,OAAA5U,MAAA2U,QAEAA,oBAAA,KAAAh0B,KAAA+G,MAAA/G,KAAA+V,IAAAie,UAAAnU,OAAA/kB,QAAA,GAAA+kB,OAAA/kB,MAEA,IAAAi8F,QAAAl3E,QAAAmU,SAAA,GAAAnU,OAAA/kB,QACAk8F,OAAAn3E,OAAA,SAAAA,OAAA/kB,QACAm8F,OAAAp3E,QAAAmU,SAAA,GAAAnU,OAAA/kB,QACAo8F,OAAAr3E,QAAAmU,SAAA,GAAAnU,OAAA/kB,QAEA+K,OAAA,GAAAhG,OAAAgW,OAMA,OAJAhQ,QAAAxL,EAAAwF,MAAA0mF,MAAApE,MAAAtuD,YAAAkjE,OAAA18F,EAAA28F,OAAA38F,EAAA48F,OAAA58F,EAAA68F,OAAA78F,EAAA45B,QACApuB,OAAAvL,EAAAuF,MAAA0mF,MAAApE,MAAAtuD,YAAAkjE,OAAAz8F,EAAA08F,OAAA18F,EAAA28F,OAAA38F,EAAA48F,OAAA58F,EAAA25B,QACApuB,OAAAxM,EAAAwG,MAAA0mF,MAAApE,MAAAtuD,YAAAkjE,OAAA19F,EAAA29F,OAAA39F,EAAA49F,OAAA59F,EAAA69F,OAAA79F,EAAA46B,QAEApuB,SAYAhG,MAAA43F,kBAEAlwB,OAAA,EACAmwB,WAAA,EACAC,mBAAA,EAIA79F,IAAA,WAAmB+F,MAAAK,KAAA,sDACnB4vC,IAAA,WAAmBjwC,MAAAK,KAAA,sDACnBtD,OAAA,WAAsBiD,MAAAK,KAAA,yDAItB45C,cAEAghC,KAAA,SAAAp9C,MAEA,GAAAA,KAAAk6D,eAAA,QAAAl6D,KAIA,QAAAz2B,GAAA,EAAkBA,EAAAy2B,KAAAm6D,UAAA/8F,OAA2BmM,IAAA,CAE7C,OAAA0tB,GAAA,EAAmBA,EAAA+I,KAAAm6D,UAAA5wF,GAAAu5B,KAAA1lC,OAAqC65B,IAYxD,GARA+I,KAAAm6D,UAAA5wF,GAAAu5B,KAAA7L,GAAAgyB,KAAA,IAEAjpB,KAAAm6D,UAAA5wF,GAAAu5B,KAAA7L,GAAAgyB,KAAA,GAMA5mD,SAAA29B,KAAAm6D,UAAA5wF,GAAAu5B,KAAA7L,GAAAmjE,OACAp6D,KAAAm6D,UAAA5wF,GAAAu5B,KAAA7L,GAAAmjE,cAAAj4F,OAAAqT,YAAA,CAEA,GAAA6kF,MAAAr6D,KAAAm6D,UAAA5wF,GAAAu5B,KAAA7L,GAAAmjE,GACAp6D,MAAAm6D,UAAA5wF,GAAAu5B,KAAA7L,GAAAmjE,KAAA,GAAAj4F,OAAAqT,YAAAxJ,UAAAquF,MAQA,GAAAr6D,KAAAm6D,UAAA5wF,GAAAu5B,KAAA1lC,QAAAiF,SAAA29B,KAAAm6D,UAAA5wF,GAAAu5B,KAAA,GAAAmG,aAAA,CAMA,OAFAqxD,qBAEArjE,EAAA,EAAoBA,EAAA+I,KAAAm6D,UAAA5wF,GAAAu5B,KAAA1lC,OAAqC65B,IAEzD,OAAAj/B,GAAA,EAAqBA,EAAAgoC,KAAAm6D,UAAA5wF,GAAAu5B,KAAA7L,GAAAgS,aAAA7rC,OAAuDpF,IAAA,CAE5E,GAAAuiG,iBAAAv6D,KAAAm6D,UAAA5wF,GAAAu5B,KAAA7L,GAAAgS,aAAAjxC,EACAsiG,kBAAAC,iBAAA,GAMAv6D,KAAAm6D,UAAA5wF,GAAA+wF,iCAKA,QAAArjE,GAAA,EAAoBA,EAAA+I,KAAAm6D,UAAA5wF,GAAAu5B,KAAA1lC,OAAqC65B,IAAA,CAEzD,GAAAuzB,cAEA,QAAA+vC,mBAAAD,kBAAA,CAEA,OAAAtiG,GAAA,EAAsBA,EAAAgoC,KAAAm6D,UAAA5wF,GAAAu5B,KAAA7L,GAAAgS,aAAA7rC,OAAuDpF,IAE7E,GAAAgoC,KAAAm6D,UAAA5wF,GAAAu5B,KAAA7L,GAAAgS,aAAAjxC,KAAAuiG,gBAAA,CAEA/vC,WAAA+vC,iBAAAv6D,KAAAm6D,UAAA5wF,GAAAu5B,KAAA7L,GAAAujE,uBAAAxiG,EACA,OAMAA,IAAAgoC,KAAAm6D,UAAA5wF,GAAAu5B,KAAA7L,GAAAgS,aAAA7rC,SAEAotD,WAAA+vC,iBAAA,GAMAv6D,KAAAm6D,UAAA5wF,GAAAu5B,KAAA7L,GAAAujE,uBAAAhwC,YASA,OAAAvzB,GAAA,EAAmBA,EAAA+I,KAAAm6D,UAAA5wF,GAAAu5B,KAAA1lC,OAAqC65B,IAExD+I,KAAAm6D,UAAA5wF,GAAAu5B,KAAA7L,GAAAgyB,OAAAjpB,KAAAm6D,UAAA5wF,GAAAu5B,KAAA7L,EAAA,GAAAgyB,OAEAjpB,KAAAm6D,UAAA5wF,GAAAu5B,KAAAhI,OAAA7D,EAAA,GACAA,IASA,QAAAA,GAAA,EAAmBA,EAAA+I,KAAAm6D,UAAA5wF,GAAAu5B,KAAA1lC,OAAqC65B,IAExD+I,KAAAm6D,UAAA5wF,GAAAu5B,KAAA7L,GAAA92B,MAAA82B,EAQA,MAFA+I,MAAAk6D,aAAA,EAEAl6D,MAIAW,MAAA,SAAA85D,MAEA,GAAAC,uBAAA,SAAAD,KAAAN,WAEAA,UAAAp9F,KAAA09F,KAEA,QAAAxiG,GAAA,EAAmBA,EAAAwiG,KAAA5+D,SAAAz+B,OAA0BnF,IAC7CyiG,sBAAAD,KAAA5+D,SAAA5jC,GAAAkiG,YAMAA,YAEA,IAAAM,eAAAt4F,OAAAgmD,YAEA,OAAAp/C,GAAA,EAAmBA,EAAA0xF,KAAA7xC,SAAA1M,MAAA9+C,OAAgC2L,IAEnDoxF,UAAAp9F,KAAA09F,KAAA7xC,SAAA1M,MAAAnzC,QAMA2xF,uBAAAD,KAAAN,UAIA,OAAAA,YAIAxS,KAAA,SAAAxrC,WAEA,KAAA1jD,KAAA2jD,WAAAxhB,QAAAuhB,YAEA1jD,KAAA2jD,WAAAr/C,KAAAo/C,YAMAliB,KAAA,SAAAkiB,WAEA,GAAAh8C,OAAA1H,KAAA2jD,WAAAxhB,QAAAuhB,UAEA,MAAAh8C,OAEA1H,KAAA2jD,WAAAthB,OAAA36B,MAAA;AAMAlB,OAAA,SAAA07F,aAEA,OAAAx9F,GAAA,EAAkBA,EAAA1E,KAAA2jD,WAAAh/C,OAA4BD,IAE9C1E,KAAA2jD,WAAAj/C,GAAAy9F,mBAIA,QAAAz9F,GAAA,EAAkBA,EAAA1E,KAAA2jD,WAAAh/C,OAA4BD,IAE9C1E,KAAA2jD,WAAAj/C,GAAA8B,OAAA07F,eAgBAx4F,MAAA04F,UAAA,SAAAJ,KAAAz6D,MAEAvnC,KAAAgiG,UACAhiG,KAAAunC,KAAA79B,MAAA43F,iBAAA3c,KAAAp9C,MACAvnC,KAAA0hG,UAAAh4F,MAAA43F,iBAAAp5D,MAAA85D,MAEAhiG,KAAAqvF,YAAA,EACArvF,KAAAqiG,UAAA,EAEAriG,KAAA+uF,WAAA,EACA/uF,KAAAmvF,MAAA,EACAnvF,KAAA89B,OAAA,EAEA99B,KAAAsiG,kBAAA54F,MAAA43F,iBAAAlwB,QAIA1nE,MAAA04F,UAAA9hG,WAEAM,YAAA8I,MAAA04F,UAEAG,UAAA,mBAEArT,KAAA,SAAAjuD,UAAAnD,QAEA99B,KAAAqvF,YAAAzlF,SAAAq3B,oBAAA,EACAjhC,KAAA89B,OAAAl0B,SAAAk0B,cAAA,EAEA99B,KAAA+uF,WAAA,EAEA/uF,KAAA83E,QAEApuE,MAAA43F,iBAAApS,KAAAlvF,OAIAwhC,KAAA,WAEAxhC,KAAA+uF,WAAA,EAEArlF,MAAA43F,iBAAA9/D,KAAAxhC,OAIA83E,MAAA,WAEA,OAAAhnE,GAAA,EAAAgvF,GAAA9/F,KAAA0hG,UAAA/8F,OAA8Cm7F,GAAAhvF,EAAQA,IAAA,CAEtD,GAAAma,QAAAjrB,KAAA0hG,UAAA5wF,EAEAlH,UAAAqhB,OAAAu3E,iBAEAv3E,OAAAu3E,gBACA7+C,cACAnG,UACAilD,eAAA,EACAC,iBAAA,EACAC,YAAA,IAKA,IAAA3+D,MAAAhkC,KAAAunC,KAAAvD,KACA2f,WAAA14B,OAAAu3E,eAAA7+C,WACA6+C,eAAA7+C,WAAA3f,KAEAp6B,UAAA44F,iBAEAA,gBACAI,SAAe7yC,IAAA,EAAA4xC,IAAA,EAAA1xC,IAAA,GACf4yC,SAAe9yC,IAAA,EAAA4xC,IAAA,EAAA1xC,IAAA,GACf6yC,eAAA73E,OAAAtG,QAGAg/B,WAAA3f,MAAAw+D,eAMA,QAAArxF,GAAA,EAAmB,EAAAA,EAAOA,IAAA,CAO1B,IALA,GAAA/K,MAAApG,KAAAuiG,SAAApxF,GAEAyxF,QAAA5iG,KAAAunC,KAAAm6D,UAAA5wF,GAAAu5B,KAAA,GACAw4D,QAAA7iG,KAAA+iG,eAAA38F,KAAA0K,EAAA,GAEA+xF,QAAAryC,KAAAxwD,KAAAqvF,aAAAwT,QAAAn7F,MAAAk7F,QAAAl7F,OAEAk7F,QAAAC,QACAA,QAAA7iG,KAAA+iG,eAAA38F,KAAA0K,EAAA+xF,QAAAn7F,MAAA,EAIA86F,gBAAAI,QAAAx8F,MAAAw8F,QACAJ,eAAAK,QAAAz8F,MAAAy8F,WAQAV,kBAAA,WAEA,OAAArxF,GAAA,EAAAgvF,GAAA9/F,KAAA0hG,UAAA/8F,OAA8Cm7F,GAAAhvF,EAAQA,IAAA,CAEtD,GAAAma,QAAAjrB,KAAA0hG,UAAA5wF,GACA0xF,eAAAv3E,OAAAu3E,cAEA,IAAA54F,SAAA44F,eAAA,CAEA,GAAAhlD,UAAAglD,eAAAhlD,QAEAA,UAAAilD,eAAA,EACAjlD,SAAAklD,iBAAA,EACAllD,SAAAmlD,YAAA,KAQAn8F,OAAA,WAEA,GAAAkjB,WACAoG,OAAA,GAAApmB,OAAAgW,QACAsjF,UAAA,GAAAt5F,OAAAgW,QACAujF,QAAA,GAAAv5F,OAAAqT,WAIAmmF,sBAAA,SAAAx5E,OAAAiJ,OAEA,GACAzJ,OAAA2U,SAAAC,OAAAC,GAAAC,GACAC,GAAAC,GAAAC,GAAAC,GAFA5+B,KAAA6+B,KAyBA,OArBAnV,QAAAQ,OAAA/kB,OAAA,GAAAguB,MACAkL,SAAAh0B,KAAA+G,MAAAsY,OACA4U,OAAA5U,MAAA2U,SAEAr+B,EAAA,OAAAq+B,2BAAA,EACAr+B,EAAA,GAAAq+B,SACAr+B,EAAA,GAAAq+B,SAAAnU,OAAA/kB,OAAA,EAAAk5B,kBAAA,EACAr+B,EAAA,GAAAq+B,SAAAnU,OAAA/kB,OAAA,EAAAk5B,kBAAA,EAEAI,GAAAvU,OAAAlqB,EAAA,IACA0+B,GAAAxU,OAAAlqB,EAAA,IACA2+B,GAAAzU,OAAAlqB,EAAA,IACA4+B,GAAA1U,OAAAlqB,EAAA,IAEAu+B,GAAAD,cACAE,GAAAF,OAAAC,GAEAM,GAAA,GAAAX,YAAAO,GAAA,GAAAC,GAAA,GAAAC,GAAA,GAAAC,GAAA,GAAAN,OAAAC,GAAAC,IACAK,GAAA,GAAAX,YAAAO,GAAA,GAAAC,GAAA,GAAAC,GAAA,GAAAC,GAAA,GAAAN,OAAAC,GAAAC,IACAK,GAAA,GAAAX,YAAAO,GAAA,GAAAC,GAAA,GAAAC,GAAA,GAAAC,GAAA,GAAAN,OAAAC,GAAAC,IAEAK,IAIAX,YAAA,SAAA/E,GAAAC,GAAAC,GAAAC,GAAA3nB,EAAAwsB,GAAAC,IAEA,GAAAtI,IAAA,IAAAuD,GAAAF,IACArZ,GAAA,IAAAwZ,GAAAF,GAEA,WAAAA,GAAAC,IAAAvD,GAAAhW,IAAAse,IAAA,IAAAhF,GAAAC,IAAA,EAAAvD,GAAAhW,IAAAqe,GAAArI,GAAAnkB,EAAAynB,GAIA,iBAAAjmB,OAEA,GAAA3S,KAAA+uF,aAAA,IAEA/uF,KAAAqvF,aAAA18E,MAAA3S,KAAAqiG,UAEA,IAAAriG,KAAA89B,QAAA,CAKA,GAAAwyB,UAAAtwD,KAAAunC,KAAA5iC,QAEA3E,KAAAqvF,YAAA/+B,UAAAtwD,KAAAqvF,YAAA,KAEArvF,KAAAmvF,MAEAnvF,KAAAqvF,aAAA/+B,SAEAtwD,KAAAqvF,YAAA,IACArvF,KAAAqvF,aAAA/+B,UAEAtwD,KAAA83E,SAIA93E,KAAAwhC,OAMA,QAAA1wB,GAAA,EAAAgvF,GAAA9/F,KAAA0hG,UAAA/8F,OAA+Cm7F,GAAAhvF,EAAQA,IAQvD,OANAma,QAAAjrB,KAAA0hG,UAAA5wF,GACA0xF,eAAAv3E,OAAAu3E,eAAA7+C,WAAA3jD,KAAAunC,KAAAvD,MACAwZ,SAAAvyB,OAAAu3E,eAAAhlD,SAIArsC,EAAA,EAAoB,EAAAA,EAAOA,IAAA,CAI3B,GAAA/K,MAAApG,KAAAuiG,SAAApxF,GACAyxF,QAAAJ,eAAAI,QAAAx8F,MACAy8F,QAAAL,eAAAK,QAAAz8F,KAEA,IAAApG,KAAAqiG,UAAA,GAAAQ,QAAAryC,MAAAxwD,KAAAqvF,aACArvF,KAAAqiG,UAAA,GAAAO,QAAApyC,MAAAxwD,KAAAqvF,YAAA,CAKA,IAHAuT,QAAA5iG,KAAAunC,KAAAm6D,UAAA5wF,GAAAu5B,KAAA,GACAw4D,QAAA7iG,KAAA+iG,eAAA38F,KAAA0K,EAAA,GAEA+xF,QAAAryC,KAAAxwD,KAAAqvF,aAAAwT,QAAAn7F,MAAAk7F,QAAAl7F,OAEAk7F,QAAAC,QACAA,QAAA7iG,KAAA+iG,eAAA38F,KAAA0K,EAAA+xF,QAAAn7F,MAAA,EAIA86F,gBAAAI,QAAAx8F,MAAAw8F,QACAJ,eAAAK,QAAAz8F,MAAAy8F,QAIA,GAAAlwE,QAAA3yB,KAAAqvF,YAAAuT,QAAApyC,OAAAqyC,QAAAryC,KAAAoyC,QAAApyC,MAEA2yC,QAAAP,QAAAx8F,MACAg9F,QAAAP,QAAAz8F,KAOA,IALA,EAAAusB,cAAA,GACAA,MAAA,IAAAA,MAAA,GAIA,QAAAvsB,MAEA,GAAApG,KAAAsiG,oBAAA54F,MAAA43F,iBAAAlwB,OAAA,CAEA4xB,UAAA9+F,EAAAi/F,QAAA,IAAAC,QAAA,GAAAD,QAAA,IAAAxwE,MACAqwE,UAAA7+F,EAAAg/F,QAAA,IAAAC,QAAA,GAAAD,QAAA,IAAAxwE,MACAqwE,UAAA9/F,EAAAigG,QAAA,IAAAC,QAAA,GAAAD,QAAA,IAAAxwE,KAGA,IAAA0wE,oBAAArjG,KAAA89B,QAAA99B,KAAA89B,OAAA0f,SAAAilD,eACAx3E,QAAAhoB,SAAAmQ,KAAA4vF,UAAAK,oBACA7lD,SAAAilD,gBAAAziG,KAAA89B,WAEO,IAAA99B,KAAAsiG,oBAAA54F,MAAA43F,iBAAAC,YACPvhG,KAAAsiG,oBAAA54F,MAAA43F,iBAAAE,mBAAA,CAEA93E,OAAA,GAAA1pB,KAAAsjG,eAAA,MAAAxyF,EAAA8xF,QAAAl7F,MAAA,OACAgiB,OAAA,GAAAy5E,QACAz5E,OAAA,GAAA05E,QACA15E,OAAA,GAAA1pB,KAAA+iG,eAAA,MAAAjyF,EAAA+xF,QAAAn7F,MAAA,OAEAirB,MAAA,IAAAA,MAAA,GAEA,IAAA4wE,cAAAL,sBAAAx5E,OAAAiJ,OACA0wE,mBAAArjG,KAAA89B,QAAA99B,KAAA89B,OAAA0f,SAAAilD,eACAjlD,UAAAilD,gBAAAziG,KAAA89B,MAIA,IAAApuB,QAAAub,OAAAhoB,QAMA,IAJAyM,OAAAxL,EAAAwL,OAAAxL,GAAAq/F,aAAA,GAAA7zF,OAAAxL,GAAAm/F,mBACA3zF,OAAAvL,EAAAuL,OAAAvL,GAAAo/F,aAAA,GAAA7zF,OAAAvL,GAAAk/F,mBACA3zF,OAAAxM,EAAAwM,OAAAxM,GAAAqgG,aAAA,GAAA7zF,OAAAxM,GAAAmgG,mBAEArjG,KAAAsiG,oBAAA54F,MAAA43F,iBAAAE,mBAAA,CAEA,GAAAgC,cAAAN,sBAAAx5E,OAAA,KAAAiJ,MAEA7C,QAAA3f,IAAAqzF,aAAA,GAAAA,aAAA,GAAAA,aAAA,IACA1zE,OAAAtvB,IAAAkP,QACAogB,OAAA3rB,EAAA,EACA2rB,OAAAhQ,WAEA,IAAAxB,OAAAzU,KAAAke,MAAA+H,OAAA5rB,EAAA4rB,OAAA5sB,EACA+nB,QAAAhnB,SAAAkM,IAAA,EAAAmO,MAAA,SAMM,YAAAlY,KAKN,GAHAsD,MAAAqT,WAAAgE,MAAAoiF,QAAAC,QAAAH,QAAAtwE,OAGA,IAAA6qB,SAAAklD,iBAEAz3E,OAAA1N,WAAA/M,KAAAyyF,SACAzlD,SAAAklD,iBAAA1iG,KAAA89B,WAEO,CAEP,GAAAulE,oBAAArjG,KAAA89B,QAAA99B,KAAA89B,OAAA0f,SAAAklD,iBACAh5F,OAAAqT,WAAAgE,MAAAkK,OAAA1N,WAAA0lF,QAAAh4E,OAAA1N,WAAA8lF,oBACA7lD,SAAAklD,kBAAA1iG,KAAA89B,WAIM,YAAA13B,KAAA,CAEN48F,UAAA9+F,EAAAi/F,QAAA,IAAAC,QAAA,GAAAD,QAAA,IAAAxwE,MACAqwE,UAAA7+F,EAAAg/F,QAAA,IAAAC,QAAA,GAAAD,QAAA,IAAAxwE,MACAqwE,UAAA9/F,EAAAigG,QAAA,IAAAC,QAAA,GAAAD,QAAA,IAAAxwE,KAEA,IAAA0wE,oBAAArjG,KAAA89B,QAAA99B,KAAA89B,OAAA0f,SAAAmlD,YACA13E,QAAA0H,MAAAvf,KAAA4vF,UAAAK,oBACA7lD,SAAAmlD,aAAA3iG,KAAA89B,QAQA,cAMAilE,eAAA,SAAA38F,KAAA0K,EAAA3P,KAEA,GAAAkpC,MAAArqC,KAAAunC,KAAAm6D,UAAA5wF,GAAAu5B,IAaA,KAXArqC,KAAAsiG,oBAAA54F,MAAA43F,iBAAAC,YACAvhG,KAAAsiG,oBAAA54F,MAAA43F,iBAAAE,mBAEArgG,QAAAkpC,KAAA1lC,OAAA,EAAAxD,IAAAkpC,KAAA1lC,OAAA,EAIAxD,KAAAkpC,KAAA1lC,OAISxD,IAAAkpC,KAAA1lC,OAAmBxD,MAE5B,GAAAyI,SAAAygC,KAAAlpC,KAAAiF,MAEA,MAAAikC,MAAAlpC,IAMA,OAAAnB,MAAAunC,KAAAm6D,UAAA5wF,GAAAu5B,KAAA,IAIAi5D,eAAA,SAAAl9F,KAAA0K,EAAA3P,KAEA,GAAAkpC,MAAArqC,KAAAunC,KAAAm6D,UAAA5wF,GAAAu5B,IAcA,KATAlpC,IAHAnB,KAAAsiG,oBAAA54F,MAAA43F,iBAAAC,YACAvhG,KAAAsiG,oBAAA54F,MAAA43F,iBAAAE,mBAEArgG,IAAA,EAAAA,IAAA,EAIAA,KAAA,EAAAA,QAAAkpC,KAAA1lC,OAKSxD,KAAA,EAAUA,MAEnB,GAAAyI,SAAAygC,KAAAlpC,KAAAiF,MAEA,MAAAikC,MAAAlpC,IAMA,OAAAnB,MAAAunC,KAAAm6D,UAAA5wF,GAAAu5B,UAAA1lC,OAAA,KAgBA+E,MAAA+5F,kBAAA,SAAAl8D,MAEAvnC,KAAAgiG,KAAAz6D,KAAAlc,KACArrB,KAAAunC,KAAA79B,MAAA43F,iBAAA3c,KAAAp9C,MACAvnC,KAAA0hG,UAAAh4F,MAAA43F,iBAAAp5D,MAAAloC,KAAAgiG,MACAhiG,KAAAqvF,YAAA,EACArvF,KAAAqiG,UAAA,KACAriG,KAAA+uF,WAAA,EACA/uF,KAAA0jG,UAAA,EACA1jG,KAAAmvF,MAAA,CAIA,QAAAr+E,GAAA,EAAAgvF,GAAA9/F,KAAA0hG,UAAA/8F,OAA6Cm7F,GAAAhvF,EAAQA,IAAA,CAErD,GAAAu5B,MAAArqC,KAAAunC,KAAAm6D,UAAA5wF,GAAAu5B,KACAs5D,KAAA3jG,KAAAunC,KAAAm6D,UAAA5wF,GAAA6yF,KACA5iG,IAAAf,KAAA0hG,UAAA5wF,EAEA,IAAAu5B,KAAA1lC,QAAAg/F,KAAA,CAEA,OAAA5yF,GAAA,EAAmBA,EAAA4yF,KAAAh/F,OAAiBoM,IAAA,CAEpC,GAAA6yF,KAAAD,KAAA5yF,GACA8yF,KAAA7jG,KAAA+iG,eAAAa,IAAA9yF,EAAA,EAEA+yF,OAEAA,KAAAtiG,MAAAqiG,KAMA7iG,IAAAyjC,kBAAA,EACAxkC,KAAAunC,KAAAm6D,UAAA5wF,GAAAua,KAAAqb,eACA3lC,IAAA0jC,wBAAA,KAQA/6B,MAAA+5F,kBAAAnjG,WAEAM,YAAA8I,MAAA+5F,kBAEAvU,KAAA,SAAAjuD,WAIA,GAFAjhC,KAAAqvF,YAAAzlF,SAAAq3B,oBAAA,EAEAjhC,KAAA+uF,aAAA,GAEA/uF,KAAA+uF,WAAA,CAIA,IAAAj+E,GACAma,OACAI,KAFAy0E,GAAA9/F,KAAA0hG,UAAA/8F,MAIA,KAAAmM,EAAA,EAAegvF,GAAAhvF,EAAQA,IAAA,CAEvBma,OAAAjrB,KAAA0hG,UAAA5wF,GACAua,KAAArrB,KAAAunC,KAAAm6D,UAAA5wF,GAEAlH,SAAAyhB,KAAAm3E,iBAEAn3E,KAAAm3E,kBACAn3E,KAAAm3E,eAAAI,QAAA,KACAv3E,KAAAm3E,eAAAK,QAAA,KACAx3E,KAAAm3E,eAAAM,eAAA73E,OAAAtG,OAIA,IAAA0lB,MAAArqC,KAAAunC,KAAAm6D,UAAA5wF,GAAAu5B,IAEAA,MAAA1lC,SAEA0mB,KAAAm3E,eAAAI,QAAAv4D,KAAA,GACAhf,KAAAm3E,eAAAK,QAAAx4D,KAAA,GAEArqC,KAAAihC,UAAAp3B,KAAAyH,IAAA+4B,KAAA,GAAAmmB,KAAAxwD,KAAAihC,WACAjhC,KAAA8jG,QAAAj6F,KAAA4I,IAAA43B,UAAA1lC,OAAA,GAAA6rD,KAAAxwD,KAAA8jG,UAMA9jG,KAAAwG,OAAA,GAIAxG,KAAA0jG,UAAA,EAEAh6F,MAAA43F,iBAAApS,KAAAlvF,OAIAwhC,KAAA,WAEAxhC,KAAA+uF,WAAA,EACA/uF,KAAA0jG,UAAA,EAEAh6F,MAAA43F,iBAAA9/D,KAAAxhC,KAIA,QAAA8Q,GAAA,EAAkBA,EAAA9Q,KAAAunC,KAAAm6D,UAAA/8F,OAAgCmM,IAAA,CAElD,GAAA/P,KAAAf,KAAA0hG,UAAA5wF,GACAua,KAAArrB,KAAAunC,KAAAm6D,UAAA5wF,EAEA,IAAAlH,SAAAyhB,KAAAm3E,eAAA,CAEA,GAAAuB,UAAA14E,KAAAm3E,eAAAM,cAEAiB,UAAAvzF,KAAAzP,IAAA4jB,QACA5jB,IAAA4jB,OAAAo/E,eAEA14E,MAAAm3E,kBAQAh8F,OAAA,SAAAmM,OAEA,GAAA3S,KAAA+uF,aAAA,GAEA/uF,KAAAqvF,aAAA18E,MAAA3S,KAAAqiG,SAIA,IAAA/xC,UAAAtwD,KAAAunC,KAAA5iC,MAEA3E,MAAAmvF,QAAA,GAAAnvF,KAAAqvF,YAAA/+B,WAEAtwD,KAAAqvF,aAAA/+B,UAIAtwD,KAAAqvF,YAAAxlF,KAAAyH,IAAAtR,KAAAqvF,YAAA/+B,SAEA,QAAAx/C,GAAA,EAAAgvF,GAAA9/F,KAAA0hG,UAAA/8F,OAA8Cm7F,GAAAhvF,EAAQA,IAAA,CAEtD,GAAAma,QAAAjrB,KAAA0hG,UAAA5wF,GACAua,KAAArrB,KAAAunC,KAAAm6D,UAAA5wF,GAEAu5B,KAAAhf,KAAAgf,KACAm4D,eAAAn3E,KAAAm3E,cAGA,IAAAn4D,KAAA1lC,OAAA,CAEA,GAAAi+F,SAAAJ,eAAAI,QACAC,QAAAL,eAAAK,OAEA,IAAAA,QAAAryC,MAAAxwD,KAAAqvF,YAAA,CAEA,KAAAwT,QAAAryC,KAAAxwD,KAAAqvF,aAAAwT,QAAAn7F,MAAAk7F,QAAAl7F,OAEAk7F,QAAAC,QACAA,QAAAx4D,KAAAu4D,QAAAl7F,MAAA,EAIA86F,gBAAAI,gBACAJ,eAAAK,gBAIAA,QAAAryC,MAAAxwD,KAAAqvF,YAEAuT,QAAAllE,YAAAmlE,QAAA7iG,KAAAqvF,aAIAuT,QAAAllE,YAAAmlE,gBAAAryC,MAIAxwD,KAAAunC,KAAAm6D,UAAA5wF,GAAAua,KAAAqb,eACAzb,OAAAwZ,wBAAA,MAQAs+D,eAAA,SAAAa,IAAA9yF,EAAA3P,KAEA,GAAAkpC,MAAArqC,KAAAunC,KAAAm6D,UAAA5wF,GAAAu5B,IAGA,KAFAlpC,KAAAkpC,KAAA1lC,OAESxD,IAAAkpC,KAAA1lC,OAAmBxD,MAE5B,GAAAkpC,KAAAlpC,KAAA6iG,UAAAJ,KAEA,MAAAv5D,MAAAlpC,IAMA,OAAAkpC,MAAA,IAIAi5D,eAAA,SAAAM,IAAA9yF,EAAA3P,KAEA,GAAAkpC,MAAArqC,KAAAunC,KAAAm6D,UAAA5wF,GAAAu5B,IAGA,KAFAlpC,SAAA,EAAAA,QAAAkpC,KAAA1lC,OAESxD,KAAA,EAAUA,MAEnB,GAAAkpC,KAAAlpC,KAAA6iG,UAAAJ,KAEA,MAAAv5D,MAAAlpC,IAMA,OAAAkpC,WAAA1lC,OAAA,KAaA+E,MAAAu6F,eAAA,SAAAxgG,MAEAzD,KAAAyD,UACAzD,KAAAkkG,OAAAzgG,KAAAuqD,sBAAArpD,OACA3E,KAAAqvF,YAAA,EACArvF,KAAAswD,SAAA,IACAtwD,KAAAmvF,MAAA,EACAnvF,KAAAmkG,UAAA,EACAnkG,KAAAokG,aAAA,EAEApkG,KAAA+uF,WAAA,GAIArlF,MAAAu6F,eAAA3jG,WAEAM,YAAA8I,MAAAu6F,eAEA/U,KAAA,WAEAlvF,KAAA+uF,WAAA,GAIAK,MAAA,WAEApvF,KAAA+uF,WAAA,GAIAvoF,OAAA,SAAAmM,OAEA,GAAA3S,KAAA+uF,aAAA,GAEA/uF,KAAAqvF,aAAA18E,MAEA3S,KAAAmvF,QAAA,GAAAnvF,KAAAqvF,YAAArvF,KAAAswD,WAEAtwD,KAAAqvF,aAAArvF,KAAAswD,UAIAtwD,KAAAqvF,YAAAxlF,KAAAyH,IAAAtR,KAAAqvF,YAAArvF,KAAAswD,SAEA,IAAA+zC,eAAArkG,KAAAswD,SAAAtwD,KAAAkkG,OACAI,MAAAz6F,KAAA+G,MAAA5Q,KAAAqvF,YAAAgV,eAEAtyC,WAAA/xD,KAAAyD,KAAAuqD,qBAEAs2C,QAAAtkG,KAAAokG,eAEAryC,WAAA/xD,KAAAmkG,WAAA,EACApyC,WAAA/xD,KAAAokG,cAAA,EACAryC,WAAAuyC,OAAA,EAEAtkG,KAAAmkG,UAAAnkG,KAAAokG,aACApkG,KAAAokG,aAAAE,OAIAvyC,WAAAuyC,OAAAtkG,KAAAqvF,YAAAgV,4BACAtyC,WAAA/xD,KAAAmkG,WAAA,EAAApyC,WAAAuyC,UAaA56F,MAAAtG,YAAA,SAAAi0C,MAAAC,OAAAmO,MAAAF,cAAAC,eAAAE,eAgCA,QAAA6+C,YAAAhkE,EAAAtgB,EAAAukF,KAAAC,KAAAptD,MAAAC,OAAAmO,MAAArd,eAEA,GAAAprB,GAAAuH,GAAAC,GACAkgF,MAAAx5E,MAAAq6B,cACAo/C,MAAAz5E,MAAAs6B,eACAo/C,WAAAvtD,MAAA,EACAwtD,YAAAvtD,OAAA,EACA5jC,OAAAwX,MAAAK,SAAA5mB,MAEA,OAAA47B,GAAA,MAAAtgB,GAAA,MAAAsgB,GAAA,MAAAtgB,EAEAjD,EAAA,IAEG,MAAAujB,GAAA,MAAAtgB,GAAA,MAAAsgB,GAAA,MAAAtgB,GAEHjD,EAAA,IACA2nF,MAAAz5E,MAAAw6B,gBAEG,MAAAnlB,GAAA,MAAAtgB,GAAA,MAAAsgB,GAAA,MAAAtgB,KAEHjD,EAAA,IACA0nF,MAAAx5E,MAAAw6B,cAIA,IAAAo/C,QAAAJ,MAAA,EACAK,OAAAJ,MAAA,EACAK,cAAA3tD,MAAAqtD,MACAO,eAAA3tD,OAAAqtD,MACA7+E,OAAA,GAAApc,OAAAgW,OAIA,KAFAoG,OAAA9I,GAAAyoC,MAAA,OAEAjhC,GAAA,EAAeugF,OAAAvgF,GAAaA,KAE5B,IAAAD,GAAA,EAAgBugF,OAAAvgF,GAAaA,KAAA,CAE7B,GAAA7U,QAAA,GAAAhG,OAAAgW,OACAhQ,QAAA6wB,IAAAhc,GAAAygF,cAAAJ,YAAAJ,KACA90F,OAAAuQ,IAAAuE,GAAAygF,eAAAJ,aAAAJ,KACA/0F,OAAAsN,GAAAyoC,MAEAv6B,MAAAK,SAAAjnB,KAAAoL,QAMA,IAAA8U,GAAA,EAAemgF,MAAAngF,GAAYA,KAE3B,IAAAD,GAAA,EAAgBmgF,MAAAngF,GAAYA,KAAA,CAE5B,GAAAnE,GAAAmE,GAAAugF,OAAAtgF,GACAlU,EAAAiU,GAAAugF,QAAAtgF,GAAA,GACAhlB,EAAA+kB,GAAA,EAAAugF,QAAAtgF,GAAA,GACAN,EAAAK,GAAA,EAAAugF,OAAAtgF,GAEAmnB,IAAA,GAAAjiC,OAAAiY,QAAA4C,GAAAmgF,MAAA,EAAAlgF,GAAAmgF,OACA/4D,IAAA,GAAAliC,OAAAiY,QAAA4C,GAAAmgF,MAAA,GAAAlgF,GAAA,GAAAmgF,OACA94D,IAAA,GAAAniC,OAAAiY,SAAA4C,GAAA,GAAAmgF,MAAA,GAAAlgF,GAAA,GAAAmgF,OACAO,IAAA,GAAAx7F,OAAAiY,SAAA4C,GAAA,GAAAmgF,MAAA,EAAAlgF,GAAAmgF,OAEAn8D,KAAA,GAAA9+B,OAAAy+B,MAAA/nB,EAAA1M,OAAApD,EAAAoD,OAAAwQ,EAAAxQ,OACA80B,MAAA1iB,OAAAtV,KAAAsV,QACA0iB,KAAAH,cAAA/jC,KAAAwhB,OAAAnS,QAAAmS,OAAAnS,QAAAmS,OAAAnS,SACA60B,KAAAJ,4BAEAld,MAAA0f,MAAAtmC,KAAAkkC,MACAtd,MAAA2f,cAAA,GAAAvmC,MAAAqnC,IAAAC,IAAAs5D,MAEA18D,KAAA,GAAA9+B,OAAAy+B,MAAA73B,EAAAoD,OAAAlU,EAAAkU,OAAAwQ,EAAAxQ,QACA80B,KAAA1iB,OAAAtV,KAAAsV,QACA0iB,KAAAH,cAAA/jC,KAAAwhB,OAAAnS,QAAAmS,OAAAnS,QAAAmS,OAAAnS,SACA60B,KAAAJ,4BAEAld,MAAA0f,MAAAtmC,KAAAkkC,MACAtd,MAAA2f,cAAA,GAAAvmC,MAAAsnC,IAAAj4B,QAAAk4B,IAAAq5D,IAAAvxF,WA1GAjK,MAAA4hB,SAAAhsB,KAAAU,MAEAA,KAAAoG,KAAA,cAEApG,KAAA+0C,YACAsC,YACAC,cACAmO,YACAF,4BACAC,8BACAE,6BAGA1lD,KAAAulD,6BAAA,EACAvlD,KAAAwlD,+BAAA,EACAxlD,KAAA0lD,6BAAA,CAEA,IAAAx6B,OAAAlrB,KAEA4kG,WAAAvtD,MAAA,EACAwtD,YAAAvtD,OAAA,EACA6tD,WAAA1/C,MAAA,CAEA8+C,YAAA,cAAA9+C,MAAAnO,OAAAstD,WAAA,GACAL,WAAA,aAAA9+C,MAAAnO,QAAAstD,WAAA,GACAL,WAAA,YAAAltD,MAAAoO,MAAAo/C,YAAA,GACAN,WAAA,aAAAltD,MAAAoO,OAAAo/C,YAAA,GACAN,WAAA,aAAAltD,MAAAC,OAAA6tD,WAAA,GACAZ,WAAA,cAAAltD,MAAAC,QAAA6tD,WAAA,GAsFAnlG,KAAA8zC,iBAIApqC,MAAAtG,YAAA9C,UAAAujC,OAAAiG,OAAApgC,MAAA4hB,SAAAhrB,WACAoJ,MAAAtG,YAAA9C,UAAAM,YAAA8I,MAAAtG,YAQAsG,MAAAi8C,eAAA,SAAA95B,OAAA+5B,SAAAS,WAAAC,aAEA58C,MAAA4hB,SAAAhsB,KAAAU,MAEAA,KAAAoG,KAAA,iBAEApG,KAAA+0C,YACAlpB,cACA+5B,kBACAS,sBACAC,yBAGAz6B,eAAA,GACA+5B,SAAAh8C,SAAAg8C,SAAA/7C,KAAA4I,IAAA,EAAAmzC,UAAA,EAEAS,WAAAz8C,SAAAy8C,sBAAA,EACAC,YAAA18C,SAAA08C,wBAAA,EAAAz8C,KAAAud,EAEA,IAAA1iB,GAAAwmC,OACAviB,OAAA,GAAAjf,OAAAgW,QAAA0lF,SAAA,GAAA17F,OAAAiY,QAAA,MAKA,KAHA3hB,KAAAurB,SAAAjnB,KAAAqkB,QACAuiB,IAAA5mC,KAAA8gG,UAEA1gG,EAAA,EAAakhD,UAAAlhD,EAAeA,IAAA,CAE5B,GAAA8sC,QAAA,GAAA9nC,OAAAgW,QACA2lF,QAAAh/C,WAAA3hD,EAAAkhD,SAAAU,WAEA9U,QAAAttC,EAAA2nB,OAAAhiB,KAAA+T,IAAAynF,SACA7zD,OAAArtC,EAAA0nB,OAAAhiB,KAAAmU,IAAAqnF,SAEArlG,KAAAurB,SAAAjnB,KAAAktC,QACAtG,IAAA5mC,KAAA,GAAAoF,OAAAiY,SAAA6vB,OAAAttC,EAAA2nB,OAAA,MAAA2lB,OAAArtC,EAAA0nB,OAAA,OAIA,GAAAmE,GAAA,GAAAtmB,OAAAgW,QAAA,MAEA,KAAAhb,EAAA,EAAakhD,UAAAlhD,EAAeA,IAE5B1E,KAAA4qC,MAAAtmC,KAAA,GAAAoF,OAAAy+B,MAAAzjC,IAAA,KAAAsrB,EAAArc,QAAAqc,EAAArc,QAAAqc,EAAArc,WACA3T,KAAA6qC,cAAA,GAAAvmC,MAAA4mC,IAAAxmC,GAAAiP,QAAAu3B,IAAAxmC,EAAA,GAAAiP,QAAAyxF,SAAAzxF,SAIA3T,MAAAgsC,qBAEAhsC,KAAAu6B,eAAA,GAAA7wB,OAAAkiB,OAAA,GAAAliB,OAAAgW,QAAAmM,SAIAniB,MAAAi8C,eAAArlD,UAAAujC,OAAAiG,OAAApgC,MAAA4hB,SAAAhrB,WACAoJ,MAAAi8C,eAAArlD,UAAAM,YAAA8I,MAAAi8C,eASAj8C,MAAA47F,aAAA,SAAAjuD,MAAAC,OAAAmO,MAAAF,cAAAC,eAAAE,eAGA,MADAh8C,OAAAK,KAAA,6DACA,GAAAL,OAAAtG,YAAAi0C,MAAAC,OAAAmO,MAAAF,cAAAC,eAAAE,gBAUAh8C,MAAAm8C,iBAAA,SAAAC,UAAAC,aAAAzO,OAAA0O,eAAAR,eAAAS,UAAAI,WAAAC,aAEA58C,MAAA4hB,SAAAhsB,KAAAU,MAEAA,KAAAoG,KAAA,mBAEApG,KAAA+0C,YACA+Q,oBACAC,0BACAzO,cACA0O,8BACAR,8BACAS,oBACAI,sBACAC,yBAGAR,UAAAl8C,SAAAk8C,oBAAA,GACAC,aAAAn8C,SAAAm8C,0BAAA,GACAzO,OAAA1tC,SAAA0tC,cAAA,IAEA0O,+BAAA,EACAR,+BAAA,EAEAS,UAAAr8C,SAAAq8C,qBAAA,EACAI,WAAAz8C,SAAAy8C,sBAAA,EACAC,YAAA18C,SAAA08C,wBAAA,EAAAz8C,KAAAud,EAEA,IAEAljB,GAAAC,EAFAohG,WAAAjuD,OAAA,EAEA/rB,YAAA2f,MAEA,KAAA/mC,EAAA,EAAaqhD,gBAAArhD,EAAqBA,IAAA,CAElC,GAAAqhG,gBACAC,UAEAxlF,EAAA9b,EAAAqhD,eACA35B,OAAA5L,GAAA8lC,aAAAD,oBAEA,KAAA5hD,EAAA,EAAc8hD,gBAAA9hD,EAAqBA,IAAA,CAEnC,GAAAq8B,GAAAr8B,EAAA8hD,eAEAxU,OAAA,GAAA9nC,OAAAgW,OACA8xB,QAAAttC,EAAA2nB,OAAAhiB,KAAAmU,IAAAuiB,EAAA+lB,YAAAD,YACA7U,OAAArtC,GAAA8b,EAAAq3B,OAAAiuD,WACA/zD,OAAAtuC,EAAA2oB,OAAAhiB,KAAA+T,IAAA2iB,EAAA+lB,YAAAD,YAEArmD,KAAAurB,SAAAjnB,KAAAktC,QAEAg0D,YAAAlhG,KAAAtE,KAAAurB,SAAA5mB,OAAA,GACA8gG,OAAAnhG,KAAA,GAAAoF,OAAAiY,QAAA4e,EAAA,EAAAtgB,IAIAsL,SAAAjnB,KAAAkhG,aACAt6D,IAAA5mC,KAAAmhG,QAIA,GACAr6D,IAAAC,GADAq6D,UAAA3/C,aAAAD,WAAAxO,MAGA,KAAApzC,EAAA,EAAa8hD,eAAA9hD,EAAoBA,IAiBjC,IAfA,IAAA4hD,WAEA1a,GAAAprC,KAAAurB,kBAAA,GAAArnB,IAAAyP,QACA03B,GAAArrC,KAAAurB,kBAAA,GAAArnB,EAAA,IAAAyP,UAIAy3B,GAAAprC,KAAAurB,kBAAA,GAAArnB,IAAAyP,QACA03B,GAAArrC,KAAAurB,kBAAA,GAAArnB,EAAA,IAAAyP,SAIAy3B,GAAAvpB,KAAAhY,KAAAmI,KAAAo5B,GAAAlnC,EAAAknC,GAAAlnC,EAAAknC,GAAAloC,EAAAkoC,GAAAloC,GAAAwiG,UAAA5lF,YACAurB,GAAAxpB,KAAAhY,KAAAmI,KAAAq5B,GAAAnnC,EAAAmnC,GAAAnnC,EAAAmnC,GAAAnoC,EAAAmoC,GAAAnoC,GAAAwiG,UAAA5lF,YAEA3b,EAAA,EAAcqhD,eAAArhD,EAAoBA,IAAA,CAElC,GAAAmb,IAAAiM,SAAApnB,GAAAD,GACAof,GAAAiI,SAAApnB,EAAA,GAAAD,GACAm6B,GAAA9S,SAAApnB,EAAA,GAAAD,EAAA,GACAyhG,GAAAp6E,SAAApnB,GAAAD,EAAA,GAEAq3D,GAAAnwB,GAAAz3B,QACA+5B,GAAAtC,GAAAz3B,QACA6nD,GAAAnwB,GAAA13B,QACAiyF,GAAAv6D,GAAA13B,QAEAkyF,IAAA36D,IAAA/mC,GAAAD,GAAAyP,QACA63C,IAAAtgB,IAAA/mC,EAAA,GAAAD,GAAAyP,QACAmyF,IAAA56D,IAAA/mC,EAAA,GAAAD,EAAA,GAAAyP,QACAoyF,IAAA76D,IAAA/mC,GAAAD,EAAA,GAAAyP,OAEA3T,MAAA4qC,MAAAtmC,KAAA,GAAAoF,OAAAy+B,MAAA7oB,GAAAgE,GAAAqiF,IAAApqC,GAAA7tB,GAAAk4D,MACA5lG,KAAA6qC,cAAA,GAAAvmC,MAAAuhG,IAAAr6C,IAAAu6C,MAEA/lG,KAAA4qC,MAAAtmC,KAAA,GAAAoF,OAAAy+B,MAAA7kB,GAAA+a,GAAAsnE,IAAAj4D,GAAA/5B,QAAA6nD,GAAAoqC,GAAAjyF,WACA3T,KAAA6qC,cAAA,GAAAvmC,MAAAknD,IAAA73C,QAAAmyF,IAAAC,IAAApyF,UAQA,GAAAsyC,aAAA,GAAAH,UAAA,EAIA,IAFA9lD,KAAAurB,SAAAjnB,KAAA,GAAAoF,OAAAgW,QAAA,EAAA6lF,WAAA,IAEArhG,EAAA,EAAc8hD,eAAA9hD,EAAoBA,IAAA,CAElC,GAAAob,IAAAiM,SAAA,GAAArnB,GACAof,GAAAiI,SAAA,GAAArnB,EAAA,GACAm6B,GAAAr+B,KAAAurB,SAAA5mB,OAAA,EAEA42D,GAAA,GAAA7xD,OAAAgW,QAAA,OACAguB,GAAA,GAAAhkC,OAAAgW,QAAA,OACA87C,GAAA,GAAA9xD,OAAAgW,QAAA,OAEAmmF,IAAA36D,IAAA,GAAAhnC,GAAAyP,QACA63C,IAAAtgB,IAAA,GAAAhnC,EAAA,GAAAyP,QACAmyF,IAAA,GAAAp8F,OAAAiY,QAAA6pC,IAAAtnD,EAAA,EAEAlE,MAAA4qC,MAAAtmC,KAAA,GAAAoF,OAAAy+B,MAAA7oB,GAAAgE,GAAA+a,IAAAk9B,GAAA7tB,GAAA8tB,MACAx7D,KAAA6qC,cAAA,GAAAvmC,MAAAuhG,IAAAr6C,IAAAs6C,MAQA,GAAA7/C,aAAA,GAAAF,aAAA,EAIA,IAFA/lD,KAAAurB,SAAAjnB,KAAA,GAAAoF,OAAAgW,QAAA,GAAA6lF,WAAA,IAEArhG,EAAA,EAAc8hD,eAAA9hD,EAAoBA,IAAA,CAElC,GAAAob,IAAAiM,SAAAi6B,gBAAAthD,EAAA,GACAof,GAAAiI,SAAAi6B,gBAAAthD,GACAm6B,GAAAr+B,KAAAurB,SAAA5mB,OAAA,EAEA42D,GAAA,GAAA7xD,OAAAgW,QAAA,QACAguB,GAAA,GAAAhkC,OAAAgW,QAAA,QACA87C,GAAA,GAAA9xD,OAAAgW,QAAA,QAEAmmF,IAAA36D,IAAAsa,gBAAAthD,EAAA,GAAAyP,QACA63C,IAAAtgB,IAAAsa,gBAAAthD,GAAAyP,QACAmyF,IAAA,GAAAp8F,OAAAiY,QAAA6pC,IAAAtnD,EAAA,EAEAlE,MAAA4qC,MAAAtmC,KAAA,GAAAoF,OAAAy+B,MAAA7oB,GAAAgE,GAAA+a,IAAAk9B,GAAA7tB,GAAA8tB,MACAx7D,KAAA6qC,cAAA,GAAAvmC,MAAAuhG,IAAAr6C,IAAAs6C,MAMA9lG,KAAAgsC,sBAIAtiC,MAAAm8C,iBAAAvlD,UAAAujC,OAAAiG,OAAApgC,MAAA4hB,SAAAhrB,WACAoJ,MAAAm8C,iBAAAvlD,UAAAM,YAAA8I,MAAAm8C,iBA8BAn8C,MAAA+wF,gBAAA,SAAAlO,OAAArnF,SAEA,sCACAqnF,YAIA7iF,MAAA4hB,SAAAhsB,KAAAU,MAEAA,KAAAoG,KAAA,kBAEAmmF,wBAAAtwD,OAAAswD,gBAEAvsF,KAAAgmG,aAAAzZ,OAAArnF,aAEAlF,MAAAgsC,uBAYAtiC,MAAA+wF,gBAAAn6F,UAAAujC,OAAAiG,OAAApgC,MAAA4hB,SAAAhrB,WACAoJ,MAAA+wF,gBAAAn6F,UAAAM,YAAA8I,MAAA+wF,gBAEA/wF,MAAA+wF,gBAAAn6F,UAAA0lG,aAAA,SAAAzZ,OAAArnF,SAGA,OAFA06B,IAAA2sD,OAAA5nF,OAEAoM,EAAA,EAAiB6uB,GAAA7uB,EAAQA,IAAA,CACzB,GAAAiqF,OAAAzO,OAAAx7E,EACA/Q,MAAAimG,SAAAjL,MAAA91F,WAIAwE,MAAA+wF,gBAAAn6F,UAAA2lG,SAAA,SAAAjL,MAAA91F,SA4GA,QAAAghG,UAAAC,GAAAxU,IAAA5nE,MAIA,MAFA4nE,MAAAjoF,MAAAM,MAAA,6CAEA2nF,IAAAh+E,QAAAR,eAAA4W,MAAApmB,IAAAwiG,IAYA,QAAAC,aAAA5N,KAAA6N,OAAAC,QAEA,GASAC,WAAAC,UATA9Z,QAAA,MASA+Z,UAAA,EAKAC,SAAAlO,KAAAt0F,EAAAmiG,OAAAniG,EAAAyiG,SAAAnO,KAAAr0F,EAAAkiG,OAAAliG,EACAyiG,SAAAN,OAAApiG,EAAAs0F,KAAAt0F,EAAA2iG,SAAAP,OAAAniG,EAAAq0F,KAAAr0F,EAEA2iG,aAAAJ,kBAAAC,kBAGAI,UAAAL,SAAAG,SAAAF,SAAAC,QAEA,IAAA/8F,KAAA+V,IAAAmnF,WAAAra,QAAA,CAIA,GAAAsa,YAAAn9F,KAAAmI,KAAA80F,cACAG,WAAAp9F,KAAAmI,KAAA40F,kBAAAC,mBAIAK,cAAAb,OAAAniG,EAAAyiG,SAAAK,WACAG,cAAAd,OAAAliG,EAAAuiG,SAAAM,WAEAI,cAAAd,OAAApiG,EAAA2iG,SAAAI,WACAI,cAAAf,OAAAniG,EAAAyiG,SAAAK,WAIAK,KAAAF,cAAAF,eAAAL,UACAQ,cAAAF,eAAAP,WACAF,SAAAG,SAAAF,SAAAC,SAIAL,WAAAW,cAAAR,SAAAY,GAAA9O,KAAAt0F,EACAsiG,UAAAW,cAAAR,SAAAW,GAAA9O,KAAAr0F,CAIA,IAAAojG,eAAAhB,oBAAAC,mBACA,OAAAe,cACA,UAAA79F,OAAAiY,QAAA4kF,UAAAC,UAEAC,WAAA58F,KAAAmI,KAAAu1F,cAAA,OAGG,CAEH,GAAAC,eAAA,CACAd,UAAAha,QACAka,SAAAla,UAA+B8a,cAAA,IAE/B9a,QAAAga,UACAha,QAAAka,WAAkCY,cAAA,GAElC39F,KAAAC,KAAA68F,WAAA98F,KAAAC,KAAA+8F,YAAwDW,cAAA,GAIxDA,cAEAjB,WAAAI,SACAH,UAAAE,SACAD,UAAA58F,KAAAmI,KAAA80F,gBAGAP,UAAAG,SACAF,UAAAG,SACAF,UAAA58F,KAAAmI,KAAA80F,aAAA,IAKA,UAAAp9F,OAAAiY,QAAA4kF,UAAAE,UAAAD,UAAAC,WA2MA,QAAAgB,iBAEA,GAAAC,aAAA,CAEA,GAAAC,OAAA,EACAj0F,OAAAiiF,KAAAgS,KAIA,KAAAjjG,EAAA,EAAekjG,KAAAljG,EAAUA,IAEzB8jC,KAAAoC,MAAAlmC,GACAmjG,GAAAr/D,KAAA,GAAA90B,OAAA80B,KAAA,GAAA90B,OAAA80B,KAAA,GAAA90B,OASA,KALAi0F,MAAAG,MAAA,EAAAC,cACAr0F,OAAAiiF,KAAAgS,MAIAjjG,EAAA,EAAekjG,KAAAljG,EAAUA,IAEzB8jC,KAAAoC,MAAAlmC,GACAmjG,GAAAr/D,KAAA,GAAA90B,OAAA80B,KAAA,GAAA90B,OAAA80B,KAAA,GAAA90B,YAIG,CAIH,IAAAhP,EAAA,EAAekjG,KAAAljG,EAAUA,IAEzB8jC,KAAAoC,MAAAlmC,GACAmjG,GAAAr/D,KAAA,GAAAA,KAAA,GAAAA,KAAA,GAMA,KAAA9jC,EAAA,EAAekjG,KAAAljG,EAAUA,IAEzB8jC,KAAAoC,MAAAlmC,GACAmjG,GAAAr/D,KAAA,GAAAmtD,KAAAmS,MAAAt/D,KAAA,GAAAmtD,KAAAmS,MAAAt/D,KAAA,GAAAmtD,KAAAmS,QASA,QAAAE,kBAEA,GAAAC,aAAA,CAIA,KAHAC,UAAAtb,QAAAqb,aACAA,aAAArb,QAAAjoF,OAEAmM,EAAA,EAAAgvF,GAAAxF,MAAA31F,OAAiCm7F,GAAAhvF,EAAQA,IAEzCq3F,MAAA7N,MAAAxpF,GACAo3F,UAAAC,MAAAF,aAGAA,aAAAE,MAAAxjG,OAMA,QAAAujG,WAAAtb,QAAAqb,aAEA,GAAA3iG,GAAAk5B,CAGA,KAFA95B,EAAAkoF,QAAAjoF,SAEAD,GAAA,IAEAY,EAAAZ,EACA85B,EAAA95B,EAAA,EACA,EAAA85B,MAAAouD,QAAAjoF,OAAA,EAIA,IAAAoM,GAAA,EAAA6uB,GAAAkoE,MAAA,EAAAC,aAEA,KAAAh3F,EAAA,EAAe6uB,GAAA7uB,EAAQA,IAAA,CAEvB,GAAAq3F,OAAAzS,KAAA5kF,EACAs3F,MAAA1S,MAAA5kF,EAAA,GAEAqP,EAAA6nF,YAAA3iG,EAAA8iG,MACA93F,EAAA23F,YAAAzpE,EAAA4pE,MACA5oG,EAAAyoG,YAAAzpE,EAAA6pE,MACAnkF,EAAA+jF,YAAA3iG,EAAA+iG,KAEAC,IAAAloF,EAAA9P,EAAA9Q,EAAA0kB,EAAA0oE,QAAA77E,EAAA6uB,GAAAt6B,EAAAk5B,KAQA,QAAAve,GAAA/b,EAAAC,EAAAjB,GAEAgoB,MAAAK,SAAAjnB,KAAA,GAAAoF,OAAAgW,QAAAxb,EAAAC,EAAAjB,IAIA,QAAA2kG,IAAAznF,EAAA9P,EAAA9Q,GAEA4gB,GAAAmoF,aACAj4F,GAAAi4F,aACA/oG,GAAA+oG,aAGAr9E,MAAA0f,MAAAtmC,KAAA,GAAAoF,OAAAy+B,MAAA/nB,EAAA9P,EAAA9Q,EAAA,UAAA6D,UAEA,IAAA6nC,KAAAs9D,MAAAC,cAAAv9E,MAAA9K,EAAA9P,EAAA9Q,EAEA0rB,OAAA2f,cAAA,GAAAvmC,KAAA4mC,KAIA,QAAAo9D,IAAAloF,EAAA9P,EAAA9Q,EAAA0kB,EAAAwkF,YAAAC,UAAAC,YAAAC,cAAAC,eAEA1oF,GAAAmoF,aACAj4F,GAAAi4F,aACA/oG,GAAA+oG,aACArkF,GAAAqkF,aAEAr9E,MAAA0f,MAAAtmC,KAAA,GAAAoF,OAAAy+B,MAAA/nB,EAAA9P,EAAA4T,EAAA,UAAA6kF,kBACA79E,MAAA0f,MAAAtmC,KAAA,GAAAoF,OAAAy+B,MAAA73B,EAAA9Q,EAAA0kB,EAAA,UAAA6kF,iBAEA,IAAA79D,KAAAs9D,MAAAQ,mBAAA99E,MAAA9K,EAAA9P,EAAA9Q,EAAA0kB,EAEAgH,OAAA2f,cAAA,GAAAvmC,MAAA4mC,IAAA,GAAAA,IAAA,GAAAA,IAAA,KACAhgB,MAAA2f,cAAA,GAAAvmC,MAAA4mC,IAAA,GAAAA,IAAA,GAAAA,IAAA,KAriBA,GAaA+9D,YAQAC,WAAAC,SAAArjF,OAAAsjF,UArBAC,OAAAz/F,SAAA1E,QAAAmkG,OAAAnkG,QAAAmkG,OAAA,IAEAC,eAAA1/F,SAAA1E,QAAAokG,eAAApkG,QAAAokG,eAAA,EACAC,UAAA3/F,SAAA1E,QAAAqkG,UAAArkG,QAAAqkG,UAAAD,eAAA,EACAvB,cAAAn+F,SAAA1E,QAAA6iG,cAAA7iG,QAAA6iG,cAAA,EAEAL,aAAA99F,SAAA1E,QAAAwiG,aAAAxiG,QAAAwiG,cAAA,EAEArb,cAAAziF,SAAA1E,QAAAmnF,cAAAnnF,QAAAmnF,cAAA,GAEAyb,MAAAl+F,SAAA1E,QAAA4iG,MAAA5iG,QAAA4iG,MAAA,EAEA0B,YAAAtkG,QAAAskG,YACAC,eAAA,EAEApmG,SAAA6B,QAAA7B,SACA0lG,gBAAA7jG,QAAA6jG,gBAGAP,MAAA5+F,SAAA1E,QAAAwkG,YAAAxkG,QAAAwkG,YAAAhgG,MAAA+wF,gBAAAkP,gBAGAH,eAEAP,WAAAO,YAAAhZ,gBAAAsX,OAEA2B,eAAA,EACA/B,cAAA,EAOAwB,WAAAt/F,SAAA1E,QAAAg/F,OAAAh/F,QAAAg/F,OAAA,GAAAx6F,OAAAkgG,aAAAC,aAAAL,YAAA1B,OAAA,GAIAqB,SAAA,GAAAz/F,OAAAgW,QACAoG,OAAA,GAAApc,OAAAgW,QACA0pF,UAAA,GAAA1/F,OAAAgW,SAMAgoF,eAEAK,cAAA,EACAuB,eAAA,EACAC,UAAA,EAMA,IAAApB,OAAAr3F,EAAAgvF,GACA50E,MAAAlrB,KAEAuoG,aAAAvoG,KAAAurB,SAAA5mB,OAEAmlG,YAAA9O,MAAAC,cAAA5O,eAEA9gE,SAAAu+E,YAAA9O,MACAV,MAAAwP,YAAAxP,MAEAyP,SAAArgG,MAAAqiF,MAAAC,MAAAmN,YAAA5tE,SAEA,IAAAw+E,QAAA,CAMA,IAJAx+E,kBAAAw+E,UAIAj5F,EAAA,EAAAgvF,GAAAxF,MAAA31F,OAAiCm7F,GAAAhvF,EAAQA,IAEzCq3F,MAAA7N,MAAAxpF,GAEApH,MAAAqiF,MAAAC,MAAAmN,YAAAgP,SAEA7N,MAAAxpF,GAAAq3F,MAAA4B,UAMAA,UAAA,EAKA,GAAAn/D,OAAAlhC,MAAAqiF,MAAAC,MAAAmP,iBAAA5vE,SAAA+uE,OAIA1N,QAAArhE,QAEA,KAAAza,EAAA,EAAAgvF,GAAAxF,MAAA31F,OAAgCm7F,GAAAhvF,EAAQA,IAExCq3F,MAAA7N,MAAAxpF,GAEAya,kBAAAksE,OAAA0Q,MAkHA,QArGA73F,GAAA05F,GAAA74F,EAAAjO,EACA+mG,KACAzhE,KADAmtD,KAAApqE,SAAA5mB,OACAijG,KAAAh9D,MAAAjmC,OAiGAulG,oBAEAxlG,EAAA,EAAAklB,GAAAgjE,QAAAjoF,OAAAW,EAAAskB,GAAA,EAAA4U,EAAA95B,EAAA,EAA6DklB,GAAAllB,EAAQA,IAAAY,IAAAk5B,IAErEl5B,IAAAskB,KAAAtkB,EAAA,GACAk5B,IAAA5U,KAAA4U,EAAA,GAKA0rE,iBAAAxlG,GAAA0hG,YAAAxZ,QAAAloF,GAAAkoF,QAAAtnF,GAAAsnF,QAAApuD,GAIA,IAAA2rE,kBAAAC,kBAAAC,kBAAAH,iBAAAzS,QAEA,KAAA3mF,EAAA,EAAAgvF,GAAAxF,MAAA31F,OAAgCm7F,GAAAhvF,EAAQA,IAAA,CAMxC,IAJAq3F,MAAA7N,MAAAxpF,GAEAq5F,oBAEAzlG,EAAA,EAAAklB,GAAAu+E,MAAAxjG,OAAAW,EAAAskB,GAAA,EAAA4U,EAAA95B,EAAA,EAAwDklB,GAAAllB,EAAQA,IAAAY,IAAAk5B,IAEhEl5B,IAAAskB,KAAAtkB,EAAA,GACAk5B,IAAA5U,KAAA4U,EAAA,GAGA2rE,iBAAAzlG,GAAA0hG,YAAA+B,MAAAzjG,GAAAyjG,MAAA7iG,GAAA6iG,MAAA3pE,GAIA4rE,gBAAA9lG,KAAA6lG,kBACAE,oCAAA5S,OAAA0S,kBAOA,IAAA75F,EAAA,EAAay3F,cAAAz3F,EAAmBA,IAAA,CAYhC,IATAa,EAAAb,EAAAy3F,cACA7kG,EAAAomG,gBAAA,EAAAn4F,GAGA64F,GAAAT,UAAA1/F,KAAAmU,IAAA7M,EAAAtH,KAAAud,GAAA,GAKA1iB,EAAA,EAAAklB,GAAAgjE,QAAAjoF,OAAmCilB,GAAAllB,EAAQA,IAE3CulG,KAAA/D,SAAAtZ,QAAAloF,GAAAwlG,iBAAAxlG,GAAAslG,IAEA/pF,EAAAgqF,KAAA/lG,EAAA+lG,KAAA9lG,GAAAjB,EAMA,KAAA4N,EAAA,EAAAgvF,GAAAxF,MAAA31F,OAAiCm7F,GAAAhvF,EAAQA,IAKzC,IAHAq3F,MAAA7N,MAAAxpF,GACAq5F,iBAAAC,eAAAt5F,GAEApM,EAAA,EAAAklB,GAAAu+E,MAAAxjG,OAAkCilB,GAAAllB,EAAQA,IAE1CulG,KAAA/D,SAAAiC,MAAAzjG,GAAAylG,iBAAAzlG,GAAAslG,IAEA/pF,EAAAgqF,KAAA/lG,EAAA+lG,KAAA9lG,GAAAjB,GAYA,IAJA8mG,GAAAT,UAIA7kG,EAAA,EAAaixF,KAAAjxF,EAAUA,IAEvBulG,KAAAvC,aAAAxB,SAAA36E,SAAA7mB,GAAA2lG,kBAAA3lG,GAAAslG,IAAAz+E,SAAA7mB,GAEA+kG,eAQA3jF,OAAAtV,KAAA04F,WAAAl+D,QAAA,IAAA73B,eAAA82F,KAAA/lG,GACAilG,SAAA34F,KAAA04F,WAAAoB,UAAA,IAAAn3F,eAAA82F,KAAA9lG,GAEAilG,UAAA54F,KAAAy4F,WAAA,IAAAtlG,IAAAmiB,QAAAniB,IAAAwlG,UAEAlpF,EAAAmpF,UAAAllG,EAAAklG,UAAAjlG,EAAAilG,UAAAlmG,IAXA+c,EAAAgqF,KAAA/lG,EAAA+lG,KAAA9lG,EAAA,EAoBA,IAAA4M,EAEA,KAAAA,EAAA,EAAa+2F,OAAA/2F,EAAYA,IAEzB,IAAArM,EAAA,EAAcixF,KAAAjxF,EAAUA,IAExBulG,KAAAvC,aAAAxB,SAAA36E,SAAA7mB,GAAA2lG,kBAAA3lG,GAAAslG,IAAAz+E,SAAA7mB,GAEA+kG,eAQA3jF,OAAAtV,KAAA04F,WAAAl+D,QAAAj6B,IAAAoC,eAAA82F,KAAA/lG,GACAilG,SAAA34F,KAAA04F,WAAAoB,UAAAv5F,IAAAoC,eAAA82F,KAAA9lG,GAEAilG,UAAA54F,KAAAy4F,WAAAl4F,IAAApN,IAAAmiB,QAAAniB,IAAAwlG,UAEAlpF,EAAAmpF,UAAAllG,EAAAklG,UAAAjlG,EAAAilG,UAAAlmG,IAXA+c,EAAAgqF,KAAA/lG,EAAA+lG,KAAA9lG,EAAAklG,OAAAvB,MAAA/2F,EAuBA,KAAAT,EAAAy3F,cAAA,EAA6Bz3F,GAAA,EAAQA,IAAA,CASrC,IAPAa,EAAAb,EAAAy3F,cACA7kG,EAAAomG,gBAAA,EAAAn4F,GAEA64F,GAAAT,UAAA1/F,KAAAmU,IAAA7M,EAAAtH,KAAAud,GAAA,GAIA1iB,EAAA,EAAAklB,GAAAgjE,QAAAjoF,OAAmCilB,GAAAllB,EAAQA,IAE3CulG,KAAA/D,SAAAtZ,QAAAloF,GAAAwlG,iBAAAxlG,GAAAslG,IACA/pF,EAAAgqF,KAAA/lG,EAAA+lG,KAAA9lG,EAAAklG,OAAAnmG,EAMA,KAAA4N,EAAA,EAAAgvF,GAAAxF,MAAA31F,OAAiCm7F,GAAAhvF,EAAQA,IAKzC,IAHAq3F,MAAA7N,MAAAxpF,GACAq5F,iBAAAC,eAAAt5F,GAEApM,EAAA,EAAAklB,GAAAu+E,MAAAxjG,OAAkCilB,GAAAllB,EAAQA,IAE1CulG,KAAA/D,SAAAiC,MAAAzjG,GAAAylG,iBAAAzlG,GAAAslG,IAEAP,cAMAxpF,EAAAgqF,KAAA/lG,EAAA+lG,KAAA9lG,EAAA8kG,WAAAnB,MAAA,GAAA3jG,EAAA8kG,WAAAnB,MAAA,GAAA5jG,EAAAhB,GAJA+c,EAAAgqF,KAAA/lG,EAAA+lG,KAAA9lG,EAAAklG,OAAAnmG,GAkBAukG,gBAIAO,kBAqJAt+F,MAAA+wF,gBAAAkP,kBAEAlB,cAAA,SAAAtlG,SAAAonG,OAAAC,OAAAC,QAEA,GAAAl/E,UAAApoB,SAAAooB,SAEAnL,EAAAmL,SAAAg/E,QACAj6F,EAAAib,SAAAi/E,QACAhrG,EAAA+rB,SAAAk/E,OAEA,QACA,GAAA/gG,OAAAiY,QAAAvB,EAAAlc,EAAAkc,EAAAjc,GACA,GAAAuF,OAAAiY,QAAArR,EAAApM,EAAAoM,EAAAnM,GACA,GAAAuF,OAAAiY,QAAAniB,EAAA0E,EAAA1E,EAAA2E,KAKA6kG,mBAAA,SAAA7lG,SAAAonG,OAAAC,OAAAC,OAAAC,QAEA,GAAAn/E,UAAApoB,SAAAooB,SAEAnL,EAAAmL,SAAAg/E,QACAj6F,EAAAib,SAAAi/E,QACAhrG,EAAA+rB,SAAAk/E,QACAvmF,EAAAqH,SAAAm/E,OAEA,OAAA7gG,MAAA+V,IAAAQ,EAAAjc,EAAAmM,EAAAnM,GAAA,KAEA,GAAAuF,OAAAiY,QAAAvB,EAAAlc,EAAA,EAAAkc,EAAAld,GACA,GAAAwG,OAAAiY,QAAArR,EAAApM,EAAA,EAAAoM,EAAApN,GACA,GAAAwG,OAAAiY,QAAAniB,EAAA0E,EAAA,EAAA1E,EAAA0D,GACA,GAAAwG,OAAAiY,QAAAuC,EAAAhgB,EAAA,EAAAggB,EAAAhhB,KAIA,GAAAwG,OAAAiY,QAAAvB,EAAAjc,EAAA,EAAAic,EAAAld,GACA,GAAAwG,OAAAiY,QAAArR,EAAAnM,EAAA,EAAAmM,EAAApN,GACA,GAAAwG,OAAAiY,QAAAniB,EAAA2E,EAAA,EAAA3E,EAAA0D,GACA,GAAAwG,OAAAiY,QAAAuC,EAAA/f,EAAA,EAAA+f,EAAAhhB,MAwBAwG,MAAAixF,cAAA,SAAApO,OAAArnF,SAEAwE,MAAA4hB,SAAAhsB,KAAAU,MAEAA,KAAAoG,KAAA,gBAEAmmF,iBAAAtwD,SAAA,IAAAswD,iBAEAvsF,KAAAgmG,aAAAzZ,OAAArnF,SAEAlF,KAAAgsC,sBAIAtiC,MAAAixF,cAAAr6F,UAAAujC,OAAAiG,OAAApgC,MAAA4hB,SAAAhrB,WACAoJ,MAAAixF,cAAAr6F,UAAAM,YAAA8I,MAAAixF,cAKAjxF,MAAAixF,cAAAr6F,UAAA0lG,aAAA,SAAAzZ,OAAArnF,SAEA,OAAAR,GAAA,EAAAsM,EAAAu7E,OAAA5nF,OAAoCqM,EAAAtM,EAAOA,IAE3C1E,KAAAimG,SAAA1Z,OAAA7nF,GAAAQ,QAIA,OAAAlF,OAOA0J,MAAAixF,cAAAr6F,UAAA2lG,SAAA,SAAAjL,MAAA91F,SAEA0E,SAAA1E,qBACA,IAOAR,GAAAsM,EAAAopF,KAPA/N,cAAAziF,SAAA1E,QAAAmnF,cAAAnnF,QAAAmnF,cAAA,GAEAhpF,SAAA6B,QAAA7B,SACAmlG,MAAA5+F,SAAA1E,QAAAwkG,YAAAhgG,MAAA+wF,gBAAAkP,iBAAAzkG,QAAAwkG,YAMAnB,aAAAvoG,KAAAurB,SAAA5mB,OACAmlG,YAAA9O,MAAAC,cAAA5O,eAEA9gE,SAAAu+E,YAAA9O,MACAV,MAAAwP,YAAAxP,MAEAyP,SAAArgG,MAAAqiF,MAAAC,MAAAmN,YAAA5tE,SAEA,IAAAw+E,QAAA,CAMA,IAJAx+E,kBAAAw+E,UAIArlG,EAAA,EAAAsM,EAAAspF,MAAA31F,OAAgCqM,EAAAtM,EAAOA,IAEvC01F,KAAAE,MAAA51F,GAEAgF,MAAAqiF,MAAAC,MAAAmN,YAAAiB,QAEAE,MAAA51F,GAAA01F,KAAA2P,UAMAA,UAAA,EAIA,GAAAn/D,OAAAlhC,MAAAqiF,MAAAC,MAAAmP,iBAAA5vE,SAAA+uE,MAMA,KAAA51F,EAAA,EAAAsM,EAAAspF,MAAA31F,OAA+BqM,EAAAtM,EAAOA,IAEtC01F,KAAAE,MAAA51F,GACA6mB,kBAAAksE,OAAA2C,KAMA,IAAA6P,MACAzhE,KADAmtD,KAAApqE,SAAA5mB,OACAijG,KAAAh9D,MAAAjmC,MAEA,KAAAD,EAAA,EAAaixF,KAAAjxF,EAAUA,IAEvBulG,KAAA1+E,SAAA7mB,GAEA1E,KAAAurB,SAAAjnB,KAAA,GAAAoF,OAAAgW,QAAAuqF,KAAA/lG,EAAA+lG,KAAA9lG,EAAA,GAIA,KAAAO,EAAA,EAAakjG,KAAAljG,EAAUA,IAAA,CAEvB8jC,KAAAoC,MAAAlmC,EAEA,IAAA0b,GAAAooB,KAAA,GAAA+/D,aACAj4F,EAAAk4B,KAAA,GAAA+/D,aACA/oG,EAAAgpC,KAAA,GAAA+/D,YAEAvoG,MAAA4qC,MAAAtmC,KAAA,GAAAoF,OAAAy+B,MAAA/nB,EAAA9P,EAAA9Q,EAAA,UAAA6D,WACArD,KAAA6qC,cAAA,GAAAvmC,KAAAkkG,MAAAC,cAAAzoG,KAAAogB,EAAA9P,EAAA9Q,MAqBAkK,MAAAihG,cAAA,SAAAjhF,OAAAk8B,SAAAO,SAAAC,WAEA18C,MAAA4hB,SAAAhsB,KAAAU,MAEAA,KAAAoG,KAAA,gBAEApG,KAAA+0C,YACArrB,cACAk8B,kBACAO,kBACAC,qBAGAR,mBAAA,GACAO,mBAAA,EACAC,qBAAA,EAAAv8C,KAAAud,EAKA,QAHAwjF,oBAAA,GAAAlhF,OAAA/kB,OAAA,GACAkmG,gBAAA,EAAAjlD,SAEAlhD,EAAA,EAAAklB,GAAAg8B,SAAgCh8B,IAAAllB,EAASA,IAOzC,OALAomG,KAAA3kD,SAAAzhD,EAAAmmG,gBAAAzkD,UAEA5mD,EAAAqK,KAAA+T,IAAAktF,KACA/5F,EAAAlH,KAAAmU,IAAA8sF,KAEAxlG,EAAA,EAAAqnC,GAAAjjB,OAAA/kB,OAAsCgoC,GAAArnC,EAAQA,IAAA,CAE9C,GAAA6gG,IAAAz8E,OAAApkB,GAEAksC,OAAA,GAAA9nC,OAAAgW,OAEA8xB,QAAAttC,EAAA1E,EAAA2mG,GAAAjiG,EAAA6M,EAAAo1F,GAAAhiG,EACAqtC,OAAArtC,EAAA4M,EAAAo1F,GAAAjiG,EAAA1E,EAAA2mG,GAAAhiG,EACAqtC,OAAAtuC,EAAAijG,GAAAjjG,EAEAlD,KAAAurB,SAAAjnB,KAAAktC,QAQA,OAFAu5D,IAAArhF,OAAA/kB,OAEAD,EAAA,EAAAklB,GAAAg8B,SAAgCh8B,GAAAllB,EAAQA,IAExC,OAAAY,GAAA,EAAAqnC,GAAAjjB,OAAA/kB,OAAA,EAA0CgoC,GAAArnC,EAAQA,IAAA,CAElD,GAAAshE,MAAAthE,EAAAylG,GAAArmG,EACA0b,EAAAwmD,KACAt2D,EAAAs2D,KAAAmkC,GACAvrG,EAAAonE,KAAA,EAAAmkC,GACA7mF,EAAA0iD,KAAA,EAEAokC,GAAAtmG,EAAAmmG,gBACAv1E,GAAAhwB,EAAAslG,mBACAK,GAAAD,GAAAH,gBACAvrF,GAAAgW,GAAAs1E,kBAEA5qG,MAAA4qC,MAAAtmC,KAAA,GAAAoF,OAAAy+B,MAAA/nB,EAAA9P,EAAA4T,IAEAlkB,KAAA6qC,cAAA,GAAAvmC,MAEA,GAAAoF,OAAAiY,QAAAqpF,GAAA11E,IACA,GAAA5rB,OAAAiY,QAAAspF,GAAA31E,IACA,GAAA5rB,OAAAiY,QAAAqpF,GAAA1rF,MAIAtf,KAAA4qC,MAAAtmC,KAAA,GAAAoF,OAAAy+B,MAAA73B,EAAA9Q,EAAA0kB,IAEAlkB,KAAA6qC,cAAA,GAAAvmC,MAEA,GAAAoF,OAAAiY,QAAAspF,GAAA31E,IACA,GAAA5rB,OAAAiY,QAAAspF,GAAA3rF,IACA,GAAA5V,OAAAiY,QAAAqpF,GAAA1rF,MASAtf,KAAA8zC,gBACA9zC,KAAAgsC,qBACAhsC,KAAAisC,wBAIAviC,MAAAihG,cAAArqG,UAAAujC,OAAAiG,OAAApgC,MAAA4hB,SAAAhrB,WACAoJ,MAAAihG,cAAArqG,UAAAM,YAAA8I,MAAAihG,cASAjhG,MAAAwhG,cAAA,SAAA7zD,MAAAC,OAAAiO,cAAAC,gBAEArlD,QAAAw2D,KAAA,6FAEAjtD,MAAA4hB,SAAAhsB,KAAAU,MAEAA,KAAAoG,KAAA,gBAEApG,KAAA+0C,YACAsC,YACAC,cACAiO,4BACAC,+BAGAxlD,KAAAyxC,mBAAA,GAAA/nC,OAAAyhG,oBAAA9zD,MAAAC,OAAAiO,cAAAC,kBAIA97C,MAAAwhG,cAAA5qG,UAAAujC,OAAAiG,OAAApgC,MAAA4hB,SAAAhrB,WACAoJ,MAAAwhG,cAAA5qG,UAAAM,YAAA8I,MAAAwhG,cASAxhG,MAAAyhG,oBAAA,SAAA9zD,MAAAC,OAAAiO,cAAAC,gBAEA97C,MAAA8hB,eAAAlsB,KAAAU,MAEAA,KAAAoG,KAAA,sBAEApG,KAAA+0C,YACAsC,YACAC,cACAiO,4BACAC,8BAsBA,QAnBAo/C,YAAAvtD,MAAA,EACAwtD,YAAAvtD,OAAA,EAEAotD,MAAAn/C,eAAA,EACAo/C,MAAAn/C,gBAAA,EAEAs/C,OAAAJ,MAAA,EACAK,OAAAJ,MAAA,EAEAK,cAAA3tD,MAAAqtD,MACAO,eAAA3tD,OAAAqtD,MAEAp5E,SAAA,GAAAQ,cAAA+4E,OAAAC,OAAA,GACA/5D,QAAA,GAAAjf,cAAA+4E,OAAAC,OAAA,GACA75D,IAAA,GAAAnf,cAAA+4E,OAAAC,OAAA,GAEArxF,OAAA,EACA03F,QAAA,EAEA5mF,GAAA,EAAkBugF,OAAAvgF,GAAaA,KAI/B,OAFArgB,GAAAqgB,GAAAygF,eAAAJ,YAEAtgF,GAAA,EAAmBugF,OAAAvgF,GAAaA,KAAA,CAEhC,GAAArgB,GAAAqgB,GAAAygF,cAAAJ,UAEAr5E,UAAA7X,QAAAxP,EACAqnB,SAAA7X,OAAA,IAAAvP,EAEA6mC,QAAAt3B,OAAA,KAEAw3B,IAAAkgE,SAAA7mF,GAAAmgF,MACAx5D,IAAAkgE,QAAA,KAAA5mF,GAAAmgF,MAEAjxF,QAAA,EACA03F,SAAA,EAMA13F,OAAA,CAIA,QAFAg5B,SAAA,IAAAnhB,SAAA5mB,OAAA,QAAA40D,YAAAjrB,aAAAo2D,MAAAC,MAAA,GAEAngF,GAAA,EAAkBmgF,MAAAngF,GAAYA,KAE9B,OAAAD,IAAA,EAAmBmgF,MAAAngF,GAAYA,KAAA,CAE/B,GAAAnE,GAAAmE,GAAAugF,OAAAtgF,GACAlU,EAAAiU,GAAAugF,QAAAtgF,GAAA,GACAhlB,EAAA+kB,GAAA,EAAAugF,QAAAtgF,GAAA,GACAN,EAAAK,GAAA,EAAAugF,OAAAtgF,EAEAkoB,SAAAh5B,QAAA0M,EACAssB,QAAAh5B,OAAA,GAAApD,EACAo8B,QAAAh5B,OAAA,GAAAwQ,EAEAwoB,QAAAh5B,OAAA,GAAApD,EACAo8B,QAAAh5B,OAAA,GAAAlU,EACAktC,QAAAh5B,OAAA,GAAAwQ,EAEAxQ,QAAA,EAMA1T,KAAAoqC,aAAA,WAAA1gC,OAAAg/B,gBAAAgE,QAAA,IACA1sC,KAAAoqC,aAAA,cAAA1gC,OAAAg/B,gBAAAnd,SAAA,IACAvrB,KAAAoqC,aAAA,YAAA1gC,OAAAg/B,gBAAAsC,QAAA,IACAhrC,KAAAoqC,aAAA,QAAA1gC,OAAAg/B,gBAAAwC,IAAA,KAIAxhC,MAAAyhG,oBAAA7qG,UAAAujC,OAAAiG,OAAApgC,MAAA8hB,eAAAlrB,WACAoJ,MAAAyhG,oBAAA7qG,UAAAM,YAAA8I,MAAAyhG,oBAQAzhG,MAAA2hG,aAAA,SAAAC,YAAAC,YAAAC,cAAAC,YAAAplD,WAAAC,aAEA58C,MAAA4hB,SAAAhsB,KAAAU,MAEAA,KAAAoG,KAAA,eAEApG,KAAA+0C,YACAu2D,wBACAC,wBACAC,4BACAC,wBACAplD,sBACAC,yBAGAglD,yBAAA,EACAC,yBAAA,GAEAllD,WAAAz8C,SAAAy8C,sBAAA,EACAC,YAAA18C,SAAA08C,wBAAA,EAAAz8C,KAAAud,GAEAokF,cAAA5hG,SAAA4hG,cAAA3hG,KAAA4I,IAAA,EAAA+4F,eAAA,EACAC,YAAA7hG,SAAA6hG,YAAA5hG,KAAA4I,IAAA,EAAAg5F,aAAA,CAEA,IAAA/mG,GAAAw/D,EAAAh5B,OAAArf,OAAAy/E,YAAAI,YAAAH,YAAAD,aAAAG;AAEA,IAAA/mG,EAAA,EAAa+mG,YAAA,EAAA/mG,EAAqBA,IAAA,CAElC,IAAAw/D,EAAA,EAAcsnC,cAAA,EAAAtnC,EAAuBA,IAAA,CAErC,GAAA1yB,QAAA,GAAA9nC,OAAAgW,QACA2lF,QAAAh/C,WAAA6d,EAAAsnC,cAAAllD,WACA9U,QAAAttC,EAAA2nB,OAAAhiB,KAAA+T,IAAAynF,SACA7zD,OAAArtC,EAAA0nB,OAAAhiB,KAAAmU,IAAAqnF,SAEArlG,KAAAurB,SAAAjnB,KAAAktC,QACAtG,IAAA5mC,KAAA,GAAAoF,OAAAiY,SAAA6vB,OAAAttC,EAAAqnG,YAAA,MAAA/5D,OAAArtC,EAAAonG,YAAA,OAGA1/E,QAAA6/E,WAIA,GAAA17E,GAAA,GAAAtmB,OAAAgW,QAAA,MAEA,KAAAhb,EAAA,EAAa+mG,YAAA/mG,EAAiBA,IAAA,CAE9B,GAAAinG,cAAAjnG,GAAA8mG,cAAA,EAEA,KAAAtnC,EAAA,EAAcsnC,cAAAtnC,EAAoBA,IAAA,CAElC,GAAAmhC,SAAAnhC,EAAAynC,aAEArsF,GAAA+lF,QACA/hF,GAAA+hF,QAAAmG,cAAA,EACAntE,GAAAgnE,QAAAmG,cAAA,CAEAxrG,MAAA4qC,MAAAtmC,KAAA,GAAAoF,OAAAy+B,MAAA7oB,GAAAgE,GAAA+a,IAAArO,EAAArc,QAAAqc,EAAArc,QAAAqc,EAAArc,WACA3T,KAAA6qC,cAAA,GAAAvmC,MAAA4mC,IAAA5rB,IAAA3L,QAAAu3B,IAAA5nB,IAAA3P,QAAAu3B,IAAA7M,IAAA1qB,UAEA2L,GAAA+lF,QACA/hF,GAAA+hF,QAAAmG,cAAA,EACAntE,GAAAgnE,QAAA,EAEArlG,KAAA4qC,MAAAtmC,KAAA,GAAAoF,OAAAy+B,MAAA7oB,GAAAgE,GAAA+a,IAAArO,EAAArc,QAAAqc,EAAArc,QAAAqc,EAAArc,WACA3T,KAAA6qC,cAAA,GAAAvmC,MAAA4mC,IAAA5rB,IAAA3L,QAAAu3B,IAAA5nB,IAAA3P,QAAAu3B,IAAA7M,IAAA1qB,WAKA3T,KAAAgsC,qBAEAhsC,KAAAu6B,eAAA,GAAA7wB,OAAAkiB,OAAA,GAAAliB,OAAAgW,QAAAmM,SAIAniB,MAAA2hG,aAAA/qG,UAAAujC,OAAAiG,OAAApgC,MAAA4hB,SAAAhrB,WACAoJ,MAAA2hG,aAAA/qG,UAAAM,YAAA8I,MAAA2hG,aASA3hG,MAAAw8C,eAAA,SAAAr6B,OAAA05B,cAAAC,eAAAW,SAAAC,UAAAC,WAAAC,aAEA58C,MAAA4hB,SAAAhsB,KAAAU,MAEAA,KAAAoG,KAAA,iBAEApG,KAAA+0C,YACAlpB,cACA05B,4BACAC,8BACAW,kBACAC,oBACAC,sBACAC,yBAGAz6B,eAAA,GAEA05B,cAAA17C,KAAA4I,IAAA,EAAA5I,KAAA+G,MAAA20C,gBAAA,GACAC,eAAA37C,KAAA4I,IAAA,EAAA5I,KAAA+G,MAAA40C,iBAAA,GAEAW,SAAAv8C,SAAAu8C,kBAAA,EACAC,UAAAx8C,SAAAw8C,oBAAA,EAAAv8C,KAAAud,GAEAi/B,WAAAz8C,SAAAy8C,sBAAA,EACAC,YAAA18C,SAAA08C,wBAAAz8C,KAAAud,EAEA,IAAAljB,GAAAC,EAAAonB,YAAA2f,MAEA,KAAA/mC,EAAA,EAAaqhD,gBAAArhD,EAAqBA,IAAA,CAElC,GAAAqhG,gBACAC,SAEA,KAAAvhG,EAAA,EAAcqhD,eAAArhD,EAAoBA,IAAA,CAElC,GAAAq8B,GAAAr8B,EAAAqhD,cACAtlC,EAAA9b,EAAAqhD,eAEAhU,OAAA,GAAA9nC,OAAAgW,OACA8xB,QAAAttC,GAAA2nB,OAAAhiB,KAAA+T,IAAAuoC,SAAA5lB,EAAA6lB,WAAAv8C,KAAAmU,IAAAqoC,WAAApmC,EAAAqmC,aACA9U,OAAArtC,EAAA0nB,OAAAhiB,KAAA+T,IAAAyoC,WAAApmC,EAAAqmC,aACA9U,OAAAtuC,EAAA2oB,OAAAhiB,KAAAmU,IAAAmoC,SAAA5lB,EAAA6lB,WAAAv8C,KAAAmU,IAAAqoC,WAAApmC,EAAAqmC,aAEAtmD,KAAAurB,SAAAjnB,KAAAktC,QAEAg0D,YAAAlhG,KAAAtE,KAAAurB,SAAA5mB,OAAA,GACA8gG,OAAAnhG,KAAA,GAAAoF,OAAAiY,QAAA4e,EAAA,EAAAtgB,IAIAsL,SAAAjnB,KAAAkhG,aACAt6D,IAAA5mC,KAAAmhG,QAIA,IAAAthG,EAAA,EAAaqhD,eAAArhD,EAAoBA,IAEjC,IAAAD,EAAA,EAAcqhD,cAAArhD,EAAmBA,IAAA,CAEjC,GAAAob,IAAAiM,SAAApnB,GAAAD,EAAA,GACAof,GAAAiI,SAAApnB,GAAAD,GACAm6B,GAAA9S,SAAApnB,EAAA,GAAAD,GACAyhG,GAAAp6E,SAAApnB,EAAA,GAAAD,EAAA,GAEAq3D,GAAAv7D,KAAAurB,SAAAjM,IAAA3L,QAAAmM,YACA4tB,GAAA1tC,KAAAurB,SAAAjI,IAAA3P,QAAAmM,YACA07C,GAAAx7D,KAAAurB,SAAA8S,IAAA1qB,QAAAmM,YACA8lF,GAAA5lG,KAAAurB,SAAAo6E,IAAAhyF,QAAAmM,YAEA+lF,IAAA36D,IAAA/mC,GAAAD,EAAA,GAAAyP,QACA63C,IAAAtgB,IAAA/mC,GAAAD,GAAAyP,QACAmyF,IAAA56D,IAAA/mC,EAAA,GAAAD,GAAAyP,QACAoyF,IAAA76D,IAAA/mC,EAAA,GAAAD,EAAA,GAAAyP,OAEA9J,MAAA+V,IAAA5f,KAAAurB,SAAAjM,IAAAnb,KAAA0nB,QAEAg6E,IAAA3hG,GAAA2hG,IAAA3hG,EAAAsnD,IAAAtnD,GAAA,EACAlE,KAAA4qC,MAAAtmC,KAAA,GAAAoF,OAAAy+B,MAAA7oB,GAAA+e,GAAAsnE,IAAApqC,GAAAC,GAAAoqC,MACA5lG,KAAA6qC,cAAA,GAAAvmC,MAAAuhG,IAAAC,IAAAC,OAEIl8F,KAAA+V,IAAA5f,KAAAurB,SAAA8S,IAAAl6B,KAAA0nB,QAEJi6E,IAAA5hG,GAAA4hG,IAAA5hG,EAAA6hG,IAAA7hG,GAAA,EACAlE,KAAA4qC,MAAAtmC,KAAA,GAAAoF,OAAAy+B,MAAA7oB,GAAAgE,GAAA+a,IAAAk9B,GAAA7tB,GAAA8tB,MACAx7D,KAAA6qC,cAAA,GAAAvmC,MAAAuhG,IAAAr6C,IAAAs6C,QAIA9lG,KAAA4qC,MAAAtmC,KAAA,GAAAoF,OAAAy+B,MAAA7oB,GAAAgE,GAAAqiF,IAAApqC,GAAA7tB,GAAAk4D,MACA5lG,KAAA6qC,cAAA,GAAAvmC,MAAAuhG,IAAAr6C,IAAAu6C,MAEA/lG,KAAA4qC,MAAAtmC,KAAA,GAAAoF,OAAAy+B,MAAA7kB,GAAA+a,GAAAsnE,IAAAj4D,GAAA/5B,QAAA6nD,GAAAoqC,GAAAjyF,WACA3T,KAAA6qC,cAAA,GAAAvmC,MAAAknD,IAAA73C,QAAAmyF,IAAAC,IAAApyF,WAQA3T,KAAAgsC,qBAEAhsC,KAAAu6B,eAAA,GAAA7wB,OAAAkiB,OAAA,GAAAliB,OAAAgW,QAAAmM,SAIAniB,MAAAw8C,eAAA5lD,UAAAujC,OAAAiG,OAAApgC,MAAA4hB,SAAAhrB,WACAoJ,MAAAw8C,eAAA5lD,UAAAM,YAAA8I,MAAAw8C,eA0CAx8C,MAAAkiG,aAAA,SAAAxnD,KAAArP,YAEAA,yBAEA,IAAA82D,YAAAniG,MAAAkgF,UAAAwC,eAAAhoC,KAAArP,WAIAA,YAAAs0D,OAAAz/F,SAAAmrC,WAAAuC,OAAAvC,WAAAuC,OAAA,GAIA1tC,SAAAmrC,WAAAu0D,iBAAAv0D,WAAAu0D,eAAA,IACA1/F,SAAAmrC,WAAAw0D,YAAAx0D,WAAAw0D,UAAA,GACA3/F,SAAAmrC,WAAA2yD,eAAA3yD,WAAA2yD,cAAA,GAEAh+F,MAAA+wF,gBAAAn7F,KAAAU,KAAA6rG,WAAA92D,YAEA/0C,KAAAoG,KAAA,gBAIAsD,MAAAkiG,aAAAtrG,UAAAujC,OAAAiG,OAAApgC,MAAA+wF,gBAAAn6F,WACAoJ,MAAAkiG,aAAAtrG,UAAAM,YAAA8I,MAAAkiG,aAUAliG,MAAA+8C,cAAA,SAAA56B,OAAA66B,KAAAV,eAAAW,gBAAAC,KAEAl9C,MAAA4hB,SAAAhsB,KAAAU,MAEAA,KAAAoG,KAAA,gBAEApG,KAAA+0C,YACAlpB,cACA66B,UACAV,8BACAW,gCACAC,SAGA/6B,eAAA,IACA66B,WAAA,GACAV,+BAAA,EACAW,iCAAA,EACAC,SAAA,EAAA/8C,KAAAud,EAIA,QAFAuB,QAAA,GAAAjf,OAAAgW,QAAAwrB,OAAAF,WAEA1lC,EAAA,EAAiB0gD,gBAAA1gD,EAAqBA,IAEtC,OAAAZ,GAAA,EAAkBiiD,iBAAAjiD,EAAsBA,IAAA,CAExC,GAAA67B,GAAA77B,EAAAiiD,gBAAAC,IACA3mC,EAAA3a,EAAA0gD,eAAAn8C,KAAAud,GAAA,CAEAuB,QAAAzkB,EAAA2nB,OAAAhiB,KAAA+T,IAAA2iB,GACA5X,OAAAxkB,EAAA0nB,OAAAhiB,KAAAmU,IAAAuiB,EAEA,IAAAiR,QAAA,GAAA9nC,OAAAgW,OACA8xB,QAAAttC,GAAA2nB,OAAA66B,KAAA78C,KAAA+T,IAAAqC,IAAApW,KAAA+T,IAAA2iB,GACAiR,OAAArtC,GAAA0nB,OAAA66B,KAAA78C,KAAA+T,IAAAqC,IAAApW,KAAAmU,IAAAuiB,GACAiR,OAAAtuC,EAAAwjD,KAAA78C,KAAAmU,IAAAiC,GAEAjgB,KAAAurB,SAAAjnB,KAAAktC,QAEAtG,IAAA5mC,KAAA,GAAAoF,OAAAiY,QAAAjd,EAAAiiD,gBAAArhD,EAAA0gD,iBACAhb,QAAA1mC,KAAAktC,OAAA79B,QAAAnT,IAAAmoB,QAAA7I,aAMA,OAAAxa,GAAA,EAAiB0gD,gBAAA1gD,EAAqBA,IAEtC,OAAAZ,GAAA,EAAkBiiD,iBAAAjiD,EAAsBA,IAAA,CAExC,GAAA0b,IAAAumC,gBAAA,GAAArhD,EAAAZ,EAAA,EACA4L,GAAAq2C,gBAAA,IAAArhD,EAAA,GAAAZ,EAAA,EACAlF,GAAAmnD,gBAAA,IAAArhD,EAAA,GAAAZ,EACAwf,GAAAyiC,gBAAA,GAAArhD,EAAAZ,EAEA8jC,KAAA,GAAA9+B,OAAAy+B,MAAA/nB,EAAA9P,EAAA4T,GAAA8mB,QAAA5qB,GAAAzM,QAAAq3B,QAAA16B,GAAAqD,QAAAq3B,QAAA9mB,GAAAvQ,SACA3T,MAAA4qC,MAAAtmC,KAAAkkC,MACAxoC,KAAA6qC,cAAA,GAAAvmC,MAAA4mC,IAAA9qB,GAAAzM,QAAAu3B,IAAA56B,GAAAqD,QAAAu3B,IAAAhnB,GAAAvQ,UAEA60B,KAAA,GAAA9+B,OAAAy+B,MAAA73B,EAAA9Q,EAAA0kB,GAAA8mB,QAAA16B,GAAAqD,QAAAq3B,QAAAxrC,GAAAmU,QAAAq3B,QAAA9mB,GAAAvQ,UACA3T,KAAA4qC,MAAAtmC,KAAAkkC,MACAxoC,KAAA6qC,cAAA,GAAAvmC,MAAA4mC,IAAA56B,GAAAqD,QAAAu3B,IAAA1rC,GAAAmU,QAAAu3B,IAAAhnB,GAAAvQ,UAMA3T,KAAAgsC,sBAIAtiC,MAAA+8C,cAAAnmD,UAAAujC,OAAAiG,OAAApgC,MAAA4hB,SAAAhrB,WACAoJ,MAAA+8C,cAAAnmD,UAAAM,YAAA8I,MAAA+8C,cASA/8C,MAAAm9C,kBAAA,SAAAh7B,OAAA66B,KAAAV,eAAAW,gBAAAlnD,EAAAyR,EAAA41C,aAyFA,QAAAglD,QAAAvrE,EAAAwrE,KAAAC,KAAAngF,OAAAi7B,aAEA,GAAAmlD,IAAApiG,KAAA+T,IAAA2iB,GACA2rE,GAAAriG,KAAAmU,IAAAuiB,GACA4rE,QAAAJ,KAAAC,KAAAzrE,EACA6rE,GAAAviG,KAAA+T,IAAAuuF,SAEA94E,GAAAxH,QAAA,EAAAugF,IAAA,GAAAH,GACA34E,GAAAzH,QAAA,EAAAugF,IAAAF,GAAA,GACAG,GAAAvlD,YAAAj7B,OAAAhiB,KAAAmU,IAAAmuF,SAAA,EAEA,WAAAziG,OAAAgW,QAAA2T,GAAAC,GAAA+4E,IAlGA3iG,MAAA4hB,SAAAhsB,KAAAU,MAEAA,KAAAoG,KAAA,oBAEApG,KAAA+0C,YACAlpB,cACA66B,UACAV,8BACAW,gCACAlnD,IACAyR,IACA41C,yBAGAj7B,eAAA,IACA66B,WAAA,GACAV,+BAAA,GACAW,iCAAA,EACAlnD,KAAA,EACAyR,KAAA,EACA41C,yBAAA,CAOA,QALAwlD,MAAA,GAAArwE,OAAA+pB,gBACAumD,KAAA,GAAA7iG,OAAAgW,QACAsQ,EAAA,GAAAtmB,OAAAgW,QACA8sF,MAAA,GAAA9iG,OAAAgW,QAEAhb,EAAA,EAAiBshD,eAAAthD,IAAoBA,EAAA,CAErC4nG,KAAA5nG,GAAA,GAAAu3B,OAAA0qB,gBACA,IAAApmB,GAAA77B,EAAAshD,eAAA,EAAAvmD,EAAAoK,KAAAud,GACAwR,GAAAkzE,OAAAvrE,EAAArvB,EAAAzR,EAAAosB,OAAAi7B,aACAjuB,GAAAizE,OAAAvrE,EAAA,IAAArvB,EAAAzR,EAAAosB,OAAAi7B,YACAylD,MAAAtqF,WAAA4W,GAAAD,IACA5I,EAAAhO,WAAA6W,GAAAD,IAEA4zE,MAAA3sF,aAAA0sF,KAAAv8E,GACAA,EAAAnQ,aAAA2sF,MAAAD,MACAC,MAAA1sF,YACAkQ,EAAAlQ,WAEA,QAAAxa,GAAA,EAAkBqhD,gBAAArhD,IAAqBA,EAAA,CAEvC,GAAA2a,GAAA3a,EAAAqhD,gBAAA,EAAA98C,KAAAud,GACAwvB,IAAA8P,KAAA78C,KAAA+T,IAAAqC,GACA42B,GAAA6P,KAAA78C,KAAAmU,IAAAiC,GAEA8vC,IAAA,GAAArmD,OAAAgW,OACAqwC,KAAA7rD,EAAA00B,GAAA10B,EAAA0yC,GAAA5mB,EAAA9rB,EAAA2yC,GAAA21D,MAAAtoG,EACA6rD,IAAA5rD,EAAAy0B,GAAAz0B,EAAAyyC,GAAA5mB,EAAA7rB,EAAA0yC,GAAA21D,MAAAroG,EACA4rD,IAAA7sD,EAAA01B,GAAA11B,EAAA0zC,GAAA5mB,EAAA9sB,EAAA2zC,GAAA21D,MAAAtpG,EAEAopG,KAAA5nG,GAAAY,GAAAtF,KAAAurB,SAAAjnB,KAAAyrD,KAAA,GAMA,OAAArrD,GAAA,EAAiBshD,eAAAthD,IAAoBA,EAErC,OAAAY,GAAA,EAAkBqhD,gBAAArhD,IAAqBA,EAAA,CAEvC,GAAAmnG,KAAA/nG,EAAA,GAAAshD,eACA0mD,IAAApnG,EAAA,GAAAqhD,gBAEAvmC,EAAAksF,KAAA5nG,GAAAY,GACAgL,EAAAg8F,KAAAG,IAAAnnG,GACA9F,EAAA8sG,KAAAG,IAAAC,IACAxoF,EAAAooF,KAAA5nG,GAAAgoG,IAEA/gE,IAAA,GAAAjiC,OAAAiY,QAAAjd,EAAAshD,eAAA1gD,EAAAqhD,iBACA/a,IAAA,GAAAliC,OAAAiY,SAAAjd,EAAA,GAAAshD,eAAA1gD,EAAAqhD,iBACA9a,IAAA,GAAAniC,OAAAiY,SAAAjd,EAAA,GAAAshD,gBAAA1gD,EAAA,GAAAqhD,iBACAu+C,IAAA,GAAAx7F,OAAAiY,QAAAjd,EAAAshD,gBAAA1gD,EAAA,GAAAqhD,gBAEA3mD,MAAA4qC,MAAAtmC,KAAA,GAAAoF,OAAAy+B,MAAA/nB,EAAA9P,EAAA4T,IACAlkB,KAAA6qC,cAAA,GAAAvmC,MAAAqnC,IAAAC,IAAAs5D,MAEAllG,KAAA4qC,MAAAtmC,KAAA,GAAAoF,OAAAy+B,MAAA73B,EAAA9Q,EAAA0kB,IACAlkB,KAAA6qC,cAAA,GAAAvmC,MAAAsnC,IAAAj4B,QAAAk4B,IAAAq5D,IAAAvxF,UAKA3T,KAAAgsC,qBACAhsC,KAAAisC,wBAmBAviC,MAAAm9C,kBAAAvmD,UAAAujC,OAAAiG,OAAApgC,MAAA4hB,SAAAhrB,WACAoJ,MAAAm9C,kBAAAvmD,UAAAM,YAAA8I,MAAAm9C,kBAkBAn9C,MAAAkgG,aAAA,SAAAxiD,KAAAxB,SAAA/5B,OAAAm6B,eAAA2mD,OAAAC,OAiDA,QAAA3C,MAAA/lG,EAAAC,EAAAjB,GAEA,MAAAgoB,OAAAK,SAAAjnB,KAAA,GAAAoF,OAAAgW,QAAAxb,EAAAC,EAAAjB,IAAA,EAjDAwG,MAAA4hB,SAAAhsB,KAAAU,MAEAA,KAAAoG,KAAA,eAEApG,KAAA+0C,YACAqS,UACAxB,kBACA/5B,cACAm6B,8BACA2mD,eAGA/mD,mBAAA,GACA/5B,eAAA,EACAm6B,+BAAA,EACA2mD,gBAAA,EACAC,aAAAljG,MAAAkgG,aAAAiD,OAEA,IAIA9+D,SACAjoB,OACAqjF,SAIA5oE,EAAAtgB,EAAA7P,EAEAwmC,GAAAC,GACAkZ,IACArrD,EAAAY,EACAmnG,GAAAC,GACAtsF,EAAA9P,EAAA9Q,EAAA0kB,EACAynB,IAAAC,IAAAC,IAAAq5D,IAjBAoH,QAEAphF,MAAAlrB,KAMA8sG,UAAAlnD,SAAA,EAKAmnD,KAAA,GAAArjG,OAAAgW,QAMAwkF,OAAA,GAAAx6F,OAAAkgG,aAAAC,aAAAziD,KAAAxB,SAAA+mD,QACA/+D,SAAAs2D,OAAAt2D,SACA5C,QAAAk5D,OAAAl5D,QACAs/D,UAAApG,OAAAoG,SAeA,KAZAtqG,KAAA4tC,kBACA5tC,KAAAgrC,gBACAhrC,KAAAsqG,oBAUA5lG,EAAA,EAAaooG,UAAApoG,EAAeA,IAc5B,IAZA4nG,KAAA5nG,MAEA67B,EAAA77B,GAAAooG,UAAA,GAEA/8C,IAAA3I,KAAAipC,WAAA9vD,GAEAwN,QAAAH,SAAAlpC,GACAohB,OAAAklB,QAAAtmC,GACAykG,SAAAmB,UAAA5lG,GAEA0L,EAAAyb,OAAA+gF,MAAArsE,GAEAj7B,EAAA,EAAc0gD,eAAA1gD,EAAoBA,IAElC2a,EAAA3a,EAAA0gD,eAAA,EAAAn8C,KAAAud,GAEAwvB,IAAAxmC,EAAAvG,KAAA+T,IAAAqC,GACA42B,GAAAzmC,EAAAvG,KAAAmU,IAAAiC,GAEA8sF,KAAAv8F,KAAAu/C,KACAg9C,KAAA7oG,GAAA0yC,GAAA9wB,OAAA5hB,EAAA2yC,GAAAsyD,SAAAjlG,EACA6oG,KAAA5oG,GAAAyyC,GAAA9wB,OAAA3hB,EAAA0yC,GAAAsyD,SAAAhlG,EACA4oG,KAAA7pG,GAAA0zC,GAAA9wB,OAAA5iB,EAAA2zC,GAAAsyD,SAAAjmG,EAEAopG,KAAA5nG,GAAAY,GAAA2kG,KAAA8C,KAAA7oG,EAAA6oG,KAAA5oG,EAAA4oG,KAAA7pG,EAQA,KAAAwB,EAAA,EAAakhD,SAAAlhD,EAAcA,IAE3B,IAAAY,EAAA,EAAc0gD,eAAA1gD,EAAoBA,IAElCmnG,GAAA,QAAA/nG,EAAA,GAAAkhD,SAAAlhD,EAAA,EACAgoG,IAAApnG,EAAA,GAAA0gD,eAEA5lC,EAAAksF,KAAA5nG,GAAAY,GACAgL,EAAAg8F,KAAAG,IAAAnnG,GACA9F,EAAA8sG,KAAAG,IAAAC,IACAxoF,EAAAooF,KAAA5nG,GAAAgoG,IAEA/gE,IAAA,GAAAjiC,OAAAiY,QAAAjd,EAAAkhD,SAAAtgD,EAAA0gD,gBACApa,IAAA,GAAAliC,OAAAiY,SAAAjd,EAAA,GAAAkhD,SAAAtgD,EAAA0gD,gBACAna,IAAA,GAAAniC,OAAAiY,SAAAjd,EAAA,GAAAkhD,UAAAtgD,EAAA,GAAA0gD,gBACAk/C,IAAA,GAAAx7F,OAAAiY,QAAAjd,EAAAkhD,UAAAtgD,EAAA,GAAA0gD,gBAEAhmD,KAAA4qC,MAAAtmC,KAAA,GAAAoF,OAAAy+B,MAAA/nB,EAAA9P,EAAA4T,IACAlkB,KAAA6qC,cAAA,GAAAvmC,MAAAqnC,IAAAC,IAAAs5D,MAEAllG,KAAA4qC,MAAAtmC,KAAA,GAAAoF,OAAAy+B,MAAA73B,EAAA9Q,EAAA0kB,IACAlkB,KAAA6qC,cAAA,GAAAvmC,MAAAsnC,IAAAj4B,QAAAk4B,IAAAq5D,IAAAvxF,SAKA3T,MAAAgsC,qBACAhsC,KAAAisC,wBAIAviC,MAAAkgG,aAAAtpG,UAAAujC,OAAAiG,OAAApgC,MAAA4hB,SAAAhrB,WACAoJ,MAAAkgG,aAAAtpG,UAAAM,YAAA8I,MAAAkgG,aAEAlgG,MAAAkgG,aAAAiD,QAAA,SAAAtsE,GAEA,UAIA72B,MAAAkgG,aAAAoD,gBAAA,SAAAzsE,GAEA,MAAA12B,MAAAmU,IAAAnU,KAAAud,GAAAmZ,IAKA72B,MAAAkgG,aAAAC,aAAA,SAAAziD,KAAAxB,SAAA+mD,QA8DA,QAAAM,kBAIAjiE,QAAA,MAAAthC,OAAAgW,QACA4qF,UAAA,MAAA5gG,OAAAgW,QACAwtF,SAAAzjD,OAAA0jD,UACA95E,GAAAxpB,KAAA+V,IAAAguB,SAAA,GAAA1pC,GACAovB,GAAAzpB,KAAA+V,IAAAguB,SAAA,GAAAzpC,GACAkoG,GAAAxiG,KAAA+V,IAAAguB,SAAA,GAAA1qC,GAEAgqG,UAAA75E,KACA65E,SAAA75E,GACAvN,OAAA3V,IAAA,QAGA+8F,UAAA55E,KACA45E,SAAA55E,GACAxN,OAAA3V,IAAA,QAGA+8F,UAAAb,IACAvmF,OAAA3V,IAAA,OAGAwhF,IAAA9xE,aAAA+tB,SAAA,GAAA9nB,QAAAhG,YAEAkrB,QAAA,GAAAnrB,aAAA+tB,SAAA,GAAA+jD,KACA2Y,UAAA,GAAAzqF,aAAA+tB,SAAA,GAAA5C,QAAA,IAxFA,GAUAhlB,OAEAknF,SAEA75E,GAAAC,GAAA+4E,GACA3nG,EAAA67B,EAfAza,OAAA,GAAApc,OAAAgW,QAEAkuB,YACA5C,WACAs/D,aAEA3Y,IAAA,GAAAjoF,OAAAgW,QACA0tF,IAAA,GAAA1jG,OAAAkb,QAEAkoF,UAAAlnD,SAAA,EAEA1+B,QAAA,IAcA,KANAlnB,KAAA4tC,kBACA5tC,KAAAgrC,gBACAhrC,KAAAsqG,oBAIA5lG,EAAA,EAAaooG,UAAApoG,EAAeA,IAE5B67B,EAAA77B,GAAAooG,UAAA,GAEAl/D,SAAAlpC,GAAA0iD,KAAAwqC,aAAArxD,GACAqN,SAAAlpC,GAAAob,WAgEA,KA5DAmtF,iBA4DAvoG,EAAA,EAAaooG,UAAApoG,EAAeA,IAE5BsmC,QAAAtmC,GAAAsmC,QAAAtmC,EAAA,GAAAiP,QAEA22F,UAAA5lG,GAAA4lG,UAAA5lG,EAAA,GAAAiP,QAEAg+E,IAAA9xE,aAAA+tB,SAAAlpC,EAAA,GAAAkpC,SAAAlpC,IAEAitF,IAAAhtF,SAAAuiB,UAEAyqE,IAAA7xE,YAEAkG,MAAAnc,KAAAsX,KAAAzX,MAAAG,KAAA0Y,MAAAqrB,SAAAlpC,EAAA,GAAAib,IAAAiuB,SAAAlpC,IAAA,OAEAsmC,QAAAtmC,GAAAsf,aAAAopF,IAAAh6E,iBAAAu+D,IAAA3rE,SAIAskF,UAAA5lG,GAAAmb,aAAA+tB,SAAAlpC,GAAAsmC,QAAAtmC,GAOA,IAAAioG,OAWA,IATA3mF,MAAAnc,KAAAsX,KAAAzX,MAAAG,KAAA0Y,MAAAyoB,QAAA,GAAArrB,IAAAqrB,QAAA8hE,UAAA,WACA9mF,OAAA8mF,UAAA,EAEAl/D,SAAA,GAAAjuB,IAAAgyE,IAAA9xE,aAAAmrB,QAAA,GAAAA,QAAA8hE,UAAA,SAEA9mF,cAIAthB,EAAA,EAAcooG,UAAApoG,EAAeA,IAG7BsmC,QAAAtmC,GAAAsf,aAAAopF,IAAAh6E,iBAAAwa,SAAAlpC,GAAAshB,MAAAthB,IACA4lG,UAAA5lG,GAAAmb,aAAA+tB,SAAAlpC,GAAAsmC,QAAAtmC,KAeAgF,MAAA2jG,mBAAA,SAAA9hF,SAAAmhB,QAAA7gB,OAAA26B,QA2FA,QAAA8mD,SAAA59F,QAEA,GAAA8hC,QAAA9hC,OAAAoQ,YAAAnM,OACA69B,QAAA9pC,MAAA6lG,KAAAhiF,SAAAjnB,KAAAktC,QAAA,CAIA,IAAAjR,GAAAitE,QAAA99F,QAAA,EAAA7F,KAAAud,GAAA,GACAnH,EAAAwtF,YAAA/9F,QAAA7F,KAAAud,GAAA,EAGA,OAFAoqB,QAAA3D,GAAA,GAAAnkC,OAAAiY,QAAA4e,EAAA,EAAAtgB,GAEAuxB,OAOA,QAAAk8D,MAAApuF,GAAAgE,GAAA+a,IAEA,GAAAmK,MAAA,GAAA9+B,OAAAy+B,MAAA7oB,GAAA5X,MAAA4b,GAAA5b,MAAA22B,GAAA32B,OAAA4X,GAAA3L,QAAA2P,GAAA3P,QAAA0qB,GAAA1qB,SACA45F,MAAA3iE,MAAAtmC,KAAAkkC,MAEAmlE,SAAAn9F,KAAA8O,IAAA3b,IAAA2f,IAAA3f,IAAA06B,IAAAjc,aAAA,EAEA,IAAAwrF,KAAAJ,QAAAG,SAEAJ,MAAA1iE,cAAA,GAAAvmC,MACAupG,UAAAvuF,GAAAuuB,GAAAvuB,GAAAsuF,KACAC,UAAAvqF,GAAAuqB,GAAAvqB,GAAAsqF,KACAC,UAAAxvE,GAAAwP,GAAAxP,GAAAuvE,OAQA,QAAAE,WAAAtlE,KAAAge,QAUA,OARAunD,MAAAlkG,KAAA8H,IAAA,EAAA60C,QACApmC,EAAAktF,QAAAC,KAAAhiF,SAAAid,KAAApoB,IACA9P,EAAAg9F,QAAAC,KAAAhiF,SAAAid,KAAAl4B,IACA9Q,EAAA8tG,QAAAC,KAAAhiF,SAAAid,KAAAhpC,IACAygB,KAIAvb,EAAA,EAAmBqpG,MAAArpG,EAAWA,IAAA,CAE9Bub,EAAAvb,KAMA,QAJAspG,IAAAV,QAAAltF,EAAAzM,QAAAP,KAAA5T,EAAAkF,EAAAqpG,OACAE,GAAAX,QAAAh9F,EAAAqD,QAAAP,KAAA5T,EAAAkF,EAAAqpG,OACAG,KAAAH,KAAArpG,EAEAY,EAAA,EAAmB4oG,MAAA5oG,EAAWA,IAE9B,GAAAA,GAAAZ,GAAAqpG,KAEA9tF,EAAAvb,GAAAY,GAAA0oG,GAIA/tF,EAAAvb,GAAAY,GAAAgoG,QAAAU,GAAAr6F,QAAAP,KAAA66F,GAAA3oG,EAAA4oG,OAUA,OAAAxpG,GAAA,EAAkBqpG,KAAArpG,EAAWA,IAE7B,OAAAY,GAAA,EAAmB,GAAAyoG,KAAArpG,GAAA,EAAAY,EAAwBA,IAAA,CAE3C,GAAAk5B,GAAA30B,KAAA+G,MAAAtL,EAAA,EAEAA,GAAA,KAEAooG,KACAztF,EAAAvb,GAAA85B,EAAA,GACAve,EAAAvb,EAAA,GAAA85B,GACAve,EAAAvb,GAAA85B,IAKAkvE,KACAztF,EAAAvb,GAAA85B,EAAA,GACAve,EAAAvb,EAAA,GAAA85B,EAAA,GACAve,EAAAvb,EAAA,GAAA85B,KAcA,QAAAgvE,SAAA99F,QAEA,MAAA7F,MAAAke,MAAArY,OAAAxM,GAAAwM,OAAAxL,GAOA,QAAAupG,aAAA/9F,QAEA,MAAA7F,MAAAke,OAAArY,OAAAvL,EAAA0F,KAAAmI,KAAAtC,OAAAxL,EAAAwL,OAAAxL,EAAAwL,OAAAxM,EAAAwM,OAAAxM,IAOA,QAAA2qG,WAAAhgE,GAAAn+B,OAAA89F,SAIA,MAFA,GAAAA,SAAA,IAAA3/D,GAAA3pC,IAAA2pC,GAAA,GAAAnkC,OAAAiY,QAAAksB,GAAA3pC,EAAA,EAAA2pC,GAAA1pC,IACA,IAAAuL,OAAAxL,GAAA,IAAAwL,OAAAxM,IAAA2qC,GAAA,GAAAnkC,OAAAiY,QAAA6rF,QAAA,EAAA3jG,KAAAud,GAAA,GAAAymB,GAAA1pC,IACA0pC,GAAAl6B,QA1NAjK,MAAA4hB,SAAAhsB,KAAAU,MAEAA,KAAAoG,KAAA,qBAEApG,KAAA+0C,YACAxpB,kBACAmhB,gBACA7gB,cACA26B,eAGA36B,eAAA,EACA26B,eAAA,CAIA,QAFA+mD,MAAAvtG,KAEA0E,EAAA,EAAAsM,EAAAua,SAAA5mB,OAAsCqM,EAAAtM,EAAOA,GAAA,EAE7C4oG,QAAA,GAAA5jG,OAAAgW,QAAA6L,SAAA7mB,GAAA6mB,SAAA7mB,EAAA,GAAA6mB,SAAA7mB,EAAA,IAQA,QAJAjF,GAAAO,KAAAurB,SAEAqf,SAEAlmC,EAAA,EAAAY,EAAA,EAAA0L,EAAA07B,QAAA/nC,OAA4CqM,EAAAtM,EAAOA,GAAA,EAAAY,IAAA,CAEnD,GAAAga,IAAA7f,EAAAitC,QAAAhoC,IACA4e,GAAA7jB,EAAAitC,QAAAhoC,EAAA,IACA25B,GAAA5+B,EAAAitC,QAAAhoC,EAAA,GAEAkmC,OAAAtlC,GAAA,GAAAoE,OAAAy+B,MAAA7oB,GAAA5X,MAAA4b,GAAA5b,MAAA22B,GAAA32B,OAAA4X,GAAA3L,QAAA2P,GAAA3P,QAAA0qB,GAAA1qB,UAMA,OAFAg6F,UAAA,GAAAjkG,OAAAgW,QAEAhb,EAAA,EAAAsM,EAAA45B,MAAAjmC,OAAmCqM,EAAAtM,EAAOA,IAE1CopG,UAAAljE,MAAAlmC,GAAA8hD,OAOA,QAAA9hD,GAAA,EAAAsM,EAAAhR,KAAA6qC,cAAA,GAAAlmC,OAAqDqM,EAAAtM,EAAOA,IAAA,CAE5D,GAAAwmC,KAAAlrC,KAAA6qC,cAAA,GAAAnmC,GAEAoxF,GAAA5qD,IAAA,GAAAhnC,EACAgpC,GAAAhC,IAAA,GAAAhnC,EACAorB,GAAA4b,IAAA,GAAAhnC,EAEAuO,IAAA5I,KAAA4I,IAAAqjF,GAAAjsF,KAAA4I,IAAAy6B,GAAA5d,KACAhe,IAAAzH,KAAAyH,IAAAwkF,GAAAjsF,KAAAyH,IAAA47B,GAAA5d,IAEA7c,KAAA,OAAAnB,MAEA,GAAAwkF,KAAA5qD,IAAA,GAAAhnC,GAAA,GACA,GAAAgpC,KAAAhC,IAAA,GAAAhnC,GAAA,GACA,GAAAorB,KAAA4b,IAAA,GAAAhnC,GAAA,IASA,OAAAQ,GAAA,EAAAsM,EAAAhR,KAAAurB,SAAA5mB,OAA2CqM,EAAAtM,EAAOA,IAElD1E,KAAAurB,SAAA7mB,GAAAyO,eAAA0Y,OAOA7rB,MAAA8zC,gBAEA9zC,KAAAgsC,qBAEAhsC,KAAAu6B,eAAA,GAAA7wB,OAAAkiB,OAAA,GAAAliB,OAAAgW,QAAAmM,SA6IAniB,MAAA2jG,mBAAA/sG,UAAAujC,OAAAiG,OAAApgC,MAAA4hB,SAAAhrB,WACAoJ,MAAA2jG,mBAAA/sG,UAAAM,YAAA8I,MAAA2jG,mBAQA3jG,MAAAykG,qBAAA,SAAAtiF,OAAA26B,QAEAxmD,KAAA+0C,YACAlpB,cACA26B,cAGA,IAAAr1C,IAAA,EAAAtH,KAAAmI,KAAA,MACA5B,EAAA,EAAAe,EAEAoa,UAGA,iBACA,eACA,eACA,aAGA,GAAAnb,GAAAe,EAAA,GAAAf,EAAAe,EACA,EAAAf,GAAAe,EAAA,EAAAf,EAAAe,GAGAf,GAAAe,EAAA,GAAAf,EAAAe,EAAA,EACAf,GAAAe,EAAA,EAAAf,EAAAe,EAAA,GAGAA,EAAA,GAAAf,EAAAe,EAAA,GAAAf,GACAe,EAAA,EAAAf,EAAAe,EAAA,EAAAf,GAGAs8B,SACA,sBACA,sBACA,uBACA,qBACA,sBACA,sBACA,sBACA,uBACA,qBACA,uBACA,wBACA,qBAGAhjC,OAAA2jG,mBAAA/tG,KAAAU,KAAAurB,SAAAmhB,QAAA7gB,OAAA26B,SAIA98C,MAAAykG,qBAAA7tG,UAAAujC,OAAAiG,OAAApgC,MAAA4hB,SAAAhrB,WACAoJ,MAAAykG,qBAAA7tG,UAAAM,YAAA8I,MAAAykG,qBAQAzkG,MAAA68C,oBAAA,SAAA16B,OAAA26B,QAEA,GAAAr1C,IAAA,EAAAtH,KAAAmI,KAAA,MAEAuZ,UACA,GAAApa,EAAA,IAAAA,EAAA,MAAAA,EAAA,KAAAA,EAAA,EACA,KAAAA,EAAA,IAAAA,EAAA,MAAAA,EAAA,KAAAA,EACAA,EAAA,KAAAA,EAAA,KAAAA,EAAA,MAAAA,EAAA,KAGAu7B,SACA,kCACA,kCACA,8BACA,gCAGAhjC,OAAA2jG,mBAAA/tG,KAAAU,KAAAurB,SAAAmhB,QAAA7gB,OAAA26B,QAEAxmD,KAAAoG,KAAA,sBAEApG,KAAA+0C,YACAlpB,cACA26B,gBAIA98C,MAAA68C,oBAAAjmD,UAAAujC,OAAAiG,OAAApgC,MAAA4hB,SAAAhrB,WACAoJ,MAAA68C,oBAAAjmD,UAAAM,YAAA8I,MAAA68C,oBAQA78C,MAAA0kG,mBAAA,SAAAviF,OAAA26B,QAEAxmD,KAAA+0C,YACAlpB,cACA26B,cAGA,IAAAj7B,WACA,wCAGAmhB,SACA,gDAGAhjC,OAAA2jG,mBAAA/tG,KAAAU,KAAAurB,SAAAmhB,QAAA7gB,OAAA26B,QAEAxmD,KAAAoG,KAAA,qBAEApG,KAAA+0C,YACAlpB,cACA26B,gBAIA98C,MAAA0kG,mBAAA9tG,UAAAujC,OAAAiG,OAAApgC,MAAA4hB,SAAAhrB,WACAoJ,MAAA0kG,mBAAA9tG,UAAAM,YAAA8I,MAAA0kG,mBAQA1kG,MAAA2kG,oBAAA,SAAAxiF,OAAA26B,QAEA,GAAAj7B,WACA,+BAGAmhB,SACA,wBAGAhjC,OAAA2jG,mBAAA/tG,KAAAU,KAAAurB,SAAAmhB,QAAA7gB,OAAA26B,QAEAxmD,KAAAoG,KAAA,sBAEApG,KAAA+0C,YACAlpB,cACA26B,gBAKA98C,MAAA2kG,oBAAA/tG,UAAAujC,OAAAiG,OAAApgC,MAAA4hB,SAAAhrB,WACAoJ,MAAA2kG,oBAAA/tG,UAAAM,YAAA8I,MAAA2kG,oBAaA3kG,MAAA4kG,mBAAA,SAAAC,KAAAC,OAAAC,QAEA/kG,MAAA4hB,SAAAhsB,KAAAU,MAEAA,KAAAoG,KAAA,qBAEApG,KAAA+0C,YACAw5D,UACAC,cACAC,cAGA,IAIA/pG,GAAAY,EAAA7F,EACA8gC,EAAAtgB,EALA4sE,MAAA7sF,KAAAurB,SACAqf,MAAA5qC,KAAA4qC,MACAM,IAAAlrC,KAAA6qC,cAAA,GAKA6jE,WAAAF,OAAA,CAEA,KAAA9pG,EAAA,EAAa+pG,QAAA/pG,EAAaA,IAI1B,IAFAub,EAAAvb,EAAA+pG,OAEAnpG,EAAA,EAAckpG,QAAAlpG,EAAaA,IAE3Bi7B,EAAAj7B,EAAAkpG,OAEA/uG,EAAA8uG,KAAAhuE,EAAAtgB,GACA4sE,MAAAvoF,KAAA7E,EAKA,IAAA2gB,GAAA9P,EAAA9Q,EAAA0kB,EACAynB,IAAAC,IAAAC,IAAAq5D,GAEA,KAAAxgG,EAAA,EAAa+pG,OAAA/pG,EAAYA,IAEzB,IAAAY,EAAA,EAAckpG,OAAAlpG,EAAYA,IAE1B8a,EAAA1b,EAAAgqG,WAAAppG,EACAgL,EAAA5L,EAAAgqG,WAAAppG,EAAA,EACA9F,GAAAkF,EAAA,GAAAgqG,WAAAppG,EAAA,EACA4e,GAAAxf,EAAA,GAAAgqG,WAAAppG,EAEAqmC,IAAA,GAAAjiC,OAAAiY,QAAArc,EAAAkpG,OAAA9pG,EAAA+pG,QACA7iE,IAAA,GAAAliC,OAAAiY,SAAArc,EAAA,GAAAkpG,OAAA9pG,EAAA+pG,QACA5iE,IAAA,GAAAniC,OAAAiY,SAAArc,EAAA,GAAAkpG,QAAA9pG,EAAA,GAAA+pG,QACAvJ,IAAA,GAAAx7F,OAAAiY,QAAArc,EAAAkpG,QAAA9pG,EAAA,GAAA+pG,QAEA7jE,MAAAtmC,KAAA,GAAAoF,OAAAy+B,MAAA/nB,EAAA9P,EAAA4T,IACAgnB,IAAA5mC,MAAAqnC,IAAAC,IAAAs5D,MAEAt6D,MAAAtmC,KAAA,GAAAoF,OAAAy+B,MAAA73B,EAAA9Q,EAAA0kB,IACAgnB,IAAA5mC,MAAAsnC,IAAAj4B,QAAAk4B,IAAAq5D,IAAAvxF,SAYA3T,MAAAgsC,qBACAhsC,KAAAisC,wBAIAviC,MAAA4kG,mBAAAhuG,UAAAujC,OAAAiG,OAAApgC,MAAA4hB,SAAAhrB,WACAoJ,MAAA4kG,mBAAAhuG,UAAAM,YAAA8I,MAAA4kG,mBASA5kG,MAAAilG,WAAA,SAAA5kF,MAEAA,WAAA,CAEA,IAAAwB,UAAA,GAAAQ,eACA,MAAAhC,KAAA,IACA,QAAAA,KAAA,EACA,UAAAA,OAGAkhB,OAAA,GAAAlf,eACA,aACA,aACA,eAGA5oB,SAAA,GAAAuG,OAAA8hB,cACAroB,UAAAinC,aAAA,cAAA1gC,OAAAg/B,gBAAAnd,SAAA,IACApoB,SAAAinC,aAAA,WAAA1gC,OAAAg/B,gBAAAuC,OAAA,GAEA,IAAA5nC,UAAA,GAAAqG,OAAAsgD,mBAA8C1hB,aAAA5+B,MAAA4B,cAE9C5B,OAAAm5B,KAAAvjC,KAAAU,KAAAmD,SAAAE,SAAAqG,MAAAyjD,aAIAzjD,MAAAilG,WAAAruG,UAAAujC,OAAAiG,OAAApgC,MAAAm5B,KAAAviC,WACAoJ,MAAAilG,WAAAruG,UAAAM,YAAA8I,MAAAilG,WAoBAjlG,MAAAklG,YAAA,WAEA,GAAAC,cAAA,GAAAnlG,OAAA4hB,QACAujF,cAAAtjF,SAAAjnB,KAAA,GAAAoF,OAAAgW,QAAA,UAAAhW,OAAAgW,QAAA,OAEA,IAAAovF,cAAA,GAAAplG,OAAAm8C,iBAAA,WAGA,OAFAipD,cAAA5pE,aAAA,GAAAx7B,OAAAkb,SAAAoO,gBAAA,UAEA,SAAA+7E,IAAAl6E,OAAAlwB,OAAApB,MAAAyrG,WAAAC,WAIAvlG,MAAAk6B,SAAAtkC,KAAAU,MAEA4J,SAAArG,cAAA,UACAqG,SAAAjF,gBAAA,GACAiF,SAAAolG,wBAAA,GAAArqG,QACAiF,SAAAqlG,sBAAA,GAAAD,YAEAhvG,KAAAiD,SAAAuN,KAAAqkB,QAEA70B,KAAA0oB,KAAA,GAAAhf,OAAAm5B,KAAAgsE,aAAA,GAAAnlG,OAAAsgD,mBAA0EzmD,eAC1EvD,KAAA0oB,KAAA8b,kBAAA,EACAxkC,KAAA2D,IAAA3D,KAAA0oB,MAEA1oB,KAAAkvG,KAAA,GAAAxlG,OAAAhG,KAAAorG,aAAA,GAAAplG,OAAApG,mBAA0EC,eAC1EvD,KAAAkvG,KAAA1qE,kBAAA,EACAxkC,KAAA2D,IAAA3D,KAAAkvG,MAEAlvG,KAAAmvG,aAAAJ,KACA/uG,KAAAmjB,UAAAxe,OAAAqqG,WAAAC,eAMAvlG,MAAAklG,YAAAtuG,UAAAujC,OAAAiG,OAAApgC,MAAAk6B,SAAAtjC,WACAoJ,MAAAklG,YAAAtuG,UAAAM,YAAA8I,MAAAklG,YAEAllG,MAAAklG,YAAAtuG,UAAA6uG,aAAA,WAEA,GACA7xE,SADAjf,KAAA,GAAA3U,OAAAgW,OAGA,iBAAAqvF,KAIAA,IAAA5qG,EAAA,OAEAnE,KAAAud,WAAApN,IAAA,SAEG4+F,IAAA5qG,GAAA,OAEHnE,KAAAud,WAAApN,IAAA,UAIAkO,KAAAlO,IAAA4+F,IAAA7rG,EAAA,GAAA6rG,IAAA7qG,GAAA4b,YAEAwd,QAAAzzB,KAAAsX,KAAA4tF,IAAA5qG,GAEAnE,KAAAud,WAAAa,iBAAAC,KAAAif,cAQA5zB,MAAAklG,YAAAtuG,UAAA6iB,UAAA,SAAAxe,OAAAqqG,WAAAC,WAEArlG,SAAAolG,wBAAA,GAAArqG,QACAiF,SAAAqlG,sBAAA,GAAAD,YAEAhvG,KAAA0oB,KAAAiK,MAAAxiB,IAAA,EAAAxL,OAAAqqG,WAAA,GACAhvG,KAAA0oB,KAAAge,eAEA1mC,KAAAkvG,KAAAv8E,MAAAxiB,IAAA8+F,UAAAD,WAAAC,WACAjvG,KAAAkvG,KAAAjsG,SAAAkB,EAAAQ,OACA3E,KAAAkvG,KAAAxoE,gBAIAh9B,MAAAklG,YAAAtuG,UAAA8uG,SAAA,SAAA7rG,OAEAvD,KAAA0oB,KAAArlB,SAAAE,MAAA4M,IAAA5M,OACAvD,KAAAkvG,KAAA7rG,SAAAE,MAAA4M,IAAA5M,QAUAmG,MAAA2lG,UAAA,SAAApkF,QAEA,GAAA9nB,UAAA,GAAAuG,OAAA8hB,cACAroB,UAAAinC,aAAA,cAAA1gC,OAAAg/B,gBAAA,GAAA3c,cAAA,QAEAriB,MAAAm5B,KAAAvjC,KAAAU,KAAAmD,SAAA,GAAAuG,OAAAsgD,mBAAgEzmD,MAAA,WAAkBmG,MAAAyjD,YAElFvjD,SAAAqhB,QAEAjrB,KAAAwG,OAAAykB,SAMAvhB,MAAA2lG,UAAA/uG,UAAAujC,OAAAiG,OAAApgC,MAAAm5B,KAAAviC,WACAoJ,MAAA2lG,UAAA/uG,UAAAM,YAAA8I,MAAA2lG,UAEA3lG,MAAA2lG,UAAA/uG,UAAAkG,OAAA,SAAAykB,QAEA,GAAA9nB,UAAA8nB,OAAA9nB,QAEA,QAAAA,SAAAgnC,aAEAhnC,SAAAsnC,oBAIA,IAAAn5B,KAAAnO,SAAAgnC,YAAA74B,IACAmB,IAAAtP,SAAAgnC,YAAA13B,IAkBA8Y,SAAAvrB,KAAAmD,SAAAsoB,WAAAxoB,SAAAuQ,KAEA+X,UAAA,GAAA9Y,IAAAvO,EAAwBqnB,SAAA,GAAA9Y,IAAAtO,EAAwBonB,SAAA,GAAA9Y,IAAAvP,EAChDqoB,SAAA,GAAAja,IAAApN,EAAwBqnB,SAAA,GAAA9Y,IAAAtO,EAAwBonB,SAAA,GAAA9Y,IAAAvP,EAEhDqoB,SAAA,GAAAja,IAAApN,EAAwBqnB,SAAA,GAAA9Y,IAAAtO,EAAwBonB,SAAA,GAAA9Y,IAAAvP,EAChDqoB,SAAA,GAAAja,IAAApN,EAAwBqnB,SAAA,IAAAja,IAAAnN,EAAwBonB,SAAA,IAAA9Y,IAAAvP,EAEhDqoB,SAAA,IAAAja,IAAApN,EAAwBqnB,SAAA,IAAAja,IAAAnN,EAAwBonB,SAAA,IAAA9Y,IAAAvP,EAChDqoB,SAAA,IAAA9Y,IAAAvO,EAAwBqnB,SAAA,IAAAja,IAAAnN,EAAwBonB,SAAA,IAAA9Y,IAAAvP,EAEhDqoB,SAAA,IAAA9Y,IAAAvO,EAAwBqnB,SAAA,IAAAja,IAAAnN,EAAwBonB,SAAA,IAAA9Y,IAAAvP,EAChDqoB,SAAA,IAAA9Y,IAAAvO,EAAwBqnB,SAAA,IAAA9Y,IAAAtO,EAAwBonB,SAAA,IAAA9Y,IAAAvP,EAIhDqoB,SAAA,IAAA9Y,IAAAvO,EAAwBqnB,SAAA,IAAA9Y,IAAAtO,EAAwBonB,SAAA,IAAAja,IAAApO,EAChDqoB,SAAA,IAAAja,IAAApN,EAAwBqnB,SAAA,IAAA9Y,IAAAtO,EAAwBonB,SAAA,IAAAja,IAAApO,EAEhDqoB,SAAA,IAAAja,IAAApN,EAAwBqnB,SAAA,IAAA9Y,IAAAtO,EAAwBonB,SAAA,IAAAja,IAAApO,EAChDqoB,SAAA,IAAAja,IAAApN,EAAwBqnB,SAAA,IAAAja,IAAAnN,EAAwBonB,SAAA,IAAAja,IAAApO,EAEhDqoB,SAAA,IAAAja,IAAApN,EAAwBqnB,SAAA,IAAAja,IAAAnN,EAAwBonB,SAAA,IAAAja,IAAApO,EAChDqoB,SAAA,IAAA9Y,IAAAvO,EAAwBqnB,SAAA,IAAAja,IAAAnN,EAAwBonB,SAAA,IAAAja,IAAApO,EAEhDqoB,SAAA,IAAA9Y,IAAAvO,EAAwBqnB,SAAA,IAAAja,IAAAnN,EAAwBonB,SAAA,IAAAja,IAAApO,EAChDqoB,SAAA,IAAA9Y,IAAAvO,EAAwBqnB,SAAA,IAAA9Y,IAAAtO,EAAwBonB,SAAA,IAAAja,IAAApO,EAIhDqoB,SAAA,IAAA9Y,IAAAvO,EAAwBqnB,SAAA,IAAA9Y,IAAAtO,EAAwBonB,SAAA,IAAA9Y,IAAAvP,EAChDqoB,SAAA,IAAA9Y,IAAAvO,EAAwBqnB,SAAA,IAAA9Y,IAAAtO,EAAwBonB,SAAA,IAAAja,IAAApO,EAEhDqoB,SAAA,IAAAja,IAAApN,EAAwBqnB,SAAA,IAAA9Y,IAAAtO,EAAwBonB,SAAA,IAAA9Y,IAAAvP,EAChDqoB,SAAA,IAAAja,IAAApN,EAAwBqnB,SAAA,IAAA9Y,IAAAtO,EAAwBonB,SAAA,IAAAja,IAAApO,EAEhDqoB,SAAA,IAAAja,IAAApN,EAAwBqnB,SAAA,IAAAja,IAAAnN,EAAwBonB,SAAA,IAAA9Y,IAAAvP,EAChDqoB,SAAA,IAAAja,IAAApN,EAAwBqnB,SAAA,IAAAja,IAAAnN,EAAwBonB,SAAA,IAAAja,IAAApO,EAEhDqoB,SAAA,IAAA9Y,IAAAvO,EAAwBqnB,SAAA,IAAAja,IAAAnN,EAAwBonB,SAAA,IAAA9Y,IAAAvP,EAChDqoB,SAAA,IAAA9Y,IAAAvO,EAAwBqnB,SAAA,IAAAja,IAAAnN,EAAwBonB,SAAA,IAAAja,IAAApO,EAEhDlD,KAAAmD,SAAAsoB,WAAAxoB,SAAA0lC,aAAA,EAEA3oC,KAAAmD,SAAAq3B,wBAEAx6B,KAAA2kB,OAAAsG,OAAAjG,YACAhlB,KAAAwkC,kBAAA,GAYA96B,MAAA4lG,kBAAA,SAAArkF,OAAAta,KAEA,GAAApN,OAAAqG,SAAA+G,QAAA,OAEA3Q,MAAAirB,cAEAjrB,KAAAiqB,IAAA,GAAAvgB,OAAAqhB,KAEArhB,MAAAhG,KAAApE,KAAAU,KAAA,GAAA0J,OAAAtG,YAAA,UAAAsG,OAAApG,mBAAwFC,YAAAC,WAAA,MAIxFkG,MAAA4lG,kBAAAhvG,UAAAujC,OAAAiG,OAAApgC,MAAAhG,KAAApD,WACAoJ,MAAA4lG,kBAAAhvG,UAAAM,YAAA8I,MAAA4lG,kBAEA5lG,MAAA4lG,kBAAAhvG,UAAAkG,OAAA,WAEAxG,KAAAiqB,IAAAe,cAAAhrB,KAAAirB,QAEAjrB,KAAAiqB,IAAAF,KAAA/pB,KAAA2yB,OAEA3yB,KAAAiqB,IAAAtB,OAAA3oB,KAAAiD,WAeAyG,MAAA29E,aAAA,SAAAxkF,QA8DA,QAAA0sG,SAAAnvF,EAAA9P,EAAAK,KAEA6+F,SAAApvF,EAAAzP,KACA6+F,SAAAl/F,EAAAK,KAIA,QAAA6+F,UAAApwG,GAAAuR,KAEAxN,SAAAooB,SAAAjnB,KAAA,GAAAoF,OAAAgW,SACAvc,SAAA8nC,OAAA3mC,KAAA,GAAAoF,OAAAuG,MAAAU,MAEA/G,SAAA6lG,SAAArwG,MAEAqwG,SAAArwG,QAIAqwG,SAAArwG,IAAAkF,KAAAnB,SAAAooB,SAAA5mB,OAAA,GA9EA,GAAAxB,UAAA,GAAAuG,OAAA4hB,SACAjoB,SAAA,GAAAqG,OAAAsgD,mBAA8CzmD,MAAA,SAAA+kC,aAAA5+B,MAAA2B,aAE9CokG,YAIAC,WAAA,SACAC,QAAA,SACAC,MAAA,MACAC,UAAA,SACAC,SAAA,OAIAP,SAAA,UAAAG,YACAH,QAAA,UAAAG,YACAH,QAAA,UAAAG,YACAH,QAAA,UAAAG,YAIAH,QAAA,UAAAG,YACAH,QAAA,UAAAG,YACAH,QAAA,UAAAG,YACAH,QAAA,UAAAG,YAIAH,QAAA,UAAAG,YACAH,QAAA,UAAAG,YACAH,QAAA,UAAAG,YACAH,QAAA,UAAAG,YAIAH,QAAA,SAAAI,SACAJ,QAAA,SAAAI,SACAJ,QAAA,SAAAI,SACAJ,QAAA,SAAAI,SAIAJ,QAAA,UAAAK,OACAL,QAAA,UAAAK,OACAL,QAAA,UAAAK,OAIAL,QAAA,QAAAM,WACAN,QAAA,QAAAO,UAIAP,QAAA,YAAAO,UACAP,QAAA,YAAAO,UAEAP,QAAA,YAAAO,UACAP,QAAA,YAAAO,UAwBApmG,MAAAm5B,KAAAvjC,KAAAU,KAAAmD,SAAAE,SAAAqG,MAAAyjD,YAEAntD,KAAA6C,cACA7C,KAAA2kB,OAAA9hB,OAAAmiB,YACAhlB,KAAAwkC,kBAAA,EAEAxkC,KAAAyvG,kBAEAzvG,KAAAwG,UAIAkD,MAAA29E,aAAA/mF,UAAAujC,OAAAiG,OAAApgC,MAAAm5B,KAAAviC,WACAoJ,MAAA29E,aAAA/mF,UAAAM,YAAA8I,MAAA29E,aAEA39E,MAAA29E,aAAA/mF,UAAAkG,OAAA,WAEA,GAAArD,UAAAssG,SAEA//F,OAAA,GAAAhG,OAAAgW,QACA7c,OAAA,GAAA6G,OAAA+rC,OAEAs6D,SAAA,SAAA7mF,MAAAhlB,EAAAC,EAAAjB,GAEAwM,OAAAS,IAAAjM,EAAAC,EAAAjB,GAAA2M,UAAAhN,OAEA,IAAA6mB,QAAA+lF,SAAAvmF,MAEA,IAAAtf,SAAA8f,OAEA,OAAAhlB,GAAA,EAAAklB,GAAAF,OAAA/kB,OAAuCilB,GAAAllB,EAAQA,IAE/CvB,SAAAooB,SAAA7B,OAAAhlB,IAAA8L,KAAAd,QAQA,mBAEAvM,SAAAnD,KAAAmD,SACAssG,SAAAzvG,KAAAyvG,QAEA,IAAAzyF,GAAA,EAAAlM,EAAA,CAKAjO,QAAAiiB,iBAAAtU,KAAAxQ,KAAA6C,OAAAiiB,kBAIAirF,SAAA,YACAA,SAAA,WAIAA,SAAA,MAAA/yF,GAAAlM,EAAA,IACAi/F,SAAA,KAAA/yF,GAAAlM,EAAA,IACAi/F,SAAA,MAAA/yF,EAAAlM,EAAA,IACAi/F,SAAA,KAAA/yF,EAAAlM,EAAA,IAIAi/F,SAAA,MAAA/yF,GAAAlM,EAAA,GACAi/F,SAAA,KAAA/yF,GAAAlM,EAAA,GACAi/F,SAAA,MAAA/yF,EAAAlM,EAAA,GACAi/F,SAAA,KAAA/yF,EAAAlM,EAAA,GAIAi/F,SAAA,QAAA/yF,EAAA,IAAAlM,EAAA,IACAi/F,SAAA,SAAA/yF,EAAA,IAAAlM,EAAA,IACAi/F,SAAA,SAAAj/F,EAAA,IAIAi/F,SAAA,OAAA/yF,EAAA,KACA+yF,SAAA,MAAA/yF,EAAA,KACA+yF,SAAA,SAAAj/F,EAAA,GACAi/F,SAAA,QAAAj/F,EAAA,GAEAi/F,SAAA,OAAA/yF,EAAA,MACA+yF,SAAA,MAAA/yF,EAAA,MACA+yF,SAAA,SAAAj/F,EAAA,IACAi/F,SAAA,QAAAj/F,EAAA,IAEA3N,SAAA6tC,oBAAA,MAcAtnC,MAAAsmG,uBAAA,SAAAx4D,MAAAztB,MAEArgB,MAAAk6B,SAAAtkC,KAAAU,MAEAA,KAAAw3C,YACAx3C,KAAAw3C,MAAArsB,oBAEAnrB,KAAA2kB,OAAA6yB,MAAAxyB,YACAhlB,KAAAwkC,kBAAA,EAEAza,WAAA,CAEA,IAAA5mB,UAAA,GAAAuG,OAAA4hB,QACAnoB,UAAAooB,SAAAjnB,KACA,GAAAoF,OAAAgW,SAAAqK,UAAA,GACA,GAAArgB,OAAAgW,QAAAqK,UAAA,GACA,GAAArgB,OAAAgW,QAAAqK,WAAA,GACA,GAAArgB,OAAAgW,SAAAqK,WAAA,GACA,GAAArgB,OAAAgW,SAAAqK,UAAA,GAGA,IAAA1mB,UAAA,GAAAqG,OAAAsgD,mBAA8CI,KAAA,GAC9C/mD,UAAAE,MAAAiN,KAAAxQ,KAAAw3C,MAAAj0C,OAAA4P,eAAAnT,KAAAw3C,MAAA9P,WAEA1nC,KAAAiwG,WAAA,GAAAvmG,OAAAm5B,KAAA1/B,SAAAE,UACArD,KAAA2D,IAAA3D,KAAAiwG,YAEA9sG,SAAA,GAAAuG,OAAA4hB,SACAnoB,SAAAooB,SAAAjnB,KACA,GAAAoF,OAAAgW,QACA,GAAAhW,OAAAgW,SAGArc,SAAA,GAAAqG,OAAAsgD,mBAA0CI,KAAA,IAC1C/mD,SAAAE,MAAAiN,KAAAxQ,KAAAw3C,MAAAj0C,OAAA4P,eAAAnT,KAAAw3C,MAAA9P,WAEA1nC,KAAAkwG,WAAA,GAAAxmG,OAAAm5B,KAAA1/B,SAAAE,UACArD,KAAA2D,IAAA3D,KAAAkwG,YAEAlwG,KAAAwG,UAIAkD,MAAAsmG,uBAAA1vG,UAAAujC,OAAAiG,OAAApgC,MAAAk6B,SAAAtjC,WACAoJ,MAAAsmG,uBAAA1vG,UAAAM,YAAA8I,MAAAsmG,uBAEAtmG,MAAAsmG,uBAAA1vG,UAAAiwC,QAAA,WAEAvwC,KAAAiwG,WAAA9sG,SAAAotC,UACAvwC,KAAAiwG,WAAA5sG,SAAAktC,UACAvwC,KAAAkwG,WAAA/sG,SAAAotC,UACAvwC,KAAAkwG,WAAA7sG,SAAAktC,WAGA7mC,MAAAsmG,uBAAA1vG,UAAAkG,OAAA,WAEA,GAAA8Y,IAAA,GAAA5V,OAAAgW,QACA4D,GAAA,GAAA5Z,OAAAgW,QACA2e,GAAA,GAAA30B,OAAAgW,OAEA,mBAEAJ,GAAA+G,sBAAArmB,KAAAw3C,MAAAxyB,aACA1B,GAAA+C,sBAAArmB,KAAAw3C,MAAA1nB,OAAA9K,aACAqZ,GAAApc,WAAAqB,GAAAhE,IAEAtf,KAAAiwG,WAAArgF,OAAAyO,IACAr+B,KAAAiwG,WAAA5sG,SAAAE,MAAAiN,KAAAxQ,KAAAw3C,MAAAj0C,OAAA4P,eAAAnT,KAAAw3C,MAAA9P,WAEA1nC,KAAAkwG,WAAA/sG,SAAAooB,SAAA,GAAA/a,KAAA6tB,IACAr+B,KAAAkwG,WAAA/sG,SAAA6tC,oBAAA,EACAhxC,KAAAkwG,WAAA7sG,SAAAE,MAAAiN,KAAAxQ,KAAAiwG,WAAA5sG,SAAAE,WAkBAmG,MAAAymG,YAAA,SAAAllF,OAAAta,IAAAy/F,gBAEA,GAAA7sG,OAAAqG,SAAA+G,QAAA,QACAy/F,gBAAAxmG,SAAAwmG,8BAAA,CAEA,IAQA7nB,WARA8nB,aAAAxmG,KAAA+T,IAAAlU,MAAAG,KAAA0qB,SAAA67E,iBAEAE,MAAA,KAAA77D,QACA87D,aAAA,SAAAnwF,EAAA9P,GAAuC,MAAA8P,GAAA9P,GAEvC+5B,MAAA,aACAlnC,SAAA,GAAAuG,OAAA8hB,cAIAP,QAAA9nB,mBAAAuG,OAAA8hB,gBAEA+8D,UAAA,GAAA7+E,OAAA4hB,SACAi9D,UAAA92C,mBAAAxmB,OAAA9nB,WAIAolF,UAAAt9D,OAAA9nB,SAAAwQ,QAIA40E,UAAAz0C,gBACAy0C,UAAAv8C,oBAMA,QAJAzgB,UAAAg9D,UAAAh9D,SACAqf,MAAA29C,UAAA39C,MACA4lE,SAAA,EAEA9rG,EAAA,EAAAsM,EAAA45B,MAAAjmC,OAAmCqM,EAAAtM,EAAOA,IAI1C,OAFA8jC,MAAAoC,MAAAlmC,GAEAY,EAAA,EAAkB,EAAAA,EAAOA,IAAA,CAEzBgrG,KAAA,GAAA9nE,KAAA6B,KAAA/kC,IACAgrG,KAAA,GAAA9nE,KAAA6B,MAAA/kC,EAAA,OACAgrG,KAAA7sE,KAAA8sE,aAEA,IAAApvG,KAAAmvG,KAAA9rG,UAEAoF,UAAA6qC,KAAAtzC,MAEAszC,KAAAtzC,MAAmBsvG,MAAAH,KAAA,GAAAI,MAAAJ,KAAA,GAAAK,MAAAjsG,EAAAksG,MAAAhnG,QACnB4mG,YAIA/7D,KAAAtzC,KAAAyvG,MAAAlsG,EAQA,GAAAg6B,QAAA,GAAA3S,cAAA,EAAAykF,SAAA,GAEA9oG,MAAA,CAEA,QAAAvG,OAAAszC,MAAA,CAEA,GAAA3jC,GAAA2jC,KAAAtzC,IAEA,IAAAyI,SAAAkH,EAAA8/F,OAAAhmE,MAAA95B,EAAA6/F,OAAA7qF,OAAAnG,IAAAirB,MAAA95B,EAAA8/F,OAAA9qF,SAAAuqF,aAAA,CAEA,GAAA7+D,QAAAjmB,SAAAza,EAAA2/F,MACA/xE,QAAAh3B,SAAA8pC,OAAAttC,EACAw6B,OAAAh3B,SAAA8pC,OAAArtC,EACAu6B,OAAAh3B,SAAA8pC,OAAAtuC,EAEAsuC,OAAAjmB,SAAAza,EAAA4/F,OACAhyE,OAAAh3B,SAAA8pC,OAAAttC,EACAw6B,OAAAh3B,SAAA8pC,OAAArtC,EACAu6B,OAAAh3B,SAAA8pC,OAAAtuC,GAMAC,SAAAinC,aAAA,cAAA1gC,OAAAg/B,gBAAAhK,OAAA,IAEAh1B,MAAAm5B,KAAAvjC,KAAAU,KAAAmD,SAAA,GAAAuG,OAAAsgD,mBAAgEzmD,cAAemG,MAAAyjD,YAE/EntD,KAAA2kB,OAAAsG,OAAAjG,YACAhlB,KAAAwkC,kBAAA,GAIA96B,MAAAymG,YAAA7vG,UAAAujC,OAAAiG,OAAApgC,MAAAm5B,KAAAviC,WACAoJ,MAAAymG,YAAA7vG,UAAAM,YAAA8I,MAAAymG,YASAzmG,MAAAmnG,kBAAA,SAAA5lF,OAAAlB,KAAApZ,IAAAs5C,WAEAjqD,KAAAirB,cAEAjrB,KAAA+pB,KAAAngB,SAAAmgB,UAAA,CAUA,QARAxmB,OAAAqG,SAAA+G,QAAA,SAEA0mC,MAAAztC,SAAAqgD,oBAAA,EAEA9mD,SAAA,GAAAuG,OAAA4hB,SAEAsf,MAAA5qC,KAAAirB,OAAA9nB,SAAAynC,MAEAlmC,EAAA,EAAAsM,EAAA45B,MAAAjmC,OAAmCqM,EAAAtM,EAAOA,IAE1CvB,SAAAooB,SAAAjnB,KAAA,GAAAoF,OAAAgW,QAAA,GAAAhW,OAAAgW,QAIAhW,OAAAm5B,KAAAvjC,KAAAU,KAAAmD,SAAA,GAAAuG,OAAAsgD,mBAAgEzmD,YAAA0mD,UAAA5S,QAAiC3tC,MAAAyjD,YAEjGntD,KAAAwkC,kBAAA,EAEAxkC,KAAA07B,aAAA,GAAAhyB,OAAAoiB,QAEA9rB,KAAAwG,UAIAkD,MAAAmnG,kBAAAvwG,UAAAujC,OAAAiG,OAAApgC,MAAAm5B,KAAAviC,WACAoJ,MAAAmnG,kBAAAvwG,UAAAM,YAAA8I,MAAAmnG,kBAEAnnG,MAAAmnG,kBAAAvwG,UAAAkG,OAAA,WAEA,GAAA+kB,UAAAvrB,KAAAmD,SAAAooB,SAEAN,OAAAjrB,KAAAirB,OACA6lF,eAAA7lF,OAAA9nB,SAAAooB,SACAwlF,YAAA9lF,OAAA9nB,SAAAynC,MACAomE,kBAAA/lF,OAAAjG,WAEAiG,QAAAE,mBAAA,GAEAnrB,KAAA07B,aAAAtO,gBAAA4jF,kBAEA,QAAAtsG,GAAA,EAAAi8B,GAAA,EAAA3vB,EAAA+/F,YAAApsG,OAAiDqM,EAAAtM,EAAOA,IAAAi8B,IAAA,GAExD,GAAA6H,MAAAuoE,YAAArsG,EAEA6mB,UAAAoV,IAAAnwB,KAAAsgG,eAAAtoE,KAAApoB,IACAzc,IAAAmtG,eAAAtoE,KAAAl4B,IACA3M,IAAAmtG,eAAAtoE,KAAAhpC,IACA4iB,aAAA,GACA4B,aAAAgtF,mBAEAzlF,SAAAoV,GAAA,GAAAnwB,KAAAg4B,KAAA1iB,QACAhC,aAAA9jB,KAAA07B,cACA5b,YACA3M,eAAAnT,KAAA+pB,MACApmB,IAAA4nB,SAAAoV,KAMA,MAFA3gC,MAAAmD,SAAA6tC,oBAAA,EAEAhxC,MAWA0J,MAAAunG,WAAA,SAAAlnF,KAAA0jC,MAEA,GAAAtqD,UAAA,GAAAuG,OAAA4hB,SACAjoB,SAAA,GAAAqG,OAAAsgD,mBAA8C1hB,aAAA5+B,MAAA4B,cAE9CtL,MAAA+S,OAAA,GAAArJ,OAAAuG,MAAA,SACAjQ,KAAAgT,OAAA,GAAAtJ,OAAAuG,MAAA,QAEA,QAAAvL,IAAAqlB,KAAsBA,MAAArlB,EAAWA,GAAA+oD,KAAA,CAEjCtqD,SAAAooB,SAAAjnB,KACA,GAAAoF,OAAAgW,SAAAqK,KAAA,EAAArlB,GAAA,GAAAgF,OAAAgW,QAAAqK,KAAA,EAAArlB,GACA,GAAAgF,OAAAgW,QAAAhb,EAAA,GAAAqlB,MAAA,GAAArgB,OAAAgW,QAAAhb,EAAA,EAAAqlB,MAGA,IAAAxmB,OAAA,IAAAmB,EAAA1E,KAAA+S,OAAA/S,KAAAgT,MAEA7P,UAAA8nC,OAAA3mC,KAAAf,yBAIAmG,MAAAm5B,KAAAvjC,KAAAU,KAAAmD,SAAAE,SAAAqG,MAAAyjD,aAIAzjD,MAAAunG,WAAA3wG,UAAAujC,OAAAiG,OAAApgC,MAAAm5B,KAAAviC,WACAoJ,MAAAunG,WAAA3wG,UAAAM,YAAA8I,MAAAunG,WAEAvnG,MAAAunG,WAAA3wG,UAAA4wG,UAAA,SAAAC,gBAAAC,WAEApxG,KAAA+S,OAAA5C,IAAAghG,iBACAnxG,KAAAgT,OAAA7C,IAAAihG,WAEApxG,KAAAmD,SAAAkuC,kBAAA,GAWA3nC,MAAA2nG,sBAAA,SAAA75D,MAAA85D,YAEA5nG,MAAAk6B,SAAAtkC,KAAAU,MAEAA,KAAAw3C,YACAx3C,KAAAw3C,MAAArsB,oBAEAnrB,KAAA2kB,OAAA6yB,MAAAxyB,YACAhlB,KAAAwkC,kBAAA,EAEAxkC,KAAAirC,QAAA,GAAAvhC,OAAAuG,MAAA,GAAAvG,OAAAuG,MAEA,IAAA9M,UAAA,GAAAuG,OAAAw8C,eAAAorD,WAAA,IACAnuG,UAAA+hC,aAAA,GAAAx7B,OAAAkb,SAAAqO,eAAAppB,KAAAud,GAAA,GAEA,QAAA1iB,GAAA,EAAAklB,GAAA,EAAyBA,GAAAllB,EAAQA,IAEjCvB,SAAAynC,MAAAlmC,GAAAnB,MAAAvD,KAAAirC,OAAA,EAAAvmC,EAAA,IAIA,IAAArB,UAAA,GAAAqG,OAAApG,mBAA8CglC,aAAA5+B,MAAA2B,WAAA7H,WAAA,GAE9CxD,MAAAuxG,YAAA,GAAA7nG,OAAAhG,KAAAP,SAAAE,UACArD,KAAA2D,IAAA3D,KAAAuxG,aAEAvxG,KAAAwG,UAIAkD,MAAA2nG,sBAAA/wG,UAAAujC,OAAAiG,OAAApgC,MAAAk6B,SAAAtjC,WACAoJ,MAAA2nG,sBAAA/wG,UAAAM,YAAA8I,MAAA2nG,sBAEA3nG,MAAA2nG,sBAAA/wG,UAAAiwC,QAAA,WACAvwC,KAAAuxG,YAAApuG,SAAAotC,UACAvwC,KAAAuxG,YAAAluG,SAAAktC,WAGA7mC,MAAA2nG,sBAAA/wG,UAAAkG,OAAA,WAEA,GAAAkJ,QAAA,GAAAhG,OAAAgW,OAEA,mBAEA1f,KAAAirC,OAAA,GAAAz6B,KAAAxQ,KAAAw3C,MAAAj0C,OAAA4P,eAAAnT,KAAAw3C,MAAA9P,WACA1nC,KAAAirC,OAAA,GAAAz6B,KAAAxQ,KAAAw3C,MAAAxP,aAAA70B,eAAAnT,KAAAw3C,MAAA9P,WAEA1nC,KAAAuxG,YAAA3hF,OAAAlgB,OAAA2W,sBAAArmB,KAAAw3C,MAAAxyB,aAAAlC,UACA9iB,KAAAuxG,YAAApuG,SAAAkuC,kBAAA,MAaA3nC,MAAA8nG,iBAAA,SAAAh6D,MAAA85D,YAEAtxG,KAAAw3C,YACAx3C,KAAAw3C,MAAArsB,mBAEA,IAAAhoB,UAAA,GAAAuG,OAAAw8C,eAAAorD,WAAA,KACAjuG,SAAA,GAAAqG,OAAApG;AAA8CE,WAAA,EAAA4mD,KAAA,GAC9C/mD,UAAAE,MAAAiN,KAAAxQ,KAAAw3C,MAAAj0C,OAAA4P,eAAAnT,KAAAw3C,MAAA9P,WAEAh+B,MAAAhG,KAAApE,KAAAU,KAAAmD,SAAAE,UAEArD,KAAA2kB,OAAA3kB,KAAAw3C,MAAAxyB,YACAhlB,KAAAwkC,kBAAA,GA0BA96B,MAAA8nG,iBAAAlxG,UAAAujC,OAAAiG,OAAApgC,MAAAhG,KAAApD,WACAoJ,MAAA8nG,iBAAAlxG,UAAAM,YAAA8I,MAAA8nG,iBAEA9nG,MAAA8nG,iBAAAlxG,UAAAiwC,QAAA,WAEAvwC,KAAAmD,SAAAotC,UACAvwC,KAAAqD,SAAAktC,WAGA7mC,MAAA8nG,iBAAAlxG,UAAAkG,OAAA,WAEAxG,KAAAqD,SAAAE,MAAAiN,KAAAxQ,KAAAw3C,MAAAj0C,OAAA4P,eAAAnT,KAAAw3C,MAAA9P,YA4BAh+B,MAAA+nG,eAAA,SAAAxmF,QAEAjrB,KAAAyjD,MAAAzjD,KAAA0xG,YAAAzmF,OAIA,QAFA9nB,UAAA,GAAAuG,OAAA4hB,SAEA5mB,EAAA,EAAiBA,EAAA1E,KAAAyjD,MAAA9+C,OAAuBD,IAAA,CAExC,GAAA8qD,MAAAxvD,KAAAyjD,MAAA/+C,EAEA8qD,MAAAvrB,iBAAAv6B,OAAAilD,OAEAxrD,SAAAooB,SAAAjnB,KAAA,GAAAoF,OAAAgW,SACAvc,SAAAooB,SAAAjnB,KAAA,GAAAoF,OAAAgW,SACAvc,SAAA8nC,OAAA3mC,KAAA,GAAAoF,OAAAuG,MAAA,QACA9M,SAAA8nC,OAAA3mC,KAAA,GAAAoF,OAAAuG,MAAA,SAMA,GAAA5M,UAAA,GAAAqG,OAAAsgD,mBAA8C1hB,aAAA5+B,MAAA4B,aAAAoyC,WAAA,EAAAC,YAAA,EAAAF,aAAA,GAE9C/zC,OAAAm5B,KAAAvjC,KAAAU,KAAAmD,SAAAE,SAAAqG,MAAAyjD,YAEAntD,KAAAgiG,KAAA/2E,OAEAjrB,KAAA2kB,OAAAsG,OAAAjG,YACAhlB,KAAAwkC,kBAAA,EAEAxkC,KAAAwG,UAKAkD,MAAA+nG,eAAAnxG,UAAAujC,OAAAiG,OAAApgC,MAAAm5B,KAAAviC,WACAoJ,MAAA+nG,eAAAnxG,UAAAM,YAAA8I,MAAA+nG,eAEA/nG,MAAA+nG,eAAAnxG,UAAAoxG,YAAA,SAAAzmF,QAEA,GAAA0mF,YAEA1mF,kBAAAvhB,OAAAilD,MAEAgjD,SAAArtG,KAAA2mB,OAIA,QAAAvmB,GAAA,EAAiBA,EAAAumB,OAAAmY,SAAAz+B,OAA4BD,IAE7CitG,SAAArtG,KAAA/C,MAAAowG,SAAA3xG,KAAA0xG,YAAAzmF,OAAAmY,SAAA1+B,IAIA,OAAAitG,WAIAjoG,MAAA+nG,eAAAnxG,UAAAkG,OAAA,WAUA,OARArD,UAAAnD,KAAAmD,SAEAyuG,gBAAA,GAAAloG,OAAAkb,SAAAG,WAAA/kB,KAAAgiG,KAAAh9E,aAEA6sF,WAAA,GAAAnoG,OAAAkb,QAEAtf,EAAA,EAEAZ,EAAA,EAAiBA,EAAA1E,KAAAyjD,MAAA9+C,OAAuBD,IAAA,CAExC,GAAA8qD,MAAAxvD,KAAAyjD,MAAA/+C,EAEA8qD,MAAAvrB,iBAAAv6B,OAAAilD,OAEAkjD,WAAAhtF,iBAAA+sF,eAAApiD,KAAAxqC,aACA7hB,SAAAooB,SAAAjmB,GAAA+gB,sBAAAwrF,YAEAA,WAAAhtF,iBAAA+sF,eAAApiD,KAAAvrB,OAAAjf,aACA7hB,SAAAooB,SAAAjmB,EAAA,GAAA+gB,sBAAAwrF,YAEAvsG,GAAA,GAMAnC,SAAA6tC,oBAAA,EAEA7tC,SAAAq3B,yBAYA9wB,MAAAooG,gBAAA,SAAAt6D,OAEA9tC,MAAAk6B,SAAAtkC,KAAAU,MAEAA,KAAAw3C,YACAx3C,KAAAw3C,MAAArsB,oBAEAnrB,KAAA2kB,OAAA6yB,MAAAxyB,YACAhlB,KAAAwkC,kBAAA,CAEA,IAAArhC,UAAA,GAAAuG,OAAAm8C,iBAAA,aAEA1iD,UAAA+hC,aAAA,GAAAx7B,OAAAkb,SAAAoO,gBAAA,UACA7vB,SAAA+hC,aAAA,GAAAx7B,OAAAkb,SAAAqO,eAAAppB,KAAAud,GAAA,GAEA,IAAA/jB,UAAA,GAAAqG,OAAApG,mBAA8CE,WAAA,EAAA4mD,KAAA,GAE9CpqD,MAAAkvG,KAAA,GAAAxlG,OAAAhG,KAAAP,SAAAE,UACArD,KAAA2D,IAAA3D,KAAAkvG,MAEAlvG,KAAAwG,UAIAkD,MAAAooG,gBAAAxxG,UAAAujC,OAAAiG,OAAApgC,MAAAk6B,SAAAtjC,WACAoJ,MAAAooG,gBAAAxxG,UAAAM,YAAA8I,MAAAooG,gBAEApoG,MAAAooG,gBAAAxxG,UAAAiwC,QAAA,WACAvwC,KAAAkvG,KAAA/rG,SAAAotC,UACAvwC,KAAAkvG,KAAA7rG,SAAAktC,WAGA7mC,MAAAooG,gBAAAxxG,UAAAkG,OAAA,WAEA,GAAAkJ,QAAA,GAAAhG,OAAAgW,QACAqyF,QAAA,GAAAroG,OAAAgW,OAEA,mBAEA,GAAAsyF,YAAAhyG,KAAAw3C,MAAA3uB,SAAA7oB,KAAAw3C,MAAA3uB,SAAA,IACAopF,UAAAD,WAAAnoG,KAAAuS,IAAApc,KAAAw3C,MAAAl5B,MAEAte,MAAAkvG,KAAAv8E,MAAAxiB,IAAA8hG,oBAAAD,YAEAtiG,OAAA2W,sBAAArmB,KAAAw3C,MAAAxyB,aACA+sF,QAAA1rF,sBAAArmB,KAAAw3C,MAAA1nB,OAAA9K,aAEAhlB,KAAAkvG,KAAAt/E,OAAAmiF,QAAAvxG,IAAAkP,SAEA1P,KAAAkvG,KAAA7rG,SAAAE,MAAAiN,KAAAxQ,KAAAw3C,MAAAj0C,OAAA4P,eAAAnT,KAAAw3C,MAAA9P,eAaAh+B,MAAAwoG,oBAAA,SAAAjnF,OAAAlB,KAAApZ,IAAAs5C,WAEAjqD,KAAAirB,cAEAjrB,KAAA+pB,KAAAngB,SAAAmgB,UAAA,CAUA,QARAxmB,OAAAqG,SAAA+G,QAAA,SAEA0mC,MAAAztC,SAAAqgD,oBAAA,EAEA9mD,SAAA,GAAAuG,OAAA4hB,SAEAsf,MAAA3f,OAAA9nB,SAAAynC,MAEAlmC,EAAA,EAAAsM,EAAA45B,MAAAjmC,OAAmCqM,EAAAtM,EAAOA,IAI1C,OAFA8jC,MAAAoC,MAAAlmC,GAEAY,EAAA,EAAAqnC,GAAAnE,KAAAH,cAAA1jC,OAAkDgoC,GAAArnC,EAAQA,IAE1DnC,SAAAooB,SAAAjnB,KAAA,GAAAoF,OAAAgW,QAAA,GAAAhW,OAAAgW,QAMAhW,OAAAm5B,KAAAvjC,KAAAU,KAAAmD,SAAA,GAAAuG,OAAAsgD,mBAAgEzmD,YAAA0mD,UAAA5S,QAAiC3tC,MAAAyjD,YAEjGntD,KAAAwkC,kBAAA,EAEAxkC,KAAA07B,aAAA,GAAAhyB,OAAAoiB,QAEA9rB,KAAAwG,UAIAkD,MAAAwoG,oBAAA5xG,UAAAujC,OAAAiG,OAAApgC,MAAAm5B,KAAAviC,WACAoJ,MAAAwoG,oBAAA5xG,UAAAM,YAAA8I,MAAAwoG,oBAEAxoG,MAAAwoG,oBAAA5xG,UAAAkG,OAAA,SAAAykB,QAEA,GAAA3L,IAAA,GAAA5V,OAAAgW,OAEA,iBAAAuL,QAEA,GAAAof,OAAA,gBAEArqC,MAAAirB,OAAAE,mBAAA,GAEAnrB,KAAA07B,aAAAtO,gBAAAptB,KAAAirB,OAAAjG,YAYA,QAVAuG,UAAAvrB,KAAAmD,SAAAooB,SAEAshE,MAAA7sF,KAAAirB,OAAA9nB,SAAAooB,SAEAqf,MAAA5qC,KAAAirB,OAAA9nB,SAAAynC,MAEAunE,YAAAnyG,KAAAirB,OAAAjG,YAEAqvB,IAAA,EAEA3vC,EAAA,EAAAsM,EAAA45B,MAAAjmC,OAAoCqM,EAAAtM,EAAOA,IAI3C,OAFA8jC,MAAAoC,MAAAlmC,GAEAY,EAAA,EAAAqnC,GAAAnE,KAAAH,cAAA1jC,OAAmDgoC,GAAArnC,EAAQA,IAAA,CAE3D,GAAA8sG,UAAA5pE,KAAA6B,KAAA/kC,IACAksC,OAAAq7C,MAAAulB,UAEAtsF,OAAA0iB,KAAAH,cAAA/iC,EAEAimB,UAAA8oB,KAAA7jC,KAAAghC,QAAAxtB,aAAAmuF,aAEA7yF,GAAA9O,KAAAsV,QAAAhC,aAAA9jB,KAAA07B,cAAA5b,YAAA3M,eAAAnT,KAAA+pB,MAEAzK,GAAA3b,IAAA4nB,SAAA8oB,MACAA,KAAA,EAEA9oB,SAAA8oB,KAAA7jC,KAAA8O,IACA+0B,KAAA,EAQA,MAFAr0C,MAAAmD,SAAA6tC,oBAAA,EAEAhxC,SAaA0J,MAAA2oG,qBAAA,SAAApnF,OAAAlB,KAAApZ,IAAAs5C,WAEAjqD,KAAAirB,cAEAjrB,KAAA+pB,KAAAngB,SAAAmgB,UAAA,CAUA,QARAxmB,OAAAqG,SAAA+G,QAAA,IAEA0mC,MAAAztC,SAAAqgD,oBAAA,EAEA9mD,SAAA,GAAAuG,OAAA4hB,SAEAsf,MAAA3f,OAAA9nB,SAAAynC,MAEAlmC,EAAA,EAAAsM,EAAA45B,MAAAjmC,OAAmCqM,EAAAtM,EAAOA,IAI1C,OAFA8jC,MAAAoC,MAAAlmC,GAEAY,EAAA,EAAAqnC,GAAAnE,KAAAD,eAAA5jC,OAAmDgoC,GAAArnC,EAAQA,IAE3DnC,SAAAooB,SAAAjnB,KAAA,GAAAoF,OAAAgW,SACAvc,SAAAooB,SAAAjnB,KAAA,GAAAoF,OAAAgW,QAMAhW,OAAAm5B,KAAAvjC,KAAAU,KAAAmD,SAAA,GAAAuG,OAAAsgD,mBAAgEzmD,YAAA0mD,UAAA5S,QAAiC3tC,MAAAyjD,YAEjGntD,KAAAwkC,kBAAA,EAEAxkC,KAAAwG,UAIAkD,MAAA2oG,qBAAA/xG,UAAAujC,OAAAiG,OAAApgC,MAAAm5B,KAAAviC,WACAoJ,MAAA2oG,qBAAA/xG,UAAAM,YAAA8I,MAAA2oG,qBAEA3oG,MAAA2oG,qBAAA/xG,UAAAkG,OAAA,SAAAykB,QAEA,GAAA3L,IAAA,GAAA5V,OAAAgW,OAEA,iBAAAuL,QAEA,GAAAof,OAAA,gBAEArqC,MAAAirB,OAAAE,mBAAA,EAYA,QAVAI,UAAAvrB,KAAAmD,SAAAooB,SAEAshE,MAAA7sF,KAAAirB,OAAA9nB,SAAAooB,SAEAqf,MAAA5qC,KAAAirB,OAAA9nB,SAAAynC,MAEAunE,YAAAnyG,KAAAirB,OAAAjG,YAEAqvB,IAAA,EAEA3vC,EAAA,EAAAsM,EAAA45B,MAAAjmC,OAAoCqM,EAAAtM,EAAOA,IAI3C,OAFA8jC,MAAAoC,MAAAlmC,GAEAY,EAAA,EAAAqnC,GAAAnE,KAAAD,eAAA5jC,OAAoDgoC,GAAArnC,EAAQA,IAAA,CAE5D,GAAA8sG,UAAA5pE,KAAA6B,KAAA/kC,IACAksC,OAAAq7C,MAAAulB,UAEArkE,QAAAvF,KAAAD,eAAAjjC,EAEAimB,UAAA8oB,KAAA7jC,KAAAghC,QAAAxtB,aAAAmuF,aAEA7yF,GAAA9O,KAAAu9B,SAAA9oB,mBAAAktF,aAAAh/F,eAAAnT,KAAA+pB,MAEAzK,GAAA3b,IAAA4nB,SAAA8oB,MACAA,KAAA,EAEA9oB,SAAA8oB,KAAA7jC,KAAA8O,IACA+0B,KAAA,EAQA,MAFAr0C,MAAAmD,SAAA6tC,oBAAA,EAEAhxC,SAYA0J,MAAA4oG,gBAAA,SAAArnF,OAAAta,KAEA,GAAApN,OAAAqG,SAAA+G,QAAA,SAEA2/F,MAAA,KAAA77D,QACA87D,aAAA,SAAAnwF,EAAA9P,GAAuC,MAAA8P,GAAA9P,GAEvC+5B,MAAA,aACAlnC,SAAA,GAAAuG,OAAA8hB,cAEA,IAAAP,OAAA9nB,mBAAAuG,OAAA4hB,SAAA,CASA,OAPAC,UAAAN,OAAA9nB,SAAAooB,SACAqf,MAAA3f,OAAA9nB,SAAAynC,MACA4lE,SAAA,EAGA+B,MAAA,GAAAh5C,aAAA,EAAA3uB,MAAAjmC,QAEAD,EAAA,EAAAsM,EAAA45B,MAAAjmC,OAAoCqM,EAAAtM,EAAOA,IAI3C,OAFA8jC,MAAAoC,MAAAlmC,GAEAY,EAAA,EAAmB,EAAAA,EAAOA,IAAA,CAE1BgrG,KAAA,GAAA9nE,KAAA6B,KAAA/kC,IACAgrG,KAAA,GAAA9nE,KAAA6B,MAAA/kC,EAAA,OACAgrG,KAAA7sE,KAAA8sE,aAEA,IAAApvG,KAAAmvG,KAAA9rG,UAEAoF,UAAA6qC,KAAAtzC,OAEAoxG,MAAA,EAAA/B,UAAAF,KAAA,GACAiC,MAAA,EAAA/B,SAAA,GAAAF,KAAA,GACA77D,KAAAtzC,MAAA,EACAqvG,YAUA,OAFA9xE,QAAA,GAAA3S,cAAA,EAAAykF,SAAA,GAEA9rG,EAAA,EAAAsM,EAAAw/F,SAAgCx/F,EAAAtM,EAAOA,IAEvC,OAAAY,GAAA,EAAmB,EAAAA,EAAOA,IAAA,CAE1B,GAAAksC,QAAAjmB,SAAAgnF,MAAA,EAAA7tG,EAAAY,IAEAoC,MAAA,EAAAhD,EAAA,EAAAY,CACAo5B,QAAAh3B,MAAA,GAAA8pC,OAAAttC,EACAw6B,OAAAh3B,MAAA,GAAA8pC,OAAArtC,EACAu6B,OAAAh3B,MAAA,GAAA8pC,OAAAtuC,EAMAC,SAAAinC,aAAA,cAAA1gC,OAAAg/B,gBAAAhK,OAAA,QAEE,IAAAzT,OAAA9nB,mBAAAuG,OAAA8hB,eAEF,GAAA5hB,SAAAqhB,OAAA9nB,SAAAsoB,WAAA/jB,MAAA,CAEA,GAAA6jB,UAAAN,OAAA9nB,SAAAsoB,WAAAxoB,SAAAuQ,MACAk5B,QAAAzhB,OAAA9nB,SAAAsoB,WAAA/jB,MAAA8L,MACAy2B,UAAAhf,OAAA9nB,SAAA8mC,UACAumE,SAAA,CAEA,KAAAvmE,UAAAtlC,SAEAslC,YAAmBJ,MAAA6C,QAAA/nC,OAAA+C,MAAA,EAAA8gB,MAAA,IAOnB,QAFA+pF,OAAA,GAAAh5C,aAAA,EAAA7sB,QAAA/nC,QAEAu/D,EAAA,EAAAnX,GAAA9iB,UAAAtlC,OAA0CooD,GAAAmX,IAAQA,EAMlD,OAJA17C,OAAAyhB,UAAAi6B,GAAA17C,MACAqhB,MAAAI,UAAAi6B,GAAAr6B,MACAniC,MAAAuiC,UAAAi6B,GAAAx8D,MAEAhD,EAAA8jB,MAAAoB,GAAApB,MAAAqhB,MAA4CjgB,GAAAllB,EAAQA,GAAA,EAEpD,OAAAY,GAAA,EAAqB,EAAAA,EAAOA,IAAA,CAE5BgrG,KAAA,GAAA5oG,MAAAglC,QAAAhoC,EAAAY,GACAgrG,KAAA,GAAA5oG,MAAAglC,QAAAhoC,GAAAY,EAAA,MACAgrG,KAAA7sE,KAAA8sE,aAEA,IAAApvG,KAAAmvG,KAAA9rG,UAEAoF,UAAA6qC,KAAAtzC,OAEAoxG,MAAA,EAAA/B,UAAAF,KAAA,GACAiC,MAAA,EAAA/B,SAAA,GAAAF,KAAA,GACA77D,KAAAtzC,MAAA,EACAqvG,YAYA,OAFA9xE,QAAA,GAAA3S,cAAA,EAAAykF,SAAA,GAEA9rG,EAAA,EAAAsM,EAAAw/F,SAAiCx/F,EAAAtM,EAAOA,IAExC,OAAAY,GAAA,EAAoB,EAAAA,EAAOA,IAAA,CAE3B,GAAAoC,OAAA,EAAAhD,EAAA,EAAAY,EACAwjC,OAAA,EAAAypE,MAAA,EAAA7tG,EAAAY,EACAo5B,QAAAh3B,MAAA,GAAA6jB,SAAAud,QACApK,OAAAh3B,MAAA,GAAA6jB,SAAAud,OAAA,GACApK,OAAAh3B,MAAA,GAAA6jB,SAAAud,OAAA,GAMA3lC,SAAAinC,aAAA,cAAA1gC,OAAAg/B,gBAAAhK,OAAA,QAEG,CAQH,OANAnT,UAAAN,OAAA9nB,SAAAsoB,WAAAxoB,SAAAuQ,MACAg9F,SAAAjlF,SAAA5mB,OAAA,EACA6tG,QAAAhC,SAAA,EAEA9xE,OAAA,GAAA3S,cAAA,EAAAykF,SAAA,GAEA9rG,EAAA,EAAAsM,EAAAwhG,QAAgCxhG,EAAAtM,EAAOA,IAEvC,OAAAY,GAAA,EAAoB,EAAAA,EAAOA,IAAA,CAE3B,GAAAoC,OAAA,GAAAhD,EAAA,EAAAY,EAEAujC,OAAA,EAAAnkC,EAAA,EAAAY,CACAo5B,QAAAh3B,MAAA,GAAA6jB,SAAAsd,QACAnK,OAAAh3B,MAAA,GAAA6jB,SAAAsd,OAAA,GACAnK,OAAAh3B,MAAA,GAAA6jB,SAAAsd,OAAA,EAEA,IAAAC,QAAA,EAAApkC,EAAA,IAAAY,EAAA,KACAo5B,QAAAh3B,MAAA,GAAA6jB,SAAAud,QACApK,OAAAh3B,MAAA,GAAA6jB,SAAAud,OAAA,GACApK,OAAAh3B,MAAA,GAAA6jB,SAAAud,OAAA,GAMA3lC,SAAAinC,aAAA,cAAA1gC,OAAAg/B,gBAAAhK,OAAA,IAMAh1B,MAAAm5B,KAAAvjC,KAAAU,KAAAmD,SAAA,GAAAuG,OAAAsgD,mBAAgEzmD,cAAemG,MAAAyjD,YAE/EntD,KAAA2kB,OAAAsG,OAAAjG,YACAhlB,KAAAwkC,kBAAA,GAIA96B,MAAA4oG,gBAAAhyG,UAAAujC,OAAAiG,OAAApgC,MAAAm5B,KAAAviC,WACAoJ,MAAA4oG,gBAAAhyG,UAAAM,YAAA8I,MAAA4oG,gBAQA5oG,MAAA44D,sBAAA,WAEA54D,MAAAk6B,SAAAtkC,KAAAU,MAEAA,KAAAiC,OAAA,SAAAwwG,mBAIA/oG,MAAA44D,sBAAAhiE,UAAAujC,OAAAiG,OAAApgC,MAAAk6B,SAAAtjC,WACAoJ,MAAA44D,sBAAAhiE,UAAAM,YAAA8I,MAAA44D,sBAQA54D,MAAAgpG,eAAA,SAAAvvG,SAAAE,UAEAqG,MAAAhG,KAAApE,KAAAU,KAAAmD,SAAAE,UAEArD,KAAA2yG,iBACA3yG,KAAA4yG,iBAKA,IAAAC,WAAA7yG,KAAAmD,SAAAqtC,aAAA7rC,OAEAq/B,KAAA,YAEA8uE,WAAA,EACAC,SAAAF,UAAA,EAEAphD,IAAAohD,UAAA,CAEA7yG,MAAAgzG,gBAAAhvE,KAAA8uE,WAAAC,SAAAthD,KACAzxD,KAAAizG,mBAAAjvE,KAAA,IAIAt6B,MAAAgpG,eAAApyG,UAAAujC,OAAAiG,OAAApgC,MAAAhG,KAAApD,WACAoJ,MAAAgpG,eAAApyG,UAAAM,YAAA8I,MAAAgpG,eAEAhpG,MAAAgpG,eAAApyG,UAAA0yG,gBAAA,SAAAhvE,KAAAxb,MAAAC,IAAAgpC,KAEA,GAAA/N,YAEAovD,WAAAtqF,MACAuqF,SAAAtqF,IAEA9jB,OAAA8jB,IAAAD,MAAA,EAEAipC,QACAnB,UAAA7nC,IAAAD,OAAAipC,IAEA0yC,UAAA,EACAC,aAAA,EAEA8O,QAAA,EAEA1iD,KAAA,EACA17B,UAAA,EACAgJ,OAAA,EAEA6yB,oBAAA,EACAJ,cAAA,EAIAvwD,MAAA2yG,cAAA3uE,MAAA0f,UACA1jD,KAAA4yG,eAAAtuG,KAAAo/C,YAIAh6C,MAAAgpG,eAAApyG,UAAA6yG,qBAAA,SAAA1hD,KAQA,OAJAP,gBAFAC,QAAA,kBAEAiiD,eAEAjwG,SAAAnD,KAAAmD,SAEAuB,EAAA,EAAAklB,GAAAzmB,SAAAqtC,aAAA7rC,OAAoDilB,GAAAllB,EAAQA,IAAA,CAE5D,GAAA0sD,OAAAjuD,SAAAqtC,aAAA9rC,GACAy6B,OAAAiyB,MAAAptB,KAAAqtB,MAAAF,QAEA,IAAAhyB,eAAAx6B,OAAA,GAEA,GAAAq/B,MAAA7E,OAAA,EAEAi0E,aAAApvE,QAAAovE,YAAApvE,OAAuDxb,MAAAgB,IAAAf,MAAAe,MAEvD,IAAAyT,OAAAm2E,YAAApvE,KAEAt/B,GAAAu4B,MAAAzU,QAAAyU,MAAAzU,MAAA9jB,GACAA,EAAAu4B,MAAAxU,MAAAwU,MAAAxU,IAAA/jB,GAEAwsD,gCAAAltB,OAMA,OAAAA,QAAAovE,aAAA,CAEA,GAAAn2E,OAAAm2E,YAAApvE,KACAhkC,MAAAgzG,gBAAAhvE,KAAA/G,MAAAzU,MAAAyU,MAAAxU,IAAAgpC,KAIAzxD,KAAAkxD,+BAIAxnD,MAAAgpG,eAAApyG,UAAA+yG,6BAAA,SAAArvE,MAEA,GAAA0f,WAAA1jD,KAAA2yG,cAAA3uE,KAEA0f,aAEAA,UAAA5uB,UAAA,EACA4uB,UAAAiN,oBAAA,IAMAjnD,MAAAgpG,eAAApyG,UAAAgzG,8BAAA,SAAAtvE,MAEA,GAAA0f,WAAA1jD,KAAA2yG,cAAA3uE,KAEA0f,aAEAA,UAAA5uB,UAAA,GACA4uB,UAAAiN,oBAAA,IAMAjnD,MAAAgpG,eAAApyG,UAAAizG,gBAAA,SAAAvvE,KAAAytB,KAEA,GAAA/N,WAAA1jD,KAAA2yG,cAAA3uE,KAEA0f,aAEAA,UAAA+N,QACA/N,UAAA4M,UAAA5M,UAAAj7B,IAAAi7B,UAAAl7B,OAAAk7B,UAAA+N,MAMA/nD,MAAAgpG,eAAApyG,UAAAkzG,qBAAA,SAAAxvE,KAAAssB,UAEA,GAAA5M,WAAA1jD,KAAA2yG,cAAA3uE,KAEA0f,aAEAA,UAAA4M,kBACA5M,UAAA+N,KAAA/N,UAAAj7B,IAAAi7B,UAAAl7B,OAAAk7B,UAAA4M,WAMA5mD,MAAAgpG,eAAApyG,UAAA2yG,mBAAA,SAAAjvE,KAAAlG,QAEA,GAAA4lB,WAAA1jD,KAAA2yG,cAAA3uE,KAEA0f,aAEAA,UAAA5lB,gBAMAp0B,MAAAgpG,eAAApyG,UAAAmzG,iBAAA,SAAAzvE,KAAAwsB,MAEA,GAAA9M,WAAA1jD,KAAA2yG,cAAA3uE,KAEA0f,aAEAA,UAAA8M,YAMA9mD,MAAAgpG,eAAApyG,UAAAozG,iBAAA,SAAA1vE,MAEA,GAAAwsB,MAAA,EAEA9M,UAAA1jD,KAAA2yG,cAAA3uE,KAQA,OANA0f,aAEA8M,KAAA9M,UAAA8M,MAIAA,MAIA9mD,MAAAgpG,eAAApyG,UAAAqzG,qBAAA,SAAA3vE,MAEA,GAAAssB,UAAA,GAEA5M,UAAA1jD,KAAA2yG,cAAA3uE,KAQA,OANA0f,aAEA4M,SAAA5M,UAAA4M,UAIAA,UAIA5mD,MAAAgpG,eAAApyG,UAAAkxD,cAAA,SAAAxtB,MAEA,GAAA0f,WAAA1jD,KAAA2yG,cAAA3uE,KAEA0f,YAEAA,UAAA8M,KAAA,EACA9M,UAAAwvD,QAAA,GAIAxpG,MAAAK,KAAA,mCAAAi6B,KAAA,oCAMAt6B,MAAAgpG,eAAApyG,UAAAszG,cAAA,SAAA5vE,MAEA,GAAA0f,WAAA1jD,KAAA2yG,cAAA3uE,KAEA0f,aAEAA,UAAAwvD,QAAA,IAMAxpG,MAAAgpG,eAAApyG,UAAAkG,OAAA,SAAAmM,OAEA,OAAAjO,GAAA,EAAAklB,GAAA5pB,KAAA4yG,eAAAjuG,OAAkDilB,GAAAllB,EAAQA,IAAA,CAE1D,GAAAg/C,WAAA1jD,KAAA4yG,eAAAluG,EAEA,IAAAg/C,UAAAwvD,OAAA,CAEA,GAAAvhD,WAAAjO,UAAA4M,SAAA5M,UAAA/+C,MAEA++C,WAAA8M,MAAA9M,UAAA5uB,UAAAniB,MAEA+wC,UAAA6M,cAEA7M,UAAA8M,KAAA9M,UAAA4M,UAAA5M,UAAA8M,KAAA,KAEA9M,UAAA5uB,WAAA,GAEA4uB,UAAA8M,KAAA9M,UAAA4M,WAEA5M,UAAA8M,KAAA9M,UAAA4M,SACA5M,UAAAiN,oBAAA,GAIAjN,UAAA8M,KAAA,IAEA9M,UAAA8M,KAAA,EACA9M,UAAAiN,oBAAA,KAQAjN,UAAA8M,KAAA9M,UAAA8M,KAAA9M,UAAA4M,SAEA5M,UAAA8M,KAAA,IAAA9M,UAAA8M,MAAA9M,UAAA4M,UAIA,IAAAsB,UAAAlO,UAAAovD,WAAAppG,MAAAG,KAAA0Y,MAAA1Y,KAAA+G,MAAA8yC,UAAA8M,KAAAmB,WAAA,EAAAjO,UAAA/+C,OAAA,GACAm5B,OAAA4lB,UAAA5lB,MAEA8zB,YAAAlO,UAAA0gD,eAEApkG,KAAAguD,sBAAAtK,UAAAygD,WAAA,EACAnkG,KAAAguD,sBAAAtK,UAAA0gD,cAAA,EAAAtmE,OAEA99B,KAAAguD,sBAAA4D,UAAA,EAEAlO,UAAAygD,UAAAzgD,UAAA0gD,aACA1gD,UAAA0gD,aAAAxyC,SAIA,IAAAC,KAAAnO,UAAA8M,KAAAmB,mBAEAjO,WAAAiN,qBAAAkB,IAAA,EAAAA,KAEA7xD,KAAAguD,sBAAAtK,UAAA0gD,cAAAvyC,IAAA/zB,OACA99B,KAAAguD,sBAAAtK,UAAAygD,YAAA,EAAAtyC,KAAA/zB,UAYA,mBAAA3+B,gBAAAD,UACAA,QAAAC,OAAAD,QAAAwK,OAEAxK,QAAAwK,aZkiBM,SAASvK,OAAQD,QAASH,qBA6B/B,QAASwB,SAAQC,IAAKC,KACpB,QAASC,QAGT,MAHiBA,KAAIJ,WAAaE,IAAIG,WAAaF,KAAKH,WACvDE,IAAIF,UAAY,GAAII,MAAKE,YAAcJ,IACb,kBAAhBC,KAAII,UAAwBJ,IAAII,SAASL,KAC7CA,IAET,QAASM,SAAQC,IAAKC,KACpB,GAAIC,QAASC,cACb,KAAK,GAAIC,OAAOH,KAASC,IAAI3B,KAAK0B,IAAKG,OAAMJ,IAAII,KAAOH,IAAIG,KAC5D,OAAOJ,KApCT,GAAI8yG,cAAczyG,OAAQrB,KAAyB,mBAAXb,UAA0BA,SAAWc,Ia12lCzD6zG,cAAV90G,oBAAA,IAAU80G,ab42lCpB9zG,KAAKqB,Oa12lCOA,OAAN,SAAAT,YACL,QAAAS,QAAA6iC,QAACjkC,KAACikC,cACAjkC,KAACojC,Yby2lCF,GAAI9iC,WAAYC,SAASO,QAAQM,OAAQT,YAAYN,YAAc,SAAUe,QAAST,YAAYL,SAsBlG,OAjBAA,Wa52lCDe,SAAW,SAAAC,Ib+2lCR,Ma92lCDtB,MAACojC,SAAS9+B,KAAKhD,IACftB,KAACyB,KAAK,aAAYH,IAClBA,Ib82lCDhB,Ua52lCDoB,YAAc,SAAAJ,Ib62lCX,GAAIwyG,IAAIC,KAAMC,KAAMtsG,MAAOw+B,Ka52lC5B,KAAA4tE,GAAA,EAAAE,MAAAD,KAAA/zG,KAAAojC,UAAAz+B,OAAAqvG,KAAAF,QACE,Gb62lCCpsG,MAAQosG,Ga92lCP5tE,MAAA6tE,KAAAD,IACC5tE,QAAS5kC,GAGV,MAFAtB,MAACojC,SAASf,OAAO36B,MAAO,GACxB1H,KAACyB,KAAK,eAAcH,IACbA,Ibm3lCLF,Qaj4lCUyyG,ebm5lCd,SAAS10G,OAAQD,Sch4lCvB,QAAA20G,gBACA7zG,KAAAi0G,QAAAj0G,KAAAi0G,YACAj0G,KAAAk0G,cAAAl0G,KAAAk0G,eAAAtqG,OAuQA,QAAAuqG,YAAAC,KACA,wBAAAA,KAGA,QAAAC,UAAAD,KACA,sBAAAA,KAGA,QAAAE,UAAAF,KACA,sBAAAA,MAAA,OAAAA,IAGA,QAAAG,aAAAH,KACA,gBAAAA,IAlRAj1G,OAAAD,QAAA20G,aAGAA,uCAEAA,aAAAvzG,UAAA2zG,QAAArqG,OACAiqG,aAAAvzG,UAAA4zG,cAAAtqG,OAIAiqG,aAAAW,oBAAA,GAIAX,aAAAvzG,UAAAm0G,gBAAA,SAAAzkF,GACA,IAAAqkF,SAAArkF,IAAA,EAAAA,GAAA+b,MAAA/b,GACA,KAAA0kF,WAAA,8BAEA,OADA10G,MAAAk0G,cAAAlkF,EACAhwB,MAGA6zG,aAAAvzG,UAAAmB,KAAA,SAAA2E,MACA,GAAAuuG,IAAAC,QAAAC,IAAAjf,KAAAlxF,EAAAw9B,SAMA,IAJAliC,KAAAi0G,UACAj0G,KAAAi0G,YAGA,UAAA7tG,QACApG,KAAAi0G,QAAAjqG,OACAsqG,SAAAt0G,KAAAi0G,QAAAjqG,SAAAhK,KAAAi0G,QAAAjqG,MAAArF,QAAA,CAEA,GADAgwG,GAAAnzG,UAAA,GACAmzG,aAAAxrG,OACA,KAAAwrG,GAEA,MAAAD,WAAA,wCAMA,GAFAE,QAAA50G,KAAAi0G,QAAA7tG,MAEAmuG,YAAAK,SACA,QAEA,IAAAT,WAAAS,SACA,OAAApzG,UAAAmD,QAEA,OACAiwG,QAAAt1G,KAAAU,KACA,MACA,QACA40G,QAAAt1G,KAAAU,KAAAwB,UAAA,GACA,MACA,QACAozG,QAAAt1G,KAAAU,KAAAwB,UAAA,GAAAA,UAAA,GACA,MAEA,SAGA,IAFAqzG,IAAArzG,UAAAmD,OACAixF,KAAA,GAAA35D,OAAA44E,IAAA,GACAnwG,EAAA,EAAmBmwG,IAAAnwG,EAASA,IAC5BkxF,KAAAlxF,EAAA,GAAAlD,UAAAkD,EACAkwG,SAAArzG,MAAAvB,KAAA41F,UAEG,IAAA0e,SAAAM,SAAA,CAGH,IAFAC,IAAArzG,UAAAmD,OACAixF,KAAA,GAAA35D,OAAA44E,IAAA,GACAnwG,EAAA,EAAemwG,IAAAnwG,EAASA,IACxBkxF,KAAAlxF,EAAA,GAAAlD,UAAAkD,EAIA,KAFAw9B,UAAA0yE,QAAAziG,QACA0iG,IAAA3yE,UAAAv9B,OACAD,EAAA,EAAemwG,IAAAnwG,EAASA,IACxBw9B,UAAAx9B,GAAAnD,MAAAvB,KAAA41F,MAGA,UAGAie,aAAAvzG,UAAAw0G,YAAA,SAAA1uG,KAAA47B,UACA,GAAAziC,EAEA,KAAA40G,WAAAnyE,UACA,KAAA0yE,WAAA,8BAuBA,IArBA10G,KAAAi0G,UACAj0G,KAAAi0G,YAIAj0G,KAAAi0G,QAAAc,aACA/0G,KAAAyB,KAAA,cAAA2E,KACA+tG,WAAAnyE,mBACAA,4BAEAhiC,KAAAi0G,QAAA7tG,MAGAkuG,SAAAt0G,KAAAi0G,QAAA7tG,OAEApG,KAAAi0G,QAAA7tG,MAAA9B,KAAA09B,UAGAhiC,KAAAi0G,QAAA7tG,OAAApG,KAAAi0G,QAAA7tG,MAAA47B,UANAhiC,KAAAi0G,QAAA7tG,MAAA47B,SASAsyE,SAAAt0G,KAAAi0G,QAAA7tG,SAAApG,KAAAi0G,QAAA7tG,MAAA4uG,OAAA,CACA,GAAAz1G,EAIAA,GAHAg1G,YAAAv0G,KAAAk0G,eAGAL,aAAAW,oBAFAx0G,KAAAk0G,cAKA30G,KAAA,GAAAS,KAAAi0G,QAAA7tG,MAAAzB,OAAApF,IACAS,KAAAi0G,QAAA7tG,MAAA4uG,QAAA,EACA70G,QAAA6J,MAAA,mIAGAhK,KAAAi0G,QAAA7tG,MAAAzB,QACA,kBAAAxE,SAAAif,OAEAjf,QAAAif,SAKA,MAAApf,OAGA6zG,aAAAvzG,UAAA20G,GAAApB,aAAAvzG,UAAAw0G,YAEAjB,aAAAvzG,UAAA40G,KAAA,SAAA9uG,KAAA47B,UAMA,QAAA3xB,KACArQ,KAAAm1G,eAAA/uG,KAAAiK,GAEA+kG,QACAA,OAAA,EACApzE,SAAAzgC,MAAAvB,KAAAwB,YAVA,IAAA2yG,WAAAnyE,UACA,KAAA0yE,WAAA,8BAEA,IAAAU,QAAA,CAcA,OAHA/kG,GAAA2xB,kBACAhiC,KAAAi1G,GAAA7uG,KAAAiK,GAEArQ,MAIA6zG,aAAAvzG,UAAA60G,eAAA,SAAA/uG,KAAA47B,UACA,GAAAz9B,MAAAtB,SAAA0B,OAAAD,CAEA,KAAAyvG,WAAAnyE,UACA,KAAA0yE,WAAA,8BAEA,KAAA10G,KAAAi0G,UAAAj0G,KAAAi0G,QAAA7tG,MACA,MAAApG,KAMA,IAJAuE,KAAAvE,KAAAi0G,QAAA7tG,MACAzB,OAAAJ,KAAAI,OACA1B,SAAA,GAEAsB,OAAAy9B,UACAmyE,WAAA5vG,KAAAy9B,WAAAz9B,KAAAy9B,0BACAhiC,MAAAi0G,QAAA7tG,MACApG,KAAAi0G,QAAAkB,gBACAn1G,KAAAyB,KAAA,iBAAA2E,KAAA47B,cAEG,IAAAsyE,SAAA/vG,MAAA,CACH,IAAAG,EAAAC,OAAoBD,IAAA,GACpB,GAAAH,KAAAG,KAAAs9B,UACAz9B,KAAAG,GAAAs9B,UAAAz9B,KAAAG,GAAAs9B,oBAAA,CACA/+B,SAAAyB,CACA,OAIA,KAAAzB,SACA,MAAAjD,KAEA,KAAAuE,KAAAI,QACAJ,KAAAI,OAAA,QACA3E,MAAAi0G,QAAA7tG,OAEA7B,KAAA89B,OAAAp/B,SAAA,GAGAjD,KAAAi0G,QAAAkB,gBACAn1G,KAAAyB,KAAA,iBAAA2E,KAAA47B,UAGA,MAAAhiC,OAGA6zG,aAAAvzG,UAAA+0G,mBAAA,SAAAjvG,MACA,GAAAjF,KAAA+gC,SAEA,KAAAliC,KAAAi0G,QACA,MAAAj0G,KAGA,KAAAA,KAAAi0G,QAAAkB,eAKA,MAJA,KAAA3zG,UAAAmD,OACA3E,KAAAi0G,WACAj0G,KAAAi0G,QAAA7tG,aACApG,MAAAi0G,QAAA7tG,MACApG,IAIA,QAAAwB,UAAAmD,OAAA,CACA,IAAAxD,MAAAnB,MAAAi0G,QACA,mBAAA9yG,KACAnB,KAAAq1G,mBAAAl0G,IAIA,OAFAnB,MAAAq1G,mBAAA,kBACAr1G,KAAAi0G,WACAj0G,KAKA,GAFAkiC,UAAAliC,KAAAi0G,QAAA7tG,MAEA+tG,WAAAjyE,WACAliC,KAAAm1G,eAAA/uG,KAAA87B,eAGA,MAAAA,UAAAv9B,QACA3E,KAAAm1G,eAAA/uG,KAAA87B,oBAAAv9B,OAAA,GAIA,cAFA3E,MAAAi0G,QAAA7tG,MAEApG,MAGA6zG,aAAAvzG,UAAA4hC,UAAA,SAAA97B,MACA,GAAAskF,IAOA,OAHAA,KAHA1qF,KAAAi0G,SAAAj0G,KAAAi0G,QAAA7tG,MAEA+tG,WAAAn0G,KAAAi0G,QAAA7tG,QACApG,KAAAi0G,QAAA7tG,OAEApG,KAAAi0G,QAAA7tG,MAAA+L,YAIA0hG,aAAAyB,cAAA,SAAAC,QAAAnvG,MACA,GAAAskF,IAOA,OAHAA,KAHA6qB,QAAAtB,SAAAsB,QAAAtB,QAAA7tG,MAEA+tG,WAAAoB,QAAAtB,QAAA7tG,OACA,EAEAmvG,QAAAtB,QAAA7tG,MAAAzB,OAJA","file":"proto.min.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar Game, Renderer, game, renderer;\n\tGame = __webpack_require__(1).Game;\n\tRenderer = __webpack_require__(3).Renderer;\n\tgame = new Game();\n\trenderer = new Renderer(game);\n\t//# sourceMappingURL=/home/amar/misc/Dropbox/projects/home/proto/node_modules/livescript-loader/index.js!/home/amar/misc/Dropbox/projects/home/proto/servers/web/proto.ls.map\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar Scene, Game, out$ = typeof exports != 'undefined' && exports || this;\n\tScene = __webpack_require__(2).Scene;\n\tout$.Game = Game = (function(){\n\t  Game.displayName = 'Game';\n\t  var prototype = Game.prototype, constructor = Game;\n\t  function Game(config){\n\t    var scene;\n\t    config == null && (config = {});\n\t    scene = new Scene();\n\t    console.log('game');\n\t  }\n\t  return Game;\n\t}());\n\t//# sourceMappingURL=/home/amar/misc/Dropbox/projects/home/proto/node_modules/livescript-loader/index.js!/home/amar/misc/Dropbox/projects/home/proto/src/core/game.ls.map\n\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar Entity, Scene, out$ = typeof exports != 'undefined' && exports || this;\n\tEntity = __webpack_require__(11).Entity;\n\tout$.Scene = Scene = (function(superclass){\n\t  var prototype = extend$((import$(Scene, superclass).displayName = 'Scene', Scene), superclass).prototype, constructor = Scene;\n\t  function Scene(){\n\t    Scene.superclass.call(this, null);\n\t  }\n\t  prototype.addChild = function(it){\n\t    it = superclass.prototype.addChild.apply(this, arguments);\n\t    if (it != null) {\n\t      this.emit('entityspawned', it);\n\t    }\n\t    return it;\n\t  };\n\t  prototype.removeChild = function(it){\n\t    it = superclass.prototype.removeChild.apply(this, arguments);\n\t    if (it != null) {\n\t      this.emit('entitydespawned', it);\n\t    }\n\t    return it;\n\t  };\n\t  return Scene;\n\t}(Entity));\n\tfunction extend$(sub, sup){\n\t  function fun(){} fun.prototype = (sub.superclass = sup).prototype;\n\t  (sub.prototype = new fun).constructor = sub;\n\t  if (typeof sup.extended == 'function') sup.extended(sub);\n\t  return sub;\n\t}\n\tfunction import$(obj, src){\n\t  var own = {}.hasOwnProperty;\n\t  for (var key in src) if (own.call(src, key)) obj[key] = src[key];\n\t  return obj;\n\t}\n\t//# sourceMappingURL=/home/amar/misc/Dropbox/projects/home/proto/node_modules/livescript-loader/index.js!/home/amar/misc/Dropbox/projects/home/proto/src/core/scene.ls.map\n\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar clear, standard, three, Renderer, out$ = typeof exports != 'undefined' && exports || this;\n\tclear = __webpack_require__(4);\n\tstandard = __webpack_require__(8);\n\tthree = __webpack_require__(10);\n\tout$.Renderer = Renderer = (function(){\n\t  Renderer.displayName = 'Renderer';\n\t  var prototype = Renderer.prototype, constructor = Renderer;\n\t  function Renderer(config){\n\t    var x$, self, y$, render;\n\t    config == null && (config = {});\n\t    x$ = this.threeRenderer = new three.WebGLRenderer({\n\t      antialias: true\n\t    });\n\t    x$.setSize(window.innerWidth, window.innerHeight);\n\t    x$.shadowMapEnabled = true;\n\t    x$.shadowMapSoft = true;\n\t    x$.sortObjects = false;\n\t    self = this;\n\t    window.addEventListener('resize', function(){\n\t      if (self.camera) {\n\t        self.camera.aspect = window.innerWidth / window.innerHeight;\n\t        self.camera.updateProjectionMatrix();\n\t      }\n\t      self.threeRenderer.setSize(window.innerWidth, window.innerHeight);\n\t    });\n\t    this.scene = new three.Scene();\n\t    this.camera = new three.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 10000);\n\t    this.camera.position.z = 1000;\n\t    this.geometry = new three.BoxGeometry(200, 200, 200);\n\t    this.material = new three.MeshBasicMaterial({\n\t      color: 0xff0000,\n\t      wireframe: true\n\t    });\n\t    this.mesh = new three.Mesh(this.geometry, this.material);\n\t    this.scene.add(this.mesh);\n\t    y$ = this.threeRenderer.domElement;\n\t    y$.id = 'wgl-canvas';\n\t    document.body.appendChild(\n\t    y$);\n\t    window.requestAnimationFrame(render = function(){\n\t      window.requestAnimationFrame(render);\n\t      self.render();\n\t    });\n\t  }\n\t  prototype.render = function(){\n\t    this.mesh.rotation.x += 0.01;\n\t    this.mesh.rotation.y += 0.02;\n\t    this.threeRenderer.render(this.scene, this.camera);\n\t  };\n\t  return Renderer;\n\t}());\n\t//# sourceMappingURL=/home/amar/misc/Dropbox/projects/home/proto/node_modules/livescript-loader/index.js!/home/amar/misc/Dropbox/projects/home/proto/src/gfx/renderer.ls.map\n\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// style-loader: Adds some css to the DOM by adding a <style> tag\n\t\n\t// load the styles\n\tvar content = __webpack_require__(5);\n\tif(typeof content === 'string') content = [[module.id, content, '']];\n\t// add the styles to the DOM\n\tvar update = __webpack_require__(7)(content, {});\n\tif(content.locals) module.exports = content.locals;\n\t// Hot Module Replacement\n\tif(false) {\n\t\t// When the styles change, update the <style> tags\n\t\tif(!content.locals) {\n\t\t\tmodule.hot.accept(\"!!./../../../node_modules/css-loader/index.js!./../../../node_modules/stylus-loader/index.js!./clear.styl\", function() {\n\t\t\t\tvar newContent = require(\"!!./../../../node_modules/css-loader/index.js!./../../../node_modules/stylus-loader/index.js!./clear.styl\");\n\t\t\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\t\t\t\tupdate(newContent);\n\t\t\t});\n\t\t}\n\t\t// When the module is disposed, remove the <style> tags\n\t\tmodule.hot.dispose(function() { update(); });\n\t}\n\n/***/ },\n/* 5 */\n/***/ function(module, exports, __webpack_require__) {\n\n\texports = module.exports = __webpack_require__(6)();\n\t// imports\n\t\n\t\n\t// module\n\texports.push([module.id, \"*{margin:0;padding:0;height:100%}\", \"\"]);\n\t\n\t// exports\n\n\n/***/ },\n/* 6 */\n/***/ function(module, exports) {\n\n\t/*\r\n\t\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\t\tAuthor Tobias Koppers @sokra\r\n\t*/\r\n\t// css base code, injected by the css-loader\r\n\tmodule.exports = function() {\r\n\t\tvar list = [];\r\n\t\r\n\t\t// return the list of modules as css string\r\n\t\tlist.toString = function toString() {\r\n\t\t\tvar result = [];\r\n\t\t\tfor(var i = 0; i < this.length; i++) {\r\n\t\t\t\tvar item = this[i];\r\n\t\t\t\tif(item[2]) {\r\n\t\t\t\t\tresult.push(\"@media \" + item[2] + \"{\" + item[1] + \"}\");\r\n\t\t\t\t} else {\r\n\t\t\t\t\tresult.push(item[1]);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn result.join(\"\");\r\n\t\t};\r\n\t\r\n\t\t// import a list of modules into the list\r\n\t\tlist.i = function(modules, mediaQuery) {\r\n\t\t\tif(typeof modules === \"string\")\r\n\t\t\t\tmodules = [[null, modules, \"\"]];\r\n\t\t\tvar alreadyImportedModules = {};\r\n\t\t\tfor(var i = 0; i < this.length; i++) {\r\n\t\t\t\tvar id = this[i][0];\r\n\t\t\t\tif(typeof id === \"number\")\r\n\t\t\t\t\talreadyImportedModules[id] = true;\r\n\t\t\t}\r\n\t\t\tfor(i = 0; i < modules.length; i++) {\r\n\t\t\t\tvar item = modules[i];\r\n\t\t\t\t// skip already imported module\r\n\t\t\t\t// this implementation is not 100% perfect for weird media query combinations\r\n\t\t\t\t//  when a module is imported multiple times with different media queries.\r\n\t\t\t\t//  I hope this will never occur (Hey this way we have smaller bundles)\r\n\t\t\t\tif(typeof item[0] !== \"number\" || !alreadyImportedModules[item[0]]) {\r\n\t\t\t\t\tif(mediaQuery && !item[2]) {\r\n\t\t\t\t\t\titem[2] = mediaQuery;\r\n\t\t\t\t\t} else if(mediaQuery) {\r\n\t\t\t\t\t\titem[2] = \"(\" + item[2] + \") and (\" + mediaQuery + \")\";\r\n\t\t\t\t\t}\r\n\t\t\t\t\tlist.push(item);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t};\r\n\t\treturn list;\r\n\t};\r\n\n\n/***/ },\n/* 7 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/*\r\n\t\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\t\tAuthor Tobias Koppers @sokra\r\n\t*/\r\n\tvar stylesInDom = {},\r\n\t\tmemoize = function(fn) {\r\n\t\t\tvar memo;\r\n\t\t\treturn function () {\r\n\t\t\t\tif (typeof memo === \"undefined\") memo = fn.apply(this, arguments);\r\n\t\t\t\treturn memo;\r\n\t\t\t};\r\n\t\t},\r\n\t\tisOldIE = memoize(function() {\r\n\t\t\treturn /msie [6-9]\\b/.test(window.navigator.userAgent.toLowerCase());\r\n\t\t}),\r\n\t\tgetHeadElement = memoize(function () {\r\n\t\t\treturn document.head || document.getElementsByTagName(\"head\")[0];\r\n\t\t}),\r\n\t\tsingletonElement = null,\r\n\t\tsingletonCounter = 0;\r\n\t\r\n\tmodule.exports = function(list, options) {\r\n\t\tif(true) {\r\n\t\t\tif(typeof document !== \"object\") throw new Error(\"The style-loader cannot be used in a non-browser environment\");\r\n\t\t}\r\n\t\r\n\t\toptions = options || {};\r\n\t\t// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\r\n\t\t// tags it will allow on a page\r\n\t\tif (typeof options.singleton === \"undefined\") options.singleton = isOldIE();\r\n\t\r\n\t\tvar styles = listToStyles(list);\r\n\t\taddStylesToDom(styles, options);\r\n\t\r\n\t\treturn function update(newList) {\r\n\t\t\tvar mayRemove = [];\r\n\t\t\tfor(var i = 0; i < styles.length; i++) {\r\n\t\t\t\tvar item = styles[i];\r\n\t\t\t\tvar domStyle = stylesInDom[item.id];\r\n\t\t\t\tdomStyle.refs--;\r\n\t\t\t\tmayRemove.push(domStyle);\r\n\t\t\t}\r\n\t\t\tif(newList) {\r\n\t\t\t\tvar newStyles = listToStyles(newList);\r\n\t\t\t\taddStylesToDom(newStyles, options);\r\n\t\t\t}\r\n\t\t\tfor(var i = 0; i < mayRemove.length; i++) {\r\n\t\t\t\tvar domStyle = mayRemove[i];\r\n\t\t\t\tif(domStyle.refs === 0) {\r\n\t\t\t\t\tfor(var j = 0; j < domStyle.parts.length; j++)\r\n\t\t\t\t\t\tdomStyle.parts[j]();\r\n\t\t\t\t\tdelete stylesInDom[domStyle.id];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t};\r\n\t}\r\n\t\r\n\tfunction addStylesToDom(styles, options) {\r\n\t\tfor(var i = 0; i < styles.length; i++) {\r\n\t\t\tvar item = styles[i];\r\n\t\t\tvar domStyle = stylesInDom[item.id];\r\n\t\t\tif(domStyle) {\r\n\t\t\t\tdomStyle.refs++;\r\n\t\t\t\tfor(var j = 0; j < domStyle.parts.length; j++) {\r\n\t\t\t\t\tdomStyle.parts[j](item.parts[j]);\r\n\t\t\t\t}\r\n\t\t\t\tfor(; j < item.parts.length; j++) {\r\n\t\t\t\t\tdomStyle.parts.push(addStyle(item.parts[j], options));\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tvar parts = [];\r\n\t\t\t\tfor(var j = 0; j < item.parts.length; j++) {\r\n\t\t\t\t\tparts.push(addStyle(item.parts[j], options));\r\n\t\t\t\t}\r\n\t\t\t\tstylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t\r\n\tfunction listToStyles(list) {\r\n\t\tvar styles = [];\r\n\t\tvar newStyles = {};\r\n\t\tfor(var i = 0; i < list.length; i++) {\r\n\t\t\tvar item = list[i];\r\n\t\t\tvar id = item[0];\r\n\t\t\tvar css = item[1];\r\n\t\t\tvar media = item[2];\r\n\t\t\tvar sourceMap = item[3];\r\n\t\t\tvar part = {css: css, media: media, sourceMap: sourceMap};\r\n\t\t\tif(!newStyles[id])\r\n\t\t\t\tstyles.push(newStyles[id] = {id: id, parts: [part]});\r\n\t\t\telse\r\n\t\t\t\tnewStyles[id].parts.push(part);\r\n\t\t}\r\n\t\treturn styles;\r\n\t}\r\n\t\r\n\tfunction createStyleElement() {\r\n\t\tvar styleElement = document.createElement(\"style\");\r\n\t\tvar head = getHeadElement();\r\n\t\tstyleElement.type = \"text/css\";\r\n\t\thead.appendChild(styleElement);\r\n\t\treturn styleElement;\r\n\t}\r\n\t\r\n\tfunction createLinkElement() {\r\n\t\tvar linkElement = document.createElement(\"link\");\r\n\t\tvar head = getHeadElement();\r\n\t\tlinkElement.rel = \"stylesheet\";\r\n\t\thead.appendChild(linkElement);\r\n\t\treturn linkElement;\r\n\t}\r\n\t\r\n\tfunction addStyle(obj, options) {\r\n\t\tvar styleElement, update, remove;\r\n\t\r\n\t\tif (options.singleton) {\r\n\t\t\tvar styleIndex = singletonCounter++;\r\n\t\t\tstyleElement = singletonElement || (singletonElement = createStyleElement());\r\n\t\t\tupdate = applyToSingletonTag.bind(null, styleElement, styleIndex, false);\r\n\t\t\tremove = applyToSingletonTag.bind(null, styleElement, styleIndex, true);\r\n\t\t} else if(obj.sourceMap &&\r\n\t\t\ttypeof URL === \"function\" &&\r\n\t\t\ttypeof URL.createObjectURL === \"function\" &&\r\n\t\t\ttypeof URL.revokeObjectURL === \"function\" &&\r\n\t\t\ttypeof Blob === \"function\" &&\r\n\t\t\ttypeof btoa === \"function\") {\r\n\t\t\tstyleElement = createLinkElement();\r\n\t\t\tupdate = updateLink.bind(null, styleElement);\r\n\t\t\tremove = function() {\r\n\t\t\t\tstyleElement.parentNode.removeChild(styleElement);\r\n\t\t\t\tif(styleElement.href)\r\n\t\t\t\t\tURL.revokeObjectURL(styleElement.href);\r\n\t\t\t};\r\n\t\t} else {\r\n\t\t\tstyleElement = createStyleElement();\r\n\t\t\tupdate = applyToTag.bind(null, styleElement);\r\n\t\t\tremove = function() {\r\n\t\t\t\tstyleElement.parentNode.removeChild(styleElement);\r\n\t\t\t};\r\n\t\t}\r\n\t\r\n\t\tupdate(obj);\r\n\t\r\n\t\treturn function updateStyle(newObj) {\r\n\t\t\tif(newObj) {\r\n\t\t\t\tif(newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap)\r\n\t\t\t\t\treturn;\r\n\t\t\t\tupdate(obj = newObj);\r\n\t\t\t} else {\r\n\t\t\t\tremove();\r\n\t\t\t}\r\n\t\t};\r\n\t}\r\n\t\r\n\tvar replaceText = (function () {\r\n\t\tvar textStore = [];\r\n\t\r\n\t\treturn function (index, replacement) {\r\n\t\t\ttextStore[index] = replacement;\r\n\t\t\treturn textStore.filter(Boolean).join('\\n');\r\n\t\t};\r\n\t})();\r\n\t\r\n\tfunction applyToSingletonTag(styleElement, index, remove, obj) {\r\n\t\tvar css = remove ? \"\" : obj.css;\r\n\t\r\n\t\tif (styleElement.styleSheet) {\r\n\t\t\tstyleElement.styleSheet.cssText = replaceText(index, css);\r\n\t\t} else {\r\n\t\t\tvar cssNode = document.createTextNode(css);\r\n\t\t\tvar childNodes = styleElement.childNodes;\r\n\t\t\tif (childNodes[index]) styleElement.removeChild(childNodes[index]);\r\n\t\t\tif (childNodes.length) {\r\n\t\t\t\tstyleElement.insertBefore(cssNode, childNodes[index]);\r\n\t\t\t} else {\r\n\t\t\t\tstyleElement.appendChild(cssNode);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t\r\n\tfunction applyToTag(styleElement, obj) {\r\n\t\tvar css = obj.css;\r\n\t\tvar media = obj.media;\r\n\t\tvar sourceMap = obj.sourceMap;\r\n\t\r\n\t\tif(media) {\r\n\t\t\tstyleElement.setAttribute(\"media\", media)\r\n\t\t}\r\n\t\r\n\t\tif(styleElement.styleSheet) {\r\n\t\t\tstyleElement.styleSheet.cssText = css;\r\n\t\t} else {\r\n\t\t\twhile(styleElement.firstChild) {\r\n\t\t\t\tstyleElement.removeChild(styleElement.firstChild);\r\n\t\t\t}\r\n\t\t\tstyleElement.appendChild(document.createTextNode(css));\r\n\t\t}\r\n\t}\r\n\t\r\n\tfunction updateLink(linkElement, obj) {\r\n\t\tvar css = obj.css;\r\n\t\tvar media = obj.media;\r\n\t\tvar sourceMap = obj.sourceMap;\r\n\t\r\n\t\tif(sourceMap) {\r\n\t\t\t// http://stackoverflow.com/a/26603875\r\n\t\t\tcss += \"\\n/*# sourceMappingURL=data:application/json;base64,\" + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + \" */\";\r\n\t\t}\r\n\t\r\n\t\tvar blob = new Blob([css], { type: \"text/css\" });\r\n\t\r\n\t\tvar oldSrc = linkElement.href;\r\n\t\r\n\t\tlinkElement.href = URL.createObjectURL(blob);\r\n\t\r\n\t\tif(oldSrc)\r\n\t\t\tURL.revokeObjectURL(oldSrc);\r\n\t}\r\n\n\n/***/ },\n/* 8 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// style-loader: Adds some css to the DOM by adding a <style> tag\n\t\n\t// load the styles\n\tvar content = __webpack_require__(9);\n\tif(typeof content === 'string') content = [[module.id, content, '']];\n\t// add the styles to the DOM\n\tvar update = __webpack_require__(7)(content, {});\n\tif(content.locals) module.exports = content.locals;\n\t// Hot Module Replacement\n\tif(false) {\n\t\t// When the styles change, update the <style> tags\n\t\tif(!content.locals) {\n\t\t\tmodule.hot.accept(\"!!./../../../node_modules/css-loader/index.js!./../../../node_modules/stylus-loader/index.js!./standard.styl\", function() {\n\t\t\t\tvar newContent = require(\"!!./../../../node_modules/css-loader/index.js!./../../../node_modules/stylus-loader/index.js!./standard.styl\");\n\t\t\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\t\t\t\tupdate(newContent);\n\t\t\t});\n\t\t}\n\t\t// When the module is disposed, remove the <style> tags\n\t\tmodule.hot.dispose(function() { update(); });\n\t}\n\n/***/ },\n/* 9 */\n/***/ function(module, exports, __webpack_require__) {\n\n\texports = module.exports = __webpack_require__(6)();\n\t// imports\n\t\n\t\n\t// module\n\texports.push([module.id, \"\", \"\"]);\n\t\n\t// exports\n\n\n/***/ },\n/* 10 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar self = self || {};// File:src/Three.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tvar THREE = { REVISION: '71' };\r\n\t\r\n\t// browserify support\r\n\t\r\n\tif ( true ) {\r\n\t\r\n\t\tmodule.exports = THREE;\r\n\t\r\n\t}\r\n\t\r\n\t// polyfills\r\n\t\r\n\tif ( Math.sign === undefined ) {\r\n\t\r\n\t\t// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/sign\r\n\t\r\n\t\tMath.sign = function ( x ) {\r\n\t\r\n\t\t\treturn ( x < 0 ) ? - 1 : ( x > 0 ) ? 1 : +x;\r\n\t\r\n\t\t};\r\n\t\r\n\t}\r\n\t\r\n\t\r\n\t// set the default log handlers\r\n\tTHREE.log = function() { console.log.apply( console, arguments ); }\r\n\tTHREE.warn = function() { console.warn.apply( console, arguments ); }\r\n\tTHREE.error = function() { console.error.apply( console, arguments ); }\r\n\t\r\n\t\r\n\t// https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent.button\r\n\t\r\n\tTHREE.MOUSE = { LEFT: 0, MIDDLE: 1, RIGHT: 2 };\r\n\t\r\n\t// GL STATE CONSTANTS\r\n\t\r\n\tTHREE.CullFaceNone = 0;\r\n\tTHREE.CullFaceBack = 1;\r\n\tTHREE.CullFaceFront = 2;\r\n\tTHREE.CullFaceFrontBack = 3;\r\n\t\r\n\tTHREE.FrontFaceDirectionCW = 0;\r\n\tTHREE.FrontFaceDirectionCCW = 1;\r\n\t\r\n\t// SHADOWING TYPES\r\n\t\r\n\tTHREE.BasicShadowMap = 0;\r\n\tTHREE.PCFShadowMap = 1;\r\n\tTHREE.PCFSoftShadowMap = 2;\r\n\t\r\n\t// MATERIAL CONSTANTS\r\n\t\r\n\t// side\r\n\t\r\n\tTHREE.FrontSide = 0;\r\n\tTHREE.BackSide = 1;\r\n\tTHREE.DoubleSide = 2;\r\n\t\r\n\t// shading\r\n\t\r\n\tTHREE.NoShading = 0;\r\n\tTHREE.FlatShading = 1;\r\n\tTHREE.SmoothShading = 2;\r\n\t\r\n\t// colors\r\n\t\r\n\tTHREE.NoColors = 0;\r\n\tTHREE.FaceColors = 1;\r\n\tTHREE.VertexColors = 2;\r\n\t\r\n\t// blending modes\r\n\t\r\n\tTHREE.NoBlending = 0;\r\n\tTHREE.NormalBlending = 1;\r\n\tTHREE.AdditiveBlending = 2;\r\n\tTHREE.SubtractiveBlending = 3;\r\n\tTHREE.MultiplyBlending = 4;\r\n\tTHREE.CustomBlending = 5;\r\n\t\r\n\t// custom blending equations\r\n\t// (numbers start from 100 not to clash with other\r\n\t//  mappings to OpenGL constants defined in Texture.js)\r\n\t\r\n\tTHREE.AddEquation = 100;\r\n\tTHREE.SubtractEquation = 101;\r\n\tTHREE.ReverseSubtractEquation = 102;\r\n\tTHREE.MinEquation = 103;\r\n\tTHREE.MaxEquation = 104;\r\n\t\r\n\t// custom blending destination factors\r\n\t\r\n\tTHREE.ZeroFactor = 200;\r\n\tTHREE.OneFactor = 201;\r\n\tTHREE.SrcColorFactor = 202;\r\n\tTHREE.OneMinusSrcColorFactor = 203;\r\n\tTHREE.SrcAlphaFactor = 204;\r\n\tTHREE.OneMinusSrcAlphaFactor = 205;\r\n\tTHREE.DstAlphaFactor = 206;\r\n\tTHREE.OneMinusDstAlphaFactor = 207;\r\n\t\r\n\t// custom blending source factors\r\n\t\r\n\t//THREE.ZeroFactor = 200;\r\n\t//THREE.OneFactor = 201;\r\n\t//THREE.SrcAlphaFactor = 204;\r\n\t//THREE.OneMinusSrcAlphaFactor = 205;\r\n\t//THREE.DstAlphaFactor = 206;\r\n\t//THREE.OneMinusDstAlphaFactor = 207;\r\n\tTHREE.DstColorFactor = 208;\r\n\tTHREE.OneMinusDstColorFactor = 209;\r\n\tTHREE.SrcAlphaSaturateFactor = 210;\r\n\t\r\n\t\r\n\t// TEXTURE CONSTANTS\r\n\t\r\n\tTHREE.MultiplyOperation = 0;\r\n\tTHREE.MixOperation = 1;\r\n\tTHREE.AddOperation = 2;\r\n\t\r\n\t// Mapping modes\r\n\t\r\n\tTHREE.UVMapping = 300;\r\n\t\r\n\tTHREE.CubeReflectionMapping = 301;\r\n\tTHREE.CubeRefractionMapping = 302;\r\n\t\r\n\tTHREE.EquirectangularReflectionMapping = 303;\r\n\tTHREE.EquirectangularRefractionMapping = 304;\r\n\t\r\n\tTHREE.SphericalReflectionMapping = 305;\r\n\t\r\n\t// Wrapping modes\r\n\t\r\n\tTHREE.RepeatWrapping = 1000;\r\n\tTHREE.ClampToEdgeWrapping = 1001;\r\n\tTHREE.MirroredRepeatWrapping = 1002;\r\n\t\r\n\t// Filters\r\n\t\r\n\tTHREE.NearestFilter = 1003;\r\n\tTHREE.NearestMipMapNearestFilter = 1004;\r\n\tTHREE.NearestMipMapLinearFilter = 1005;\r\n\tTHREE.LinearFilter = 1006;\r\n\tTHREE.LinearMipMapNearestFilter = 1007;\r\n\tTHREE.LinearMipMapLinearFilter = 1008;\r\n\t\r\n\t// Data types\r\n\t\r\n\tTHREE.UnsignedByteType = 1009;\r\n\tTHREE.ByteType = 1010;\r\n\tTHREE.ShortType = 1011;\r\n\tTHREE.UnsignedShortType = 1012;\r\n\tTHREE.IntType = 1013;\r\n\tTHREE.UnsignedIntType = 1014;\r\n\tTHREE.FloatType = 1015;\r\n\tTHREE.HalfFloatType = 1025;\r\n\t\r\n\t// Pixel types\r\n\t\r\n\t//THREE.UnsignedByteType = 1009;\r\n\tTHREE.UnsignedShort4444Type = 1016;\r\n\tTHREE.UnsignedShort5551Type = 1017;\r\n\tTHREE.UnsignedShort565Type = 1018;\r\n\t\r\n\t// Pixel formats\r\n\t\r\n\tTHREE.AlphaFormat = 1019;\r\n\tTHREE.RGBFormat = 1020;\r\n\tTHREE.RGBAFormat = 1021;\r\n\tTHREE.LuminanceFormat = 1022;\r\n\tTHREE.LuminanceAlphaFormat = 1023;\r\n\t// THREE.RGBEFormat handled as THREE.RGBAFormat in shaders\r\n\tTHREE.RGBEFormat = THREE.RGBAFormat; //1024;\r\n\t\r\n\t// DDS / ST3C Compressed texture formats\r\n\t\r\n\tTHREE.RGB_S3TC_DXT1_Format = 2001;\r\n\tTHREE.RGBA_S3TC_DXT1_Format = 2002;\r\n\tTHREE.RGBA_S3TC_DXT3_Format = 2003;\r\n\tTHREE.RGBA_S3TC_DXT5_Format = 2004;\r\n\t\r\n\t\r\n\t// PVRTC compressed texture formats\r\n\t\r\n\tTHREE.RGB_PVRTC_4BPPV1_Format = 2100;\r\n\tTHREE.RGB_PVRTC_2BPPV1_Format = 2101;\r\n\tTHREE.RGBA_PVRTC_4BPPV1_Format = 2102;\r\n\tTHREE.RGBA_PVRTC_2BPPV1_Format = 2103;\r\n\t\r\n\t\r\n\t// DEPRECATED\r\n\t\r\n\tTHREE.Projector = function () {\r\n\t\r\n\t\tTHREE.error( 'THREE.Projector has been moved to /examples/js/renderers/Projector.js.' );\r\n\t\r\n\t\tthis.projectVector = function ( vector, camera ) {\r\n\t\r\n\t\t\tTHREE.warn( 'THREE.Projector: .projectVector() is now vector.project().' );\r\n\t\t\tvector.project( camera );\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.unprojectVector = function ( vector, camera ) {\r\n\t\r\n\t\t\tTHREE.warn( 'THREE.Projector: .unprojectVector() is now vector.unproject().' );\r\n\t\t\tvector.unproject( camera );\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.pickingRay = function ( vector, camera ) {\r\n\t\r\n\t\t\tTHREE.error( 'THREE.Projector: .pickingRay() is now raycaster.setFromCamera().' );\r\n\t\r\n\t\t};\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.CanvasRenderer = function () {\r\n\t\r\n\t\tTHREE.error( 'THREE.CanvasRenderer has been moved to /examples/js/renderers/CanvasRenderer.js' );\r\n\t\r\n\t\tthis.domElement = document.createElement( 'canvas' );\r\n\t\tthis.clear = function () {};\r\n\t\tthis.render = function () {};\r\n\t\tthis.setClearColor = function () {};\r\n\t\tthis.setSize = function () {};\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/math/Color.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tTHREE.Color = function ( color ) {\r\n\t\r\n\t\tif ( arguments.length === 3 ) {\r\n\t\r\n\t\t\treturn this.setRGB( arguments[ 0 ], arguments[ 1 ], arguments[ 2 ] );\r\n\t\r\n\t\t}\r\n\t\r\n\t\treturn this.set( color )\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Color.prototype = {\r\n\t\r\n\t\tconstructor: THREE.Color,\r\n\t\r\n\t\tr: 1, g: 1, b: 1,\r\n\t\r\n\t\tset: function ( value ) {\r\n\t\r\n\t\t\tif ( value instanceof THREE.Color ) {\r\n\t\r\n\t\t\t\tthis.copy( value );\r\n\t\r\n\t\t\t} else if ( typeof value === 'number' ) {\r\n\t\r\n\t\t\t\tthis.setHex( value );\r\n\t\r\n\t\t\t} else if ( typeof value === 'string' ) {\r\n\t\r\n\t\t\t\tthis.setStyle( value );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetHex: function ( hex ) {\r\n\t\r\n\t\t\thex = Math.floor( hex );\r\n\t\r\n\t\t\tthis.r = ( hex >> 16 & 255 ) / 255;\r\n\t\t\tthis.g = ( hex >> 8 & 255 ) / 255;\r\n\t\t\tthis.b = ( hex & 255 ) / 255;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetRGB: function ( r, g, b ) {\r\n\t\r\n\t\t\tthis.r = r;\r\n\t\t\tthis.g = g;\r\n\t\t\tthis.b = b;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetHSL: function ( h, s, l ) {\r\n\t\r\n\t\t\t// h,s,l ranges are in 0.0 - 1.0\r\n\t\r\n\t\t\tif ( s === 0 ) {\r\n\t\r\n\t\t\t\tthis.r = this.g = this.b = l;\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\tvar hue2rgb = function ( p, q, t ) {\r\n\t\r\n\t\t\t\t\tif ( t < 0 ) t += 1;\r\n\t\t\t\t\tif ( t > 1 ) t -= 1;\r\n\t\t\t\t\tif ( t < 1 / 6 ) return p + ( q - p ) * 6 * t;\r\n\t\t\t\t\tif ( t < 1 / 2 ) return q;\r\n\t\t\t\t\tif ( t < 2 / 3 ) return p + ( q - p ) * 6 * ( 2 / 3 - t );\r\n\t\t\t\t\treturn p;\r\n\t\r\n\t\t\t\t};\r\n\t\r\n\t\t\t\tvar p = l <= 0.5 ? l * ( 1 + s ) : l + s - ( l * s );\r\n\t\t\t\tvar q = ( 2 * l ) - p;\r\n\t\r\n\t\t\t\tthis.r = hue2rgb( q, p, h + 1 / 3 );\r\n\t\t\t\tthis.g = hue2rgb( q, p, h );\r\n\t\t\t\tthis.b = hue2rgb( q, p, h - 1 / 3 );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetStyle: function ( style ) {\r\n\t\r\n\t\t\t// rgb(255,0,0)\r\n\t\r\n\t\t\tif ( /^rgb\\((\\d+), ?(\\d+), ?(\\d+)\\)$/i.test( style ) ) {\r\n\t\r\n\t\t\t\tvar color = /^rgb\\((\\d+), ?(\\d+), ?(\\d+)\\)$/i.exec( style );\r\n\t\r\n\t\t\t\tthis.r = Math.min( 255, parseInt( color[ 1 ], 10 ) ) / 255;\r\n\t\t\t\tthis.g = Math.min( 255, parseInt( color[ 2 ], 10 ) ) / 255;\r\n\t\t\t\tthis.b = Math.min( 255, parseInt( color[ 3 ], 10 ) ) / 255;\r\n\t\r\n\t\t\t\treturn this;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// rgb(100%,0%,0%)\r\n\t\r\n\t\t\tif ( /^rgb\\((\\d+)\\%, ?(\\d+)\\%, ?(\\d+)\\%\\)$/i.test( style ) ) {\r\n\t\r\n\t\t\t\tvar color = /^rgb\\((\\d+)\\%, ?(\\d+)\\%, ?(\\d+)\\%\\)$/i.exec( style );\r\n\t\r\n\t\t\t\tthis.r = Math.min( 100, parseInt( color[ 1 ], 10 ) ) / 100;\r\n\t\t\t\tthis.g = Math.min( 100, parseInt( color[ 2 ], 10 ) ) / 100;\r\n\t\t\t\tthis.b = Math.min( 100, parseInt( color[ 3 ], 10 ) ) / 100;\r\n\t\r\n\t\t\t\treturn this;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// #ff0000\r\n\t\r\n\t\t\tif ( /^\\#([0-9a-f]{6})$/i.test( style ) ) {\r\n\t\r\n\t\t\t\tvar color = /^\\#([0-9a-f]{6})$/i.exec( style );\r\n\t\r\n\t\t\t\tthis.setHex( parseInt( color[ 1 ], 16 ) );\r\n\t\r\n\t\t\t\treturn this;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// #f00\r\n\t\r\n\t\t\tif ( /^\\#([0-9a-f])([0-9a-f])([0-9a-f])$/i.test( style ) ) {\r\n\t\r\n\t\t\t\tvar color = /^\\#([0-9a-f])([0-9a-f])([0-9a-f])$/i.exec( style );\r\n\t\r\n\t\t\t\tthis.setHex( parseInt( color[ 1 ] + color[ 1 ] + color[ 2 ] + color[ 2 ] + color[ 3 ] + color[ 3 ], 16 ) );\r\n\t\r\n\t\t\t\treturn this;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// red\r\n\t\r\n\t\t\tif ( /^(\\w+)$/i.test( style ) ) {\r\n\t\r\n\t\t\t\tthis.setHex( THREE.ColorKeywords[ style ] );\r\n\t\r\n\t\t\t\treturn this;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcopy: function ( color ) {\r\n\t\r\n\t\t\tthis.r = color.r;\r\n\t\t\tthis.g = color.g;\r\n\t\t\tthis.b = color.b;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcopyGammaToLinear: function ( color, gammaFactor ) {\r\n\t\r\n\t\t\tif ( gammaFactor === undefined ) gammaFactor = 2.0;\r\n\t\r\n\t\t\tthis.r = Math.pow( color.r, gammaFactor );\r\n\t\t\tthis.g = Math.pow( color.g, gammaFactor );\r\n\t\t\tthis.b = Math.pow( color.b, gammaFactor );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcopyLinearToGamma: function ( color, gammaFactor ) {\r\n\t\r\n\t\t\tif ( gammaFactor === undefined ) gammaFactor = 2.0;\r\n\t\r\n\t\t\tvar safeInverse = ( gammaFactor > 0 ) ? ( 1.0 / gammaFactor ) : 1.0;\r\n\t\r\n\t\t\tthis.r = Math.pow( color.r, safeInverse );\r\n\t\t\tthis.g = Math.pow( color.g, safeInverse );\r\n\t\t\tthis.b = Math.pow( color.b, safeInverse );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tconvertGammaToLinear: function () {\r\n\t\r\n\t\t\tvar r = this.r, g = this.g, b = this.b;\r\n\t\r\n\t\t\tthis.r = r * r;\r\n\t\t\tthis.g = g * g;\r\n\t\t\tthis.b = b * b;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tconvertLinearToGamma: function () {\r\n\t\r\n\t\t\tthis.r = Math.sqrt( this.r );\r\n\t\t\tthis.g = Math.sqrt( this.g );\r\n\t\t\tthis.b = Math.sqrt( this.b );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tgetHex: function () {\r\n\t\r\n\t\t\treturn ( this.r * 255 ) << 16 ^ ( this.g * 255 ) << 8 ^ ( this.b * 255 ) << 0;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tgetHexString: function () {\r\n\t\r\n\t\t\treturn ( '000000' + this.getHex().toString( 16 ) ).slice( - 6 );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tgetHSL: function ( optionalTarget ) {\r\n\t\r\n\t\t\t// h,s,l ranges are in 0.0 - 1.0\r\n\t\r\n\t\t\tvar hsl = optionalTarget || { h: 0, s: 0, l: 0 };\r\n\t\r\n\t\t\tvar r = this.r, g = this.g, b = this.b;\r\n\t\r\n\t\t\tvar max = Math.max( r, g, b );\r\n\t\t\tvar min = Math.min( r, g, b );\r\n\t\r\n\t\t\tvar hue, saturation;\r\n\t\t\tvar lightness = ( min + max ) / 2.0;\r\n\t\r\n\t\t\tif ( min === max ) {\r\n\t\r\n\t\t\t\thue = 0;\r\n\t\t\t\tsaturation = 0;\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\tvar delta = max - min;\r\n\t\r\n\t\t\t\tsaturation = lightness <= 0.5 ? delta / ( max + min ) : delta / ( 2 - max - min );\r\n\t\r\n\t\t\t\tswitch ( max ) {\r\n\t\r\n\t\t\t\t\tcase r: hue = ( g - b ) / delta + ( g < b ? 6 : 0 ); break;\r\n\t\t\t\t\tcase g: hue = ( b - r ) / delta + 2; break;\r\n\t\t\t\t\tcase b: hue = ( r - g ) / delta + 4; break;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\thue /= 6;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\thsl.h = hue;\r\n\t\t\thsl.s = saturation;\r\n\t\t\thsl.l = lightness;\r\n\t\r\n\t\t\treturn hsl;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tgetStyle: function () {\r\n\t\r\n\t\t\treturn 'rgb(' + ( ( this.r * 255 ) | 0 ) + ',' + ( ( this.g * 255 ) | 0 ) + ',' + ( ( this.b * 255 ) | 0 ) + ')';\r\n\t\r\n\t\t},\r\n\t\r\n\t\toffsetHSL: function ( h, s, l ) {\r\n\t\r\n\t\t\tvar hsl = this.getHSL();\r\n\t\r\n\t\t\thsl.h += h; hsl.s += s; hsl.l += l;\r\n\t\r\n\t\t\tthis.setHSL( hsl.h, hsl.s, hsl.l );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tadd: function ( color ) {\r\n\t\r\n\t\t\tthis.r += color.r;\r\n\t\t\tthis.g += color.g;\r\n\t\t\tthis.b += color.b;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\taddColors: function ( color1, color2 ) {\r\n\t\r\n\t\t\tthis.r = color1.r + color2.r;\r\n\t\t\tthis.g = color1.g + color2.g;\r\n\t\t\tthis.b = color1.b + color2.b;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\taddScalar: function ( s ) {\r\n\t\r\n\t\t\tthis.r += s;\r\n\t\t\tthis.g += s;\r\n\t\t\tthis.b += s;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tmultiply: function ( color ) {\r\n\t\r\n\t\t\tthis.r *= color.r;\r\n\t\t\tthis.g *= color.g;\r\n\t\t\tthis.b *= color.b;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tmultiplyScalar: function ( s ) {\r\n\t\r\n\t\t\tthis.r *= s;\r\n\t\t\tthis.g *= s;\r\n\t\t\tthis.b *= s;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tlerp: function ( color, alpha ) {\r\n\t\r\n\t\t\tthis.r += ( color.r - this.r ) * alpha;\r\n\t\t\tthis.g += ( color.g - this.g ) * alpha;\r\n\t\t\tthis.b += ( color.b - this.b ) * alpha;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tequals: function ( c ) {\r\n\t\r\n\t\t\treturn ( c.r === this.r ) && ( c.g === this.g ) && ( c.b === this.b );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tfromArray: function ( array ) {\r\n\t\r\n\t\t\tthis.r = array[ 0 ];\r\n\t\t\tthis.g = array[ 1 ];\r\n\t\t\tthis.b = array[ 2 ];\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\ttoArray: function ( array, offset ) {\r\n\t\r\n\t\t\tif ( array === undefined ) array = [];\r\n\t\t\tif ( offset === undefined ) offset = 0;\r\n\t\r\n\t\t\tarray[ offset ] = this.r;\r\n\t\t\tarray[ offset + 1 ] = this.g;\r\n\t\t\tarray[ offset + 2 ] = this.b;\r\n\t\r\n\t\t\treturn array;\r\n\t\t},\r\n\t\r\n\t\tclone: function () {\r\n\t\r\n\t\t\treturn new THREE.Color().setRGB( this.r, this.g, this.b );\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.ColorKeywords = { 'aliceblue': 0xF0F8FF, 'antiquewhite': 0xFAEBD7, 'aqua': 0x00FFFF, 'aquamarine': 0x7FFFD4, 'azure': 0xF0FFFF,\r\n\t'beige': 0xF5F5DC, 'bisque': 0xFFE4C4, 'black': 0x000000, 'blanchedalmond': 0xFFEBCD, 'blue': 0x0000FF, 'blueviolet': 0x8A2BE2,\r\n\t'brown': 0xA52A2A, 'burlywood': 0xDEB887, 'cadetblue': 0x5F9EA0, 'chartreuse': 0x7FFF00, 'chocolate': 0xD2691E, 'coral': 0xFF7F50,\r\n\t'cornflowerblue': 0x6495ED, 'cornsilk': 0xFFF8DC, 'crimson': 0xDC143C, 'cyan': 0x00FFFF, 'darkblue': 0x00008B, 'darkcyan': 0x008B8B,\r\n\t'darkgoldenrod': 0xB8860B, 'darkgray': 0xA9A9A9, 'darkgreen': 0x006400, 'darkgrey': 0xA9A9A9, 'darkkhaki': 0xBDB76B, 'darkmagenta': 0x8B008B,\r\n\t'darkolivegreen': 0x556B2F, 'darkorange': 0xFF8C00, 'darkorchid': 0x9932CC, 'darkred': 0x8B0000, 'darksalmon': 0xE9967A, 'darkseagreen': 0x8FBC8F,\r\n\t'darkslateblue': 0x483D8B, 'darkslategray': 0x2F4F4F, 'darkslategrey': 0x2F4F4F, 'darkturquoise': 0x00CED1, 'darkviolet': 0x9400D3,\r\n\t'deeppink': 0xFF1493, 'deepskyblue': 0x00BFFF, 'dimgray': 0x696969, 'dimgrey': 0x696969, 'dodgerblue': 0x1E90FF, 'firebrick': 0xB22222,\r\n\t'floralwhite': 0xFFFAF0, 'forestgreen': 0x228B22, 'fuchsia': 0xFF00FF, 'gainsboro': 0xDCDCDC, 'ghostwhite': 0xF8F8FF, 'gold': 0xFFD700,\r\n\t'goldenrod': 0xDAA520, 'gray': 0x808080, 'green': 0x008000, 'greenyellow': 0xADFF2F, 'grey': 0x808080, 'honeydew': 0xF0FFF0, 'hotpink': 0xFF69B4,\r\n\t'indianred': 0xCD5C5C, 'indigo': 0x4B0082, 'ivory': 0xFFFFF0, 'khaki': 0xF0E68C, 'lavender': 0xE6E6FA, 'lavenderblush': 0xFFF0F5, 'lawngreen': 0x7CFC00,\r\n\t'lemonchiffon': 0xFFFACD, 'lightblue': 0xADD8E6, 'lightcoral': 0xF08080, 'lightcyan': 0xE0FFFF, 'lightgoldenrodyellow': 0xFAFAD2, 'lightgray': 0xD3D3D3,\r\n\t'lightgreen': 0x90EE90, 'lightgrey': 0xD3D3D3, 'lightpink': 0xFFB6C1, 'lightsalmon': 0xFFA07A, 'lightseagreen': 0x20B2AA, 'lightskyblue': 0x87CEFA,\r\n\t'lightslategray': 0x778899, 'lightslategrey': 0x778899, 'lightsteelblue': 0xB0C4DE, 'lightyellow': 0xFFFFE0, 'lime': 0x00FF00, 'limegreen': 0x32CD32,\r\n\t'linen': 0xFAF0E6, 'magenta': 0xFF00FF, 'maroon': 0x800000, 'mediumaquamarine': 0x66CDAA, 'mediumblue': 0x0000CD, 'mediumorchid': 0xBA55D3,\r\n\t'mediumpurple': 0x9370DB, 'mediumseagreen': 0x3CB371, 'mediumslateblue': 0x7B68EE, 'mediumspringgreen': 0x00FA9A, 'mediumturquoise': 0x48D1CC,\r\n\t'mediumvioletred': 0xC71585, 'midnightblue': 0x191970, 'mintcream': 0xF5FFFA, 'mistyrose': 0xFFE4E1, 'moccasin': 0xFFE4B5, 'navajowhite': 0xFFDEAD,\r\n\t'navy': 0x000080, 'oldlace': 0xFDF5E6, 'olive': 0x808000, 'olivedrab': 0x6B8E23, 'orange': 0xFFA500, 'orangered': 0xFF4500, 'orchid': 0xDA70D6,\r\n\t'palegoldenrod': 0xEEE8AA, 'palegreen': 0x98FB98, 'paleturquoise': 0xAFEEEE, 'palevioletred': 0xDB7093, 'papayawhip': 0xFFEFD5, 'peachpuff': 0xFFDAB9,\r\n\t'peru': 0xCD853F, 'pink': 0xFFC0CB, 'plum': 0xDDA0DD, 'powderblue': 0xB0E0E6, 'purple': 0x800080, 'red': 0xFF0000, 'rosybrown': 0xBC8F8F,\r\n\t'royalblue': 0x4169E1, 'saddlebrown': 0x8B4513, 'salmon': 0xFA8072, 'sandybrown': 0xF4A460, 'seagreen': 0x2E8B57, 'seashell': 0xFFF5EE,\r\n\t'sienna': 0xA0522D, 'silver': 0xC0C0C0, 'skyblue': 0x87CEEB, 'slateblue': 0x6A5ACD, 'slategray': 0x708090, 'slategrey': 0x708090, 'snow': 0xFFFAFA,\r\n\t'springgreen': 0x00FF7F, 'steelblue': 0x4682B4, 'tan': 0xD2B48C, 'teal': 0x008080, 'thistle': 0xD8BFD8, 'tomato': 0xFF6347, 'turquoise': 0x40E0D0,\r\n\t'violet': 0xEE82EE, 'wheat': 0xF5DEB3, 'white': 0xFFFFFF, 'whitesmoke': 0xF5F5F5, 'yellow': 0xFFFF00, 'yellowgreen': 0x9ACD32 };\r\n\t\r\n\t// File:src/math/Quaternion.js\r\n\t\r\n\t/**\r\n\t * @author mikael emtinger / http://gomo.se/\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t * @author WestLangley / http://github.com/WestLangley\r\n\t * @author bhouston / http://exocortex.com\r\n\t */\r\n\t\r\n\tTHREE.Quaternion = function ( x, y, z, w ) {\r\n\t\r\n\t\tthis._x = x || 0;\r\n\t\tthis._y = y || 0;\r\n\t\tthis._z = z || 0;\r\n\t\tthis._w = ( w !== undefined ) ? w : 1;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Quaternion.prototype = {\r\n\t\r\n\t\tconstructor: THREE.Quaternion,\r\n\t\r\n\t\t_x: 0,_y: 0, _z: 0, _w: 0,\r\n\t\r\n\t\tget x () {\r\n\t\r\n\t\t\treturn this._x;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tset x ( value ) {\r\n\t\r\n\t\t\tthis._x = value;\r\n\t\t\tthis.onChangeCallback();\r\n\t\r\n\t\t},\r\n\t\r\n\t\tget y () {\r\n\t\r\n\t\t\treturn this._y;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tset y ( value ) {\r\n\t\r\n\t\t\tthis._y = value;\r\n\t\t\tthis.onChangeCallback();\r\n\t\r\n\t\t},\r\n\t\r\n\t\tget z () {\r\n\t\r\n\t\t\treturn this._z;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tset z ( value ) {\r\n\t\r\n\t\t\tthis._z = value;\r\n\t\t\tthis.onChangeCallback();\r\n\t\r\n\t\t},\r\n\t\r\n\t\tget w () {\r\n\t\r\n\t\t\treturn this._w;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tset w ( value ) {\r\n\t\r\n\t\t\tthis._w = value;\r\n\t\t\tthis.onChangeCallback();\r\n\t\r\n\t\t},\r\n\t\r\n\t\tset: function ( x, y, z, w ) {\r\n\t\r\n\t\t\tthis._x = x;\r\n\t\t\tthis._y = y;\r\n\t\t\tthis._z = z;\r\n\t\t\tthis._w = w;\r\n\t\r\n\t\t\tthis.onChangeCallback();\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcopy: function ( quaternion ) {\r\n\t\r\n\t\t\tthis._x = quaternion.x;\r\n\t\t\tthis._y = quaternion.y;\r\n\t\t\tthis._z = quaternion.z;\r\n\t\t\tthis._w = quaternion.w;\r\n\t\r\n\t\t\tthis.onChangeCallback();\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetFromEuler: function ( euler, update ) {\r\n\t\r\n\t\t\tif ( euler instanceof THREE.Euler === false ) {\r\n\t\r\n\t\t\t\tthrow new Error( 'THREE.Quaternion: .setFromEuler() now expects a Euler rotation rather than a Vector3 and order.' );\r\n\t\t\t}\r\n\t\r\n\t\t\t// http://www.mathworks.com/matlabcentral/fileexchange/\r\n\t\t\t// \t20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/\r\n\t\t\t//\tcontent/SpinCalc.m\r\n\t\r\n\t\t\tvar c1 = Math.cos( euler._x / 2 );\r\n\t\t\tvar c2 = Math.cos( euler._y / 2 );\r\n\t\t\tvar c3 = Math.cos( euler._z / 2 );\r\n\t\t\tvar s1 = Math.sin( euler._x / 2 );\r\n\t\t\tvar s2 = Math.sin( euler._y / 2 );\r\n\t\t\tvar s3 = Math.sin( euler._z / 2 );\r\n\t\r\n\t\t\tif ( euler.order === 'XYZ' ) {\r\n\t\r\n\t\t\t\tthis._x = s1 * c2 * c3 + c1 * s2 * s3;\r\n\t\t\t\tthis._y = c1 * s2 * c3 - s1 * c2 * s3;\r\n\t\t\t\tthis._z = c1 * c2 * s3 + s1 * s2 * c3;\r\n\t\t\t\tthis._w = c1 * c2 * c3 - s1 * s2 * s3;\r\n\t\r\n\t\t\t} else if ( euler.order === 'YXZ' ) {\r\n\t\r\n\t\t\t\tthis._x = s1 * c2 * c3 + c1 * s2 * s3;\r\n\t\t\t\tthis._y = c1 * s2 * c3 - s1 * c2 * s3;\r\n\t\t\t\tthis._z = c1 * c2 * s3 - s1 * s2 * c3;\r\n\t\t\t\tthis._w = c1 * c2 * c3 + s1 * s2 * s3;\r\n\t\r\n\t\t\t} else if ( euler.order === 'ZXY' ) {\r\n\t\r\n\t\t\t\tthis._x = s1 * c2 * c3 - c1 * s2 * s3;\r\n\t\t\t\tthis._y = c1 * s2 * c3 + s1 * c2 * s3;\r\n\t\t\t\tthis._z = c1 * c2 * s3 + s1 * s2 * c3;\r\n\t\t\t\tthis._w = c1 * c2 * c3 - s1 * s2 * s3;\r\n\t\r\n\t\t\t} else if ( euler.order === 'ZYX' ) {\r\n\t\r\n\t\t\t\tthis._x = s1 * c2 * c3 - c1 * s2 * s3;\r\n\t\t\t\tthis._y = c1 * s2 * c3 + s1 * c2 * s3;\r\n\t\t\t\tthis._z = c1 * c2 * s3 - s1 * s2 * c3;\r\n\t\t\t\tthis._w = c1 * c2 * c3 + s1 * s2 * s3;\r\n\t\r\n\t\t\t} else if ( euler.order === 'YZX' ) {\r\n\t\r\n\t\t\t\tthis._x = s1 * c2 * c3 + c1 * s2 * s3;\r\n\t\t\t\tthis._y = c1 * s2 * c3 + s1 * c2 * s3;\r\n\t\t\t\tthis._z = c1 * c2 * s3 - s1 * s2 * c3;\r\n\t\t\t\tthis._w = c1 * c2 * c3 - s1 * s2 * s3;\r\n\t\r\n\t\t\t} else if ( euler.order === 'XZY' ) {\r\n\t\r\n\t\t\t\tthis._x = s1 * c2 * c3 - c1 * s2 * s3;\r\n\t\t\t\tthis._y = c1 * s2 * c3 - s1 * c2 * s3;\r\n\t\t\t\tthis._z = c1 * c2 * s3 + s1 * s2 * c3;\r\n\t\t\t\tthis._w = c1 * c2 * c3 + s1 * s2 * s3;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( update !== false ) this.onChangeCallback();\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetFromAxisAngle: function ( axis, angle ) {\r\n\t\r\n\t\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm\r\n\t\r\n\t\t\t// assumes axis is normalized\r\n\t\r\n\t\t\tvar halfAngle = angle / 2, s = Math.sin( halfAngle );\r\n\t\r\n\t\t\tthis._x = axis.x * s;\r\n\t\t\tthis._y = axis.y * s;\r\n\t\t\tthis._z = axis.z * s;\r\n\t\t\tthis._w = Math.cos( halfAngle );\r\n\t\r\n\t\t\tthis.onChangeCallback();\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetFromRotationMatrix: function ( m ) {\r\n\t\r\n\t\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm\r\n\t\r\n\t\t\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\r\n\t\r\n\t\t\tvar te = m.elements,\r\n\t\r\n\t\t\t\tm11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],\r\n\t\t\t\tm21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],\r\n\t\t\t\tm31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ],\r\n\t\r\n\t\t\t\ttrace = m11 + m22 + m33,\r\n\t\t\t\ts;\r\n\t\r\n\t\t\tif ( trace > 0 ) {\r\n\t\r\n\t\t\t\ts = 0.5 / Math.sqrt( trace + 1.0 );\r\n\t\r\n\t\t\t\tthis._w = 0.25 / s;\r\n\t\t\t\tthis._x = ( m32 - m23 ) * s;\r\n\t\t\t\tthis._y = ( m13 - m31 ) * s;\r\n\t\t\t\tthis._z = ( m21 - m12 ) * s;\r\n\t\r\n\t\t\t} else if ( m11 > m22 && m11 > m33 ) {\r\n\t\r\n\t\t\t\ts = 2.0 * Math.sqrt( 1.0 + m11 - m22 - m33 );\r\n\t\r\n\t\t\t\tthis._w = ( m32 - m23 ) / s;\r\n\t\t\t\tthis._x = 0.25 * s;\r\n\t\t\t\tthis._y = ( m12 + m21 ) / s;\r\n\t\t\t\tthis._z = ( m13 + m31 ) / s;\r\n\t\r\n\t\t\t} else if ( m22 > m33 ) {\r\n\t\r\n\t\t\t\ts = 2.0 * Math.sqrt( 1.0 + m22 - m11 - m33 );\r\n\t\r\n\t\t\t\tthis._w = ( m13 - m31 ) / s;\r\n\t\t\t\tthis._x = ( m12 + m21 ) / s;\r\n\t\t\t\tthis._y = 0.25 * s;\r\n\t\t\t\tthis._z = ( m23 + m32 ) / s;\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\ts = 2.0 * Math.sqrt( 1.0 + m33 - m11 - m22 );\r\n\t\r\n\t\t\t\tthis._w = ( m21 - m12 ) / s;\r\n\t\t\t\tthis._x = ( m13 + m31 ) / s;\r\n\t\t\t\tthis._y = ( m23 + m32 ) / s;\r\n\t\t\t\tthis._z = 0.25 * s;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tthis.onChangeCallback();\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetFromUnitVectors: function () {\r\n\t\r\n\t\t\t// http://lolengine.net/blog/2014/02/24/quaternion-from-two-vectors-final\r\n\t\r\n\t\t\t// assumes direction vectors vFrom and vTo are normalized\r\n\t\r\n\t\t\tvar v1, r;\r\n\t\r\n\t\t\tvar EPS = 0.000001;\r\n\t\r\n\t\t\treturn function ( vFrom, vTo ) {\r\n\t\r\n\t\t\t\tif ( v1 === undefined ) v1 = new THREE.Vector3();\r\n\t\r\n\t\t\t\tr = vFrom.dot( vTo ) + 1;\r\n\t\r\n\t\t\t\tif ( r < EPS ) {\r\n\t\r\n\t\t\t\t\tr = 0;\r\n\t\r\n\t\t\t\t\tif ( Math.abs( vFrom.x ) > Math.abs( vFrom.z ) ) {\r\n\t\r\n\t\t\t\t\t\tv1.set( - vFrom.y, vFrom.x, 0 );\r\n\t\r\n\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\tv1.set( 0, - vFrom.z, vFrom.y );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tv1.crossVectors( vFrom, vTo );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tthis._x = v1.x;\r\n\t\t\t\tthis._y = v1.y;\r\n\t\t\t\tthis._z = v1.z;\r\n\t\t\t\tthis._w = r;\r\n\t\r\n\t\t\t\tthis.normalize();\r\n\t\r\n\t\t\t\treturn this;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tinverse: function () {\r\n\t\r\n\t\t\tthis.conjugate().normalize();\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tconjugate: function () {\r\n\t\r\n\t\t\tthis._x *= - 1;\r\n\t\t\tthis._y *= - 1;\r\n\t\t\tthis._z *= - 1;\r\n\t\r\n\t\t\tthis.onChangeCallback();\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tdot: function ( v ) {\r\n\t\r\n\t\t\treturn this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tlengthSq: function () {\r\n\t\r\n\t\t\treturn this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tlength: function () {\r\n\t\r\n\t\t\treturn Math.sqrt( this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tnormalize: function () {\r\n\t\r\n\t\t\tvar l = this.length();\r\n\t\r\n\t\t\tif ( l === 0 ) {\r\n\t\r\n\t\t\t\tthis._x = 0;\r\n\t\t\t\tthis._y = 0;\r\n\t\t\t\tthis._z = 0;\r\n\t\t\t\tthis._w = 1;\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\tl = 1 / l;\r\n\t\r\n\t\t\t\tthis._x = this._x * l;\r\n\t\t\t\tthis._y = this._y * l;\r\n\t\t\t\tthis._z = this._z * l;\r\n\t\t\t\tthis._w = this._w * l;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tthis.onChangeCallback();\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tmultiply: function ( q, p ) {\r\n\t\r\n\t\t\tif ( p !== undefined ) {\r\n\t\r\n\t\t\t\tTHREE.warn( 'THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.' );\r\n\t\t\t\treturn this.multiplyQuaternions( q, p );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this.multiplyQuaternions( this, q );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tmultiplyQuaternions: function ( a, b ) {\r\n\t\r\n\t\t\t// from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm\r\n\t\r\n\t\t\tvar qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;\r\n\t\t\tvar qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;\r\n\t\r\n\t\t\tthis._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;\r\n\t\t\tthis._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;\r\n\t\t\tthis._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;\r\n\t\t\tthis._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;\r\n\t\r\n\t\t\tthis.onChangeCallback();\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tmultiplyVector3: function ( vector ) {\r\n\t\r\n\t\t\tTHREE.warn( 'THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.' );\r\n\t\t\treturn vector.applyQuaternion( this );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tslerp: function ( qb, t ) {\r\n\t\r\n\t\t\tif ( t === 0 ) return this;\r\n\t\t\tif ( t === 1 ) return this.copy( qb );\r\n\t\r\n\t\t\tvar x = this._x, y = this._y, z = this._z, w = this._w;\r\n\t\r\n\t\t\t// http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/\r\n\t\r\n\t\t\tvar cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;\r\n\t\r\n\t\t\tif ( cosHalfTheta < 0 ) {\r\n\t\r\n\t\t\t\tthis._w = - qb._w;\r\n\t\t\t\tthis._x = - qb._x;\r\n\t\t\t\tthis._y = - qb._y;\r\n\t\t\t\tthis._z = - qb._z;\r\n\t\r\n\t\t\t\tcosHalfTheta = - cosHalfTheta;\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\tthis.copy( qb );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( cosHalfTheta >= 1.0 ) {\r\n\t\r\n\t\t\t\tthis._w = w;\r\n\t\t\t\tthis._x = x;\r\n\t\t\t\tthis._y = y;\r\n\t\t\t\tthis._z = z;\r\n\t\r\n\t\t\t\treturn this;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar halfTheta = Math.acos( cosHalfTheta );\r\n\t\t\tvar sinHalfTheta = Math.sqrt( 1.0 - cosHalfTheta * cosHalfTheta );\r\n\t\r\n\t\t\tif ( Math.abs( sinHalfTheta ) < 0.001 ) {\r\n\t\r\n\t\t\t\tthis._w = 0.5 * ( w + this._w );\r\n\t\t\t\tthis._x = 0.5 * ( x + this._x );\r\n\t\t\t\tthis._y = 0.5 * ( y + this._y );\r\n\t\t\t\tthis._z = 0.5 * ( z + this._z );\r\n\t\r\n\t\t\t\treturn this;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar ratioA = Math.sin( ( 1 - t ) * halfTheta ) / sinHalfTheta,\r\n\t\t\tratioB = Math.sin( t * halfTheta ) / sinHalfTheta;\r\n\t\r\n\t\t\tthis._w = ( w * ratioA + this._w * ratioB );\r\n\t\t\tthis._x = ( x * ratioA + this._x * ratioB );\r\n\t\t\tthis._y = ( y * ratioA + this._y * ratioB );\r\n\t\t\tthis._z = ( z * ratioA + this._z * ratioB );\r\n\t\r\n\t\t\tthis.onChangeCallback();\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tequals: function ( quaternion ) {\r\n\t\r\n\t\t\treturn ( quaternion._x === this._x ) && ( quaternion._y === this._y ) && ( quaternion._z === this._z ) && ( quaternion._w === this._w );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tfromArray: function ( array, offset ) {\r\n\t\r\n\t\t\tif ( offset === undefined ) offset = 0;\r\n\t\r\n\t\t\tthis._x = array[ offset ];\r\n\t\t\tthis._y = array[ offset + 1 ];\r\n\t\t\tthis._z = array[ offset + 2 ];\r\n\t\t\tthis._w = array[ offset + 3 ];\r\n\t\r\n\t\t\tthis.onChangeCallback();\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\ttoArray: function ( array, offset ) {\r\n\t\r\n\t\t\tif ( array === undefined ) array = [];\r\n\t\t\tif ( offset === undefined ) offset = 0;\r\n\t\r\n\t\t\tarray[ offset ] = this._x;\r\n\t\t\tarray[ offset + 1 ] = this._y;\r\n\t\t\tarray[ offset + 2 ] = this._z;\r\n\t\t\tarray[ offset + 3 ] = this._w;\r\n\t\r\n\t\t\treturn array;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tonChange: function ( callback ) {\r\n\t\r\n\t\t\tthis.onChangeCallback = callback;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tonChangeCallback: function () {},\r\n\t\r\n\t\tclone: function () {\r\n\t\r\n\t\t\treturn new THREE.Quaternion( this._x, this._y, this._z, this._w );\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Quaternion.slerp = function ( qa, qb, qm, t ) {\r\n\t\r\n\t\treturn qm.copy( qa ).slerp( qb, t );\r\n\t\r\n\t}\r\n\t\r\n\t// File:src/math/Vector2.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t * @author philogb / http://blog.thejit.org/\r\n\t * @author egraether / http://egraether.com/\r\n\t * @author zz85 / http://www.lab4games.net/zz85/blog\r\n\t */\r\n\t\r\n\tTHREE.Vector2 = function ( x, y ) {\r\n\t\r\n\t\tthis.x = x || 0;\r\n\t\tthis.y = y || 0;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Vector2.prototype = {\r\n\t\r\n\t\tconstructor: THREE.Vector2,\r\n\t\r\n\t\tset: function ( x, y ) {\r\n\t\r\n\t\t\tthis.x = x;\r\n\t\t\tthis.y = y;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetX: function ( x ) {\r\n\t\r\n\t\t\tthis.x = x;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetY: function ( y ) {\r\n\t\r\n\t\t\tthis.y = y;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetComponent: function ( index, value ) {\r\n\t\r\n\t\t\tswitch ( index ) {\r\n\t\r\n\t\t\t\tcase 0: this.x = value; break;\r\n\t\t\t\tcase 1: this.y = value; break;\r\n\t\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t},\r\n\t\r\n\t\tgetComponent: function ( index ) {\r\n\t\r\n\t\t\tswitch ( index ) {\r\n\t\r\n\t\t\t\tcase 0: return this.x;\r\n\t\t\t\tcase 1: return this.y;\r\n\t\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcopy: function ( v ) {\r\n\t\r\n\t\t\tthis.x = v.x;\r\n\t\t\tthis.y = v.y;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tadd: function ( v, w ) {\r\n\t\r\n\t\t\tif ( w !== undefined ) {\r\n\t\r\n\t\t\t\tTHREE.warn( 'THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );\r\n\t\t\t\treturn this.addVectors( v, w );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tthis.x += v.x;\r\n\t\t\tthis.y += v.y;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\taddScalar: function ( s ) {\r\n\t\r\n\t\t\tthis.x += s;\r\n\t\t\tthis.y += s;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\taddVectors: function ( a, b ) {\r\n\t\r\n\t\t\tthis.x = a.x + b.x;\r\n\t\t\tthis.y = a.y + b.y;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsub: function ( v, w ) {\r\n\t\r\n\t\t\tif ( w !== undefined ) {\r\n\t\r\n\t\t\t\tTHREE.warn( 'THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );\r\n\t\t\t\treturn this.subVectors( v, w );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tthis.x -= v.x;\r\n\t\t\tthis.y -= v.y;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsubScalar: function ( s ) {\r\n\t\r\n\t\t\tthis.x -= s;\r\n\t\t\tthis.y -= s;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsubVectors: function ( a, b ) {\r\n\t\r\n\t\t\tthis.x = a.x - b.x;\r\n\t\t\tthis.y = a.y - b.y;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tmultiply: function ( v ) {\r\n\t\r\n\t\t\tthis.x *= v.x;\r\n\t\t\tthis.y *= v.y;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tmultiplyScalar: function ( s ) {\r\n\t\r\n\t\t\tthis.x *= s;\r\n\t\t\tthis.y *= s;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tdivide: function ( v ) {\r\n\t\r\n\t\t\tthis.x /= v.x;\r\n\t\t\tthis.y /= v.y;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tdivideScalar: function ( scalar ) {\r\n\t\r\n\t\t\tif ( scalar !== 0 ) {\r\n\t\r\n\t\t\t\tvar invScalar = 1 / scalar;\r\n\t\r\n\t\t\t\tthis.x *= invScalar;\r\n\t\t\t\tthis.y *= invScalar;\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\tthis.x = 0;\r\n\t\t\t\tthis.y = 0;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tmin: function ( v ) {\r\n\t\r\n\t\t\tif ( this.x > v.x ) {\r\n\t\r\n\t\t\t\tthis.x = v.x;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( this.y > v.y ) {\r\n\t\r\n\t\t\t\tthis.y = v.y;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tmax: function ( v ) {\r\n\t\r\n\t\t\tif ( this.x < v.x ) {\r\n\t\r\n\t\t\t\tthis.x = v.x;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( this.y < v.y ) {\r\n\t\r\n\t\t\t\tthis.y = v.y;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tclamp: function ( min, max ) {\r\n\t\r\n\t\t\t// This function assumes min < max, if this assumption isn't true it will not operate correctly\r\n\t\r\n\t\t\tif ( this.x < min.x ) {\r\n\t\r\n\t\t\t\tthis.x = min.x;\r\n\t\r\n\t\t\t} else if ( this.x > max.x ) {\r\n\t\r\n\t\t\t\tthis.x = max.x;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( this.y < min.y ) {\r\n\t\r\n\t\t\t\tthis.y = min.y;\r\n\t\r\n\t\t\t} else if ( this.y > max.y ) {\r\n\t\r\n\t\t\t\tthis.y = max.y;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this;\r\n\t\t},\r\n\t\r\n\t\tclampScalar: ( function () {\r\n\t\r\n\t\t\tvar min, max;\r\n\t\r\n\t\t\treturn function ( minVal, maxVal ) {\r\n\t\r\n\t\t\t\tif ( min === undefined ) {\r\n\t\r\n\t\t\t\t\tmin = new THREE.Vector2();\r\n\t\t\t\t\tmax = new THREE.Vector2();\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tmin.set( minVal, minVal );\r\n\t\t\t\tmax.set( maxVal, maxVal );\r\n\t\r\n\t\t\t\treturn this.clamp( min, max );\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t} )(),\r\n\t\r\n\t\tfloor: function () {\r\n\t\r\n\t\t\tthis.x = Math.floor( this.x );\r\n\t\t\tthis.y = Math.floor( this.y );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tceil: function () {\r\n\t\r\n\t\t\tthis.x = Math.ceil( this.x );\r\n\t\t\tthis.y = Math.ceil( this.y );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tround: function () {\r\n\t\r\n\t\t\tthis.x = Math.round( this.x );\r\n\t\t\tthis.y = Math.round( this.y );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\troundToZero: function () {\r\n\t\r\n\t\t\tthis.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );\r\n\t\t\tthis.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tnegate: function () {\r\n\t\r\n\t\t\tthis.x = - this.x;\r\n\t\t\tthis.y = - this.y;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tdot: function ( v ) {\r\n\t\r\n\t\t\treturn this.x * v.x + this.y * v.y;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tlengthSq: function () {\r\n\t\r\n\t\t\treturn this.x * this.x + this.y * this.y;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tlength: function () {\r\n\t\r\n\t\t\treturn Math.sqrt( this.x * this.x + this.y * this.y );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tnormalize: function () {\r\n\t\r\n\t\t\treturn this.divideScalar( this.length() );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tdistanceTo: function ( v ) {\r\n\t\r\n\t\t\treturn Math.sqrt( this.distanceToSquared( v ) );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tdistanceToSquared: function ( v ) {\r\n\t\r\n\t\t\tvar dx = this.x - v.x, dy = this.y - v.y;\r\n\t\t\treturn dx * dx + dy * dy;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetLength: function ( l ) {\r\n\t\r\n\t\t\tvar oldLength = this.length();\r\n\t\r\n\t\t\tif ( oldLength !== 0 && l !== oldLength ) {\r\n\t\r\n\t\t\t\tthis.multiplyScalar( l / oldLength );\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tlerp: function ( v, alpha ) {\r\n\t\r\n\t\t\tthis.x += ( v.x - this.x ) * alpha;\r\n\t\t\tthis.y += ( v.y - this.y ) * alpha;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tlerpVectors: function ( v1, v2, alpha ) {\r\n\t\r\n\t\t\tthis.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tequals: function ( v ) {\r\n\t\r\n\t\t\treturn ( ( v.x === this.x ) && ( v.y === this.y ) );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tfromArray: function ( array, offset ) {\r\n\t\r\n\t\t\tif ( offset === undefined ) offset = 0;\r\n\t\r\n\t\t\tthis.x = array[ offset ];\r\n\t\t\tthis.y = array[ offset + 1 ];\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\ttoArray: function ( array, offset ) {\r\n\t\r\n\t\t\tif ( array === undefined ) array = [];\r\n\t\t\tif ( offset === undefined ) offset = 0;\r\n\t\r\n\t\t\tarray[ offset ] = this.x;\r\n\t\t\tarray[ offset + 1 ] = this.y;\r\n\t\r\n\t\t\treturn array;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tfromAttribute: function ( attribute, index, offset ) {\r\n\t\r\n\t\t\tif ( offset === undefined ) offset = 0;\r\n\t\r\n\t\t\tindex = index * attribute.itemSize + offset;\r\n\t\r\n\t\t\tthis.x = attribute.array[ index ];\r\n\t\t\tthis.y = attribute.array[ index + 1 ];\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tclone: function () {\r\n\t\r\n\t\t\treturn new THREE.Vector2( this.x, this.y );\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/math/Vector3.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t * @author *kile / http://kile.stravaganza.org/\r\n\t * @author philogb / http://blog.thejit.org/\r\n\t * @author mikael emtinger / http://gomo.se/\r\n\t * @author egraether / http://egraether.com/\r\n\t * @author WestLangley / http://github.com/WestLangley\r\n\t */\r\n\t\r\n\tTHREE.Vector3 = function ( x, y, z ) {\r\n\t\r\n\t\tthis.x = x || 0;\r\n\t\tthis.y = y || 0;\r\n\t\tthis.z = z || 0;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Vector3.prototype = {\r\n\t\r\n\t\tconstructor: THREE.Vector3,\r\n\t\r\n\t\tset: function ( x, y, z ) {\r\n\t\r\n\t\t\tthis.x = x;\r\n\t\t\tthis.y = y;\r\n\t\t\tthis.z = z;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetX: function ( x ) {\r\n\t\r\n\t\t\tthis.x = x;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetY: function ( y ) {\r\n\t\r\n\t\t\tthis.y = y;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetZ: function ( z ) {\r\n\t\r\n\t\t\tthis.z = z;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetComponent: function ( index, value ) {\r\n\t\r\n\t\t\tswitch ( index ) {\r\n\t\r\n\t\t\t\tcase 0: this.x = value; break;\r\n\t\t\t\tcase 1: this.y = value; break;\r\n\t\t\t\tcase 2: this.z = value; break;\r\n\t\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t},\r\n\t\r\n\t\tgetComponent: function ( index ) {\r\n\t\r\n\t\t\tswitch ( index ) {\r\n\t\r\n\t\t\t\tcase 0: return this.x;\r\n\t\t\t\tcase 1: return this.y;\r\n\t\t\t\tcase 2: return this.z;\r\n\t\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcopy: function ( v ) {\r\n\t\r\n\t\t\tthis.x = v.x;\r\n\t\t\tthis.y = v.y;\r\n\t\t\tthis.z = v.z;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tadd: function ( v, w ) {\r\n\t\r\n\t\t\tif ( w !== undefined ) {\r\n\t\r\n\t\t\t\tTHREE.warn( 'THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );\r\n\t\t\t\treturn this.addVectors( v, w );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tthis.x += v.x;\r\n\t\t\tthis.y += v.y;\r\n\t\t\tthis.z += v.z;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\taddScalar: function ( s ) {\r\n\t\r\n\t\t\tthis.x += s;\r\n\t\t\tthis.y += s;\r\n\t\t\tthis.z += s;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\taddVectors: function ( a, b ) {\r\n\t\r\n\t\t\tthis.x = a.x + b.x;\r\n\t\t\tthis.y = a.y + b.y;\r\n\t\t\tthis.z = a.z + b.z;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsub: function ( v, w ) {\r\n\t\r\n\t\t\tif ( w !== undefined ) {\r\n\t\r\n\t\t\t\tTHREE.warn( 'THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );\r\n\t\t\t\treturn this.subVectors( v, w );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tthis.x -= v.x;\r\n\t\t\tthis.y -= v.y;\r\n\t\t\tthis.z -= v.z;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\t\r\n\t\tsubScalar: function ( s ) {\r\n\t\r\n\t\t\tthis.x -= s;\r\n\t\t\tthis.y -= s;\r\n\t\t\tthis.z -= s;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsubVectors: function ( a, b ) {\r\n\t\r\n\t\t\tthis.x = a.x - b.x;\r\n\t\t\tthis.y = a.y - b.y;\r\n\t\t\tthis.z = a.z - b.z;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tmultiply: function ( v, w ) {\r\n\t\r\n\t\t\tif ( w !== undefined ) {\r\n\t\r\n\t\t\t\tTHREE.warn( 'THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.' );\r\n\t\t\t\treturn this.multiplyVectors( v, w );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tthis.x *= v.x;\r\n\t\t\tthis.y *= v.y;\r\n\t\t\tthis.z *= v.z;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tmultiplyScalar: function ( scalar ) {\r\n\t\r\n\t\t\tthis.x *= scalar;\r\n\t\t\tthis.y *= scalar;\r\n\t\t\tthis.z *= scalar;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tmultiplyVectors: function ( a, b ) {\r\n\t\r\n\t\t\tthis.x = a.x * b.x;\r\n\t\t\tthis.y = a.y * b.y;\r\n\t\t\tthis.z = a.z * b.z;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tapplyEuler: function () {\r\n\t\r\n\t\t\tvar quaternion;\r\n\t\r\n\t\t\treturn function ( euler ) {\r\n\t\r\n\t\t\t\tif ( euler instanceof THREE.Euler === false ) {\r\n\t\r\n\t\t\t\t\tTHREE.error( 'THREE.Vector3: .applyEuler() now expects a Euler rotation rather than a Vector3 and order.' );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( quaternion === undefined ) quaternion = new THREE.Quaternion();\r\n\t\r\n\t\t\t\tthis.applyQuaternion( quaternion.setFromEuler( euler ) );\r\n\t\r\n\t\t\t\treturn this;\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tapplyAxisAngle: function () {\r\n\t\r\n\t\t\tvar quaternion;\r\n\t\r\n\t\t\treturn function ( axis, angle ) {\r\n\t\r\n\t\t\t\tif ( quaternion === undefined ) quaternion = new THREE.Quaternion();\r\n\t\r\n\t\t\t\tthis.applyQuaternion( quaternion.setFromAxisAngle( axis, angle ) );\r\n\t\r\n\t\t\t\treturn this;\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tapplyMatrix3: function ( m ) {\r\n\t\r\n\t\t\tvar x = this.x;\r\n\t\t\tvar y = this.y;\r\n\t\t\tvar z = this.z;\r\n\t\r\n\t\t\tvar e = m.elements;\r\n\t\r\n\t\t\tthis.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ] * z;\r\n\t\t\tthis.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ] * z;\r\n\t\t\tthis.z = e[ 2 ] * x + e[ 5 ] * y + e[ 8 ] * z;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tapplyMatrix4: function ( m ) {\r\n\t\r\n\t\t\t// input: THREE.Matrix4 affine matrix\r\n\t\r\n\t\t\tvar x = this.x, y = this.y, z = this.z;\r\n\t\r\n\t\t\tvar e = m.elements;\r\n\t\r\n\t\t\tthis.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ]  * z + e[ 12 ];\r\n\t\t\tthis.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ]  * z + e[ 13 ];\r\n\t\t\tthis.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ];\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tapplyProjection: function ( m ) {\r\n\t\r\n\t\t\t// input: THREE.Matrix4 projection matrix\r\n\t\r\n\t\t\tvar x = this.x, y = this.y, z = this.z;\r\n\t\r\n\t\t\tvar e = m.elements;\r\n\t\t\tvar d = 1 / ( e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] ); // perspective divide\r\n\t\r\n\t\t\tthis.x = ( e[ 0 ] * x + e[ 4 ] * y + e[ 8 ]  * z + e[ 12 ] ) * d;\r\n\t\t\tthis.y = ( e[ 1 ] * x + e[ 5 ] * y + e[ 9 ]  * z + e[ 13 ] ) * d;\r\n\t\t\tthis.z = ( e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] ) * d;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tapplyQuaternion: function ( q ) {\r\n\t\r\n\t\t\tvar x = this.x;\r\n\t\t\tvar y = this.y;\r\n\t\t\tvar z = this.z;\r\n\t\r\n\t\t\tvar qx = q.x;\r\n\t\t\tvar qy = q.y;\r\n\t\t\tvar qz = q.z;\r\n\t\t\tvar qw = q.w;\r\n\t\r\n\t\t\t// calculate quat * vector\r\n\t\r\n\t\t\tvar ix =  qw * x + qy * z - qz * y;\r\n\t\t\tvar iy =  qw * y + qz * x - qx * z;\r\n\t\t\tvar iz =  qw * z + qx * y - qy * x;\r\n\t\t\tvar iw = - qx * x - qy * y - qz * z;\r\n\t\r\n\t\t\t// calculate result * inverse quat\r\n\t\r\n\t\t\tthis.x = ix * qw + iw * - qx + iy * - qz - iz * - qy;\r\n\t\t\tthis.y = iy * qw + iw * - qy + iz * - qx - ix * - qz;\r\n\t\t\tthis.z = iz * qw + iw * - qz + ix * - qy - iy * - qx;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tproject: function () {\r\n\t\r\n\t\t\tvar matrix;\r\n\t\r\n\t\t\treturn function ( camera ) {\r\n\t\r\n\t\t\t\tif ( matrix === undefined ) matrix = new THREE.Matrix4();\r\n\t\r\n\t\t\t\tmatrix.multiplyMatrices( camera.projectionMatrix, matrix.getInverse( camera.matrixWorld ) );\r\n\t\t\t\treturn this.applyProjection( matrix );\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tunproject: function () {\r\n\t\r\n\t\t\tvar matrix;\r\n\t\r\n\t\t\treturn function ( camera ) {\r\n\t\r\n\t\t\t\tif ( matrix === undefined ) matrix = new THREE.Matrix4();\r\n\t\r\n\t\t\t\tmatrix.multiplyMatrices( camera.matrixWorld, matrix.getInverse( camera.projectionMatrix ) );\r\n\t\t\t\treturn this.applyProjection( matrix );\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\ttransformDirection: function ( m ) {\r\n\t\r\n\t\t\t// input: THREE.Matrix4 affine matrix\r\n\t\t\t// vector interpreted as a direction\r\n\t\r\n\t\t\tvar x = this.x, y = this.y, z = this.z;\r\n\t\r\n\t\t\tvar e = m.elements;\r\n\t\r\n\t\t\tthis.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ]  * z;\r\n\t\t\tthis.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ]  * z;\r\n\t\t\tthis.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z;\r\n\t\r\n\t\t\tthis.normalize();\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tdivide: function ( v ) {\r\n\t\r\n\t\t\tthis.x /= v.x;\r\n\t\t\tthis.y /= v.y;\r\n\t\t\tthis.z /= v.z;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tdivideScalar: function ( scalar ) {\r\n\t\r\n\t\t\tif ( scalar !== 0 ) {\r\n\t\r\n\t\t\t\tvar invScalar = 1 / scalar;\r\n\t\r\n\t\t\t\tthis.x *= invScalar;\r\n\t\t\t\tthis.y *= invScalar;\r\n\t\t\t\tthis.z *= invScalar;\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\tthis.x = 0;\r\n\t\t\t\tthis.y = 0;\r\n\t\t\t\tthis.z = 0;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tmin: function ( v ) {\r\n\t\r\n\t\t\tif ( this.x > v.x ) {\r\n\t\r\n\t\t\t\tthis.x = v.x;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( this.y > v.y ) {\r\n\t\r\n\t\t\t\tthis.y = v.y;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( this.z > v.z ) {\r\n\t\r\n\t\t\t\tthis.z = v.z;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tmax: function ( v ) {\r\n\t\r\n\t\t\tif ( this.x < v.x ) {\r\n\t\r\n\t\t\t\tthis.x = v.x;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( this.y < v.y ) {\r\n\t\r\n\t\t\t\tthis.y = v.y;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( this.z < v.z ) {\r\n\t\r\n\t\t\t\tthis.z = v.z;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tclamp: function ( min, max ) {\r\n\t\r\n\t\t\t// This function assumes min < max, if this assumption isn't true it will not operate correctly\r\n\t\r\n\t\t\tif ( this.x < min.x ) {\r\n\t\r\n\t\t\t\tthis.x = min.x;\r\n\t\r\n\t\t\t} else if ( this.x > max.x ) {\r\n\t\r\n\t\t\t\tthis.x = max.x;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( this.y < min.y ) {\r\n\t\r\n\t\t\t\tthis.y = min.y;\r\n\t\r\n\t\t\t} else if ( this.y > max.y ) {\r\n\t\r\n\t\t\t\tthis.y = max.y;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( this.z < min.z ) {\r\n\t\r\n\t\t\t\tthis.z = min.z;\r\n\t\r\n\t\t\t} else if ( this.z > max.z ) {\r\n\t\r\n\t\t\t\tthis.z = max.z;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tclampScalar: ( function () {\r\n\t\r\n\t\t\tvar min, max;\r\n\t\r\n\t\t\treturn function ( minVal, maxVal ) {\r\n\t\r\n\t\t\t\tif ( min === undefined ) {\r\n\t\r\n\t\t\t\t\tmin = new THREE.Vector3();\r\n\t\t\t\t\tmax = new THREE.Vector3();\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tmin.set( minVal, minVal, minVal );\r\n\t\t\t\tmax.set( maxVal, maxVal, maxVal );\r\n\t\r\n\t\t\t\treturn this.clamp( min, max );\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t} )(),\r\n\t\r\n\t\tfloor: function () {\r\n\t\r\n\t\t\tthis.x = Math.floor( this.x );\r\n\t\t\tthis.y = Math.floor( this.y );\r\n\t\t\tthis.z = Math.floor( this.z );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tceil: function () {\r\n\t\r\n\t\t\tthis.x = Math.ceil( this.x );\r\n\t\t\tthis.y = Math.ceil( this.y );\r\n\t\t\tthis.z = Math.ceil( this.z );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tround: function () {\r\n\t\r\n\t\t\tthis.x = Math.round( this.x );\r\n\t\t\tthis.y = Math.round( this.y );\r\n\t\t\tthis.z = Math.round( this.z );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\troundToZero: function () {\r\n\t\r\n\t\t\tthis.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );\r\n\t\t\tthis.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );\r\n\t\t\tthis.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tnegate: function () {\r\n\t\r\n\t\t\tthis.x = - this.x;\r\n\t\t\tthis.y = - this.y;\r\n\t\t\tthis.z = - this.z;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tdot: function ( v ) {\r\n\t\r\n\t\t\treturn this.x * v.x + this.y * v.y + this.z * v.z;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tlengthSq: function () {\r\n\t\r\n\t\t\treturn this.x * this.x + this.y * this.y + this.z * this.z;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tlength: function () {\r\n\t\r\n\t\t\treturn Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tlengthManhattan: function () {\r\n\t\r\n\t\t\treturn Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tnormalize: function () {\r\n\t\r\n\t\t\treturn this.divideScalar( this.length() );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetLength: function ( l ) {\r\n\t\r\n\t\t\tvar oldLength = this.length();\r\n\t\r\n\t\t\tif ( oldLength !== 0 && l !== oldLength  ) {\r\n\t\r\n\t\t\t\tthis.multiplyScalar( l / oldLength );\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tlerp: function ( v, alpha ) {\r\n\t\r\n\t\t\tthis.x += ( v.x - this.x ) * alpha;\r\n\t\t\tthis.y += ( v.y - this.y ) * alpha;\r\n\t\t\tthis.z += ( v.z - this.z ) * alpha;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tlerpVectors: function ( v1, v2, alpha ) {\r\n\t\r\n\t\t\tthis.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcross: function ( v, w ) {\r\n\t\r\n\t\t\tif ( w !== undefined ) {\r\n\t\r\n\t\t\t\tTHREE.warn( 'THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.' );\r\n\t\t\t\treturn this.crossVectors( v, w );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar x = this.x, y = this.y, z = this.z;\r\n\t\r\n\t\t\tthis.x = y * v.z - z * v.y;\r\n\t\t\tthis.y = z * v.x - x * v.z;\r\n\t\t\tthis.z = x * v.y - y * v.x;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcrossVectors: function ( a, b ) {\r\n\t\r\n\t\t\tvar ax = a.x, ay = a.y, az = a.z;\r\n\t\t\tvar bx = b.x, by = b.y, bz = b.z;\r\n\t\r\n\t\t\tthis.x = ay * bz - az * by;\r\n\t\t\tthis.y = az * bx - ax * bz;\r\n\t\t\tthis.z = ax * by - ay * bx;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tprojectOnVector: function () {\r\n\t\r\n\t\t\tvar v1, dot;\r\n\t\r\n\t\t\treturn function ( vector ) {\r\n\t\r\n\t\t\t\tif ( v1 === undefined ) v1 = new THREE.Vector3();\r\n\t\r\n\t\t\t\tv1.copy( vector ).normalize();\r\n\t\r\n\t\t\t\tdot = this.dot( v1 );\r\n\t\r\n\t\t\t\treturn this.copy( v1 ).multiplyScalar( dot );\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tprojectOnPlane: function () {\r\n\t\r\n\t\t\tvar v1;\r\n\t\r\n\t\t\treturn function ( planeNormal ) {\r\n\t\r\n\t\t\t\tif ( v1 === undefined ) v1 = new THREE.Vector3();\r\n\t\r\n\t\t\t\tv1.copy( this ).projectOnVector( planeNormal );\r\n\t\r\n\t\t\t\treturn this.sub( v1 );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\treflect: function () {\r\n\t\r\n\t\t\t// reflect incident vector off plane orthogonal to normal\r\n\t\t\t// normal is assumed to have unit length\r\n\t\r\n\t\t\tvar v1;\r\n\t\r\n\t\t\treturn function ( normal ) {\r\n\t\r\n\t\t\t\tif ( v1 === undefined ) v1 = new THREE.Vector3();\r\n\t\r\n\t\t\t\treturn this.sub( v1.copy( normal ).multiplyScalar( 2 * this.dot( normal ) ) );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tangleTo: function ( v ) {\r\n\t\r\n\t\t\tvar theta = this.dot( v ) / ( this.length() * v.length() );\r\n\t\r\n\t\t\t// clamp, to handle numerical problems\r\n\t\r\n\t\t\treturn Math.acos( THREE.Math.clamp( theta, - 1, 1 ) );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tdistanceTo: function ( v ) {\r\n\t\r\n\t\t\treturn Math.sqrt( this.distanceToSquared( v ) );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tdistanceToSquared: function ( v ) {\r\n\t\r\n\t\t\tvar dx = this.x - v.x;\r\n\t\t\tvar dy = this.y - v.y;\r\n\t\t\tvar dz = this.z - v.z;\r\n\t\r\n\t\t\treturn dx * dx + dy * dy + dz * dz;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetEulerFromRotationMatrix: function ( m, order ) {\r\n\t\r\n\t\t\tTHREE.error( 'THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.' );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetEulerFromQuaternion: function ( q, order ) {\r\n\t\r\n\t\t\tTHREE.error( 'THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.' );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tgetPositionFromMatrix: function ( m ) {\r\n\t\r\n\t\t\tTHREE.warn( 'THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().' );\r\n\t\r\n\t\t\treturn this.setFromMatrixPosition( m );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tgetScaleFromMatrix: function ( m ) {\r\n\t\r\n\t\t\tTHREE.warn( 'THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().' );\r\n\t\r\n\t\t\treturn this.setFromMatrixScale( m );\r\n\t\t},\r\n\t\r\n\t\tgetColumnFromMatrix: function ( index, matrix ) {\r\n\t\r\n\t\t\tTHREE.warn( 'THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().' );\r\n\t\r\n\t\t\treturn this.setFromMatrixColumn( index, matrix );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetFromMatrixPosition: function ( m ) {\r\n\t\r\n\t\t\tthis.x = m.elements[ 12 ];\r\n\t\t\tthis.y = m.elements[ 13 ];\r\n\t\t\tthis.z = m.elements[ 14 ];\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetFromMatrixScale: function ( m ) {\r\n\t\r\n\t\t\tvar sx = this.set( m.elements[ 0 ], m.elements[ 1 ], m.elements[  2 ] ).length();\r\n\t\t\tvar sy = this.set( m.elements[ 4 ], m.elements[ 5 ], m.elements[  6 ] ).length();\r\n\t\t\tvar sz = this.set( m.elements[ 8 ], m.elements[ 9 ], m.elements[ 10 ] ).length();\r\n\t\r\n\t\t\tthis.x = sx;\r\n\t\t\tthis.y = sy;\r\n\t\t\tthis.z = sz;\r\n\t\r\n\t\t\treturn this;\r\n\t\t},\r\n\t\r\n\t\tsetFromMatrixColumn: function ( index, matrix ) {\r\n\t\t\t\r\n\t\t\tvar offset = index * 4;\r\n\t\r\n\t\t\tvar me = matrix.elements;\r\n\t\r\n\t\t\tthis.x = me[ offset ];\r\n\t\t\tthis.y = me[ offset + 1 ];\r\n\t\t\tthis.z = me[ offset + 2 ];\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tequals: function ( v ) {\r\n\t\r\n\t\t\treturn ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tfromArray: function ( array, offset ) {\r\n\t\r\n\t\t\tif ( offset === undefined ) offset = 0;\r\n\t\r\n\t\t\tthis.x = array[ offset ];\r\n\t\t\tthis.y = array[ offset + 1 ];\r\n\t\t\tthis.z = array[ offset + 2 ];\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\ttoArray: function ( array, offset ) {\r\n\t\r\n\t\t\tif ( array === undefined ) array = [];\r\n\t\t\tif ( offset === undefined ) offset = 0;\r\n\t\r\n\t\t\tarray[ offset ] = this.x;\r\n\t\t\tarray[ offset + 1 ] = this.y;\r\n\t\t\tarray[ offset + 2 ] = this.z;\r\n\t\r\n\t\t\treturn array;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tfromAttribute: function ( attribute, index, offset ) {\r\n\t\r\n\t\t\tif ( offset === undefined ) offset = 0;\r\n\t\r\n\t\t\tindex = index * attribute.itemSize + offset;\r\n\t\r\n\t\t\tthis.x = attribute.array[ index ];\r\n\t\t\tthis.y = attribute.array[ index + 1 ];\r\n\t\t\tthis.z = attribute.array[ index + 2 ];\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tclone: function () {\r\n\t\r\n\t\t\treturn new THREE.Vector3( this.x, this.y, this.z );\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/math/Vector4.js\r\n\t\r\n\t/**\r\n\t * @author supereggbert / http://www.paulbrunt.co.uk/\r\n\t * @author philogb / http://blog.thejit.org/\r\n\t * @author mikael emtinger / http://gomo.se/\r\n\t * @author egraether / http://egraether.com/\r\n\t * @author WestLangley / http://github.com/WestLangley\r\n\t */\r\n\t\r\n\tTHREE.Vector4 = function ( x, y, z, w ) {\r\n\t\r\n\t\tthis.x = x || 0;\r\n\t\tthis.y = y || 0;\r\n\t\tthis.z = z || 0;\r\n\t\tthis.w = ( w !== undefined ) ? w : 1;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Vector4.prototype = {\r\n\t\r\n\t\tconstructor: THREE.Vector4,\r\n\t\r\n\t\tset: function ( x, y, z, w ) {\r\n\t\r\n\t\t\tthis.x = x;\r\n\t\t\tthis.y = y;\r\n\t\t\tthis.z = z;\r\n\t\t\tthis.w = w;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetX: function ( x ) {\r\n\t\r\n\t\t\tthis.x = x;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetY: function ( y ) {\r\n\t\r\n\t\t\tthis.y = y;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetZ: function ( z ) {\r\n\t\r\n\t\t\tthis.z = z;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetW: function ( w ) {\r\n\t\r\n\t\t\tthis.w = w;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetComponent: function ( index, value ) {\r\n\t\r\n\t\t\tswitch ( index ) {\r\n\t\r\n\t\t\t\tcase 0: this.x = value; break;\r\n\t\t\t\tcase 1: this.y = value; break;\r\n\t\t\t\tcase 2: this.z = value; break;\r\n\t\t\t\tcase 3: this.w = value; break;\r\n\t\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t},\r\n\t\r\n\t\tgetComponent: function ( index ) {\r\n\t\r\n\t\t\tswitch ( index ) {\r\n\t\r\n\t\t\t\tcase 0: return this.x;\r\n\t\t\t\tcase 1: return this.y;\r\n\t\t\t\tcase 2: return this.z;\r\n\t\t\t\tcase 3: return this.w;\r\n\t\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcopy: function ( v ) {\r\n\t\r\n\t\t\tthis.x = v.x;\r\n\t\t\tthis.y = v.y;\r\n\t\t\tthis.z = v.z;\r\n\t\t\tthis.w = ( v.w !== undefined ) ? v.w : 1;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tadd: function ( v, w ) {\r\n\t\r\n\t\t\tif ( w !== undefined ) {\r\n\t\r\n\t\t\t\tTHREE.warn( 'THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );\r\n\t\t\t\treturn this.addVectors( v, w );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tthis.x += v.x;\r\n\t\t\tthis.y += v.y;\r\n\t\t\tthis.z += v.z;\r\n\t\t\tthis.w += v.w;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\taddScalar: function ( s ) {\r\n\t\r\n\t\t\tthis.x += s;\r\n\t\t\tthis.y += s;\r\n\t\t\tthis.z += s;\r\n\t\t\tthis.w += s;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\taddVectors: function ( a, b ) {\r\n\t\r\n\t\t\tthis.x = a.x + b.x;\r\n\t\t\tthis.y = a.y + b.y;\r\n\t\t\tthis.z = a.z + b.z;\r\n\t\t\tthis.w = a.w + b.w;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsub: function ( v, w ) {\r\n\t\r\n\t\t\tif ( w !== undefined ) {\r\n\t\r\n\t\t\t\tTHREE.warn( 'THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );\r\n\t\t\t\treturn this.subVectors( v, w );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tthis.x -= v.x;\r\n\t\t\tthis.y -= v.y;\r\n\t\t\tthis.z -= v.z;\r\n\t\t\tthis.w -= v.w;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsubScalar: function ( s ) {\r\n\t\r\n\t\t\tthis.x -= s;\r\n\t\t\tthis.y -= s;\r\n\t\t\tthis.z -= s;\r\n\t\t\tthis.w -= s;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsubVectors: function ( a, b ) {\r\n\t\r\n\t\t\tthis.x = a.x - b.x;\r\n\t\t\tthis.y = a.y - b.y;\r\n\t\t\tthis.z = a.z - b.z;\r\n\t\t\tthis.w = a.w - b.w;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tmultiplyScalar: function ( scalar ) {\r\n\t\r\n\t\t\tthis.x *= scalar;\r\n\t\t\tthis.y *= scalar;\r\n\t\t\tthis.z *= scalar;\r\n\t\t\tthis.w *= scalar;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tapplyMatrix4: function ( m ) {\r\n\t\r\n\t\t\tvar x = this.x;\r\n\t\t\tvar y = this.y;\r\n\t\t\tvar z = this.z;\r\n\t\t\tvar w = this.w;\r\n\t\r\n\t\t\tvar e = m.elements;\r\n\t\r\n\t\t\tthis.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] * w;\r\n\t\t\tthis.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] * w;\r\n\t\t\tthis.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] * w;\r\n\t\t\tthis.w = e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] * w;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tdivideScalar: function ( scalar ) {\r\n\t\r\n\t\t\tif ( scalar !== 0 ) {\r\n\t\r\n\t\t\t\tvar invScalar = 1 / scalar;\r\n\t\r\n\t\t\t\tthis.x *= invScalar;\r\n\t\t\t\tthis.y *= invScalar;\r\n\t\t\t\tthis.z *= invScalar;\r\n\t\t\t\tthis.w *= invScalar;\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\tthis.x = 0;\r\n\t\t\t\tthis.y = 0;\r\n\t\t\t\tthis.z = 0;\r\n\t\t\t\tthis.w = 1;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetAxisAngleFromQuaternion: function ( q ) {\r\n\t\r\n\t\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm\r\n\t\r\n\t\t\t// q is assumed to be normalized\r\n\t\r\n\t\t\tthis.w = 2 * Math.acos( q.w );\r\n\t\r\n\t\t\tvar s = Math.sqrt( 1 - q.w * q.w );\r\n\t\r\n\t\t\tif ( s < 0.0001 ) {\r\n\t\r\n\t\t\t\t this.x = 1;\r\n\t\t\t\t this.y = 0;\r\n\t\t\t\t this.z = 0;\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\t this.x = q.x / s;\r\n\t\t\t\t this.y = q.y / s;\r\n\t\t\t\t this.z = q.z / s;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetAxisAngleFromRotationMatrix: function ( m ) {\r\n\t\r\n\t\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm\r\n\t\r\n\t\t\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\r\n\t\r\n\t\t\tvar angle, x, y, z,\t\t// variables for result\r\n\t\t\t\tepsilon = 0.01,\t\t// margin to allow for rounding errors\r\n\t\t\t\tepsilon2 = 0.1,\t\t// margin to distinguish between 0 and 180 degrees\r\n\t\r\n\t\t\t\tte = m.elements,\r\n\t\r\n\t\t\t\tm11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],\r\n\t\t\t\tm21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],\r\n\t\t\t\tm31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];\r\n\t\r\n\t\t\tif ( ( Math.abs( m12 - m21 ) < epsilon )\r\n\t\t\t   && ( Math.abs( m13 - m31 ) < epsilon )\r\n\t\t\t   && ( Math.abs( m23 - m32 ) < epsilon ) ) {\r\n\t\r\n\t\t\t\t// singularity found\r\n\t\t\t\t// first check for identity matrix which must have +1 for all terms\r\n\t\t\t\t// in leading diagonal and zero in other terms\r\n\t\r\n\t\t\t\tif ( ( Math.abs( m12 + m21 ) < epsilon2 )\r\n\t\t\t\t   && ( Math.abs( m13 + m31 ) < epsilon2 )\r\n\t\t\t\t   && ( Math.abs( m23 + m32 ) < epsilon2 )\r\n\t\t\t\t   && ( Math.abs( m11 + m22 + m33 - 3 ) < epsilon2 ) ) {\r\n\t\r\n\t\t\t\t\t// this singularity is identity matrix so angle = 0\r\n\t\r\n\t\t\t\t\tthis.set( 1, 0, 0, 0 );\r\n\t\r\n\t\t\t\t\treturn this; // zero angle, arbitrary axis\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\t// otherwise this singularity is angle = 180\r\n\t\r\n\t\t\t\tangle = Math.PI;\r\n\t\r\n\t\t\t\tvar xx = ( m11 + 1 ) / 2;\r\n\t\t\t\tvar yy = ( m22 + 1 ) / 2;\r\n\t\t\t\tvar zz = ( m33 + 1 ) / 2;\r\n\t\t\t\tvar xy = ( m12 + m21 ) / 4;\r\n\t\t\t\tvar xz = ( m13 + m31 ) / 4;\r\n\t\t\t\tvar yz = ( m23 + m32 ) / 4;\r\n\t\r\n\t\t\t\tif ( ( xx > yy ) && ( xx > zz ) ) { // m11 is the largest diagonal term\r\n\t\r\n\t\t\t\t\tif ( xx < epsilon ) {\r\n\t\r\n\t\t\t\t\t\tx = 0;\r\n\t\t\t\t\t\ty = 0.707106781;\r\n\t\t\t\t\t\tz = 0.707106781;\r\n\t\r\n\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\tx = Math.sqrt( xx );\r\n\t\t\t\t\t\ty = xy / x;\r\n\t\t\t\t\t\tz = xz / x;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t} else if ( yy > zz ) { // m22 is the largest diagonal term\r\n\t\r\n\t\t\t\t\tif ( yy < epsilon ) {\r\n\t\r\n\t\t\t\t\t\tx = 0.707106781;\r\n\t\t\t\t\t\ty = 0;\r\n\t\t\t\t\t\tz = 0.707106781;\r\n\t\r\n\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\ty = Math.sqrt( yy );\r\n\t\t\t\t\t\tx = xy / y;\r\n\t\t\t\t\t\tz = yz / y;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t} else { // m33 is the largest diagonal term so base result on this\r\n\t\r\n\t\t\t\t\tif ( zz < epsilon ) {\r\n\t\r\n\t\t\t\t\t\tx = 0.707106781;\r\n\t\t\t\t\t\ty = 0.707106781;\r\n\t\t\t\t\t\tz = 0;\r\n\t\r\n\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\tz = Math.sqrt( zz );\r\n\t\t\t\t\t\tx = xz / z;\r\n\t\t\t\t\t\ty = yz / z;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tthis.set( x, y, z, angle );\r\n\t\r\n\t\t\t\treturn this; // return 180 deg rotation\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// as we have reached here there are no singularities so we can handle normally\r\n\t\r\n\t\t\tvar s = Math.sqrt( ( m32 - m23 ) * ( m32 - m23 )\r\n\t\t\t\t\t\t\t  + ( m13 - m31 ) * ( m13 - m31 )\r\n\t\t\t\t\t\t\t  + ( m21 - m12 ) * ( m21 - m12 ) ); // used to normalize\r\n\t\r\n\t\t\tif ( Math.abs( s ) < 0.001 ) s = 1;\r\n\t\r\n\t\t\t// prevent divide by zero, should not happen if matrix is orthogonal and should be\r\n\t\t\t// caught by singularity test above, but I've left it in just in case\r\n\t\r\n\t\t\tthis.x = ( m32 - m23 ) / s;\r\n\t\t\tthis.y = ( m13 - m31 ) / s;\r\n\t\t\tthis.z = ( m21 - m12 ) / s;\r\n\t\t\tthis.w = Math.acos( ( m11 + m22 + m33 - 1 ) / 2 );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tmin: function ( v ) {\r\n\t\r\n\t\t\tif ( this.x > v.x ) {\r\n\t\r\n\t\t\t\tthis.x = v.x;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( this.y > v.y ) {\r\n\t\r\n\t\t\t\tthis.y = v.y;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( this.z > v.z ) {\r\n\t\r\n\t\t\t\tthis.z = v.z;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( this.w > v.w ) {\r\n\t\r\n\t\t\t\tthis.w = v.w;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tmax: function ( v ) {\r\n\t\r\n\t\t\tif ( this.x < v.x ) {\r\n\t\r\n\t\t\t\tthis.x = v.x;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( this.y < v.y ) {\r\n\t\r\n\t\t\t\tthis.y = v.y;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( this.z < v.z ) {\r\n\t\r\n\t\t\t\tthis.z = v.z;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( this.w < v.w ) {\r\n\t\r\n\t\t\t\tthis.w = v.w;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tclamp: function ( min, max ) {\r\n\t\r\n\t\t\t// This function assumes min < max, if this assumption isn't true it will not operate correctly\r\n\t\r\n\t\t\tif ( this.x < min.x ) {\r\n\t\r\n\t\t\t\tthis.x = min.x;\r\n\t\r\n\t\t\t} else if ( this.x > max.x ) {\r\n\t\r\n\t\t\t\tthis.x = max.x;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( this.y < min.y ) {\r\n\t\r\n\t\t\t\tthis.y = min.y;\r\n\t\r\n\t\t\t} else if ( this.y > max.y ) {\r\n\t\r\n\t\t\t\tthis.y = max.y;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( this.z < min.z ) {\r\n\t\r\n\t\t\t\tthis.z = min.z;\r\n\t\r\n\t\t\t} else if ( this.z > max.z ) {\r\n\t\r\n\t\t\t\tthis.z = max.z;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( this.w < min.w ) {\r\n\t\r\n\t\t\t\tthis.w = min.w;\r\n\t\r\n\t\t\t} else if ( this.w > max.w ) {\r\n\t\r\n\t\t\t\tthis.w = max.w;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tclampScalar: ( function () {\r\n\t\r\n\t\t\tvar min, max;\r\n\t\r\n\t\t\treturn function ( minVal, maxVal ) {\r\n\t\r\n\t\t\t\tif ( min === undefined ) {\r\n\t\r\n\t\t\t\t\tmin = new THREE.Vector4();\r\n\t\t\t\t\tmax = new THREE.Vector4();\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tmin.set( minVal, minVal, minVal, minVal );\r\n\t\t\t\tmax.set( maxVal, maxVal, maxVal, maxVal );\r\n\t\r\n\t\t\t\treturn this.clamp( min, max );\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t} )(),\r\n\t\r\n\t  floor: function () {\r\n\t\r\n\t\t\tthis.x = Math.floor( this.x );\r\n\t\t\tthis.y = Math.floor( this.y );\r\n\t\t\tthis.z = Math.floor( this.z );\r\n\t\t\tthis.w = Math.floor( this.w );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t  },\r\n\t\r\n\t  ceil: function () {\r\n\t\r\n\t\t\tthis.x = Math.ceil( this.x );\r\n\t\t\tthis.y = Math.ceil( this.y );\r\n\t\t\tthis.z = Math.ceil( this.z );\r\n\t\t\tthis.w = Math.ceil( this.w );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t  },\r\n\t\r\n\t  round: function () {\r\n\t\r\n\t\t\tthis.x = Math.round( this.x );\r\n\t\t\tthis.y = Math.round( this.y );\r\n\t\t\tthis.z = Math.round( this.z );\r\n\t\t\tthis.w = Math.round( this.w );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t  },\r\n\t\r\n\t  roundToZero: function () {\r\n\t\r\n\t\t\tthis.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );\r\n\t\t\tthis.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );\r\n\t\t\tthis.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );\r\n\t\t\tthis.w = ( this.w < 0 ) ? Math.ceil( this.w ) : Math.floor( this.w );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t  },\r\n\t\r\n\t\tnegate: function () {\r\n\t\r\n\t\t\tthis.x = - this.x;\r\n\t\t\tthis.y = - this.y;\r\n\t\t\tthis.z = - this.z;\r\n\t\t\tthis.w = - this.w;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tdot: function ( v ) {\r\n\t\r\n\t\t\treturn this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tlengthSq: function () {\r\n\t\r\n\t\t\treturn this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tlength: function () {\r\n\t\r\n\t\t\treturn Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tlengthManhattan: function () {\r\n\t\r\n\t\t\treturn Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z ) + Math.abs( this.w );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tnormalize: function () {\r\n\t\r\n\t\t\treturn this.divideScalar( this.length() );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetLength: function ( l ) {\r\n\t\r\n\t\t\tvar oldLength = this.length();\r\n\t\r\n\t\t\tif ( oldLength !== 0 && l !== oldLength ) {\r\n\t\r\n\t\t\t\tthis.multiplyScalar( l / oldLength );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tlerp: function ( v, alpha ) {\r\n\t\r\n\t\t\tthis.x += ( v.x - this.x ) * alpha;\r\n\t\t\tthis.y += ( v.y - this.y ) * alpha;\r\n\t\t\tthis.z += ( v.z - this.z ) * alpha;\r\n\t\t\tthis.w += ( v.w - this.w ) * alpha;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tlerpVectors: function ( v1, v2, alpha ) {\r\n\t\r\n\t\t\tthis.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tequals: function ( v ) {\r\n\t\r\n\t\t\treturn ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) && ( v.w === this.w ) );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tfromArray: function ( array, offset ) {\r\n\t\r\n\t\t\tif ( offset === undefined ) offset = 0;\r\n\t\r\n\t\t\tthis.x = array[ offset ];\r\n\t\t\tthis.y = array[ offset + 1 ];\r\n\t\t\tthis.z = array[ offset + 2 ];\r\n\t\t\tthis.w = array[ offset + 3 ];\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\ttoArray: function ( array, offset ) {\r\n\t\r\n\t\t\tif ( array === undefined ) array = [];\r\n\t\t\tif ( offset === undefined ) offset = 0;\r\n\t\r\n\t\t\tarray[ offset ] = this.x;\r\n\t\t\tarray[ offset + 1 ] = this.y;\r\n\t\t\tarray[ offset + 2 ] = this.z;\r\n\t\t\tarray[ offset + 3 ] = this.w;\r\n\t\r\n\t\t\treturn array;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tfromAttribute: function ( attribute, index, offset ) {\r\n\t\r\n\t\t\tif ( offset === undefined ) offset = 0;\r\n\t\r\n\t\t\tindex = index * attribute.itemSize + offset;\r\n\t\r\n\t\t\tthis.x = attribute.array[ index ];\r\n\t\t\tthis.y = attribute.array[ index + 1 ];\r\n\t\t\tthis.z = attribute.array[ index + 2 ];\r\n\t\t\tthis.w = attribute.array[ index + 3 ];\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tclone: function () {\r\n\t\r\n\t\t\treturn new THREE.Vector4( this.x, this.y, this.z, this.w );\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/math/Euler.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t * @author WestLangley / http://github.com/WestLangley\r\n\t * @author bhouston / http://exocortex.com\r\n\t */\r\n\t\r\n\tTHREE.Euler = function ( x, y, z, order ) {\r\n\t\r\n\t\tthis._x = x || 0;\r\n\t\tthis._y = y || 0;\r\n\t\tthis._z = z || 0;\r\n\t\tthis._order = order || THREE.Euler.DefaultOrder;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Euler.RotationOrders = [ 'XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX' ];\r\n\t\r\n\tTHREE.Euler.DefaultOrder = 'XYZ';\r\n\t\r\n\tTHREE.Euler.prototype = {\r\n\t\r\n\t\tconstructor: THREE.Euler,\r\n\t\r\n\t\t_x: 0, _y: 0, _z: 0, _order: THREE.Euler.DefaultOrder,\r\n\t\r\n\t\tget x () {\r\n\t\r\n\t\t\treturn this._x;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tset x ( value ) {\r\n\t\r\n\t\t\tthis._x = value;\r\n\t\t\tthis.onChangeCallback();\r\n\t\r\n\t\t},\r\n\t\r\n\t\tget y () {\r\n\t\r\n\t\t\treturn this._y;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tset y ( value ) {\r\n\t\r\n\t\t\tthis._y = value;\r\n\t\t\tthis.onChangeCallback();\r\n\t\r\n\t\t},\r\n\t\r\n\t\tget z () {\r\n\t\r\n\t\t\treturn this._z;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tset z ( value ) {\r\n\t\r\n\t\t\tthis._z = value;\r\n\t\t\tthis.onChangeCallback();\r\n\t\r\n\t\t},\r\n\t\r\n\t\tget order () {\r\n\t\r\n\t\t\treturn this._order;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tset order ( value ) {\r\n\t\r\n\t\t\tthis._order = value;\r\n\t\t\tthis.onChangeCallback();\r\n\t\r\n\t\t},\r\n\t\r\n\t\tset: function ( x, y, z, order ) {\r\n\t\r\n\t\t\tthis._x = x;\r\n\t\t\tthis._y = y;\r\n\t\t\tthis._z = z;\r\n\t\t\tthis._order = order || this._order;\r\n\t\r\n\t\t\tthis.onChangeCallback();\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcopy: function ( euler ) {\r\n\t\r\n\t\t\tthis._x = euler._x;\r\n\t\t\tthis._y = euler._y;\r\n\t\t\tthis._z = euler._z;\r\n\t\t\tthis._order = euler._order;\r\n\t\r\n\t\t\tthis.onChangeCallback();\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetFromRotationMatrix: function ( m, order, update ) {\r\n\t\r\n\t\t\tvar clamp = THREE.Math.clamp;\r\n\t\r\n\t\t\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\r\n\t\r\n\t\t\tvar te = m.elements;\r\n\t\t\tvar m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ];\r\n\t\t\tvar m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ];\r\n\t\t\tvar m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];\r\n\t\r\n\t\t\torder = order || this._order;\r\n\t\r\n\t\t\tif ( order === 'XYZ' ) {\r\n\t\r\n\t\t\t\tthis._y = Math.asin( clamp( m13, - 1, 1 ) );\r\n\t\r\n\t\t\t\tif ( Math.abs( m13 ) < 0.99999 ) {\r\n\t\r\n\t\t\t\t\tthis._x = Math.atan2( - m23, m33 );\r\n\t\t\t\t\tthis._z = Math.atan2( - m12, m11 );\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tthis._x = Math.atan2( m32, m22 );\r\n\t\t\t\t\tthis._z = 0;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t} else if ( order === 'YXZ' ) {\r\n\t\r\n\t\t\t\tthis._x = Math.asin( - clamp( m23, - 1, 1 ) );\r\n\t\r\n\t\t\t\tif ( Math.abs( m23 ) < 0.99999 ) {\r\n\t\r\n\t\t\t\t\tthis._y = Math.atan2( m13, m33 );\r\n\t\t\t\t\tthis._z = Math.atan2( m21, m22 );\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tthis._y = Math.atan2( - m31, m11 );\r\n\t\t\t\t\tthis._z = 0;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t} else if ( order === 'ZXY' ) {\r\n\t\r\n\t\t\t\tthis._x = Math.asin( clamp( m32, - 1, 1 ) );\r\n\t\r\n\t\t\t\tif ( Math.abs( m32 ) < 0.99999 ) {\r\n\t\r\n\t\t\t\t\tthis._y = Math.atan2( - m31, m33 );\r\n\t\t\t\t\tthis._z = Math.atan2( - m12, m22 );\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tthis._y = 0;\r\n\t\t\t\t\tthis._z = Math.atan2( m21, m11 );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t} else if ( order === 'ZYX' ) {\r\n\t\r\n\t\t\t\tthis._y = Math.asin( - clamp( m31, - 1, 1 ) );\r\n\t\r\n\t\t\t\tif ( Math.abs( m31 ) < 0.99999 ) {\r\n\t\r\n\t\t\t\t\tthis._x = Math.atan2( m32, m33 );\r\n\t\t\t\t\tthis._z = Math.atan2( m21, m11 );\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tthis._x = 0;\r\n\t\t\t\t\tthis._z = Math.atan2( - m12, m22 );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t} else if ( order === 'YZX' ) {\r\n\t\r\n\t\t\t\tthis._z = Math.asin( clamp( m21, - 1, 1 ) );\r\n\t\r\n\t\t\t\tif ( Math.abs( m21 ) < 0.99999 ) {\r\n\t\r\n\t\t\t\t\tthis._x = Math.atan2( - m23, m22 );\r\n\t\t\t\t\tthis._y = Math.atan2( - m31, m11 );\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tthis._x = 0;\r\n\t\t\t\t\tthis._y = Math.atan2( m13, m33 );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t} else if ( order === 'XZY' ) {\r\n\t\r\n\t\t\t\tthis._z = Math.asin( - clamp( m12, - 1, 1 ) );\r\n\t\r\n\t\t\t\tif ( Math.abs( m12 ) < 0.99999 ) {\r\n\t\r\n\t\t\t\t\tthis._x = Math.atan2( m32, m22 );\r\n\t\t\t\t\tthis._y = Math.atan2( m13, m11 );\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tthis._x = Math.atan2( - m23, m33 );\r\n\t\t\t\t\tthis._y = 0;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\tTHREE.warn( 'THREE.Euler: .setFromRotationMatrix() given unsupported order: ' + order )\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tthis._order = order;\r\n\t\r\n\t\t\tif ( update !== false ) this.onChangeCallback();\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetFromQuaternion: function () {\r\n\t\r\n\t\t\tvar matrix;\r\n\t\r\n\t\t\treturn function ( q, order, update ) {\r\n\t\r\n\t\t\t\tif ( matrix === undefined ) matrix = new THREE.Matrix4();\r\n\t\t\t\tmatrix.makeRotationFromQuaternion( q );\r\n\t\t\t\tthis.setFromRotationMatrix( matrix, order, update );\r\n\t\r\n\t\t\t\treturn this;\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tsetFromVector3: function ( v, order ) {\r\n\t\r\n\t\t\treturn this.set( v.x, v.y, v.z, order || this._order );\r\n\t\r\n\t\t},\r\n\t\r\n\t\treorder: function () {\r\n\t\r\n\t\t\t// WARNING: this discards revolution information -bhouston\r\n\t\r\n\t\t\tvar q = new THREE.Quaternion();\r\n\t\r\n\t\t\treturn function ( newOrder ) {\r\n\t\r\n\t\t\t\tq.setFromEuler( this );\r\n\t\t\t\tthis.setFromQuaternion( q, newOrder );\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tequals: function ( euler ) {\r\n\t\r\n\t\t\treturn ( euler._x === this._x ) && ( euler._y === this._y ) && ( euler._z === this._z ) && ( euler._order === this._order );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tfromArray: function ( array ) {\r\n\t\r\n\t\t\tthis._x = array[ 0 ];\r\n\t\t\tthis._y = array[ 1 ];\r\n\t\t\tthis._z = array[ 2 ];\r\n\t\t\tif ( array[ 3 ] !== undefined ) this._order = array[ 3 ];\r\n\t\r\n\t\t\tthis.onChangeCallback();\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\ttoArray: function ( array, offset ) {\r\n\t\r\n\t\t\tif ( array === undefined ) array = [];\r\n\t\t\tif ( offset === undefined ) offset = 0;\r\n\t\r\n\t\t\tarray[ offset ] = this._x;\r\n\t\t\tarray[ offset + 1 ] = this._y;\r\n\t\t\tarray[ offset + 2 ] = this._z;\r\n\t\t\tarray[ offset + 3 ] = this._order;\r\n\t\r\n\t\t\treturn array;\r\n\t\t},\r\n\t\r\n\t\ttoVector3: function ( optionalResult ) {\r\n\t\r\n\t\t\tif ( optionalResult ) {\r\n\t\r\n\t\t\t\treturn optionalResult.set( this._x, this._y, this._z );\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\treturn new THREE.Vector3( this._x, this._y, this._z );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t},\r\n\t\r\n\t\tonChange: function ( callback ) {\r\n\t\r\n\t\t\tthis.onChangeCallback = callback;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tonChangeCallback: function () {},\r\n\t\r\n\t\tclone: function () {\r\n\t\r\n\t\t\treturn new THREE.Euler( this._x, this._y, this._z, this._order );\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/math/Line3.js\r\n\t\r\n\t/**\r\n\t * @author bhouston / http://exocortex.com\r\n\t */\r\n\t\r\n\tTHREE.Line3 = function ( start, end ) {\r\n\t\r\n\t\tthis.start = ( start !== undefined ) ? start : new THREE.Vector3();\r\n\t\tthis.end = ( end !== undefined ) ? end : new THREE.Vector3();\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Line3.prototype = {\r\n\t\r\n\t\tconstructor: THREE.Line3,\r\n\t\r\n\t\tset: function ( start, end ) {\r\n\t\r\n\t\t\tthis.start.copy( start );\r\n\t\t\tthis.end.copy( end );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcopy: function ( line ) {\r\n\t\r\n\t\t\tthis.start.copy( line.start );\r\n\t\t\tthis.end.copy( line.end );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcenter: function ( optionalTarget ) {\r\n\t\r\n\t\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\t\t\treturn result.addVectors( this.start, this.end ).multiplyScalar( 0.5 );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tdelta: function ( optionalTarget ) {\r\n\t\r\n\t\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\t\t\treturn result.subVectors( this.end, this.start );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tdistanceSq: function () {\r\n\t\r\n\t\t\treturn this.start.distanceToSquared( this.end );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tdistance: function () {\r\n\t\r\n\t\t\treturn this.start.distanceTo( this.end );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tat: function ( t, optionalTarget ) {\r\n\t\r\n\t\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\t\r\n\t\t\treturn this.delta( result ).multiplyScalar( t ).add( this.start );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tclosestPointToPointParameter: function () {\r\n\t\r\n\t\t\tvar startP = new THREE.Vector3();\r\n\t\t\tvar startEnd = new THREE.Vector3();\r\n\t\r\n\t\t\treturn function ( point, clampToLine ) {\r\n\t\r\n\t\t\t\tstartP.subVectors( point, this.start );\r\n\t\t\t\tstartEnd.subVectors( this.end, this.start );\r\n\t\r\n\t\t\t\tvar startEnd2 = startEnd.dot( startEnd );\r\n\t\t\t\tvar startEnd_startP = startEnd.dot( startP );\r\n\t\r\n\t\t\t\tvar t = startEnd_startP / startEnd2;\r\n\t\r\n\t\t\t\tif ( clampToLine ) {\r\n\t\r\n\t\t\t\t\tt = THREE.Math.clamp( t, 0, 1 );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\treturn t;\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tclosestPointToPoint: function ( point, clampToLine, optionalTarget ) {\r\n\t\r\n\t\t\tvar t = this.closestPointToPointParameter( point, clampToLine );\r\n\t\r\n\t\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\t\r\n\t\t\treturn this.delta( result ).multiplyScalar( t ).add( this.start );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tapplyMatrix4: function ( matrix ) {\r\n\t\r\n\t\t\tthis.start.applyMatrix4( matrix );\r\n\t\t\tthis.end.applyMatrix4( matrix );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tequals: function ( line ) {\r\n\t\r\n\t\t\treturn line.start.equals( this.start ) && line.end.equals( this.end );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tclone: function () {\r\n\t\r\n\t\t\treturn new THREE.Line3().copy( this );\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/math/Box2.js\r\n\t\r\n\t/**\r\n\t * @author bhouston / http://exocortex.com\r\n\t */\r\n\t\r\n\tTHREE.Box2 = function ( min, max ) {\r\n\t\r\n\t\tthis.min = ( min !== undefined ) ? min : new THREE.Vector2( Infinity, Infinity );\r\n\t\tthis.max = ( max !== undefined ) ? max : new THREE.Vector2( - Infinity, - Infinity );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Box2.prototype = {\r\n\t\r\n\t\tconstructor: THREE.Box2,\r\n\t\r\n\t\tset: function ( min, max ) {\r\n\t\r\n\t\t\tthis.min.copy( min );\r\n\t\t\tthis.max.copy( max );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetFromPoints: function ( points ) {\r\n\t\r\n\t\t\tthis.makeEmpty();\r\n\t\r\n\t\t\tfor ( var i = 0, il = points.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\tthis.expandByPoint( points[ i ] )\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetFromCenterAndSize: function () {\r\n\t\r\n\t\t\tvar v1 = new THREE.Vector2();\r\n\t\r\n\t\t\treturn function ( center, size ) {\r\n\t\r\n\t\t\t\tvar halfSize = v1.copy( size ).multiplyScalar( 0.5 );\r\n\t\t\t\tthis.min.copy( center ).sub( halfSize );\r\n\t\t\t\tthis.max.copy( center ).add( halfSize );\r\n\t\r\n\t\t\t\treturn this;\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tcopy: function ( box ) {\r\n\t\r\n\t\t\tthis.min.copy( box.min );\r\n\t\t\tthis.max.copy( box.max );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tmakeEmpty: function () {\r\n\t\r\n\t\t\tthis.min.x = this.min.y = Infinity;\r\n\t\t\tthis.max.x = this.max.y = - Infinity;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tempty: function () {\r\n\t\r\n\t\t\t// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes\r\n\t\r\n\t\t\treturn ( this.max.x < this.min.x ) || ( this.max.y < this.min.y );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcenter: function ( optionalTarget ) {\r\n\t\r\n\t\t\tvar result = optionalTarget || new THREE.Vector2();\r\n\t\t\treturn result.addVectors( this.min, this.max ).multiplyScalar( 0.5 );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsize: function ( optionalTarget ) {\r\n\t\r\n\t\t\tvar result = optionalTarget || new THREE.Vector2();\r\n\t\t\treturn result.subVectors( this.max, this.min );\r\n\t\r\n\t\t},\r\n\t\r\n\t\texpandByPoint: function ( point ) {\r\n\t\r\n\t\t\tthis.min.min( point );\r\n\t\t\tthis.max.max( point );\r\n\t\r\n\t\t\treturn this;\r\n\t\t},\r\n\t\r\n\t\texpandByVector: function ( vector ) {\r\n\t\r\n\t\t\tthis.min.sub( vector );\r\n\t\t\tthis.max.add( vector );\r\n\t\r\n\t\t\treturn this;\r\n\t\t},\r\n\t\r\n\t\texpandByScalar: function ( scalar ) {\r\n\t\r\n\t\t\tthis.min.addScalar( - scalar );\r\n\t\t\tthis.max.addScalar( scalar );\r\n\t\r\n\t\t\treturn this;\r\n\t\t},\r\n\t\r\n\t\tcontainsPoint: function ( point ) {\r\n\t\r\n\t\t\tif ( point.x < this.min.x || point.x > this.max.x ||\r\n\t\t\t     point.y < this.min.y || point.y > this.max.y ) {\r\n\t\r\n\t\t\t\treturn false;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn true;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcontainsBox: function ( box ) {\r\n\t\r\n\t\t\tif ( ( this.min.x <= box.min.x ) && ( box.max.x <= this.max.x ) &&\r\n\t\t\t     ( this.min.y <= box.min.y ) && ( box.max.y <= this.max.y ) ) {\r\n\t\r\n\t\t\t\treturn true;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn false;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tgetParameter: function ( point, optionalTarget ) {\r\n\t\r\n\t\t\t// This can potentially have a divide by zero if the box\r\n\t\t\t// has a size dimension of 0.\r\n\t\r\n\t\t\tvar result = optionalTarget || new THREE.Vector2();\r\n\t\r\n\t\t\treturn result.set(\r\n\t\t\t\t( point.x - this.min.x ) / ( this.max.x - this.min.x ),\r\n\t\t\t\t( point.y - this.min.y ) / ( this.max.y - this.min.y )\r\n\t\t\t);\r\n\t\r\n\t\t},\r\n\t\r\n\t\tisIntersectionBox: function ( box ) {\r\n\t\r\n\t\t\t// using 6 splitting planes to rule out intersections.\r\n\t\r\n\t\t\tif ( box.max.x < this.min.x || box.min.x > this.max.x ||\r\n\t\t\t     box.max.y < this.min.y || box.min.y > this.max.y ) {\r\n\t\r\n\t\t\t\treturn false;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn true;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tclampPoint: function ( point, optionalTarget ) {\r\n\t\r\n\t\t\tvar result = optionalTarget || new THREE.Vector2();\r\n\t\t\treturn result.copy( point ).clamp( this.min, this.max );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tdistanceToPoint: function () {\r\n\t\r\n\t\t\tvar v1 = new THREE.Vector2();\r\n\t\r\n\t\t\treturn function ( point ) {\r\n\t\r\n\t\t\t\tvar clampedPoint = v1.copy( point ).clamp( this.min, this.max );\r\n\t\t\t\treturn clampedPoint.sub( point ).length();\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tintersect: function ( box ) {\r\n\t\r\n\t\t\tthis.min.max( box.min );\r\n\t\t\tthis.max.min( box.max );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tunion: function ( box ) {\r\n\t\r\n\t\t\tthis.min.min( box.min );\r\n\t\t\tthis.max.max( box.max );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\ttranslate: function ( offset ) {\r\n\t\r\n\t\t\tthis.min.add( offset );\r\n\t\t\tthis.max.add( offset );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tequals: function ( box ) {\r\n\t\r\n\t\t\treturn box.min.equals( this.min ) && box.max.equals( this.max );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tclone: function () {\r\n\t\r\n\t\t\treturn new THREE.Box2().copy( this );\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/math/Box3.js\r\n\t\r\n\t/**\r\n\t * @author bhouston / http://exocortex.com\r\n\t * @author WestLangley / http://github.com/WestLangley\r\n\t */\r\n\t\r\n\tTHREE.Box3 = function ( min, max ) {\r\n\t\r\n\t\tthis.min = ( min !== undefined ) ? min : new THREE.Vector3( Infinity, Infinity, Infinity );\r\n\t\tthis.max = ( max !== undefined ) ? max : new THREE.Vector3( - Infinity, - Infinity, - Infinity );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Box3.prototype = {\r\n\t\r\n\t\tconstructor: THREE.Box3,\r\n\t\r\n\t\tset: function ( min, max ) {\r\n\t\r\n\t\t\tthis.min.copy( min );\r\n\t\t\tthis.max.copy( max );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetFromPoints: function ( points ) {\r\n\t\r\n\t\t\tthis.makeEmpty();\r\n\t\r\n\t\t\tfor ( var i = 0, il = points.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\tthis.expandByPoint( points[ i ] )\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetFromCenterAndSize: function () {\r\n\t\r\n\t\t\tvar v1 = new THREE.Vector3();\r\n\t\r\n\t\t\treturn function ( center, size ) {\r\n\t\r\n\t\t\t\tvar halfSize = v1.copy( size ).multiplyScalar( 0.5 );\r\n\t\r\n\t\t\t\tthis.min.copy( center ).sub( halfSize );\r\n\t\t\t\tthis.max.copy( center ).add( halfSize );\r\n\t\r\n\t\t\t\treturn this;\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tsetFromObject: function () {\r\n\t\r\n\t\t\t// Computes the world-axis-aligned bounding box of an object (including its children),\r\n\t\t\t// accounting for both the object's, and childrens', world transforms\r\n\t\r\n\t\t\tvar v1 = new THREE.Vector3();\r\n\t\r\n\t\t\treturn function ( object ) {\r\n\t\r\n\t\t\t\tvar scope = this;\r\n\t\r\n\t\t\t\tobject.updateMatrixWorld( true );\r\n\t\r\n\t\t\t\tthis.makeEmpty();\r\n\t\r\n\t\t\t\tobject.traverse( function ( node ) {\r\n\t\r\n\t\t\t\t\tvar geometry = node.geometry;\r\n\t\r\n\t\t\t\t\tif ( geometry !== undefined ) {\r\n\t\r\n\t\t\t\t\t\tif ( geometry instanceof THREE.Geometry ) {\r\n\t\r\n\t\t\t\t\t\t\tvar vertices = geometry.vertices;\r\n\t\r\n\t\t\t\t\t\t\tfor ( var i = 0, il = vertices.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\t\t\t\t\tv1.copy( vertices[ i ] );\r\n\t\r\n\t\t\t\t\t\t\t\tv1.applyMatrix4( node.matrixWorld );\r\n\t\r\n\t\t\t\t\t\t\t\tscope.expandByPoint( v1 );\r\n\t\r\n\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t} else if ( geometry instanceof THREE.BufferGeometry && geometry.attributes[ 'position' ] !== undefined ) {\r\n\t\r\n\t\t\t\t\t\t\tvar positions = geometry.attributes[ 'position' ].array;\r\n\t\r\n\t\t\t\t\t\t\tfor ( var i = 0, il = positions.length; i < il; i += 3 ) {\r\n\t\r\n\t\t\t\t\t\t\t\tv1.set( positions[ i ], positions[ i + 1 ], positions[ i + 2 ] );\r\n\t\r\n\t\t\t\t\t\t\t\tv1.applyMatrix4( node.matrixWorld );\r\n\t\r\n\t\t\t\t\t\t\t\tscope.expandByPoint( v1 );\r\n\t\r\n\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t} );\r\n\t\r\n\t\t\t\treturn this;\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tcopy: function ( box ) {\r\n\t\r\n\t\t\tthis.min.copy( box.min );\r\n\t\t\tthis.max.copy( box.max );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tmakeEmpty: function () {\r\n\t\r\n\t\t\tthis.min.x = this.min.y = this.min.z = Infinity;\r\n\t\t\tthis.max.x = this.max.y = this.max.z = - Infinity;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tempty: function () {\r\n\t\r\n\t\t\t// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes\r\n\t\r\n\t\t\treturn ( this.max.x < this.min.x ) || ( this.max.y < this.min.y ) || ( this.max.z < this.min.z );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcenter: function ( optionalTarget ) {\r\n\t\r\n\t\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\t\t\treturn result.addVectors( this.min, this.max ).multiplyScalar( 0.5 );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsize: function ( optionalTarget ) {\r\n\t\r\n\t\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\t\t\treturn result.subVectors( this.max, this.min );\r\n\t\r\n\t\t},\r\n\t\r\n\t\texpandByPoint: function ( point ) {\r\n\t\r\n\t\t\tthis.min.min( point );\r\n\t\t\tthis.max.max( point );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\texpandByVector: function ( vector ) {\r\n\t\r\n\t\t\tthis.min.sub( vector );\r\n\t\t\tthis.max.add( vector );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\texpandByScalar: function ( scalar ) {\r\n\t\r\n\t\t\tthis.min.addScalar( - scalar );\r\n\t\t\tthis.max.addScalar( scalar );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcontainsPoint: function ( point ) {\r\n\t\r\n\t\t\tif ( point.x < this.min.x || point.x > this.max.x ||\r\n\t\t\t     point.y < this.min.y || point.y > this.max.y ||\r\n\t\t\t     point.z < this.min.z || point.z > this.max.z ) {\r\n\t\r\n\t\t\t\treturn false;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn true;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcontainsBox: function ( box ) {\r\n\t\r\n\t\t\tif ( ( this.min.x <= box.min.x ) && ( box.max.x <= this.max.x ) &&\r\n\t\t\t\t ( this.min.y <= box.min.y ) && ( box.max.y <= this.max.y ) &&\r\n\t\t\t\t ( this.min.z <= box.min.z ) && ( box.max.z <= this.max.z ) ) {\r\n\t\r\n\t\t\t\treturn true;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn false;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tgetParameter: function ( point, optionalTarget ) {\r\n\t\r\n\t\t\t// This can potentially have a divide by zero if the box\r\n\t\t\t// has a size dimension of 0.\r\n\t\r\n\t\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\t\r\n\t\t\treturn result.set(\r\n\t\t\t\t( point.x - this.min.x ) / ( this.max.x - this.min.x ),\r\n\t\t\t\t( point.y - this.min.y ) / ( this.max.y - this.min.y ),\r\n\t\t\t\t( point.z - this.min.z ) / ( this.max.z - this.min.z )\r\n\t\t\t);\r\n\t\r\n\t\t},\r\n\t\r\n\t\tisIntersectionBox: function ( box ) {\r\n\t\r\n\t\t\t// using 6 splitting planes to rule out intersections.\r\n\t\r\n\t\t\tif ( box.max.x < this.min.x || box.min.x > this.max.x ||\r\n\t\t\t     box.max.y < this.min.y || box.min.y > this.max.y ||\r\n\t\t\t     box.max.z < this.min.z || box.min.z > this.max.z ) {\r\n\t\r\n\t\t\t\treturn false;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn true;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tclampPoint: function ( point, optionalTarget ) {\r\n\t\r\n\t\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\t\t\treturn result.copy( point ).clamp( this.min, this.max );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tdistanceToPoint: function () {\r\n\t\r\n\t\t\tvar v1 = new THREE.Vector3();\r\n\t\r\n\t\t\treturn function ( point ) {\r\n\t\r\n\t\t\t\tvar clampedPoint = v1.copy( point ).clamp( this.min, this.max );\r\n\t\t\t\treturn clampedPoint.sub( point ).length();\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tgetBoundingSphere: function () {\r\n\t\r\n\t\t\tvar v1 = new THREE.Vector3();\r\n\t\r\n\t\t\treturn function ( optionalTarget ) {\r\n\t\r\n\t\t\t\tvar result = optionalTarget || new THREE.Sphere();\r\n\t\r\n\t\t\t\tresult.center = this.center();\r\n\t\t\t\tresult.radius = this.size( v1 ).length() * 0.5;\r\n\t\r\n\t\t\t\treturn result;\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tintersect: function ( box ) {\r\n\t\r\n\t\t\tthis.min.max( box.min );\r\n\t\t\tthis.max.min( box.max );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tunion: function ( box ) {\r\n\t\r\n\t\t\tthis.min.min( box.min );\r\n\t\t\tthis.max.max( box.max );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tapplyMatrix4: function () {\r\n\t\r\n\t\t\tvar points = [\r\n\t\t\t\tnew THREE.Vector3(),\r\n\t\t\t\tnew THREE.Vector3(),\r\n\t\t\t\tnew THREE.Vector3(),\r\n\t\t\t\tnew THREE.Vector3(),\r\n\t\t\t\tnew THREE.Vector3(),\r\n\t\t\t\tnew THREE.Vector3(),\r\n\t\t\t\tnew THREE.Vector3(),\r\n\t\t\t\tnew THREE.Vector3()\r\n\t\t\t];\r\n\t\r\n\t\t\treturn function ( matrix ) {\r\n\t\r\n\t\t\t\t// NOTE: I am using a binary pattern to specify all 2^3 combinations below\r\n\t\t\t\tpoints[ 0 ].set( this.min.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 000\r\n\t\t\t\tpoints[ 1 ].set( this.min.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 001\r\n\t\t\t\tpoints[ 2 ].set( this.min.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 010\r\n\t\t\t\tpoints[ 3 ].set( this.min.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 011\r\n\t\t\t\tpoints[ 4 ].set( this.max.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 100\r\n\t\t\t\tpoints[ 5 ].set( this.max.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 101\r\n\t\t\t\tpoints[ 6 ].set( this.max.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 110\r\n\t\t\t\tpoints[ 7 ].set( this.max.x, this.max.y, this.max.z ).applyMatrix4( matrix );  // 111\r\n\t\r\n\t\t\t\tthis.makeEmpty();\r\n\t\t\t\tthis.setFromPoints( points );\r\n\t\r\n\t\t\t\treturn this;\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\ttranslate: function ( offset ) {\r\n\t\r\n\t\t\tthis.min.add( offset );\r\n\t\t\tthis.max.add( offset );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tequals: function ( box ) {\r\n\t\r\n\t\t\treturn box.min.equals( this.min ) && box.max.equals( this.max );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tclone: function () {\r\n\t\r\n\t\t\treturn new THREE.Box3().copy( this );\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/math/Matrix3.js\r\n\t\r\n\t/**\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t * @author WestLangley / http://github.com/WestLangley\r\n\t * @author bhouston / http://exocortex.com\r\n\t */\r\n\t\r\n\tTHREE.Matrix3 = function () {\r\n\t\r\n\t\tthis.elements = new Float32Array( [\r\n\t\r\n\t\t\t1, 0, 0,\r\n\t\t\t0, 1, 0,\r\n\t\t\t0, 0, 1\r\n\t\r\n\t\t] );\r\n\t\r\n\t\tif ( arguments.length > 0 ) {\r\n\t\r\n\t\t\tTHREE.error( 'THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.' );\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Matrix3.prototype = {\r\n\t\r\n\t\tconstructor: THREE.Matrix3,\r\n\t\r\n\t\tset: function ( n11, n12, n13, n21, n22, n23, n31, n32, n33 ) {\r\n\t\r\n\t\t\tvar te = this.elements;\r\n\t\r\n\t\t\tte[ 0 ] = n11; te[ 3 ] = n12; te[ 6 ] = n13;\r\n\t\t\tte[ 1 ] = n21; te[ 4 ] = n22; te[ 7 ] = n23;\r\n\t\t\tte[ 2 ] = n31; te[ 5 ] = n32; te[ 8 ] = n33;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tidentity: function () {\r\n\t\r\n\t\t\tthis.set(\r\n\t\r\n\t\t\t\t1, 0, 0,\r\n\t\t\t\t0, 1, 0,\r\n\t\t\t\t0, 0, 1\r\n\t\r\n\t\t\t);\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcopy: function ( m ) {\r\n\t\r\n\t\t\tvar me = m.elements;\r\n\t\r\n\t\t\tthis.set(\r\n\t\r\n\t\t\t\tme[ 0 ], me[ 3 ], me[ 6 ],\r\n\t\t\t\tme[ 1 ], me[ 4 ], me[ 7 ],\r\n\t\t\t\tme[ 2 ], me[ 5 ], me[ 8 ]\r\n\t\r\n\t\t\t);\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tmultiplyVector3: function ( vector ) {\r\n\t\r\n\t\t\tTHREE.warn( 'THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.' );\r\n\t\t\treturn vector.applyMatrix3( this );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tmultiplyVector3Array: function ( a ) {\r\n\t\r\n\t\t\tTHREE.warn( 'THREE.Matrix3: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead.' );\r\n\t\t\treturn this.applyToVector3Array( a );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tapplyToVector3Array: function () {\r\n\t\r\n\t\t\tvar v1 = new THREE.Vector3();\r\n\t\r\n\t\t\treturn function ( array, offset, length ) {\r\n\t\r\n\t\t\t\tif ( offset === undefined ) offset = 0;\r\n\t\t\t\tif ( length === undefined ) length = array.length;\r\n\t\r\n\t\t\t\tfor ( var i = 0, j = offset; i < length; i += 3, j += 3 ) {\r\n\t\r\n\t\t\t\t\tv1.x = array[ j ];\r\n\t\t\t\t\tv1.y = array[ j + 1 ];\r\n\t\t\t\t\tv1.z = array[ j + 2 ];\r\n\t\r\n\t\t\t\t\tv1.applyMatrix3( this );\r\n\t\r\n\t\t\t\t\tarray[ j ]     = v1.x;\r\n\t\t\t\t\tarray[ j + 1 ] = v1.y;\r\n\t\t\t\t\tarray[ j + 2 ] = v1.z;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\treturn array;\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tmultiplyScalar: function ( s ) {\r\n\t\r\n\t\t\tvar te = this.elements;\r\n\t\r\n\t\t\tte[ 0 ] *= s; te[ 3 ] *= s; te[ 6 ] *= s;\r\n\t\t\tte[ 1 ] *= s; te[ 4 ] *= s; te[ 7 ] *= s;\r\n\t\t\tte[ 2 ] *= s; te[ 5 ] *= s; te[ 8 ] *= s;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tdeterminant: function () {\r\n\t\r\n\t\t\tvar te = this.elements;\r\n\t\r\n\t\t\tvar a = te[ 0 ], b = te[ 1 ], c = te[ 2 ],\r\n\t\t\t\td = te[ 3 ], e = te[ 4 ], f = te[ 5 ],\r\n\t\t\t\tg = te[ 6 ], h = te[ 7 ], i = te[ 8 ];\r\n\t\r\n\t\t\treturn a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tgetInverse: function ( matrix, throwOnInvertible ) {\r\n\t\r\n\t\t\t// input: THREE.Matrix4\r\n\t\t\t// ( based on http://code.google.com/p/webgl-mjs/ )\r\n\t\r\n\t\t\tvar me = matrix.elements;\r\n\t\t\tvar te = this.elements;\r\n\t\r\n\t\t\tte[ 0 ] =   me[ 10 ] * me[ 5 ] - me[ 6 ] * me[ 9 ];\r\n\t\t\tte[ 1 ] = - me[ 10 ] * me[ 1 ] + me[ 2 ] * me[ 9 ];\r\n\t\t\tte[ 2 ] =   me[ 6 ] * me[ 1 ] - me[ 2 ] * me[ 5 ];\r\n\t\t\tte[ 3 ] = - me[ 10 ] * me[ 4 ] + me[ 6 ] * me[ 8 ];\r\n\t\t\tte[ 4 ] =   me[ 10 ] * me[ 0 ] - me[ 2 ] * me[ 8 ];\r\n\t\t\tte[ 5 ] = - me[ 6 ] * me[ 0 ] + me[ 2 ] * me[ 4 ];\r\n\t\t\tte[ 6 ] =   me[ 9 ] * me[ 4 ] - me[ 5 ] * me[ 8 ];\r\n\t\t\tte[ 7 ] = - me[ 9 ] * me[ 0 ] + me[ 1 ] * me[ 8 ];\r\n\t\t\tte[ 8 ] =   me[ 5 ] * me[ 0 ] - me[ 1 ] * me[ 4 ];\r\n\t\r\n\t\t\tvar det = me[ 0 ] * te[ 0 ] + me[ 1 ] * te[ 3 ] + me[ 2 ] * te[ 6 ];\r\n\t\r\n\t\t\t// no inverse\r\n\t\r\n\t\t\tif ( det === 0 ) {\r\n\t\r\n\t\t\t\tvar msg = \"Matrix3.getInverse(): can't invert matrix, determinant is 0\";\r\n\t\r\n\t\t\t\tif ( throwOnInvertible || false ) {\r\n\t\r\n\t\t\t\t\tthrow new Error( msg );\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tTHREE.warn( msg );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tthis.identity();\r\n\t\r\n\t\t\t\treturn this;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tthis.multiplyScalar( 1.0 / det );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\ttranspose: function () {\r\n\t\r\n\t\t\tvar tmp, m = this.elements;\r\n\t\r\n\t\t\ttmp = m[ 1 ]; m[ 1 ] = m[ 3 ]; m[ 3 ] = tmp;\r\n\t\t\ttmp = m[ 2 ]; m[ 2 ] = m[ 6 ]; m[ 6 ] = tmp;\r\n\t\t\ttmp = m[ 5 ]; m[ 5 ] = m[ 7 ]; m[ 7 ] = tmp;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tflattenToArrayOffset: function ( array, offset ) {\r\n\t\r\n\t\t\tvar te = this.elements;\r\n\t\r\n\t\t\tarray[ offset     ] = te[ 0 ];\r\n\t\t\tarray[ offset + 1 ] = te[ 1 ];\r\n\t\t\tarray[ offset + 2 ] = te[ 2 ];\r\n\t\r\n\t\t\tarray[ offset + 3 ] = te[ 3 ];\r\n\t\t\tarray[ offset + 4 ] = te[ 4 ];\r\n\t\t\tarray[ offset + 5 ] = te[ 5 ];\r\n\t\r\n\t\t\tarray[ offset + 6 ] = te[ 6 ];\r\n\t\t\tarray[ offset + 7 ] = te[ 7 ];\r\n\t\t\tarray[ offset + 8 ]  = te[ 8 ];\r\n\t\r\n\t\t\treturn array;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tgetNormalMatrix: function ( m ) {\r\n\t\r\n\t\t\t// input: THREE.Matrix4\r\n\t\r\n\t\t\tthis.getInverse( m ).transpose();\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\ttransposeIntoArray: function ( r ) {\r\n\t\r\n\t\t\tvar m = this.elements;\r\n\t\r\n\t\t\tr[ 0 ] = m[ 0 ];\r\n\t\t\tr[ 1 ] = m[ 3 ];\r\n\t\t\tr[ 2 ] = m[ 6 ];\r\n\t\t\tr[ 3 ] = m[ 1 ];\r\n\t\t\tr[ 4 ] = m[ 4 ];\r\n\t\t\tr[ 5 ] = m[ 7 ];\r\n\t\t\tr[ 6 ] = m[ 2 ];\r\n\t\t\tr[ 7 ] = m[ 5 ];\r\n\t\t\tr[ 8 ] = m[ 8 ];\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tfromArray: function ( array ) {\r\n\t\r\n\t\t\tthis.elements.set( array );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\ttoArray: function () {\r\n\t\r\n\t\t\tvar te = this.elements;\r\n\t\r\n\t\t\treturn [\r\n\t\t\t\tte[ 0 ], te[ 1 ], te[ 2 ],\r\n\t\t\t\tte[ 3 ], te[ 4 ], te[ 5 ],\r\n\t\t\t\tte[ 6 ], te[ 7 ], te[ 8 ]\r\n\t\t\t];\r\n\t\r\n\t\t},\r\n\t\r\n\t\tclone: function () {\r\n\t\r\n\t\t\treturn new THREE.Matrix3().fromArray( this.elements );\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/math/Matrix4.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t * @author supereggbert / http://www.paulbrunt.co.uk/\r\n\t * @author philogb / http://blog.thejit.org/\r\n\t * @author jordi_ros / http://plattsoft.com\r\n\t * @author D1plo1d / http://github.com/D1plo1d\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t * @author mikael emtinger / http://gomo.se/\r\n\t * @author timknip / http://www.floorplanner.com/\r\n\t * @author bhouston / http://exocortex.com\r\n\t * @author WestLangley / http://github.com/WestLangley\r\n\t */\r\n\t\r\n\tTHREE.Matrix4 = function () {\r\n\t\r\n\t\tthis.elements = new Float32Array( [\r\n\t\r\n\t\t\t1, 0, 0, 0,\r\n\t\t\t0, 1, 0, 0,\r\n\t\t\t0, 0, 1, 0,\r\n\t\t\t0, 0, 0, 1\r\n\t\r\n\t\t] );\r\n\t\r\n\t\tif ( arguments.length > 0 ) {\r\n\t\r\n\t\t\tTHREE.error( 'THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.' );\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Matrix4.prototype = {\r\n\t\r\n\t\tconstructor: THREE.Matrix4,\r\n\t\r\n\t\tset: function ( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 ) {\r\n\t\r\n\t\t\tvar te = this.elements;\r\n\t\r\n\t\t\tte[ 0 ] = n11; te[ 4 ] = n12; te[ 8 ] = n13; te[ 12 ] = n14;\r\n\t\t\tte[ 1 ] = n21; te[ 5 ] = n22; te[ 9 ] = n23; te[ 13 ] = n24;\r\n\t\t\tte[ 2 ] = n31; te[ 6 ] = n32; te[ 10 ] = n33; te[ 14 ] = n34;\r\n\t\t\tte[ 3 ] = n41; te[ 7 ] = n42; te[ 11 ] = n43; te[ 15 ] = n44;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tidentity: function () {\r\n\t\r\n\t\t\tthis.set(\r\n\t\r\n\t\t\t\t1, 0, 0, 0,\r\n\t\t\t\t0, 1, 0, 0,\r\n\t\t\t\t0, 0, 1, 0,\r\n\t\t\t\t0, 0, 0, 1\r\n\t\r\n\t\t\t);\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcopy: function ( m ) {\r\n\t\r\n\t\t\tthis.elements.set( m.elements );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\textractPosition: function ( m ) {\r\n\t\r\n\t\t\tTHREE.warn( 'THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().' );\r\n\t\t\treturn this.copyPosition( m );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcopyPosition: function ( m ) {\r\n\t\r\n\t\t\tvar te = this.elements;\r\n\t\t\tvar me = m.elements;\r\n\t\r\n\t\t\tte[ 12 ] = me[ 12 ];\r\n\t\t\tte[ 13 ] = me[ 13 ];\r\n\t\t\tte[ 14 ] = me[ 14 ];\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\textractBasis: function ( xAxis, yAxis, zAxis ) {\r\n\t \r\n\t\t\tvar te = this.elements;\r\n\t \r\n\t\t\txAxis.set( te[ 0 ], te[ 1 ], te[ 2 ] );\r\n\t\t\tyAxis.set( te[ 4 ], te[ 5 ], te[ 6 ] );\r\n\t\t\tzAxis.set( te[ 8 ], te[ 9 ], te[ 10 ] );\r\n\t \r\n\t\t\treturn this;\r\n\t \t\t\r\n\t\t},\r\n\t \r\n\t\tmakeBasis: function ( xAxis, yAxis, zAxis ) {\r\n\t\r\n\t\t\tthis.set(\r\n\t\t\t\txAxis.x, yAxis.x, zAxis.x, 0,\r\n\t\t\t\txAxis.y, yAxis.y, zAxis.y, 0,\r\n\t\t\t\txAxis.z, yAxis.z, zAxis.z, 0,\r\n\t\t\t\t0,       0,       0,       1\r\n\t\t\t);\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\textractRotation: function () {\r\n\t\r\n\t\t\tvar v1 = new THREE.Vector3();\r\n\t\r\n\t\t\treturn function ( m ) {\r\n\t\r\n\t\t\t\tvar te = this.elements;\r\n\t\t\t\tvar me = m.elements;\r\n\t\r\n\t\t\t\tvar scaleX = 1 / v1.set( me[ 0 ], me[ 1 ], me[ 2 ] ).length();\r\n\t\t\t\tvar scaleY = 1 / v1.set( me[ 4 ], me[ 5 ], me[ 6 ] ).length();\r\n\t\t\t\tvar scaleZ = 1 / v1.set( me[ 8 ], me[ 9 ], me[ 10 ] ).length();\r\n\t\r\n\t\t\t\tte[ 0 ] = me[ 0 ] * scaleX;\r\n\t\t\t\tte[ 1 ] = me[ 1 ] * scaleX;\r\n\t\t\t\tte[ 2 ] = me[ 2 ] * scaleX;\r\n\t\r\n\t\t\t\tte[ 4 ] = me[ 4 ] * scaleY;\r\n\t\t\t\tte[ 5 ] = me[ 5 ] * scaleY;\r\n\t\t\t\tte[ 6 ] = me[ 6 ] * scaleY;\r\n\t\r\n\t\t\t\tte[ 8 ] = me[ 8 ] * scaleZ;\r\n\t\t\t\tte[ 9 ] = me[ 9 ] * scaleZ;\r\n\t\t\t\tte[ 10 ] = me[ 10 ] * scaleZ;\r\n\t\r\n\t\t\t\treturn this;\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tmakeRotationFromEuler: function ( euler ) {\r\n\t\r\n\t\t\tif ( euler instanceof THREE.Euler === false ) {\r\n\t\r\n\t\t\t\tTHREE.error( 'THREE.Matrix: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.' );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar te = this.elements;\r\n\t\r\n\t\t\tvar x = euler.x, y = euler.y, z = euler.z;\r\n\t\t\tvar a = Math.cos( x ), b = Math.sin( x );\r\n\t\t\tvar c = Math.cos( y ), d = Math.sin( y );\r\n\t\t\tvar e = Math.cos( z ), f = Math.sin( z );\r\n\t\r\n\t\t\tif ( euler.order === 'XYZ' ) {\r\n\t\r\n\t\t\t\tvar ae = a * e, af = a * f, be = b * e, bf = b * f;\r\n\t\r\n\t\t\t\tte[ 0 ] = c * e;\r\n\t\t\t\tte[ 4 ] = - c * f;\r\n\t\t\t\tte[ 8 ] = d;\r\n\t\r\n\t\t\t\tte[ 1 ] = af + be * d;\r\n\t\t\t\tte[ 5 ] = ae - bf * d;\r\n\t\t\t\tte[ 9 ] = - b * c;\r\n\t\r\n\t\t\t\tte[ 2 ] = bf - ae * d;\r\n\t\t\t\tte[ 6 ] = be + af * d;\r\n\t\t\t\tte[ 10 ] = a * c;\r\n\t\r\n\t\t\t} else if ( euler.order === 'YXZ' ) {\r\n\t\r\n\t\t\t\tvar ce = c * e, cf = c * f, de = d * e, df = d * f;\r\n\t\r\n\t\t\t\tte[ 0 ] = ce + df * b;\r\n\t\t\t\tte[ 4 ] = de * b - cf;\r\n\t\t\t\tte[ 8 ] = a * d;\r\n\t\r\n\t\t\t\tte[ 1 ] = a * f;\r\n\t\t\t\tte[ 5 ] = a * e;\r\n\t\t\t\tte[ 9 ] = - b;\r\n\t\r\n\t\t\t\tte[ 2 ] = cf * b - de;\r\n\t\t\t\tte[ 6 ] = df + ce * b;\r\n\t\t\t\tte[ 10 ] = a * c;\r\n\t\r\n\t\t\t} else if ( euler.order === 'ZXY' ) {\r\n\t\r\n\t\t\t\tvar ce = c * e, cf = c * f, de = d * e, df = d * f;\r\n\t\r\n\t\t\t\tte[ 0 ] = ce - df * b;\r\n\t\t\t\tte[ 4 ] = - a * f;\r\n\t\t\t\tte[ 8 ] = de + cf * b;\r\n\t\r\n\t\t\t\tte[ 1 ] = cf + de * b;\r\n\t\t\t\tte[ 5 ] = a * e;\r\n\t\t\t\tte[ 9 ] = df - ce * b;\r\n\t\r\n\t\t\t\tte[ 2 ] = - a * d;\r\n\t\t\t\tte[ 6 ] = b;\r\n\t\t\t\tte[ 10 ] = a * c;\r\n\t\r\n\t\t\t} else if ( euler.order === 'ZYX' ) {\r\n\t\r\n\t\t\t\tvar ae = a * e, af = a * f, be = b * e, bf = b * f;\r\n\t\r\n\t\t\t\tte[ 0 ] = c * e;\r\n\t\t\t\tte[ 4 ] = be * d - af;\r\n\t\t\t\tte[ 8 ] = ae * d + bf;\r\n\t\r\n\t\t\t\tte[ 1 ] = c * f;\r\n\t\t\t\tte[ 5 ] = bf * d + ae;\r\n\t\t\t\tte[ 9 ] = af * d - be;\r\n\t\r\n\t\t\t\tte[ 2 ] = - d;\r\n\t\t\t\tte[ 6 ] = b * c;\r\n\t\t\t\tte[ 10 ] = a * c;\r\n\t\r\n\t\t\t} else if ( euler.order === 'YZX' ) {\r\n\t\r\n\t\t\t\tvar ac = a * c, ad = a * d, bc = b * c, bd = b * d;\r\n\t\r\n\t\t\t\tte[ 0 ] = c * e;\r\n\t\t\t\tte[ 4 ] = bd - ac * f;\r\n\t\t\t\tte[ 8 ] = bc * f + ad;\r\n\t\r\n\t\t\t\tte[ 1 ] = f;\r\n\t\t\t\tte[ 5 ] = a * e;\r\n\t\t\t\tte[ 9 ] = - b * e;\r\n\t\r\n\t\t\t\tte[ 2 ] = - d * e;\r\n\t\t\t\tte[ 6 ] = ad * f + bc;\r\n\t\t\t\tte[ 10 ] = ac - bd * f;\r\n\t\r\n\t\t\t} else if ( euler.order === 'XZY' ) {\r\n\t\r\n\t\t\t\tvar ac = a * c, ad = a * d, bc = b * c, bd = b * d;\r\n\t\r\n\t\t\t\tte[ 0 ] = c * e;\r\n\t\t\t\tte[ 4 ] = - f;\r\n\t\t\t\tte[ 8 ] = d * e;\r\n\t\r\n\t\t\t\tte[ 1 ] = ac * f + bd;\r\n\t\t\t\tte[ 5 ] = a * e;\r\n\t\t\t\tte[ 9 ] = ad * f - bc;\r\n\t\r\n\t\t\t\tte[ 2 ] = bc * f - ad;\r\n\t\t\t\tte[ 6 ] = b * e;\r\n\t\t\t\tte[ 10 ] = bd * f + ac;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// last column\r\n\t\t\tte[ 3 ] = 0;\r\n\t\t\tte[ 7 ] = 0;\r\n\t\t\tte[ 11 ] = 0;\r\n\t\r\n\t\t\t// bottom row\r\n\t\t\tte[ 12 ] = 0;\r\n\t\t\tte[ 13 ] = 0;\r\n\t\t\tte[ 14 ] = 0;\r\n\t\t\tte[ 15 ] = 1;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetRotationFromQuaternion: function ( q ) {\r\n\t\r\n\t\t\tTHREE.warn( 'THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().' );\r\n\t\r\n\t\t\treturn this.makeRotationFromQuaternion( q );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tmakeRotationFromQuaternion: function ( q ) {\r\n\t\r\n\t\t\tvar te = this.elements;\r\n\t\r\n\t\t\tvar x = q.x, y = q.y, z = q.z, w = q.w;\r\n\t\t\tvar x2 = x + x, y2 = y + y, z2 = z + z;\r\n\t\t\tvar xx = x * x2, xy = x * y2, xz = x * z2;\r\n\t\t\tvar yy = y * y2, yz = y * z2, zz = z * z2;\r\n\t\t\tvar wx = w * x2, wy = w * y2, wz = w * z2;\r\n\t\r\n\t\t\tte[ 0 ] = 1 - ( yy + zz );\r\n\t\t\tte[ 4 ] = xy - wz;\r\n\t\t\tte[ 8 ] = xz + wy;\r\n\t\r\n\t\t\tte[ 1 ] = xy + wz;\r\n\t\t\tte[ 5 ] = 1 - ( xx + zz );\r\n\t\t\tte[ 9 ] = yz - wx;\r\n\t\r\n\t\t\tte[ 2 ] = xz - wy;\r\n\t\t\tte[ 6 ] = yz + wx;\r\n\t\t\tte[ 10 ] = 1 - ( xx + yy );\r\n\t\r\n\t\t\t// last column\r\n\t\t\tte[ 3 ] = 0;\r\n\t\t\tte[ 7 ] = 0;\r\n\t\t\tte[ 11 ] = 0;\r\n\t\r\n\t\t\t// bottom row\r\n\t\t\tte[ 12 ] = 0;\r\n\t\t\tte[ 13 ] = 0;\r\n\t\t\tte[ 14 ] = 0;\r\n\t\t\tte[ 15 ] = 1;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tlookAt: function () {\r\n\t\r\n\t\t\tvar x = new THREE.Vector3();\r\n\t\t\tvar y = new THREE.Vector3();\r\n\t\t\tvar z = new THREE.Vector3();\r\n\t\r\n\t\t\treturn function ( eye, target, up ) {\r\n\t\r\n\t\t\t\tvar te = this.elements;\r\n\t\r\n\t\t\t\tz.subVectors( eye, target ).normalize();\r\n\t\r\n\t\t\t\tif ( z.length() === 0 ) {\r\n\t\r\n\t\t\t\t\tz.z = 1;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tx.crossVectors( up, z ).normalize();\r\n\t\r\n\t\t\t\tif ( x.length() === 0 ) {\r\n\t\r\n\t\t\t\t\tz.x += 0.0001;\r\n\t\t\t\t\tx.crossVectors( up, z ).normalize();\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\ty.crossVectors( z, x );\r\n\t\r\n\t\r\n\t\t\t\tte[ 0 ] = x.x; te[ 4 ] = y.x; te[ 8 ] = z.x;\r\n\t\t\t\tte[ 1 ] = x.y; te[ 5 ] = y.y; te[ 9 ] = z.y;\r\n\t\t\t\tte[ 2 ] = x.z; te[ 6 ] = y.z; te[ 10 ] = z.z;\r\n\t\r\n\t\t\t\treturn this;\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tmultiply: function ( m, n ) {\r\n\t\r\n\t\t\tif ( n !== undefined ) {\r\n\t\r\n\t\t\t\tTHREE.warn( 'THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.' );\r\n\t\t\t\treturn this.multiplyMatrices( m, n );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this.multiplyMatrices( this, m );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tmultiplyMatrices: function ( a, b ) {\r\n\t\r\n\t\t\tvar ae = a.elements;\r\n\t\t\tvar be = b.elements;\r\n\t\t\tvar te = this.elements;\r\n\t\r\n\t\t\tvar a11 = ae[ 0 ], a12 = ae[ 4 ], a13 = ae[ 8 ], a14 = ae[ 12 ];\r\n\t\t\tvar a21 = ae[ 1 ], a22 = ae[ 5 ], a23 = ae[ 9 ], a24 = ae[ 13 ];\r\n\t\t\tvar a31 = ae[ 2 ], a32 = ae[ 6 ], a33 = ae[ 10 ], a34 = ae[ 14 ];\r\n\t\t\tvar a41 = ae[ 3 ], a42 = ae[ 7 ], a43 = ae[ 11 ], a44 = ae[ 15 ];\r\n\t\r\n\t\t\tvar b11 = be[ 0 ], b12 = be[ 4 ], b13 = be[ 8 ], b14 = be[ 12 ];\r\n\t\t\tvar b21 = be[ 1 ], b22 = be[ 5 ], b23 = be[ 9 ], b24 = be[ 13 ];\r\n\t\t\tvar b31 = be[ 2 ], b32 = be[ 6 ], b33 = be[ 10 ], b34 = be[ 14 ];\r\n\t\t\tvar b41 = be[ 3 ], b42 = be[ 7 ], b43 = be[ 11 ], b44 = be[ 15 ];\r\n\t\r\n\t\t\tte[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;\r\n\t\t\tte[ 4 ] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;\r\n\t\t\tte[ 8 ] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;\r\n\t\t\tte[ 12 ] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;\r\n\t\r\n\t\t\tte[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;\r\n\t\t\tte[ 5 ] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;\r\n\t\t\tte[ 9 ] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;\r\n\t\t\tte[ 13 ] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;\r\n\t\r\n\t\t\tte[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;\r\n\t\t\tte[ 6 ] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;\r\n\t\t\tte[ 10 ] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;\r\n\t\t\tte[ 14 ] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;\r\n\t\r\n\t\t\tte[ 3 ] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;\r\n\t\t\tte[ 7 ] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;\r\n\t\t\tte[ 11 ] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;\r\n\t\t\tte[ 15 ] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tmultiplyToArray: function ( a, b, r ) {\r\n\t\r\n\t\t\tvar te = this.elements;\r\n\t\r\n\t\t\tthis.multiplyMatrices( a, b );\r\n\t\r\n\t\t\tr[ 0 ] = te[ 0 ]; r[ 1 ] = te[ 1 ]; r[ 2 ] = te[ 2 ]; r[ 3 ] = te[ 3 ];\r\n\t\t\tr[ 4 ] = te[ 4 ]; r[ 5 ] = te[ 5 ]; r[ 6 ] = te[ 6 ]; r[ 7 ] = te[ 7 ];\r\n\t\t\tr[ 8 ]  = te[ 8 ]; r[ 9 ]  = te[ 9 ]; r[ 10 ] = te[ 10 ]; r[ 11 ] = te[ 11 ];\r\n\t\t\tr[ 12 ] = te[ 12 ]; r[ 13 ] = te[ 13 ]; r[ 14 ] = te[ 14 ]; r[ 15 ] = te[ 15 ];\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tmultiplyScalar: function ( s ) {\r\n\t\r\n\t\t\tvar te = this.elements;\r\n\t\r\n\t\t\tte[ 0 ] *= s; te[ 4 ] *= s; te[ 8 ] *= s; te[ 12 ] *= s;\r\n\t\t\tte[ 1 ] *= s; te[ 5 ] *= s; te[ 9 ] *= s; te[ 13 ] *= s;\r\n\t\t\tte[ 2 ] *= s; te[ 6 ] *= s; te[ 10 ] *= s; te[ 14 ] *= s;\r\n\t\t\tte[ 3 ] *= s; te[ 7 ] *= s; te[ 11 ] *= s; te[ 15 ] *= s;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tmultiplyVector3: function ( vector ) {\r\n\t\r\n\t\t\tTHREE.warn( 'THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) or vector.applyProjection( matrix ) instead.' );\r\n\t\t\treturn vector.applyProjection( this );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tmultiplyVector4: function ( vector ) {\r\n\t\r\n\t\t\tTHREE.warn( 'THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.' );\r\n\t\t\treturn vector.applyMatrix4( this );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tmultiplyVector3Array: function ( a ) {\r\n\t\r\n\t\t\tTHREE.warn( 'THREE.Matrix4: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead.' );\r\n\t\t\treturn this.applyToVector3Array( a );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tapplyToVector3Array: function () {\r\n\t\r\n\t\t\tvar v1 = new THREE.Vector3();\r\n\t\r\n\t\t\treturn function ( array, offset, length ) {\r\n\t\r\n\t\t\t\tif ( offset === undefined ) offset = 0;\r\n\t\t\t\tif ( length === undefined ) length = array.length;\r\n\t\r\n\t\t\t\tfor ( var i = 0, j = offset; i < length; i += 3, j += 3 ) {\r\n\t\r\n\t\t\t\t\tv1.x = array[ j ];\r\n\t\t\t\t\tv1.y = array[ j + 1 ];\r\n\t\t\t\t\tv1.z = array[ j + 2 ];\r\n\t\r\n\t\t\t\t\tv1.applyMatrix4( this );\r\n\t\r\n\t\t\t\t\tarray[ j ]     = v1.x;\r\n\t\t\t\t\tarray[ j + 1 ] = v1.y;\r\n\t\t\t\t\tarray[ j + 2 ] = v1.z;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\treturn array;\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\trotateAxis: function ( v ) {\r\n\t\r\n\t\t\tTHREE.warn( 'THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.' );\r\n\t\r\n\t\t\tv.transformDirection( this );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcrossVector: function ( vector ) {\r\n\t\r\n\t\t\tTHREE.warn( 'THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.' );\r\n\t\t\treturn vector.applyMatrix4( this );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tdeterminant: function () {\r\n\t\r\n\t\t\tvar te = this.elements;\r\n\t\r\n\t\t\tvar n11 = te[ 0 ], n12 = te[ 4 ], n13 = te[ 8 ], n14 = te[ 12 ];\r\n\t\t\tvar n21 = te[ 1 ], n22 = te[ 5 ], n23 = te[ 9 ], n24 = te[ 13 ];\r\n\t\t\tvar n31 = te[ 2 ], n32 = te[ 6 ], n33 = te[ 10 ], n34 = te[ 14 ];\r\n\t\t\tvar n41 = te[ 3 ], n42 = te[ 7 ], n43 = te[ 11 ], n44 = te[ 15 ];\r\n\t\r\n\t\t\t//TODO: make this more efficient\r\n\t\t\t//( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )\r\n\t\r\n\t\t\treturn (\r\n\t\t\t\tn41 * (\r\n\t\t\t\t\t+ n14 * n23 * n32\r\n\t\t\t\t\t - n13 * n24 * n32\r\n\t\t\t\t\t - n14 * n22 * n33\r\n\t\t\t\t\t + n12 * n24 * n33\r\n\t\t\t\t\t + n13 * n22 * n34\r\n\t\t\t\t\t - n12 * n23 * n34\r\n\t\t\t\t) +\r\n\t\t\t\tn42 * (\r\n\t\t\t\t\t+ n11 * n23 * n34\r\n\t\t\t\t\t - n11 * n24 * n33\r\n\t\t\t\t\t + n14 * n21 * n33\r\n\t\t\t\t\t - n13 * n21 * n34\r\n\t\t\t\t\t + n13 * n24 * n31\r\n\t\t\t\t\t - n14 * n23 * n31\r\n\t\t\t\t) +\r\n\t\t\t\tn43 * (\r\n\t\t\t\t\t+ n11 * n24 * n32\r\n\t\t\t\t\t - n11 * n22 * n34\r\n\t\t\t\t\t - n14 * n21 * n32\r\n\t\t\t\t\t + n12 * n21 * n34\r\n\t\t\t\t\t + n14 * n22 * n31\r\n\t\t\t\t\t - n12 * n24 * n31\r\n\t\t\t\t) +\r\n\t\t\t\tn44 * (\r\n\t\t\t\t\t- n13 * n22 * n31\r\n\t\t\t\t\t - n11 * n23 * n32\r\n\t\t\t\t\t + n11 * n22 * n33\r\n\t\t\t\t\t + n13 * n21 * n32\r\n\t\t\t\t\t - n12 * n21 * n33\r\n\t\t\t\t\t + n12 * n23 * n31\r\n\t\t\t\t)\r\n\t\r\n\t\t\t);\r\n\t\r\n\t\t},\r\n\t\r\n\t\ttranspose: function () {\r\n\t\r\n\t\t\tvar te = this.elements;\r\n\t\t\tvar tmp;\r\n\t\r\n\t\t\ttmp = te[ 1 ]; te[ 1 ] = te[ 4 ]; te[ 4 ] = tmp;\r\n\t\t\ttmp = te[ 2 ]; te[ 2 ] = te[ 8 ]; te[ 8 ] = tmp;\r\n\t\t\ttmp = te[ 6 ]; te[ 6 ] = te[ 9 ]; te[ 9 ] = tmp;\r\n\t\r\n\t\t\ttmp = te[ 3 ]; te[ 3 ] = te[ 12 ]; te[ 12 ] = tmp;\r\n\t\t\ttmp = te[ 7 ]; te[ 7 ] = te[ 13 ]; te[ 13 ] = tmp;\r\n\t\t\ttmp = te[ 11 ]; te[ 11 ] = te[ 14 ]; te[ 14 ] = tmp;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tflattenToArrayOffset: function ( array, offset ) {\r\n\t\r\n\t\t\tvar te = this.elements;\r\n\t\r\n\t\t\tarray[ offset     ] = te[ 0 ];\r\n\t\t\tarray[ offset + 1 ] = te[ 1 ];\r\n\t\t\tarray[ offset + 2 ] = te[ 2 ];\r\n\t\t\tarray[ offset + 3 ] = te[ 3 ];\r\n\t\r\n\t\t\tarray[ offset + 4 ] = te[ 4 ];\r\n\t\t\tarray[ offset + 5 ] = te[ 5 ];\r\n\t\t\tarray[ offset + 6 ] = te[ 6 ];\r\n\t\t\tarray[ offset + 7 ] = te[ 7 ];\r\n\t\r\n\t\t\tarray[ offset + 8 ]  = te[ 8 ];\r\n\t\t\tarray[ offset + 9 ]  = te[ 9 ];\r\n\t\t\tarray[ offset + 10 ] = te[ 10 ];\r\n\t\t\tarray[ offset + 11 ] = te[ 11 ];\r\n\t\r\n\t\t\tarray[ offset + 12 ] = te[ 12 ];\r\n\t\t\tarray[ offset + 13 ] = te[ 13 ];\r\n\t\t\tarray[ offset + 14 ] = te[ 14 ];\r\n\t\t\tarray[ offset + 15 ] = te[ 15 ];\r\n\t\r\n\t\t\treturn array;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tgetPosition: function () {\r\n\t\r\n\t\t\tvar v1 = new THREE.Vector3();\r\n\t\r\n\t\t\treturn function () {\r\n\t\r\n\t\t\t\tTHREE.warn( 'THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.' );\r\n\t\r\n\t\t\t\tvar te = this.elements;\r\n\t\t\t\treturn v1.set( te[ 12 ], te[ 13 ], te[ 14 ] );\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tsetPosition: function ( v ) {\r\n\t\r\n\t\t\tvar te = this.elements;\r\n\t\r\n\t\t\tte[ 12 ] = v.x;\r\n\t\t\tte[ 13 ] = v.y;\r\n\t\t\tte[ 14 ] = v.z;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tgetInverse: function ( m, throwOnInvertible ) {\r\n\t\r\n\t\t\t// based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm\r\n\t\t\tvar te = this.elements;\r\n\t\t\tvar me = m.elements;\r\n\t\r\n\t\t\tvar n11 = me[ 0 ], n12 = me[ 4 ], n13 = me[ 8 ], n14 = me[ 12 ];\r\n\t\t\tvar n21 = me[ 1 ], n22 = me[ 5 ], n23 = me[ 9 ], n24 = me[ 13 ];\r\n\t\t\tvar n31 = me[ 2 ], n32 = me[ 6 ], n33 = me[ 10 ], n34 = me[ 14 ];\r\n\t\t\tvar n41 = me[ 3 ], n42 = me[ 7 ], n43 = me[ 11 ], n44 = me[ 15 ];\r\n\t\r\n\t\t\tte[ 0 ] = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44;\r\n\t\t\tte[ 4 ] = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44;\r\n\t\t\tte[ 8 ] = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44;\r\n\t\t\tte[ 12 ] = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;\r\n\t\t\tte[ 1 ] = n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44;\r\n\t\t\tte[ 5 ] = n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44;\r\n\t\t\tte[ 9 ] = n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44;\r\n\t\t\tte[ 13 ] = n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34;\r\n\t\t\tte[ 2 ] = n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44;\r\n\t\t\tte[ 6 ] = n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44;\r\n\t\t\tte[ 10 ] = n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44;\r\n\t\t\tte[ 14 ] = n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34;\r\n\t\t\tte[ 3 ] = n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43;\r\n\t\t\tte[ 7 ] = n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43;\r\n\t\t\tte[ 11 ] = n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43;\r\n\t\t\tte[ 15 ] = n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33;\r\n\t\r\n\t\t\tvar det = n11 * te[ 0 ] + n21 * te[ 4 ] + n31 * te[ 8 ] + n41 * te[ 12 ];\r\n\t\r\n\t\t\tif ( det == 0 ) {\r\n\t\r\n\t\t\t\tvar msg = \"THREE.Matrix4.getInverse(): can't invert matrix, determinant is 0\";\r\n\t\r\n\t\t\t\tif ( throwOnInvertible || false ) {\r\n\t\r\n\t\t\t\t\tthrow new Error( msg );\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tTHREE.warn( msg );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tthis.identity();\r\n\t\r\n\t\t\t\treturn this;\r\n\t\t\t}\r\n\t\r\n\t\t\tthis.multiplyScalar( 1 / det );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\ttranslate: function ( v ) {\r\n\t\r\n\t\t\tTHREE.error( 'THREE.Matrix4: .translate() has been removed.' );\r\n\t\r\n\t\t},\r\n\t\r\n\t\trotateX: function ( angle ) {\r\n\t\r\n\t\t\tTHREE.error( 'THREE.Matrix4: .rotateX() has been removed.' );\r\n\t\r\n\t\t},\r\n\t\r\n\t\trotateY: function ( angle ) {\r\n\t\r\n\t\t\tTHREE.error( 'THREE.Matrix4: .rotateY() has been removed.' );\r\n\t\r\n\t\t},\r\n\t\r\n\t\trotateZ: function ( angle ) {\r\n\t\r\n\t\t\tTHREE.error( 'THREE.Matrix4: .rotateZ() has been removed.' );\r\n\t\r\n\t\t},\r\n\t\r\n\t\trotateByAxis: function ( axis, angle ) {\r\n\t\r\n\t\t\tTHREE.error( 'THREE.Matrix4: .rotateByAxis() has been removed.' );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tscale: function ( v ) {\r\n\t\r\n\t\t\tvar te = this.elements;\r\n\t\t\tvar x = v.x, y = v.y, z = v.z;\r\n\t\r\n\t\t\tte[ 0 ] *= x; te[ 4 ] *= y; te[ 8 ] *= z;\r\n\t\t\tte[ 1 ] *= x; te[ 5 ] *= y; te[ 9 ] *= z;\r\n\t\t\tte[ 2 ] *= x; te[ 6 ] *= y; te[ 10 ] *= z;\r\n\t\t\tte[ 3 ] *= x; te[ 7 ] *= y; te[ 11 ] *= z;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tgetMaxScaleOnAxis: function () {\r\n\t\r\n\t\t\tvar te = this.elements;\r\n\t\r\n\t\t\tvar scaleXSq = te[ 0 ] * te[ 0 ] + te[ 1 ] * te[ 1 ] + te[ 2 ] * te[ 2 ];\r\n\t\t\tvar scaleYSq = te[ 4 ] * te[ 4 ] + te[ 5 ] * te[ 5 ] + te[ 6 ] * te[ 6 ];\r\n\t\t\tvar scaleZSq = te[ 8 ] * te[ 8 ] + te[ 9 ] * te[ 9 ] + te[ 10 ] * te[ 10 ];\r\n\t\r\n\t\t\treturn Math.sqrt( Math.max( scaleXSq, Math.max( scaleYSq, scaleZSq ) ) );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tmakeTranslation: function ( x, y, z ) {\r\n\t\r\n\t\t\tthis.set(\r\n\t\r\n\t\t\t\t1, 0, 0, x,\r\n\t\t\t\t0, 1, 0, y,\r\n\t\t\t\t0, 0, 1, z,\r\n\t\t\t\t0, 0, 0, 1\r\n\t\r\n\t\t\t);\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tmakeRotationX: function ( theta ) {\r\n\t\r\n\t\t\tvar c = Math.cos( theta ), s = Math.sin( theta );\r\n\t\r\n\t\t\tthis.set(\r\n\t\r\n\t\t\t\t1, 0,  0, 0,\r\n\t\t\t\t0, c, - s, 0,\r\n\t\t\t\t0, s,  c, 0,\r\n\t\t\t\t0, 0,  0, 1\r\n\t\r\n\t\t\t);\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tmakeRotationY: function ( theta ) {\r\n\t\r\n\t\t\tvar c = Math.cos( theta ), s = Math.sin( theta );\r\n\t\r\n\t\t\tthis.set(\r\n\t\r\n\t\t\t\t c, 0, s, 0,\r\n\t\t\t\t 0, 1, 0, 0,\r\n\t\t\t\t- s, 0, c, 0,\r\n\t\t\t\t 0, 0, 0, 1\r\n\t\r\n\t\t\t);\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tmakeRotationZ: function ( theta ) {\r\n\t\r\n\t\t\tvar c = Math.cos( theta ), s = Math.sin( theta );\r\n\t\r\n\t\t\tthis.set(\r\n\t\r\n\t\t\t\tc, - s, 0, 0,\r\n\t\t\t\ts,  c, 0, 0,\r\n\t\t\t\t0,  0, 1, 0,\r\n\t\t\t\t0,  0, 0, 1\r\n\t\r\n\t\t\t);\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tmakeRotationAxis: function ( axis, angle ) {\r\n\t\r\n\t\t\t// Based on http://www.gamedev.net/reference/articles/article1199.asp\r\n\t\r\n\t\t\tvar c = Math.cos( angle );\r\n\t\t\tvar s = Math.sin( angle );\r\n\t\t\tvar t = 1 - c;\r\n\t\t\tvar x = axis.x, y = axis.y, z = axis.z;\r\n\t\t\tvar tx = t * x, ty = t * y;\r\n\t\r\n\t\t\tthis.set(\r\n\t\r\n\t\t\t\ttx * x + c, tx * y - s * z, tx * z + s * y, 0,\r\n\t\t\t\ttx * y + s * z, ty * y + c, ty * z - s * x, 0,\r\n\t\t\t\ttx * z - s * y, ty * z + s * x, t * z * z + c, 0,\r\n\t\t\t\t0, 0, 0, 1\r\n\t\r\n\t\t\t);\r\n\t\r\n\t\t\t return this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tmakeScale: function ( x, y, z ) {\r\n\t\r\n\t\t\tthis.set(\r\n\t\r\n\t\t\t\tx, 0, 0, 0,\r\n\t\t\t\t0, y, 0, 0,\r\n\t\t\t\t0, 0, z, 0,\r\n\t\t\t\t0, 0, 0, 1\r\n\t\r\n\t\t\t);\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcompose: function ( position, quaternion, scale ) {\r\n\t\r\n\t\t\tthis.makeRotationFromQuaternion( quaternion );\r\n\t\t\tthis.scale( scale );\r\n\t\t\tthis.setPosition( position );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tdecompose: function () {\r\n\t\r\n\t\t\tvar vector = new THREE.Vector3();\r\n\t\t\tvar matrix = new THREE.Matrix4();\r\n\t\r\n\t\t\treturn function ( position, quaternion, scale ) {\r\n\t\r\n\t\t\t\tvar te = this.elements;\r\n\t\r\n\t\t\t\tvar sx = vector.set( te[ 0 ], te[ 1 ], te[ 2 ] ).length();\r\n\t\t\t\tvar sy = vector.set( te[ 4 ], te[ 5 ], te[ 6 ] ).length();\r\n\t\t\t\tvar sz = vector.set( te[ 8 ], te[ 9 ], te[ 10 ] ).length();\r\n\t\r\n\t\t\t\t// if determine is negative, we need to invert one scale\r\n\t\t\t\tvar det = this.determinant();\r\n\t\t\t\tif ( det < 0 ) {\r\n\t\t\t\t\tsx = - sx;\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tposition.x = te[ 12 ];\r\n\t\t\t\tposition.y = te[ 13 ];\r\n\t\t\t\tposition.z = te[ 14 ];\r\n\t\r\n\t\t\t\t// scale the rotation part\r\n\t\r\n\t\t\t\tmatrix.elements.set( this.elements ); // at this point matrix is incomplete so we can't use .copy()\r\n\t\r\n\t\t\t\tvar invSX = 1 / sx;\r\n\t\t\t\tvar invSY = 1 / sy;\r\n\t\t\t\tvar invSZ = 1 / sz;\r\n\t\r\n\t\t\t\tmatrix.elements[ 0 ] *= invSX;\r\n\t\t\t\tmatrix.elements[ 1 ] *= invSX;\r\n\t\t\t\tmatrix.elements[ 2 ] *= invSX;\r\n\t\r\n\t\t\t\tmatrix.elements[ 4 ] *= invSY;\r\n\t\t\t\tmatrix.elements[ 5 ] *= invSY;\r\n\t\t\t\tmatrix.elements[ 6 ] *= invSY;\r\n\t\r\n\t\t\t\tmatrix.elements[ 8 ] *= invSZ;\r\n\t\t\t\tmatrix.elements[ 9 ] *= invSZ;\r\n\t\t\t\tmatrix.elements[ 10 ] *= invSZ;\r\n\t\r\n\t\t\t\tquaternion.setFromRotationMatrix( matrix );\r\n\t\r\n\t\t\t\tscale.x = sx;\r\n\t\t\t\tscale.y = sy;\r\n\t\t\t\tscale.z = sz;\r\n\t\r\n\t\t\t\treturn this;\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tmakeFrustum: function ( left, right, bottom, top, near, far ) {\r\n\t\r\n\t\t\tvar te = this.elements;\r\n\t\t\tvar x = 2 * near / ( right - left );\r\n\t\t\tvar y = 2 * near / ( top - bottom );\r\n\t\r\n\t\t\tvar a = ( right + left ) / ( right - left );\r\n\t\t\tvar b = ( top + bottom ) / ( top - bottom );\r\n\t\t\tvar c = - ( far + near ) / ( far - near );\r\n\t\t\tvar d = - 2 * far * near / ( far - near );\r\n\t\r\n\t\t\tte[ 0 ] = x;\tte[ 4 ] = 0;\tte[ 8 ] = a;\tte[ 12 ] = 0;\r\n\t\t\tte[ 1 ] = 0;\tte[ 5 ] = y;\tte[ 9 ] = b;\tte[ 13 ] = 0;\r\n\t\t\tte[ 2 ] = 0;\tte[ 6 ] = 0;\tte[ 10 ] = c;\tte[ 14 ] = d;\r\n\t\t\tte[ 3 ] = 0;\tte[ 7 ] = 0;\tte[ 11 ] = - 1;\tte[ 15 ] = 0;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tmakePerspective: function ( fov, aspect, near, far ) {\r\n\t\r\n\t\t\tvar ymax = near * Math.tan( THREE.Math.degToRad( fov * 0.5 ) );\r\n\t\t\tvar ymin = - ymax;\r\n\t\t\tvar xmin = ymin * aspect;\r\n\t\t\tvar xmax = ymax * aspect;\r\n\t\r\n\t\t\treturn this.makeFrustum( xmin, xmax, ymin, ymax, near, far );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tmakeOrthographic: function ( left, right, top, bottom, near, far ) {\r\n\t\r\n\t\t\tvar te = this.elements;\r\n\t\t\tvar w = right - left;\r\n\t\t\tvar h = top - bottom;\r\n\t\t\tvar p = far - near;\r\n\t\r\n\t\t\tvar x = ( right + left ) / w;\r\n\t\t\tvar y = ( top + bottom ) / h;\r\n\t\t\tvar z = ( far + near ) / p;\r\n\t\r\n\t\t\tte[ 0 ] = 2 / w;\tte[ 4 ] = 0;\tte[ 8 ] = 0;\tte[ 12 ] = - x;\r\n\t\t\tte[ 1 ] = 0;\tte[ 5 ] = 2 / h;\tte[ 9 ] = 0;\tte[ 13 ] = - y;\r\n\t\t\tte[ 2 ] = 0;\tte[ 6 ] = 0;\tte[ 10 ] = - 2 / p;\tte[ 14 ] = - z;\r\n\t\t\tte[ 3 ] = 0;\tte[ 7 ] = 0;\tte[ 11 ] = 0;\tte[ 15 ] = 1;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tfromArray: function ( array ) {\r\n\t\r\n\t\t\tthis.elements.set( array );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\ttoArray: function () {\r\n\t\r\n\t\t\tvar te = this.elements;\r\n\t\r\n\t\t\treturn [\r\n\t\t\t\tte[ 0 ], te[ 1 ], te[ 2 ], te[ 3 ],\r\n\t\t\t\tte[ 4 ], te[ 5 ], te[ 6 ], te[ 7 ],\r\n\t\t\t\tte[ 8 ], te[ 9 ], te[ 10 ], te[ 11 ],\r\n\t\t\t\tte[ 12 ], te[ 13 ], te[ 14 ], te[ 15 ]\r\n\t\t\t];\r\n\t\r\n\t\t},\r\n\t\r\n\t\tclone: function () {\r\n\t\r\n\t\t\treturn new THREE.Matrix4().fromArray( this.elements );\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/math/Ray.js\r\n\t\r\n\t/**\r\n\t * @author bhouston / http://exocortex.com\r\n\t */\r\n\t\r\n\tTHREE.Ray = function ( origin, direction ) {\r\n\t\r\n\t\tthis.origin = ( origin !== undefined ) ? origin : new THREE.Vector3();\r\n\t\tthis.direction = ( direction !== undefined ) ? direction : new THREE.Vector3();\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Ray.prototype = {\r\n\t\r\n\t\tconstructor: THREE.Ray,\r\n\t\r\n\t\tset: function ( origin, direction ) {\r\n\t\r\n\t\t\tthis.origin.copy( origin );\r\n\t\t\tthis.direction.copy( direction );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcopy: function ( ray ) {\r\n\t\r\n\t\t\tthis.origin.copy( ray.origin );\r\n\t\t\tthis.direction.copy( ray.direction );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tat: function ( t, optionalTarget ) {\r\n\t\r\n\t\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\t\r\n\t\t\treturn result.copy( this.direction ).multiplyScalar( t ).add( this.origin );\r\n\t\r\n\t\t},\r\n\t\r\n\t\trecast: function () {\r\n\t\r\n\t\t\tvar v1 = new THREE.Vector3();\r\n\t\r\n\t\t\treturn function ( t ) {\r\n\t\r\n\t\t\t\tthis.origin.copy( this.at( t, v1 ) );\r\n\t\r\n\t\t\t\treturn this;\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tclosestPointToPoint: function ( point, optionalTarget ) {\r\n\t\r\n\t\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\t\t\tresult.subVectors( point, this.origin );\r\n\t\t\tvar directionDistance = result.dot( this.direction );\r\n\t\r\n\t\t\tif ( directionDistance < 0 ) {\r\n\t\r\n\t\t\t\treturn result.copy( this.origin );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn result.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tdistanceToPoint: function () {\r\n\t\r\n\t\t\tvar v1 = new THREE.Vector3();\r\n\t\r\n\t\t\treturn function ( point ) {\r\n\t\r\n\t\t\t\tvar directionDistance = v1.subVectors( point, this.origin ).dot( this.direction );\r\n\t\r\n\t\t\t\t// point behind the ray\r\n\t\r\n\t\t\t\tif ( directionDistance < 0 ) {\r\n\t\r\n\t\t\t\t\treturn this.origin.distanceTo( point );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tv1.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );\r\n\t\r\n\t\t\t\treturn v1.distanceTo( point );\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tdistanceSqToSegment: function () {\r\n\t\r\n\t\t\tvar segCenter = new THREE.Vector3();\r\n\t\t\tvar segDir = new THREE.Vector3();\r\n\t\t\tvar diff = new THREE.Vector3();\r\n\t\r\n\t\t\treturn function ( v0, v1, optionalPointOnRay, optionalPointOnSegment ) {\r\n\t\r\n\t\t\t\t// from http://www.geometrictools.com/LibMathematics/Distance/Wm5DistRay3Segment3.cpp\r\n\t\t\t\t// It returns the min distance between the ray and the segment\r\n\t\t\t\t// defined by v0 and v1\r\n\t\t\t\t// It can also set two optional targets :\r\n\t\t\t\t// - The closest point on the ray\r\n\t\t\t\t// - The closest point on the segment\r\n\t\r\n\t\t\t\tsegCenter.copy( v0 ).add( v1 ).multiplyScalar( 0.5 );\r\n\t\t\t\tsegDir.copy( v1 ).sub( v0 ).normalize();\r\n\t\t\t\tdiff.copy( this.origin ).sub( segCenter );\r\n\t\r\n\t\t\t\tvar segExtent = v0.distanceTo( v1 ) * 0.5;\r\n\t\t\t\tvar a01 = - this.direction.dot( segDir );\r\n\t\t\t\tvar b0 = diff.dot( this.direction );\r\n\t\t\t\tvar b1 = - diff.dot( segDir );\r\n\t\t\t\tvar c = diff.lengthSq();\r\n\t\t\t\tvar det = Math.abs( 1 - a01 * a01 );\r\n\t\t\t\tvar s0, s1, sqrDist, extDet;\r\n\t\r\n\t\t\t\tif ( det > 0 ) {\r\n\t\r\n\t\t\t\t\t// The ray and segment are not parallel.\r\n\t\r\n\t\t\t\t\ts0 = a01 * b1 - b0;\r\n\t\t\t\t\ts1 = a01 * b0 - b1;\r\n\t\t\t\t\textDet = segExtent * det;\r\n\t\r\n\t\t\t\t\tif ( s0 >= 0 ) {\r\n\t\r\n\t\t\t\t\t\tif ( s1 >= - extDet ) {\r\n\t\r\n\t\t\t\t\t\t\tif ( s1 <= extDet ) {\r\n\t\r\n\t\t\t\t\t\t\t\t// region 0\r\n\t\t\t\t\t\t\t\t// Minimum at interior points of ray and segment.\r\n\t\r\n\t\t\t\t\t\t\t\tvar invDet = 1 / det;\r\n\t\t\t\t\t\t\t\ts0 *= invDet;\r\n\t\t\t\t\t\t\t\ts1 *= invDet;\r\n\t\t\t\t\t\t\t\tsqrDist = s0 * ( s0 + a01 * s1 + 2 * b0 ) + s1 * ( a01 * s0 + s1 + 2 * b1 ) + c;\r\n\t\r\n\t\t\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\t\t\t// region 1\r\n\t\r\n\t\t\t\t\t\t\t\ts1 = segExtent;\r\n\t\t\t\t\t\t\t\ts0 = Math.max( 0, - ( a01 * s1 + b0 ) );\r\n\t\t\t\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\r\n\t\r\n\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\t\t// region 5\r\n\t\r\n\t\t\t\t\t\t\ts1 = - segExtent;\r\n\t\t\t\t\t\t\ts0 = Math.max( 0, - ( a01 * s1 + b0 ) );\r\n\t\t\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\tif ( s1 <= - extDet ) {\r\n\t\r\n\t\t\t\t\t\t\t// region 4\r\n\t\r\n\t\t\t\t\t\t\ts0 = Math.max( 0, - ( - a01 * segExtent + b0 ) );\r\n\t\t\t\t\t\t\ts1 = ( s0 > 0 ) ? - segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );\r\n\t\t\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\r\n\t\r\n\t\t\t\t\t\t} else if ( s1 <= extDet ) {\r\n\t\r\n\t\t\t\t\t\t\t// region 3\r\n\t\r\n\t\t\t\t\t\t\ts0 = 0;\r\n\t\t\t\t\t\t\ts1 = Math.min( Math.max( - segExtent, - b1 ), segExtent );\r\n\t\t\t\t\t\t\tsqrDist = s1 * ( s1 + 2 * b1 ) + c;\r\n\t\r\n\t\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\t\t// region 2\r\n\t\r\n\t\t\t\t\t\t\ts0 = Math.max( 0, - ( a01 * segExtent + b0 ) );\r\n\t\t\t\t\t\t\ts1 = ( s0 > 0 ) ? segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );\r\n\t\t\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t// Ray and segment are parallel.\r\n\t\r\n\t\t\t\t\ts1 = ( a01 > 0 ) ? - segExtent : segExtent;\r\n\t\t\t\t\ts0 = Math.max( 0, - ( a01 * s1 + b0 ) );\r\n\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( optionalPointOnRay ) {\r\n\t\r\n\t\t\t\t\toptionalPointOnRay.copy( this.direction ).multiplyScalar( s0 ).add( this.origin );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( optionalPointOnSegment ) {\r\n\t\r\n\t\t\t\t\toptionalPointOnSegment.copy( segDir ).multiplyScalar( s1 ).add( segCenter );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\treturn sqrDist;\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\r\n\t\tisIntersectionSphere: function ( sphere ) {\r\n\t\r\n\t\t\treturn this.distanceToPoint( sphere.center ) <= sphere.radius;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tintersectSphere: function () {\r\n\t\r\n\t\t\t// from http://www.scratchapixel.com/lessons/3d-basic-lessons/lesson-7-intersecting-simple-shapes/ray-sphere-intersection/\r\n\t\r\n\t\t\tvar v1 = new THREE.Vector3();\r\n\t\r\n\t\t\treturn function ( sphere, optionalTarget ) {\r\n\t\r\n\t\t\t\tv1.subVectors( sphere.center, this.origin );\r\n\t\r\n\t\t\t\tvar tca = v1.dot( this.direction );\r\n\t\r\n\t\t\t\tvar d2 = v1.dot( v1 ) - tca * tca;\r\n\t\r\n\t\t\t\tvar radius2 = sphere.radius * sphere.radius;\r\n\t\r\n\t\t\t\tif ( d2 > radius2 ) return null;\r\n\t\r\n\t\t\t\tvar thc = Math.sqrt( radius2 - d2 );\r\n\t\r\n\t\t\t\t// t0 = first intersect point - entrance on front of sphere\r\n\t\t\t\tvar t0 = tca - thc;\r\n\t\r\n\t\t\t\t// t1 = second intersect point - exit point on back of sphere\r\n\t\t\t\tvar t1 = tca + thc;\r\n\t\r\n\t\t\t\t// test to see if both t0 and t1 are behind the ray - if so, return null\r\n\t\t\t\tif ( t0 < 0 && t1 < 0 ) return null;\r\n\t\r\n\t\t\t\t// test to see if t0 is behind the ray:\r\n\t\t\t\t// if it is, the ray is inside the sphere, so return the second exit point scaled by t1,\r\n\t\t\t\t// in order to always return an intersect point that is in front of the ray.\r\n\t\t\t\tif ( t0 < 0 ) return this.at( t1, optionalTarget );\r\n\t\r\n\t\t\t\t// else t0 is in front of the ray, so return the first collision point scaled by t0 \r\n\t\t\t\treturn this.at( t0, optionalTarget );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tisIntersectionPlane: function ( plane ) {\r\n\t\r\n\t\t\t// check if the ray lies on the plane first\r\n\t\r\n\t\t\tvar distToPoint = plane.distanceToPoint( this.origin );\r\n\t\r\n\t\t\tif ( distToPoint === 0 ) {\r\n\t\r\n\t\t\t\treturn true;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar denominator = plane.normal.dot( this.direction );\r\n\t\r\n\t\t\tif ( denominator * distToPoint < 0 ) {\r\n\t\r\n\t\t\t\treturn true;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// ray origin is behind the plane (and is pointing behind it)\r\n\t\r\n\t\t\treturn false;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tdistanceToPlane: function ( plane ) {\r\n\t\r\n\t\t\tvar denominator = plane.normal.dot( this.direction );\r\n\t\t\tif ( denominator == 0 ) {\r\n\t\r\n\t\t\t\t// line is coplanar, return origin\r\n\t\t\t\tif ( plane.distanceToPoint( this.origin ) == 0 ) {\r\n\t\r\n\t\t\t\t\treturn 0;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\t// Null is preferable to undefined since undefined means.... it is undefined\r\n\t\r\n\t\t\t\treturn null;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar t = - ( this.origin.dot( plane.normal ) + plane.constant ) / denominator;\r\n\t\r\n\t\t\t// Return if the ray never intersects the plane\r\n\t\r\n\t\t\treturn t >= 0 ? t :  null;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tintersectPlane: function ( plane, optionalTarget ) {\r\n\t\r\n\t\t\tvar t = this.distanceToPlane( plane );\r\n\t\r\n\t\t\tif ( t === null ) {\r\n\t\r\n\t\t\t\treturn null;\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this.at( t, optionalTarget );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tisIntersectionBox: function () {\r\n\t\r\n\t\t\tvar v = new THREE.Vector3();\r\n\t\r\n\t\t\treturn function ( box ) {\r\n\t\r\n\t\t\t\treturn this.intersectBox( box, v ) !== null;\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tintersectBox: function ( box, optionalTarget ) {\r\n\t\r\n\t\t\t// http://www.scratchapixel.com/lessons/3d-basic-lessons/lesson-7-intersecting-simple-shapes/ray-box-intersection/\r\n\t\r\n\t\t\tvar tmin,tmax,tymin,tymax,tzmin,tzmax;\r\n\t\r\n\t\t\tvar invdirx = 1 / this.direction.x,\r\n\t\t\t\tinvdiry = 1 / this.direction.y,\r\n\t\t\t\tinvdirz = 1 / this.direction.z;\r\n\t\r\n\t\t\tvar origin = this.origin;\r\n\t\r\n\t\t\tif ( invdirx >= 0 ) {\r\n\t\r\n\t\t\t\ttmin = ( box.min.x - origin.x ) * invdirx;\r\n\t\t\t\ttmax = ( box.max.x - origin.x ) * invdirx;\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\ttmin = ( box.max.x - origin.x ) * invdirx;\r\n\t\t\t\ttmax = ( box.min.x - origin.x ) * invdirx;\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( invdiry >= 0 ) {\r\n\t\r\n\t\t\t\ttymin = ( box.min.y - origin.y ) * invdiry;\r\n\t\t\t\ttymax = ( box.max.y - origin.y ) * invdiry;\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\ttymin = ( box.max.y - origin.y ) * invdiry;\r\n\t\t\t\ttymax = ( box.min.y - origin.y ) * invdiry;\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( ( tmin > tymax ) || ( tymin > tmax ) ) return null;\r\n\t\r\n\t\t\t// These lines also handle the case where tmin or tmax is NaN\r\n\t\t\t// (result of 0 * Infinity). x !== x returns true if x is NaN\r\n\t\r\n\t\t\tif ( tymin > tmin || tmin !== tmin ) tmin = tymin;\r\n\t\r\n\t\t\tif ( tymax < tmax || tmax !== tmax ) tmax = tymax;\r\n\t\r\n\t\t\tif ( invdirz >= 0 ) {\r\n\t\r\n\t\t\t\ttzmin = ( box.min.z - origin.z ) * invdirz;\r\n\t\t\t\ttzmax = ( box.max.z - origin.z ) * invdirz;\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\ttzmin = ( box.max.z - origin.z ) * invdirz;\r\n\t\t\t\ttzmax = ( box.min.z - origin.z ) * invdirz;\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( ( tmin > tzmax ) || ( tzmin > tmax ) ) return null;\r\n\t\r\n\t\t\tif ( tzmin > tmin || tmin !== tmin ) tmin = tzmin;\r\n\t\r\n\t\t\tif ( tzmax < tmax || tmax !== tmax ) tmax = tzmax;\r\n\t\r\n\t\t\t//return point closest to the ray (positive side)\r\n\t\r\n\t\t\tif ( tmax < 0 ) return null;\r\n\t\r\n\t\t\treturn this.at( tmin >= 0 ? tmin : tmax, optionalTarget );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tintersectTriangle: function () {\r\n\t\r\n\t\t\t// Compute the offset origin, edges, and normal.\r\n\t\t\tvar diff = new THREE.Vector3();\r\n\t\t\tvar edge1 = new THREE.Vector3();\r\n\t\t\tvar edge2 = new THREE.Vector3();\r\n\t\t\tvar normal = new THREE.Vector3();\r\n\t\r\n\t\t\treturn function ( a, b, c, backfaceCulling, optionalTarget ) {\r\n\t\r\n\t\t\t\t// from http://www.geometrictools.com/LibMathematics/Intersection/Wm5IntrRay3Triangle3.cpp\r\n\t\r\n\t\t\t\tedge1.subVectors( b, a );\r\n\t\t\t\tedge2.subVectors( c, a );\r\n\t\t\t\tnormal.crossVectors( edge1, edge2 );\r\n\t\r\n\t\t\t\t// Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,\r\n\t\t\t\t// E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by\r\n\t\t\t\t//   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))\r\n\t\t\t\t//   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))\r\n\t\t\t\t//   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)\r\n\t\t\t\tvar DdN = this.direction.dot( normal );\r\n\t\t\t\tvar sign;\r\n\t\r\n\t\t\t\tif ( DdN > 0 ) {\r\n\t\r\n\t\t\t\t\tif ( backfaceCulling ) return null;\r\n\t\t\t\t\tsign = 1;\r\n\t\r\n\t\t\t\t} else if ( DdN < 0 ) {\r\n\t\r\n\t\t\t\t\tsign = - 1;\r\n\t\t\t\t\tDdN = - DdN;\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\treturn null;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tdiff.subVectors( this.origin, a );\r\n\t\t\t\tvar DdQxE2 = sign * this.direction.dot( edge2.crossVectors( diff, edge2 ) );\r\n\t\r\n\t\t\t\t// b1 < 0, no intersection\r\n\t\t\t\tif ( DdQxE2 < 0 ) {\r\n\t\r\n\t\t\t\t\treturn null;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tvar DdE1xQ = sign * this.direction.dot( edge1.cross( diff ) );\r\n\t\r\n\t\t\t\t// b2 < 0, no intersection\r\n\t\t\t\tif ( DdE1xQ < 0 ) {\r\n\t\r\n\t\t\t\t\treturn null;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\t// b1+b2 > 1, no intersection\r\n\t\t\t\tif ( DdQxE2 + DdE1xQ > DdN ) {\r\n\t\r\n\t\t\t\t\treturn null;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\t// Line intersects triangle, check if ray does.\r\n\t\t\t\tvar QdN = - sign * diff.dot( normal );\r\n\t\r\n\t\t\t\t// t < 0, no intersection\r\n\t\t\t\tif ( QdN < 0 ) {\r\n\t\r\n\t\t\t\t\treturn null;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\t// Ray intersects triangle.\r\n\t\t\t\treturn this.at( QdN / DdN, optionalTarget );\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tapplyMatrix4: function ( matrix4 ) {\r\n\t\r\n\t\t\tthis.direction.add( this.origin ).applyMatrix4( matrix4 );\r\n\t\t\tthis.origin.applyMatrix4( matrix4 );\r\n\t\t\tthis.direction.sub( this.origin );\r\n\t\t\tthis.direction.normalize();\r\n\t\r\n\t\t\treturn this;\r\n\t\t},\r\n\t\r\n\t\tequals: function ( ray ) {\r\n\t\r\n\t\t\treturn ray.origin.equals( this.origin ) && ray.direction.equals( this.direction );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tclone: function () {\r\n\t\r\n\t\t\treturn new THREE.Ray().copy( this );\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/math/Sphere.js\r\n\t\r\n\t/**\r\n\t * @author bhouston / http://exocortex.com\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tTHREE.Sphere = function ( center, radius ) {\r\n\t\r\n\t\tthis.center = ( center !== undefined ) ? center : new THREE.Vector3();\r\n\t\tthis.radius = ( radius !== undefined ) ? radius : 0;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Sphere.prototype = {\r\n\t\r\n\t\tconstructor: THREE.Sphere,\r\n\t\r\n\t\tset: function ( center, radius ) {\r\n\t\r\n\t\t\tthis.center.copy( center );\r\n\t\t\tthis.radius = radius;\r\n\t\r\n\t\t\treturn this;\r\n\t\t},\r\n\t\r\n\t\tsetFromPoints: function () {\r\n\t\r\n\t\t\tvar box = new THREE.Box3();\r\n\t\r\n\t\t\treturn function ( points, optionalCenter ) {\r\n\t\r\n\t\t\t\tvar center = this.center;\r\n\t\r\n\t\t\t\tif ( optionalCenter !== undefined ) {\r\n\t\r\n\t\t\t\t\tcenter.copy( optionalCenter );\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tbox.setFromPoints( points ).center( center );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tvar maxRadiusSq = 0;\r\n\t\r\n\t\t\t\tfor ( var i = 0, il = points.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\t\tmaxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( points[ i ] ) );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tthis.radius = Math.sqrt( maxRadiusSq );\r\n\t\r\n\t\t\t\treturn this;\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tcopy: function ( sphere ) {\r\n\t\r\n\t\t\tthis.center.copy( sphere.center );\r\n\t\t\tthis.radius = sphere.radius;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tempty: function () {\r\n\t\r\n\t\t\treturn ( this.radius <= 0 );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcontainsPoint: function ( point ) {\r\n\t\r\n\t\t\treturn ( point.distanceToSquared( this.center ) <= ( this.radius * this.radius ) );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tdistanceToPoint: function ( point ) {\r\n\t\r\n\t\t\treturn ( point.distanceTo( this.center ) - this.radius );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tintersectsSphere: function ( sphere ) {\r\n\t\r\n\t\t\tvar radiusSum = this.radius + sphere.radius;\r\n\t\r\n\t\t\treturn sphere.center.distanceToSquared( this.center ) <= ( radiusSum * radiusSum );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tclampPoint: function ( point, optionalTarget ) {\r\n\t\r\n\t\t\tvar deltaLengthSq = this.center.distanceToSquared( point );\r\n\t\r\n\t\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\t\t\tresult.copy( point );\r\n\t\r\n\t\t\tif ( deltaLengthSq > ( this.radius * this.radius ) ) {\r\n\t\r\n\t\t\t\tresult.sub( this.center ).normalize();\r\n\t\t\t\tresult.multiplyScalar( this.radius ).add( this.center );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn result;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tgetBoundingBox: function ( optionalTarget ) {\r\n\t\r\n\t\t\tvar box = optionalTarget || new THREE.Box3();\r\n\t\r\n\t\t\tbox.set( this.center, this.center );\r\n\t\t\tbox.expandByScalar( this.radius );\r\n\t\r\n\t\t\treturn box;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tapplyMatrix4: function ( matrix ) {\r\n\t\r\n\t\t\tthis.center.applyMatrix4( matrix );\r\n\t\t\tthis.radius = this.radius * matrix.getMaxScaleOnAxis();\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\ttranslate: function ( offset ) {\r\n\t\r\n\t\t\tthis.center.add( offset );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tequals: function ( sphere ) {\r\n\t\r\n\t\t\treturn sphere.center.equals( this.center ) && ( sphere.radius === this.radius );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tclone: function () {\r\n\t\r\n\t\t\treturn new THREE.Sphere().copy( this );\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/math/Frustum.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t * @author bhouston / http://exocortex.com\r\n\t */\r\n\t\r\n\tTHREE.Frustum = function ( p0, p1, p2, p3, p4, p5 ) {\r\n\t\r\n\t\tthis.planes = [\r\n\t\r\n\t\t\t( p0 !== undefined ) ? p0 : new THREE.Plane(),\r\n\t\t\t( p1 !== undefined ) ? p1 : new THREE.Plane(),\r\n\t\t\t( p2 !== undefined ) ? p2 : new THREE.Plane(),\r\n\t\t\t( p3 !== undefined ) ? p3 : new THREE.Plane(),\r\n\t\t\t( p4 !== undefined ) ? p4 : new THREE.Plane(),\r\n\t\t\t( p5 !== undefined ) ? p5 : new THREE.Plane()\r\n\t\r\n\t\t];\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Frustum.prototype = {\r\n\t\r\n\t\tconstructor: THREE.Frustum,\r\n\t\r\n\t\tset: function ( p0, p1, p2, p3, p4, p5 ) {\r\n\t\r\n\t\t\tvar planes = this.planes;\r\n\t\r\n\t\t\tplanes[ 0 ].copy( p0 );\r\n\t\t\tplanes[ 1 ].copy( p1 );\r\n\t\t\tplanes[ 2 ].copy( p2 );\r\n\t\t\tplanes[ 3 ].copy( p3 );\r\n\t\t\tplanes[ 4 ].copy( p4 );\r\n\t\t\tplanes[ 5 ].copy( p5 );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcopy: function ( frustum ) {\r\n\t\r\n\t\t\tvar planes = this.planes;\r\n\t\r\n\t\t\tfor ( var i = 0; i < 6; i ++ ) {\r\n\t\r\n\t\t\t\tplanes[ i ].copy( frustum.planes[ i ] );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetFromMatrix: function ( m ) {\r\n\t\r\n\t\t\tvar planes = this.planes;\r\n\t\t\tvar me = m.elements;\r\n\t\t\tvar me0 = me[ 0 ], me1 = me[ 1 ], me2 = me[ 2 ], me3 = me[ 3 ];\r\n\t\t\tvar me4 = me[ 4 ], me5 = me[ 5 ], me6 = me[ 6 ], me7 = me[ 7 ];\r\n\t\t\tvar me8 = me[ 8 ], me9 = me[ 9 ], me10 = me[ 10 ], me11 = me[ 11 ];\r\n\t\t\tvar me12 = me[ 12 ], me13 = me[ 13 ], me14 = me[ 14 ], me15 = me[ 15 ];\r\n\t\r\n\t\t\tplanes[ 0 ].setComponents( me3 - me0, me7 - me4, me11 - me8, me15 - me12 ).normalize();\r\n\t\t\tplanes[ 1 ].setComponents( me3 + me0, me7 + me4, me11 + me8, me15 + me12 ).normalize();\r\n\t\t\tplanes[ 2 ].setComponents( me3 + me1, me7 + me5, me11 + me9, me15 + me13 ).normalize();\r\n\t\t\tplanes[ 3 ].setComponents( me3 - me1, me7 - me5, me11 - me9, me15 - me13 ).normalize();\r\n\t\t\tplanes[ 4 ].setComponents( me3 - me2, me7 - me6, me11 - me10, me15 - me14 ).normalize();\r\n\t\t\tplanes[ 5 ].setComponents( me3 + me2, me7 + me6, me11 + me10, me15 + me14 ).normalize();\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tintersectsObject: function () {\r\n\t\r\n\t\t\tvar sphere = new THREE.Sphere();\r\n\t\r\n\t\t\treturn function ( object ) {\r\n\t\r\n\t\t\t\tvar geometry = object.geometry;\r\n\t\r\n\t\t\t\tif ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();\r\n\t\r\n\t\t\t\tsphere.copy( geometry.boundingSphere );\r\n\t\t\t\tsphere.applyMatrix4( object.matrixWorld );\r\n\t\r\n\t\t\t\treturn this.intersectsSphere( sphere );\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tintersectsSphere: function ( sphere ) {\r\n\t\r\n\t\t\tvar planes = this.planes;\r\n\t\t\tvar center = sphere.center;\r\n\t\t\tvar negRadius = - sphere.radius;\r\n\t\r\n\t\t\tfor ( var i = 0; i < 6; i ++ ) {\r\n\t\r\n\t\t\t\tvar distance = planes[ i ].distanceToPoint( center );\r\n\t\r\n\t\t\t\tif ( distance < negRadius ) {\r\n\t\r\n\t\t\t\t\treturn false;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn true;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tintersectsBox: function () {\r\n\t\r\n\t\t\tvar p1 = new THREE.Vector3(),\r\n\t\t\t\tp2 = new THREE.Vector3();\r\n\t\r\n\t\t\treturn function ( box ) {\r\n\t\r\n\t\t\t\tvar planes = this.planes;\r\n\t\r\n\t\t\t\tfor ( var i = 0; i < 6 ; i ++ ) {\r\n\t\r\n\t\t\t\t\tvar plane = planes[ i ];\r\n\t\r\n\t\t\t\t\tp1.x = plane.normal.x > 0 ? box.min.x : box.max.x;\r\n\t\t\t\t\tp2.x = plane.normal.x > 0 ? box.max.x : box.min.x;\r\n\t\t\t\t\tp1.y = plane.normal.y > 0 ? box.min.y : box.max.y;\r\n\t\t\t\t\tp2.y = plane.normal.y > 0 ? box.max.y : box.min.y;\r\n\t\t\t\t\tp1.z = plane.normal.z > 0 ? box.min.z : box.max.z;\r\n\t\t\t\t\tp2.z = plane.normal.z > 0 ? box.max.z : box.min.z;\r\n\t\r\n\t\t\t\t\tvar d1 = plane.distanceToPoint( p1 );\r\n\t\t\t\t\tvar d2 = plane.distanceToPoint( p2 );\r\n\t\r\n\t\t\t\t\t// if both outside plane, no intersection\r\n\t\r\n\t\t\t\t\tif ( d1 < 0 && d2 < 0 ) {\r\n\t\r\n\t\t\t\t\t\treturn false;\r\n\t\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\treturn true;\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\r\n\t\tcontainsPoint: function ( point ) {\r\n\t\r\n\t\t\tvar planes = this.planes;\r\n\t\r\n\t\t\tfor ( var i = 0; i < 6; i ++ ) {\r\n\t\r\n\t\t\t\tif ( planes[ i ].distanceToPoint( point ) < 0 ) {\r\n\t\r\n\t\t\t\t\treturn false;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn true;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tclone: function () {\r\n\t\r\n\t\t\treturn new THREE.Frustum().copy( this );\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/math/Plane.js\r\n\t\r\n\t/**\r\n\t * @author bhouston / http://exocortex.com\r\n\t */\r\n\t\r\n\tTHREE.Plane = function ( normal, constant ) {\r\n\t\r\n\t\tthis.normal = ( normal !== undefined ) ? normal : new THREE.Vector3( 1, 0, 0 );\r\n\t\tthis.constant = ( constant !== undefined ) ? constant : 0;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Plane.prototype = {\r\n\t\r\n\t\tconstructor: THREE.Plane,\r\n\t\r\n\t\tset: function ( normal, constant ) {\r\n\t\r\n\t\t\tthis.normal.copy( normal );\r\n\t\t\tthis.constant = constant;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetComponents: function ( x, y, z, w ) {\r\n\t\r\n\t\t\tthis.normal.set( x, y, z );\r\n\t\t\tthis.constant = w;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetFromNormalAndCoplanarPoint: function ( normal, point ) {\r\n\t\r\n\t\t\tthis.normal.copy( normal );\r\n\t\t\tthis.constant = - point.dot( this.normal );\t// must be this.normal, not normal, as this.normal is normalized\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetFromCoplanarPoints: function () {\r\n\t\r\n\t\t\tvar v1 = new THREE.Vector3();\r\n\t\t\tvar v2 = new THREE.Vector3();\r\n\t\r\n\t\t\treturn function ( a, b, c ) {\r\n\t\r\n\t\t\t\tvar normal = v1.subVectors( c, b ).cross( v2.subVectors( a, b ) ).normalize();\r\n\t\r\n\t\t\t\t// Q: should an error be thrown if normal is zero (e.g. degenerate plane)?\r\n\t\r\n\t\t\t\tthis.setFromNormalAndCoplanarPoint( normal, a );\r\n\t\r\n\t\t\t\treturn this;\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\r\n\t\tcopy: function ( plane ) {\r\n\t\r\n\t\t\tthis.normal.copy( plane.normal );\r\n\t\t\tthis.constant = plane.constant;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tnormalize: function () {\r\n\t\r\n\t\t\t// Note: will lead to a divide by zero if the plane is invalid.\r\n\t\r\n\t\t\tvar inverseNormalLength = 1.0 / this.normal.length();\r\n\t\t\tthis.normal.multiplyScalar( inverseNormalLength );\r\n\t\t\tthis.constant *= inverseNormalLength;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tnegate: function () {\r\n\t\r\n\t\t\tthis.constant *= - 1;\r\n\t\t\tthis.normal.negate();\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tdistanceToPoint: function ( point ) {\r\n\t\r\n\t\t\treturn this.normal.dot( point ) + this.constant;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tdistanceToSphere: function ( sphere ) {\r\n\t\r\n\t\t\treturn this.distanceToPoint( sphere.center ) - sphere.radius;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tprojectPoint: function ( point, optionalTarget ) {\r\n\t\r\n\t\t\treturn this.orthoPoint( point, optionalTarget ).sub( point ).negate();\r\n\t\r\n\t\t},\r\n\t\r\n\t\torthoPoint: function ( point, optionalTarget ) {\r\n\t\r\n\t\t\tvar perpendicularMagnitude = this.distanceToPoint( point );\r\n\t\r\n\t\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\t\t\treturn result.copy( this.normal ).multiplyScalar( perpendicularMagnitude );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tisIntersectionLine: function ( line ) {\r\n\t\r\n\t\t\t// Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.\r\n\t\r\n\t\t\tvar startSign = this.distanceToPoint( line.start );\r\n\t\t\tvar endSign = this.distanceToPoint( line.end );\r\n\t\r\n\t\t\treturn ( startSign < 0 && endSign > 0 ) || ( endSign < 0 && startSign > 0 );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tintersectLine: function () {\r\n\t\r\n\t\t\tvar v1 = new THREE.Vector3();\r\n\t\r\n\t\t\treturn function ( line, optionalTarget ) {\r\n\t\r\n\t\t\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\t\r\n\t\t\t\tvar direction = line.delta( v1 );\r\n\t\r\n\t\t\t\tvar denominator = this.normal.dot( direction );\r\n\t\r\n\t\t\t\tif ( denominator == 0 ) {\r\n\t\r\n\t\t\t\t\t// line is coplanar, return origin\r\n\t\t\t\t\tif ( this.distanceToPoint( line.start ) == 0 ) {\r\n\t\r\n\t\t\t\t\t\treturn result.copy( line.start );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t// Unsure if this is the correct method to handle this case.\r\n\t\t\t\t\treturn undefined;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tvar t = - ( line.start.dot( this.normal ) + this.constant ) / denominator;\r\n\t\r\n\t\t\t\tif ( t < 0 || t > 1 ) {\r\n\t\r\n\t\t\t\t\treturn undefined;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\treturn result.copy( direction ).multiplyScalar( t ).add( line.start );\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\r\n\t\tcoplanarPoint: function ( optionalTarget ) {\r\n\t\r\n\t\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\t\t\treturn result.copy( this.normal ).multiplyScalar( - this.constant );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tapplyMatrix4: function () {\r\n\t\r\n\t\t\tvar v1 = new THREE.Vector3();\r\n\t\t\tvar v2 = new THREE.Vector3();\r\n\t\t\tvar m1 = new THREE.Matrix3();\r\n\t\r\n\t\t\treturn function ( matrix, optionalNormalMatrix ) {\r\n\t\r\n\t\t\t\t// compute new normal based on theory here:\r\n\t\t\t\t// http://www.songho.ca/opengl/gl_normaltransform.html\r\n\t\t\t\tvar normalMatrix = optionalNormalMatrix || m1.getNormalMatrix( matrix );\r\n\t\t\t\tvar newNormal = v1.copy( this.normal ).applyMatrix3( normalMatrix );\r\n\t\r\n\t\t\t\tvar newCoplanarPoint = this.coplanarPoint( v2 );\r\n\t\t\t\tnewCoplanarPoint.applyMatrix4( matrix );\r\n\t\r\n\t\t\t\tthis.setFromNormalAndCoplanarPoint( newNormal, newCoplanarPoint );\r\n\t\r\n\t\t\t\treturn this;\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\ttranslate: function ( offset ) {\r\n\t\r\n\t\t\tthis.constant = this.constant - offset.dot( this.normal );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tequals: function ( plane ) {\r\n\t\r\n\t\t\treturn plane.normal.equals( this.normal ) && ( plane.constant == this.constant );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tclone: function () {\r\n\t\r\n\t\t\treturn new THREE.Plane().copy( this );\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/math/Math.js\r\n\t\r\n\t/**\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tTHREE.Math = {\r\n\t\r\n\t\tgenerateUUID: function () {\r\n\t\r\n\t\t\t// http://www.broofa.com/Tools/Math.uuid.htm\r\n\t\r\n\t\t\tvar chars = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.split( '' );\r\n\t\t\tvar uuid = new Array( 36 );\r\n\t\t\tvar rnd = 0, r;\r\n\t\r\n\t\t\treturn function () {\r\n\t\r\n\t\t\t\tfor ( var i = 0; i < 36; i ++ ) {\r\n\t\r\n\t\t\t\t\tif ( i == 8 || i == 13 || i == 18 || i == 23 ) {\r\n\t\r\n\t\t\t\t\t\tuuid[ i ] = '-';\r\n\t\r\n\t\t\t\t\t} else if ( i == 14 ) {\r\n\t\r\n\t\t\t\t\t\tuuid[ i ] = '4';\r\n\t\r\n\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\tif ( rnd <= 0x02 ) rnd = 0x2000000 + ( Math.random() * 0x1000000 ) | 0;\r\n\t\t\t\t\t\tr = rnd & 0xf;\r\n\t\t\t\t\t\trnd = rnd >> 4;\r\n\t\t\t\t\t\tuuid[ i ] = chars[ ( i == 19 ) ? ( r & 0x3 ) | 0x8 : r ];\r\n\t\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\treturn uuid.join( '' );\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\t// Clamp value to range <a, b>\r\n\t\r\n\t\tclamp: function ( x, a, b ) {\r\n\t\r\n\t\t\treturn ( x < a ) ? a : ( ( x > b ) ? b : x );\r\n\t\r\n\t\t},\r\n\t\r\n\t\t// Clamp value to range <a, inf)\r\n\t\r\n\t\tclampBottom: function ( x, a ) {\r\n\t\r\n\t\t\treturn x < a ? a : x;\r\n\t\r\n\t\t},\r\n\t\r\n\t\t// Linear mapping from range <a1, a2> to range <b1, b2>\r\n\t\r\n\t\tmapLinear: function ( x, a1, a2, b1, b2 ) {\r\n\t\r\n\t\t\treturn b1 + ( x - a1 ) * ( b2 - b1 ) / ( a2 - a1 );\r\n\t\r\n\t\t},\r\n\t\r\n\t\t// http://en.wikipedia.org/wiki/Smoothstep\r\n\t\r\n\t\tsmoothstep: function ( x, min, max ) {\r\n\t\r\n\t\t\tif ( x <= min ) return 0;\r\n\t\t\tif ( x >= max ) return 1;\r\n\t\r\n\t\t\tx = ( x - min ) / ( max - min );\r\n\t\r\n\t\t\treturn x * x * ( 3 - 2 * x );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsmootherstep: function ( x, min, max ) {\r\n\t\r\n\t\t\tif ( x <= min ) return 0;\r\n\t\t\tif ( x >= max ) return 1;\r\n\t\r\n\t\t\tx = ( x - min ) / ( max - min );\r\n\t\r\n\t\t\treturn x * x * x * ( x * ( x * 6 - 15 ) + 10 );\r\n\t\r\n\t\t},\r\n\t\r\n\t\t// Random float from <0, 1> with 16 bits of randomness\r\n\t\t// (standard Math.random() creates repetitive patterns when applied over larger space)\r\n\t\r\n\t\trandom16: function () {\r\n\t\r\n\t\t\treturn ( 65280 * Math.random() + 255 * Math.random() ) / 65535;\r\n\t\r\n\t\t},\r\n\t\r\n\t\t// Random integer from <low, high> interval\r\n\t\r\n\t\trandInt: function ( low, high ) {\r\n\t\r\n\t\t\treturn Math.floor( this.randFloat( low, high ) );\r\n\t\r\n\t\t},\r\n\t\r\n\t\t// Random float from <low, high> interval\r\n\t\r\n\t\trandFloat: function ( low, high ) {\r\n\t\r\n\t\t\treturn low + Math.random() * ( high - low );\r\n\t\r\n\t\t},\r\n\t\r\n\t\t// Random float from <-range/2, range/2> interval\r\n\t\r\n\t\trandFloatSpread: function ( range ) {\r\n\t\r\n\t\t\treturn range * ( 0.5 - Math.random() );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tdegToRad: function () {\r\n\t\r\n\t\t\tvar degreeToRadiansFactor = Math.PI / 180;\r\n\t\r\n\t\t\treturn function ( degrees ) {\r\n\t\r\n\t\t\t\treturn degrees * degreeToRadiansFactor;\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tradToDeg: function () {\r\n\t\r\n\t\t\tvar radianToDegreesFactor = 180 / Math.PI;\r\n\t\r\n\t\t\treturn function ( radians ) {\r\n\t\r\n\t\t\t\treturn radians * radianToDegreesFactor;\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tisPowerOfTwo: function ( value ) {\r\n\t\r\n\t\t\treturn ( value & ( value - 1 ) ) === 0 && value !== 0;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tnextPowerOfTwo: function ( value ) {\r\n\t\r\n\t\t\tvalue --;\r\n\t\t\tvalue |= value >> 1;\r\n\t\t\tvalue |= value >> 2;\r\n\t\t\tvalue |= value >> 4;\r\n\t\t\tvalue |= value >> 8;\r\n\t\t\tvalue |= value >> 16;\r\n\t\t\tvalue ++;\r\n\t\r\n\t\t\treturn value;\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/math/Spline.js\r\n\t\r\n\t/**\r\n\t * Spline from Tween.js, slightly optimized (and trashed)\r\n\t * http://sole.github.com/tween.js/examples/05_spline.html\r\n\t *\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t */\r\n\t\r\n\tTHREE.Spline = function ( points ) {\r\n\t\r\n\t\tthis.points = points;\r\n\t\r\n\t\tvar c = [], v3 = { x: 0, y: 0, z: 0 },\r\n\t\tpoint, intPoint, weight, w2, w3,\r\n\t\tpa, pb, pc, pd;\r\n\t\r\n\t\tthis.initFromArray = function ( a ) {\r\n\t\r\n\t\t\tthis.points = [];\r\n\t\r\n\t\t\tfor ( var i = 0; i < a.length; i ++ ) {\r\n\t\r\n\t\t\t\tthis.points[ i ] = { x: a[ i ][ 0 ], y: a[ i ][ 1 ], z: a[ i ][ 2 ] };\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.getPoint = function ( k ) {\r\n\t\r\n\t\t\tpoint = ( this.points.length - 1 ) * k;\r\n\t\t\tintPoint = Math.floor( point );\r\n\t\t\tweight = point - intPoint;\r\n\t\r\n\t\t\tc[ 0 ] = intPoint === 0 ? intPoint : intPoint - 1;\r\n\t\t\tc[ 1 ] = intPoint;\r\n\t\t\tc[ 2 ] = intPoint  > this.points.length - 2 ? this.points.length - 1 : intPoint + 1;\r\n\t\t\tc[ 3 ] = intPoint  > this.points.length - 3 ? this.points.length - 1 : intPoint + 2;\r\n\t\r\n\t\t\tpa = this.points[ c[ 0 ] ];\r\n\t\t\tpb = this.points[ c[ 1 ] ];\r\n\t\t\tpc = this.points[ c[ 2 ] ];\r\n\t\t\tpd = this.points[ c[ 3 ] ];\r\n\t\r\n\t\t\tw2 = weight * weight;\r\n\t\t\tw3 = weight * w2;\r\n\t\r\n\t\t\tv3.x = interpolate( pa.x, pb.x, pc.x, pd.x, weight, w2, w3 );\r\n\t\t\tv3.y = interpolate( pa.y, pb.y, pc.y, pd.y, weight, w2, w3 );\r\n\t\t\tv3.z = interpolate( pa.z, pb.z, pc.z, pd.z, weight, w2, w3 );\r\n\t\r\n\t\t\treturn v3;\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.getControlPointsArray = function () {\r\n\t\r\n\t\t\tvar i, p, l = this.points.length,\r\n\t\t\t\tcoords = [];\r\n\t\r\n\t\t\tfor ( i = 0; i < l; i ++ ) {\r\n\t\r\n\t\t\t\tp = this.points[ i ];\r\n\t\t\t\tcoords[ i ] = [ p.x, p.y, p.z ];\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn coords;\r\n\t\r\n\t\t};\r\n\t\r\n\t\t// approximate length by summing linear segments\r\n\t\r\n\t\tthis.getLength = function ( nSubDivisions ) {\r\n\t\r\n\t\t\tvar i, index, nSamples, position,\r\n\t\t\t\tpoint = 0, intPoint = 0, oldIntPoint = 0,\r\n\t\t\t\toldPosition = new THREE.Vector3(),\r\n\t\t\t\ttmpVec = new THREE.Vector3(),\r\n\t\t\t\tchunkLengths = [],\r\n\t\t\t\ttotalLength = 0;\r\n\t\r\n\t\t\t// first point has 0 length\r\n\t\r\n\t\t\tchunkLengths[ 0 ] = 0;\r\n\t\r\n\t\t\tif ( ! nSubDivisions ) nSubDivisions = 100;\r\n\t\r\n\t\t\tnSamples = this.points.length * nSubDivisions;\r\n\t\r\n\t\t\toldPosition.copy( this.points[ 0 ] );\r\n\t\r\n\t\t\tfor ( i = 1; i < nSamples; i ++ ) {\r\n\t\r\n\t\t\t\tindex = i / nSamples;\r\n\t\r\n\t\t\t\tposition = this.getPoint( index );\r\n\t\t\t\ttmpVec.copy( position );\r\n\t\r\n\t\t\t\ttotalLength += tmpVec.distanceTo( oldPosition );\r\n\t\r\n\t\t\t\toldPosition.copy( position );\r\n\t\r\n\t\t\t\tpoint = ( this.points.length - 1 ) * index;\r\n\t\t\t\tintPoint = Math.floor( point );\r\n\t\r\n\t\t\t\tif ( intPoint != oldIntPoint ) {\r\n\t\r\n\t\t\t\t\tchunkLengths[ intPoint ] = totalLength;\r\n\t\t\t\t\toldIntPoint = intPoint;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// last point ends with total length\r\n\t\r\n\t\t\tchunkLengths[ chunkLengths.length ] = totalLength;\r\n\t\r\n\t\t\treturn { chunks: chunkLengths, total: totalLength };\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.reparametrizeByArcLength = function ( samplingCoef ) {\r\n\t\r\n\t\t\tvar i, j,\r\n\t\t\t\tindex, indexCurrent, indexNext,\r\n\t\t\t\trealDistance,\r\n\t\t\t\tsampling, position,\r\n\t\t\t\tnewpoints = [],\r\n\t\t\t\ttmpVec = new THREE.Vector3(),\r\n\t\t\t\tsl = this.getLength();\r\n\t\r\n\t\t\tnewpoints.push( tmpVec.copy( this.points[ 0 ] ).clone() );\r\n\t\r\n\t\t\tfor ( i = 1; i < this.points.length; i ++ ) {\r\n\t\r\n\t\t\t\t//tmpVec.copy( this.points[ i - 1 ] );\r\n\t\t\t\t//linearDistance = tmpVec.distanceTo( this.points[ i ] );\r\n\t\r\n\t\t\t\trealDistance = sl.chunks[ i ] - sl.chunks[ i - 1 ];\r\n\t\r\n\t\t\t\tsampling = Math.ceil( samplingCoef * realDistance / sl.total );\r\n\t\r\n\t\t\t\tindexCurrent = ( i - 1 ) / ( this.points.length - 1 );\r\n\t\t\t\tindexNext = i / ( this.points.length - 1 );\r\n\t\r\n\t\t\t\tfor ( j = 1; j < sampling - 1; j ++ ) {\r\n\t\r\n\t\t\t\t\tindex = indexCurrent + j * ( 1 / sampling ) * ( indexNext - indexCurrent );\r\n\t\r\n\t\t\t\t\tposition = this.getPoint( index );\r\n\t\t\t\t\tnewpoints.push( tmpVec.copy( position ).clone() );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tnewpoints.push( tmpVec.copy( this.points[ i ] ).clone() );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tthis.points = newpoints;\r\n\t\r\n\t\t};\r\n\t\r\n\t\t// Catmull-Rom\r\n\t\r\n\t\tfunction interpolate( p0, p1, p2, p3, t, t2, t3 ) {\r\n\t\r\n\t\t\tvar v0 = ( p2 - p0 ) * 0.5,\r\n\t\t\t\tv1 = ( p3 - p1 ) * 0.5;\r\n\t\r\n\t\t\treturn ( 2 * ( p1 - p2 ) + v0 + v1 ) * t3 + ( - 3 * ( p1 - p2 ) - 2 * v0 - v1 ) * t2 + v0 * t + p1;\r\n\t\r\n\t\t};\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/math/Triangle.js\r\n\t\r\n\t/**\r\n\t * @author bhouston / http://exocortex.com\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tTHREE.Triangle = function ( a, b, c ) {\r\n\t\r\n\t\tthis.a = ( a !== undefined ) ? a : new THREE.Vector3();\r\n\t\tthis.b = ( b !== undefined ) ? b : new THREE.Vector3();\r\n\t\tthis.c = ( c !== undefined ) ? c : new THREE.Vector3();\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Triangle.normal = function () {\r\n\t\r\n\t\tvar v0 = new THREE.Vector3();\r\n\t\r\n\t\treturn function ( a, b, c, optionalTarget ) {\r\n\t\r\n\t\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\t\r\n\t\t\tresult.subVectors( c, b );\r\n\t\t\tv0.subVectors( a, b );\r\n\t\t\tresult.cross( v0 );\r\n\t\r\n\t\t\tvar resultLengthSq = result.lengthSq();\r\n\t\t\tif ( resultLengthSq > 0 ) {\r\n\t\r\n\t\t\t\treturn result.multiplyScalar( 1 / Math.sqrt( resultLengthSq ) );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn result.set( 0, 0, 0 );\r\n\t\r\n\t\t};\r\n\t\r\n\t}();\r\n\t\r\n\t// static/instance method to calculate barycoordinates\r\n\t// based on: http://www.blackpawn.com/texts/pointinpoly/default.html\r\n\tTHREE.Triangle.barycoordFromPoint = function () {\r\n\t\r\n\t\tvar v0 = new THREE.Vector3();\r\n\t\tvar v1 = new THREE.Vector3();\r\n\t\tvar v2 = new THREE.Vector3();\r\n\t\r\n\t\treturn function ( point, a, b, c, optionalTarget ) {\r\n\t\r\n\t\t\tv0.subVectors( c, a );\r\n\t\t\tv1.subVectors( b, a );\r\n\t\t\tv2.subVectors( point, a );\r\n\t\r\n\t\t\tvar dot00 = v0.dot( v0 );\r\n\t\t\tvar dot01 = v0.dot( v1 );\r\n\t\t\tvar dot02 = v0.dot( v2 );\r\n\t\t\tvar dot11 = v1.dot( v1 );\r\n\t\t\tvar dot12 = v1.dot( v2 );\r\n\t\r\n\t\t\tvar denom = ( dot00 * dot11 - dot01 * dot01 );\r\n\t\r\n\t\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\t\r\n\t\t\t// colinear or singular triangle\r\n\t\t\tif ( denom == 0 ) {\r\n\t\t\t\t// arbitrary location outside of triangle?\r\n\t\t\t\t// not sure if this is the best idea, maybe should be returning undefined\r\n\t\t\t\treturn result.set( - 2, - 1, - 1 );\r\n\t\t\t}\r\n\t\r\n\t\t\tvar invDenom = 1 / denom;\r\n\t\t\tvar u = ( dot11 * dot02 - dot01 * dot12 ) * invDenom;\r\n\t\t\tvar v = ( dot00 * dot12 - dot01 * dot02 ) * invDenom;\r\n\t\r\n\t\t\t// barycoordinates must always sum to 1\r\n\t\t\treturn result.set( 1 - u - v, v, u );\r\n\t\r\n\t\t};\r\n\t\r\n\t}();\r\n\t\r\n\tTHREE.Triangle.containsPoint = function () {\r\n\t\r\n\t\tvar v1 = new THREE.Vector3();\r\n\t\r\n\t\treturn function ( point, a, b, c ) {\r\n\t\r\n\t\t\tvar result = THREE.Triangle.barycoordFromPoint( point, a, b, c, v1 );\r\n\t\r\n\t\t\treturn ( result.x >= 0 ) && ( result.y >= 0 ) && ( ( result.x + result.y ) <= 1 );\r\n\t\r\n\t\t};\r\n\t\r\n\t}();\r\n\t\r\n\tTHREE.Triangle.prototype = {\r\n\t\r\n\t\tconstructor: THREE.Triangle,\r\n\t\r\n\t\tset: function ( a, b, c ) {\r\n\t\r\n\t\t\tthis.a.copy( a );\r\n\t\t\tthis.b.copy( b );\r\n\t\t\tthis.c.copy( c );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetFromPointsAndIndices: function ( points, i0, i1, i2 ) {\r\n\t\r\n\t\t\tthis.a.copy( points[ i0 ] );\r\n\t\t\tthis.b.copy( points[ i1 ] );\r\n\t\t\tthis.c.copy( points[ i2 ] );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcopy: function ( triangle ) {\r\n\t\r\n\t\t\tthis.a.copy( triangle.a );\r\n\t\t\tthis.b.copy( triangle.b );\r\n\t\t\tthis.c.copy( triangle.c );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tarea: function () {\r\n\t\r\n\t\t\tvar v0 = new THREE.Vector3();\r\n\t\t\tvar v1 = new THREE.Vector3();\r\n\t\r\n\t\t\treturn function () {\r\n\t\r\n\t\t\t\tv0.subVectors( this.c, this.b );\r\n\t\t\t\tv1.subVectors( this.a, this.b );\r\n\t\r\n\t\t\t\treturn v0.cross( v1 ).length() * 0.5;\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tmidpoint: function ( optionalTarget ) {\r\n\t\r\n\t\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\t\t\treturn result.addVectors( this.a, this.b ).add( this.c ).multiplyScalar( 1 / 3 );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tnormal: function ( optionalTarget ) {\r\n\t\r\n\t\t\treturn THREE.Triangle.normal( this.a, this.b, this.c, optionalTarget );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tplane: function ( optionalTarget ) {\r\n\t\r\n\t\t\tvar result = optionalTarget || new THREE.Plane();\r\n\t\r\n\t\t\treturn result.setFromCoplanarPoints( this.a, this.b, this.c );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tbarycoordFromPoint: function ( point, optionalTarget ) {\r\n\t\r\n\t\t\treturn THREE.Triangle.barycoordFromPoint( point, this.a, this.b, this.c, optionalTarget );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcontainsPoint: function ( point ) {\r\n\t\r\n\t\t\treturn THREE.Triangle.containsPoint( point, this.a, this.b, this.c );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tequals: function ( triangle ) {\r\n\t\r\n\t\t\treturn triangle.a.equals( this.a ) && triangle.b.equals( this.b ) && triangle.c.equals( this.c );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tclone: function () {\r\n\t\r\n\t\t\treturn new THREE.Triangle().copy( this );\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/core/Clock.js\r\n\t\r\n\t/**\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t */\r\n\t\r\n\tTHREE.Clock = function ( autoStart ) {\r\n\t\r\n\t\tthis.autoStart = ( autoStart !== undefined ) ? autoStart : true;\r\n\t\r\n\t\tthis.startTime = 0;\r\n\t\tthis.oldTime = 0;\r\n\t\tthis.elapsedTime = 0;\r\n\t\r\n\t\tthis.running = false;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Clock.prototype = {\r\n\t\r\n\t\tconstructor: THREE.Clock,\r\n\t\r\n\t\tstart: function () {\r\n\t\r\n\t\t\tthis.startTime = self.performance !== undefined && self.performance.now !== undefined\r\n\t\t\t\t\t\t ? self.performance.now()\r\n\t\t\t\t\t\t : Date.now();\r\n\t\r\n\t\t\tthis.oldTime = this.startTime;\r\n\t\t\tthis.running = true;\r\n\t\t},\r\n\t\r\n\t\tstop: function () {\r\n\t\r\n\t\t\tthis.getElapsedTime();\r\n\t\t\tthis.running = false;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tgetElapsedTime: function () {\r\n\t\r\n\t\t\tthis.getDelta();\r\n\t\t\treturn this.elapsedTime;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tgetDelta: function () {\r\n\t\r\n\t\t\tvar diff = 0;\r\n\t\r\n\t\t\tif ( this.autoStart && ! this.running ) {\r\n\t\r\n\t\t\t\tthis.start();\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( this.running ) {\r\n\t\r\n\t\t\t\tvar newTime = self.performance !== undefined && self.performance.now !== undefined\r\n\t\t\t\t\t\t ? self.performance.now()\r\n\t\t\t\t\t\t : Date.now();\r\n\t\r\n\t\t\t\tdiff = 0.001 * ( newTime - this.oldTime );\r\n\t\t\t\tthis.oldTime = newTime;\r\n\t\r\n\t\t\t\tthis.elapsedTime += diff;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn diff;\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/core/EventDispatcher.js\r\n\t\r\n\t/**\r\n\t * https://github.com/mrdoob/eventdispatcher.js/\r\n\t */\r\n\t\r\n\tTHREE.EventDispatcher = function () {}\r\n\t\r\n\tTHREE.EventDispatcher.prototype = {\r\n\t\r\n\t\tconstructor: THREE.EventDispatcher,\r\n\t\r\n\t\tapply: function ( object ) {\r\n\t\r\n\t\t\tobject.addEventListener = THREE.EventDispatcher.prototype.addEventListener;\r\n\t\t\tobject.hasEventListener = THREE.EventDispatcher.prototype.hasEventListener;\r\n\t\t\tobject.removeEventListener = THREE.EventDispatcher.prototype.removeEventListener;\r\n\t\t\tobject.dispatchEvent = THREE.EventDispatcher.prototype.dispatchEvent;\r\n\t\r\n\t\t},\r\n\t\r\n\t\taddEventListener: function ( type, listener ) {\r\n\t\r\n\t\t\tif ( this._listeners === undefined ) this._listeners = {};\r\n\t\r\n\t\t\tvar listeners = this._listeners;\r\n\t\r\n\t\t\tif ( listeners[ type ] === undefined ) {\r\n\t\r\n\t\t\t\tlisteners[ type ] = [];\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( listeners[ type ].indexOf( listener ) === - 1 ) {\r\n\t\r\n\t\t\t\tlisteners[ type ].push( listener );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t},\r\n\t\r\n\t\thasEventListener: function ( type, listener ) {\r\n\t\r\n\t\t\tif ( this._listeners === undefined ) return false;\r\n\t\r\n\t\t\tvar listeners = this._listeners;\r\n\t\r\n\t\t\tif ( listeners[ type ] !== undefined && listeners[ type ].indexOf( listener ) !== - 1 ) {\r\n\t\r\n\t\t\t\treturn true;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn false;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tremoveEventListener: function ( type, listener ) {\r\n\t\r\n\t\t\tif ( this._listeners === undefined ) return;\r\n\t\r\n\t\t\tvar listeners = this._listeners;\r\n\t\t\tvar listenerArray = listeners[ type ];\r\n\t\r\n\t\t\tif ( listenerArray !== undefined ) {\r\n\t\r\n\t\t\t\tvar index = listenerArray.indexOf( listener );\r\n\t\r\n\t\t\t\tif ( index !== - 1 ) {\r\n\t\r\n\t\t\t\t\tlistenerArray.splice( index, 1 );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t},\r\n\t\r\n\t\tdispatchEvent: function ( event ) {\r\n\t\r\n\t\t\tif ( this._listeners === undefined ) return;\r\n\t\r\n\t\t\tvar listeners = this._listeners;\r\n\t\t\tvar listenerArray = listeners[ event.type ];\r\n\t\r\n\t\t\tif ( listenerArray !== undefined ) {\r\n\t\r\n\t\t\t\tevent.target = this;\r\n\t\r\n\t\t\t\tvar array = [];\r\n\t\t\t\tvar length = listenerArray.length;\r\n\t\r\n\t\t\t\tfor ( var i = 0; i < length; i ++ ) {\r\n\t\r\n\t\t\t\t\tarray[ i ] = listenerArray[ i ];\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tfor ( var i = 0; i < length; i ++ ) {\r\n\t\r\n\t\t\t\t\tarray[ i ].call( this, event );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/core/Raycaster.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t * @author bhouston / http://exocortex.com/\r\n\t * @author stephomi / http://stephaneginier.com/\r\n\t */\r\n\t\r\n\t( function ( THREE ) {\r\n\t\r\n\t\tTHREE.Raycaster = function ( origin, direction, near, far ) {\r\n\t\r\n\t\t\tthis.ray = new THREE.Ray( origin, direction );\r\n\t\t\t// direction is assumed to be normalized (for accurate distance calculations)\r\n\t\r\n\t\t\tthis.near = near || 0;\r\n\t\t\tthis.far = far || Infinity;\r\n\t\r\n\t\t\tthis.params = {\r\n\t\t\t\tSprite: {},\r\n\t\t\t\tMesh: {},\r\n\t\t\t\tPointCloud: { threshold: 1 },\r\n\t\t\t\tLOD: {},\r\n\t\t\t\tLine: {}\r\n\t\t\t};\r\n\t\r\n\t\t};\r\n\t\r\n\t\tvar descSort = function ( a, b ) {\r\n\t\r\n\t\t\treturn a.distance - b.distance;\r\n\t\r\n\t\t};\r\n\t\r\n\t\tvar intersectObject = function ( object, raycaster, intersects, recursive ) {\r\n\t\r\n\t\t\tobject.raycast( raycaster, intersects );\r\n\t\r\n\t\t\tif ( recursive === true ) {\r\n\t\r\n\t\t\t\tvar children = object.children;\r\n\t\r\n\t\t\t\tfor ( var i = 0, l = children.length; i < l; i ++ ) {\r\n\t\r\n\t\t\t\t\tintersectObject( children[ i ], raycaster, intersects, true );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t\t//\r\n\t\r\n\t\tTHREE.Raycaster.prototype = {\r\n\t\r\n\t\t\tconstructor: THREE.Raycaster,\r\n\t\r\n\t\t\tprecision: 0.0001,\r\n\t\t\tlinePrecision: 1,\r\n\t\r\n\t\t\tset: function ( origin, direction ) {\r\n\t\r\n\t\t\t\t// direction is assumed to be normalized (for accurate distance calculations)\r\n\t\r\n\t\t\t\tthis.ray.set( origin, direction );\r\n\t\r\n\t\t\t},\r\n\t\r\n\t\t\tsetFromCamera: function ( coords, camera ) {\r\n\t\r\n\t\t\t\t// camera is assumed _not_ to be a child of a transformed object\r\n\t\r\n\t\t\t\tif ( camera instanceof THREE.PerspectiveCamera ) {\r\n\t\r\n\t\t\t\t\tthis.ray.origin.copy( camera.position );\r\n\t\t\t\t\tthis.ray.direction.set( coords.x, coords.y, 0.5 ).unproject( camera ).sub( camera.position ).normalize();\r\n\t\r\n\t\t\t\t} else if ( camera instanceof THREE.OrthographicCamera ) {\r\n\t\r\n\t\t\t\t\tthis.ray.origin.set( coords.x, coords.y, - 1 ).unproject( camera );\r\n\t\t\t\t\tthis.ray.direction.set( 0, 0, - 1 ).transformDirection( camera.matrixWorld );\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tTHREE.error( 'THREE.Raycaster: Unsupported camera type.' );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t},\r\n\t\r\n\t\t\tintersectObject: function ( object, recursive ) {\r\n\t\r\n\t\t\t\tvar intersects = [];\r\n\t\r\n\t\t\t\tintersectObject( object, this, intersects, recursive );\r\n\t\r\n\t\t\t\tintersects.sort( descSort );\r\n\t\r\n\t\t\t\treturn intersects;\r\n\t\r\n\t\t\t},\r\n\t\r\n\t\t\tintersectObjects: function ( objects, recursive ) {\r\n\t\r\n\t\t\t\tvar intersects = [];\r\n\t\r\n\t\t\t\tif ( objects instanceof Array === false ) {\r\n\t\r\n\t\t\t\t\tTHREE.warn( 'THREE.Raycaster.intersectObjects: objects is not an Array.' );\r\n\t\t\t\t\treturn intersects;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tfor ( var i = 0, l = objects.length; i < l; i ++ ) {\r\n\t\r\n\t\t\t\t\tintersectObject( objects[ i ], this, intersects, recursive );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tintersects.sort( descSort );\r\n\t\r\n\t\t\t\treturn intersects;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t}( THREE ) );\r\n\t\r\n\t// File:src/core/Object3D.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t * @author mikael emtinger / http://gomo.se/\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t * @author WestLangley / http://github.com/WestLangley\r\n\t */\r\n\t\r\n\tTHREE.Object3D = function () {\r\n\t\r\n\t\tObject.defineProperty( this, 'id', { value: THREE.Object3DIdCount ++ } );\r\n\t\r\n\t\tthis.uuid = THREE.Math.generateUUID();\r\n\t\r\n\t\tthis.name = '';\r\n\t\tthis.type = 'Object3D';\r\n\t\r\n\t\tthis.parent = undefined;\r\n\t\tthis.children = [];\r\n\t\r\n\t\tthis.up = THREE.Object3D.DefaultUp.clone();\r\n\t\r\n\t\tvar position = new THREE.Vector3();\r\n\t\tvar rotation = new THREE.Euler();\r\n\t\tvar quaternion = new THREE.Quaternion();\r\n\t\tvar scale = new THREE.Vector3( 1, 1, 1 );\r\n\t\r\n\t\tvar onRotationChange = function () {\r\n\t\t\tquaternion.setFromEuler( rotation, false );\r\n\t\t};\r\n\t\r\n\t\tvar onQuaternionChange = function () {\r\n\t\t\trotation.setFromQuaternion( quaternion, undefined, false );\r\n\t\t};\r\n\t\r\n\t\trotation.onChange( onRotationChange );\r\n\t\tquaternion.onChange( onQuaternionChange );\r\n\t\r\n\t\tObject.defineProperties( this, {\r\n\t\t\tposition: {\r\n\t\t\t\tenumerable: true,\r\n\t\t\t\tvalue: position\r\n\t\t\t},\r\n\t\t\trotation: {\r\n\t\t\t\tenumerable: true,\r\n\t\t\t\tvalue: rotation\r\n\t\t\t},\r\n\t\t\tquaternion: {\r\n\t\t\t\tenumerable: true,\r\n\t\t\t\tvalue: quaternion\r\n\t\t\t},\r\n\t\t\tscale: {\r\n\t\t\t\tenumerable: true,\r\n\t\t\t\tvalue: scale\r\n\t\t\t}\r\n\t\t} );\r\n\t\r\n\t\tthis.rotationAutoUpdate = true;\r\n\t\r\n\t\tthis.matrix = new THREE.Matrix4();\r\n\t\tthis.matrixWorld = new THREE.Matrix4();\r\n\t\r\n\t\tthis.matrixAutoUpdate = true;\r\n\t\tthis.matrixWorldNeedsUpdate = false;\r\n\t\r\n\t\tthis.visible = true;\r\n\t\r\n\t\tthis.castShadow = false;\r\n\t\tthis.receiveShadow = false;\r\n\t\r\n\t\tthis.frustumCulled = true;\r\n\t\tthis.renderOrder = 0;\r\n\t\r\n\t\tthis.userData = {};\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Object3D.DefaultUp = new THREE.Vector3( 0, 1, 0 );\r\n\t\r\n\tTHREE.Object3D.prototype = {\r\n\t\r\n\t\tconstructor: THREE.Object3D,\r\n\t\r\n\t\tget eulerOrder () {\r\n\t\r\n\t\t\tTHREE.warn( 'THREE.Object3D: .eulerOrder has been moved to .rotation.order.' );\r\n\t\r\n\t\t\treturn this.rotation.order;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tset eulerOrder ( value ) {\r\n\t\r\n\t\t\tTHREE.warn( 'THREE.Object3D: .eulerOrder has been moved to .rotation.order.' );\r\n\t\r\n\t\t\tthis.rotation.order = value;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tget useQuaternion () {\r\n\t\r\n\t\t\tTHREE.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tset useQuaternion ( value ) {\r\n\t\r\n\t\t\tTHREE.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tapplyMatrix: function ( matrix ) {\r\n\t\r\n\t\t\tthis.matrix.multiplyMatrices( matrix, this.matrix );\r\n\t\r\n\t\t\tthis.matrix.decompose( this.position, this.quaternion, this.scale );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetRotationFromAxisAngle: function ( axis, angle ) {\r\n\t\r\n\t\t\t// assumes axis is normalized\r\n\t\r\n\t\t\tthis.quaternion.setFromAxisAngle( axis, angle );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetRotationFromEuler: function ( euler ) {\r\n\t\r\n\t\t\tthis.quaternion.setFromEuler( euler, true );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetRotationFromMatrix: function ( m ) {\r\n\t\r\n\t\t\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\r\n\t\r\n\t\t\tthis.quaternion.setFromRotationMatrix( m );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetRotationFromQuaternion: function ( q ) {\r\n\t\r\n\t\t\t// assumes q is normalized\r\n\t\r\n\t\t\tthis.quaternion.copy( q );\r\n\t\r\n\t\t},\r\n\t\r\n\t\trotateOnAxis: function () {\r\n\t\r\n\t\t\t// rotate object on axis in object space\r\n\t\t\t// axis is assumed to be normalized\r\n\t\r\n\t\t\tvar q1 = new THREE.Quaternion();\r\n\t\r\n\t\t\treturn function ( axis, angle ) {\r\n\t\r\n\t\t\t\tq1.setFromAxisAngle( axis, angle );\r\n\t\r\n\t\t\t\tthis.quaternion.multiply( q1 );\r\n\t\r\n\t\t\t\treturn this;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\trotateX: function () {\r\n\t\r\n\t\t\tvar v1 = new THREE.Vector3( 1, 0, 0 );\r\n\t\r\n\t\t\treturn function ( angle ) {\r\n\t\r\n\t\t\t\treturn this.rotateOnAxis( v1, angle );\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\trotateY: function () {\r\n\t\r\n\t\t\tvar v1 = new THREE.Vector3( 0, 1, 0 );\r\n\t\r\n\t\t\treturn function ( angle ) {\r\n\t\r\n\t\t\t\treturn this.rotateOnAxis( v1, angle );\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\trotateZ: function () {\r\n\t\r\n\t\t\tvar v1 = new THREE.Vector3( 0, 0, 1 );\r\n\t\r\n\t\t\treturn function ( angle ) {\r\n\t\r\n\t\t\t\treturn this.rotateOnAxis( v1, angle );\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\ttranslateOnAxis: function () {\r\n\t\r\n\t\t\t// translate object by distance along axis in object space\r\n\t\t\t// axis is assumed to be normalized\r\n\t\r\n\t\t\tvar v1 = new THREE.Vector3();\r\n\t\r\n\t\t\treturn function ( axis, distance ) {\r\n\t\r\n\t\t\t\tv1.copy( axis ).applyQuaternion( this.quaternion );\r\n\t\r\n\t\t\t\tthis.position.add( v1.multiplyScalar( distance ) );\r\n\t\r\n\t\t\t\treturn this;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\ttranslate: function ( distance, axis ) {\r\n\t\r\n\t\t\tTHREE.warn( 'THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.' );\r\n\t\t\treturn this.translateOnAxis( axis, distance );\r\n\t\r\n\t\t},\r\n\t\r\n\t\ttranslateX: function () {\r\n\t\r\n\t\t\tvar v1 = new THREE.Vector3( 1, 0, 0 );\r\n\t\r\n\t\t\treturn function ( distance ) {\r\n\t\r\n\t\t\t\treturn this.translateOnAxis( v1, distance );\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\ttranslateY: function () {\r\n\t\r\n\t\t\tvar v1 = new THREE.Vector3( 0, 1, 0 );\r\n\t\r\n\t\t\treturn function ( distance ) {\r\n\t\r\n\t\t\t\treturn this.translateOnAxis( v1, distance );\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\ttranslateZ: function () {\r\n\t\r\n\t\t\tvar v1 = new THREE.Vector3( 0, 0, 1 );\r\n\t\r\n\t\t\treturn function ( distance ) {\r\n\t\r\n\t\t\t\treturn this.translateOnAxis( v1, distance );\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tlocalToWorld: function ( vector ) {\r\n\t\r\n\t\t\treturn vector.applyMatrix4( this.matrixWorld );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tworldToLocal: function () {\r\n\t\r\n\t\t\tvar m1 = new THREE.Matrix4();\r\n\t\r\n\t\t\treturn function ( vector ) {\r\n\t\r\n\t\t\t\treturn vector.applyMatrix4( m1.getInverse( this.matrixWorld ) );\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tlookAt: function () {\r\n\t\r\n\t\t\t// This routine does not support objects with rotated and/or translated parent(s)\r\n\t\r\n\t\t\tvar m1 = new THREE.Matrix4();\r\n\t\r\n\t\t\treturn function ( vector ) {\r\n\t\r\n\t\t\t\tm1.lookAt( vector, this.position, this.up );\r\n\t\r\n\t\t\t\tthis.quaternion.setFromRotationMatrix( m1 );\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tadd: function ( object ) {\r\n\t\r\n\t\t\tif ( arguments.length > 1 ) {\r\n\t\r\n\t\t\t\tfor ( var i = 0; i < arguments.length; i ++ ) {\r\n\t\r\n\t\t\t\t\tthis.add( arguments[ i ] );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\treturn this;\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t\tif ( object === this ) {\r\n\t\r\n\t\t\t\tTHREE.error( \"THREE.Object3D.add: object can't be added as a child of itself.\", object );\r\n\t\t\t\treturn this;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( object instanceof THREE.Object3D ) {\r\n\t\r\n\t\t\t\tif ( object.parent !== undefined ) {\r\n\t\r\n\t\t\t\t\tobject.parent.remove( object );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tobject.parent = this;\r\n\t\t\t\tobject.dispatchEvent( { type: 'added' } );\r\n\t\r\n\t\t\t\tthis.children.push( object );\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\tTHREE.error( \"THREE.Object3D.add: object not an instance of THREE.Object3D.\", object );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tremove: function ( object ) {\r\n\t\r\n\t\t\tif ( arguments.length > 1 ) {\r\n\t\r\n\t\t\t\tfor ( var i = 0; i < arguments.length; i ++ ) {\r\n\t\r\n\t\t\t\t\tthis.remove( arguments[ i ] );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t\tvar index = this.children.indexOf( object );\r\n\t\r\n\t\t\tif ( index !== - 1 ) {\r\n\t\r\n\t\t\t\tobject.parent = undefined;\r\n\t\r\n\t\t\t\tobject.dispatchEvent( { type: 'removed' } );\r\n\t\r\n\t\t\t\tthis.children.splice( index, 1 );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t},\r\n\t\r\n\t\tgetChildByName: function ( name ) {\r\n\t\r\n\t\t\tTHREE.warn( 'THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().' );\r\n\t\t\treturn this.getObjectByName( name );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tgetObjectById: function ( id ) {\r\n\t\r\n\t\t\treturn this.getObjectByProperty( 'id', id );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tgetObjectByName: function ( name ) {\r\n\t\r\n\t\t\treturn this.getObjectByProperty( 'name', name );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tgetObjectByProperty: function ( name, value ) {\r\n\t\r\n\t\t\tif ( this[ name ] === value ) return this;\r\n\t\r\n\t\t\tfor ( var i = 0, l = this.children.length; i < l; i ++ ) {\r\n\t\r\n\t\t\t\tvar child = this.children[ i ];\r\n\t\t\t\tvar object = child.getObjectByProperty( name, value );\r\n\t\r\n\t\t\t\tif ( object !== undefined ) {\r\n\t\r\n\t\t\t\t\treturn object;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn undefined;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tgetWorldPosition: function ( optionalTarget ) {\r\n\t\r\n\t\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\t\r\n\t\t\tthis.updateMatrixWorld( true );\r\n\t\r\n\t\t\treturn result.setFromMatrixPosition( this.matrixWorld );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tgetWorldQuaternion: function () {\r\n\t\r\n\t\t\tvar position = new THREE.Vector3();\r\n\t\t\tvar scale = new THREE.Vector3();\r\n\t\r\n\t\t\treturn function ( optionalTarget ) {\r\n\t\r\n\t\t\t\tvar result = optionalTarget || new THREE.Quaternion();\r\n\t\r\n\t\t\t\tthis.updateMatrixWorld( true );\r\n\t\r\n\t\t\t\tthis.matrixWorld.decompose( position, result, scale );\r\n\t\r\n\t\t\t\treturn result;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tgetWorldRotation: function () {\r\n\t\r\n\t\t\tvar quaternion = new THREE.Quaternion();\r\n\t\r\n\t\t\treturn function ( optionalTarget ) {\r\n\t\r\n\t\t\t\tvar result = optionalTarget || new THREE.Euler();\r\n\t\r\n\t\t\t\tthis.getWorldQuaternion( quaternion );\r\n\t\r\n\t\t\t\treturn result.setFromQuaternion( quaternion, this.rotation.order, false );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tgetWorldScale: function () {\r\n\t\r\n\t\t\tvar position = new THREE.Vector3();\r\n\t\t\tvar quaternion = new THREE.Quaternion();\r\n\t\r\n\t\t\treturn function ( optionalTarget ) {\r\n\t\r\n\t\t\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\t\r\n\t\t\t\tthis.updateMatrixWorld( true );\r\n\t\r\n\t\t\t\tthis.matrixWorld.decompose( position, quaternion, result );\r\n\t\r\n\t\t\t\treturn result;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tgetWorldDirection: function () {\r\n\t\r\n\t\t\tvar quaternion = new THREE.Quaternion();\r\n\t\r\n\t\t\treturn function ( optionalTarget ) {\r\n\t\r\n\t\t\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\t\r\n\t\t\t\tthis.getWorldQuaternion( quaternion );\r\n\t\r\n\t\t\t\treturn result.set( 0, 0, 1 ).applyQuaternion( quaternion );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\traycast: function () {},\r\n\t\r\n\t\ttraverse: function ( callback ) {\r\n\t\r\n\t\t\tcallback( this );\r\n\t\r\n\t\t\tfor ( var i = 0, l = this.children.length; i < l; i ++ ) {\r\n\t\r\n\t\t\t\tthis.children[ i ].traverse( callback );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t},\r\n\t\r\n\t\ttraverseVisible: function ( callback ) {\r\n\t\r\n\t\t\tif ( this.visible === false ) return;\r\n\t\r\n\t\t\tcallback( this );\r\n\t\r\n\t\t\tfor ( var i = 0, l = this.children.length; i < l; i ++ ) {\r\n\t\r\n\t\t\t\tthis.children[ i ].traverseVisible( callback );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t},\r\n\t\r\n\t\ttraverseAncestors: function ( callback ) {\r\n\t\r\n\t\t\tif ( this.parent ) {\r\n\t\r\n\t\t\t\tcallback( this.parent );\r\n\t\r\n\t\t\t\tthis.parent.traverseAncestors( callback );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t},\r\n\t\r\n\t\tupdateMatrix: function () {\r\n\t\r\n\t\t\tthis.matrix.compose( this.position, this.quaternion, this.scale );\r\n\t\r\n\t\t\tthis.matrixWorldNeedsUpdate = true;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tupdateMatrixWorld: function ( force ) {\r\n\t\r\n\t\t\tif ( this.matrixAutoUpdate === true ) this.updateMatrix();\r\n\t\r\n\t\t\tif ( this.matrixWorldNeedsUpdate === true || force === true ) {\r\n\t\r\n\t\t\t\tif ( this.parent === undefined ) {\r\n\t\r\n\t\t\t\t\tthis.matrixWorld.copy( this.matrix );\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tthis.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tthis.matrixWorldNeedsUpdate = false;\r\n\t\r\n\t\t\t\tforce = true;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// update children\r\n\t\r\n\t\t\tfor ( var i = 0, l = this.children.length; i < l; i ++ ) {\r\n\t\r\n\t\t\t\tthis.children[ i ].updateMatrixWorld( force );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t},\r\n\t\r\n\t\ttoJSON: function () {\r\n\t\r\n\t\t\tvar output = {\r\n\t\t\t\tmetadata: {\r\n\t\t\t\t\tversion: 4.3,\r\n\t\t\t\t\ttype: 'Object',\r\n\t\t\t\t\tgenerator: 'ObjectExporter'\r\n\t\t\t\t}\r\n\t\t\t};\r\n\t\r\n\t\t\t//\r\n\t\r\n\t\t\tvar geometries = {};\r\n\t\r\n\t\t\tvar parseGeometry = function ( geometry ) {\r\n\t\r\n\t\t\t\tif ( output.geometries === undefined ) {\r\n\t\r\n\t\t\t\t\toutput.geometries = [];\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( geometries[ geometry.uuid ] === undefined ) {\r\n\t\r\n\t\t\t\t\tvar json = geometry.toJSON();\r\n\t\r\n\t\t\t\t\tdelete json.metadata;\r\n\t\r\n\t\t\t\t\tgeometries[ geometry.uuid ] = json;\r\n\t\r\n\t\t\t\t\toutput.geometries.push( json );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\treturn geometry.uuid;\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t\t//\r\n\t\r\n\t\t\tvar materials = {};\r\n\t\r\n\t\t\tvar parseMaterial = function ( material ) {\r\n\t\r\n\t\t\t\tif ( output.materials === undefined ) {\r\n\t\r\n\t\t\t\t\toutput.materials = [];\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( materials[ material.uuid ] === undefined ) {\r\n\t\r\n\t\t\t\t\tvar json = material.toJSON();\r\n\t\r\n\t\t\t\t\tdelete json.metadata;\r\n\t\r\n\t\t\t\t\tmaterials[ material.uuid ] = json;\r\n\t\r\n\t\t\t\t\toutput.materials.push( json );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\treturn material.uuid;\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t\t//\r\n\t\r\n\t\t\tvar parseObject = function ( object ) {\r\n\t\r\n\t\t\t\tvar data = {};\r\n\t\r\n\t\t\t\tdata.uuid = object.uuid;\r\n\t\t\t\tdata.type = object.type;\r\n\t\r\n\t\t\t\tif ( object.name !== '' ) data.name = object.name;\r\n\t\t\t\tif ( JSON.stringify( object.userData ) !== '{}' ) data.userData = object.userData;\r\n\t\t\t\tif ( object.visible !== true ) data.visible = object.visible;\r\n\t\r\n\t\t\t\tif ( object instanceof THREE.PerspectiveCamera ) {\r\n\t\r\n\t\t\t\t\tdata.fov = object.fov;\r\n\t\t\t\t\tdata.aspect = object.aspect;\r\n\t\t\t\t\tdata.near = object.near;\r\n\t\t\t\t\tdata.far = object.far;\r\n\t\r\n\t\t\t\t} else if ( object instanceof THREE.OrthographicCamera ) {\r\n\t\r\n\t\t\t\t\tdata.left = object.left;\r\n\t\t\t\t\tdata.right = object.right;\r\n\t\t\t\t\tdata.top = object.top;\r\n\t\t\t\t\tdata.bottom = object.bottom;\r\n\t\t\t\t\tdata.near = object.near;\r\n\t\t\t\t\tdata.far = object.far;\r\n\t\r\n\t\t\t\t} else if ( object instanceof THREE.AmbientLight ) {\r\n\t\r\n\t\t\t\t\tdata.color = object.color.getHex();\r\n\t\r\n\t\t\t\t} else if ( object instanceof THREE.DirectionalLight ) {\r\n\t\r\n\t\t\t\t\tdata.color = object.color.getHex();\r\n\t\t\t\t\tdata.intensity = object.intensity;\r\n\t\r\n\t\t\t\t} else if ( object instanceof THREE.PointLight ) {\r\n\t\r\n\t\t\t\t\tdata.color = object.color.getHex();\r\n\t\t\t\t\tdata.intensity = object.intensity;\r\n\t\t\t\t\tdata.distance = object.distance;\r\n\t\t\t\t\tdata.decay = object.decay;\r\n\t\r\n\t\t\t\t} else if ( object instanceof THREE.SpotLight ) {\r\n\t\r\n\t\t\t\t\tdata.color = object.color.getHex();\r\n\t\t\t\t\tdata.intensity = object.intensity;\r\n\t\t\t\t\tdata.distance = object.distance;\r\n\t\t\t\t\tdata.angle = object.angle;\r\n\t\t\t\t\tdata.exponent = object.exponent;\r\n\t\t\t\t\tdata.decay = object.decay;\r\n\t\r\n\t\t\t\t} else if ( object instanceof THREE.HemisphereLight ) {\r\n\t\r\n\t\t\t\t\tdata.color = object.color.getHex();\r\n\t\t\t\t\tdata.groundColor = object.groundColor.getHex();\r\n\t\r\n\t\t\t\t} else if ( object instanceof THREE.Mesh || object instanceof THREE.Line || object instanceof THREE.PointCloud ) {\r\n\t\r\n\t\t\t\t\tdata.geometry = parseGeometry( object.geometry );\r\n\t\t\t\t\tdata.material = parseMaterial( object.material );\r\n\t\r\n\t\t\t\t\tif ( object instanceof THREE.Line ) data.mode = object.mode;\r\n\t\r\n\t\t\t\t} else if ( object instanceof THREE.Sprite ) {\r\n\t\r\n\t\t\t\t\tdata.material = parseMaterial( object.material );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tdata.matrix = object.matrix.toArray();\r\n\t\r\n\t\t\t\tif ( object.children.length > 0 ) {\r\n\t\r\n\t\t\t\t\tdata.children = [];\r\n\t\r\n\t\t\t\t\tfor ( var i = 0; i < object.children.length; i ++ ) {\r\n\t\r\n\t\t\t\t\t\tdata.children.push( parseObject( object.children[ i ] ) );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\treturn data;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\toutput.object = parseObject( this );\r\n\t\r\n\t\t\treturn output;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tclone: function ( object, recursive ) {\r\n\t\r\n\t\t\tif ( object === undefined ) object = new THREE.Object3D();\r\n\t\t\tif ( recursive === undefined ) recursive = true;\r\n\t\r\n\t\t\tobject.name = this.name;\r\n\t\r\n\t\t\tobject.up.copy( this.up );\r\n\t\r\n\t\t\tobject.position.copy( this.position );\r\n\t\t\tobject.quaternion.copy( this.quaternion );\r\n\t\t\tobject.scale.copy( this.scale );\r\n\t\r\n\t\t\tobject.rotationAutoUpdate = this.rotationAutoUpdate;\r\n\t\r\n\t\t\tobject.matrix.copy( this.matrix );\r\n\t\t\tobject.matrixWorld.copy( this.matrixWorld );\r\n\t\r\n\t\t\tobject.matrixAutoUpdate = this.matrixAutoUpdate;\r\n\t\t\tobject.matrixWorldNeedsUpdate = this.matrixWorldNeedsUpdate;\r\n\t\r\n\t\t\tobject.visible = this.visible;\r\n\t\r\n\t\t\tobject.castShadow = this.castShadow;\r\n\t\t\tobject.receiveShadow = this.receiveShadow;\r\n\t\r\n\t\t\tobject.frustumCulled = this.frustumCulled;\r\n\t\r\n\t\t\tobject.userData = JSON.parse( JSON.stringify( this.userData ) );\r\n\t\r\n\t\t\tif ( recursive === true ) {\r\n\t\r\n\t\t\t\tfor ( var i = 0; i < this.children.length; i ++ ) {\r\n\t\r\n\t\t\t\t\tvar child = this.children[ i ];\r\n\t\t\t\t\tobject.add( child.clone() );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn object;\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.EventDispatcher.prototype.apply( THREE.Object3D.prototype );\r\n\t\r\n\tTHREE.Object3DIdCount = 0;\r\n\t\r\n\t// File:src/core/Face3.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t */\r\n\t\r\n\tTHREE.Face3 = function ( a, b, c, normal, color, materialIndex ) {\r\n\t\r\n\t\tthis.a = a;\r\n\t\tthis.b = b;\r\n\t\tthis.c = c;\r\n\t\r\n\t\tthis.normal = normal instanceof THREE.Vector3 ? normal : new THREE.Vector3();\r\n\t\tthis.vertexNormals = normal instanceof Array ? normal : [];\r\n\t\r\n\t\tthis.color = color instanceof THREE.Color ? color : new THREE.Color();\r\n\t\tthis.vertexColors = color instanceof Array ? color : [];\r\n\t\r\n\t\tthis.vertexTangents = [];\r\n\t\r\n\t\tthis.materialIndex = materialIndex !== undefined ? materialIndex : 0;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Face3.prototype = {\r\n\t\r\n\t\tconstructor: THREE.Face3,\r\n\t\r\n\t\tclone: function () {\r\n\t\r\n\t\t\tvar face = new THREE.Face3( this.a, this.b, this.c );\r\n\t\r\n\t\t\tface.normal.copy( this.normal );\r\n\t\t\tface.color.copy( this.color );\r\n\t\r\n\t\t\tface.materialIndex = this.materialIndex;\r\n\t\r\n\t\t\tfor ( var i = 0, il = this.vertexNormals.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\tface.vertexNormals[ i ] = this.vertexNormals[ i ].clone();\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tfor ( var i = 0, il = this.vertexColors.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\tface.vertexColors[ i ] = this.vertexColors[ i ].clone();\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tfor ( var i = 0, il = this.vertexTangents.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\tface.vertexTangents[ i ] = this.vertexTangents[ i ].clone();\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn face;\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/core/Face4.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tTHREE.Face4 = function ( a, b, c, d, normal, color, materialIndex ) {\r\n\t\r\n\t\tTHREE.warn( 'THREE.Face4 has been removed. A THREE.Face3 will be created instead.' )\r\n\t\treturn new THREE.Face3( a, b, c, normal, color, materialIndex );\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/core/BufferAttribute.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tTHREE.BufferAttribute = function ( array, itemSize ) {\r\n\t\r\n\t\tthis.array = array;\r\n\t\tthis.itemSize = itemSize;\r\n\t\r\n\t\tthis.needsUpdate = false;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.BufferAttribute.prototype = {\r\n\t\r\n\t\tconstructor: THREE.BufferAttribute,\r\n\t\r\n\t\tget length () {\r\n\t\r\n\t\t\treturn this.array.length;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcopyAt: function ( index1, attribute, index2 ) {\r\n\t\r\n\t\t\tindex1 *= this.itemSize;\r\n\t\t\tindex2 *= attribute.itemSize;\r\n\t\r\n\t\t\tfor ( var i = 0, l = this.itemSize; i < l; i ++ ) {\r\n\t\r\n\t\t\t\tthis.array[ index1 + i ] = attribute.array[ index2 + i ];\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tset: function ( value, offset ) {\r\n\t\r\n\t\t\tif ( offset === undefined ) offset = 0;\r\n\t\r\n\t\t\tthis.array.set( value, offset );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetX: function ( index, x ) {\r\n\t\r\n\t\t\tthis.array[ index * this.itemSize ] = x;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetY: function ( index, y ) {\r\n\t\r\n\t\t\tthis.array[ index * this.itemSize + 1 ] = y;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetZ: function ( index, z ) {\r\n\t\r\n\t\t\tthis.array[ index * this.itemSize + 2 ] = z;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetXY: function ( index, x, y ) {\r\n\t\r\n\t\t\tindex *= this.itemSize;\r\n\t\r\n\t\t\tthis.array[ index     ] = x;\r\n\t\t\tthis.array[ index + 1 ] = y;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetXYZ: function ( index, x, y, z ) {\r\n\t\r\n\t\t\tindex *= this.itemSize;\r\n\t\r\n\t\t\tthis.array[ index     ] = x;\r\n\t\t\tthis.array[ index + 1 ] = y;\r\n\t\t\tthis.array[ index + 2 ] = z;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetXYZW: function ( index, x, y, z, w ) {\r\n\t\r\n\t\t\tindex *= this.itemSize;\r\n\t\r\n\t\t\tthis.array[ index     ] = x;\r\n\t\t\tthis.array[ index + 1 ] = y;\r\n\t\t\tthis.array[ index + 2 ] = z;\r\n\t\t\tthis.array[ index + 3 ] = w;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tclone: function () {\r\n\t\r\n\t\t\treturn new THREE.BufferAttribute( new this.array.constructor( this.array ), this.itemSize );\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t//\r\n\t\r\n\tTHREE.Int8Attribute = function ( data, itemSize ) {\r\n\t\r\n\t\tTHREE.warn( 'THREE.Int8Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead.' );\r\n\t\treturn new THREE.BufferAttribute( data, itemSize );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Uint8Attribute = function ( data, itemSize ) {\r\n\t\r\n\t\tTHREE.warn( 'THREE.Uint8Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead.' );\r\n\t\treturn new THREE.BufferAttribute( data, itemSize );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Uint8ClampedAttribute = function ( data, itemSize ) {\r\n\t\r\n\t\tTHREE.warn( 'THREE.Uint8ClampedAttribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead.' );\r\n\t\treturn new THREE.BufferAttribute( data, itemSize );\r\n\t\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Int16Attribute = function ( data, itemSize ) {\r\n\t\r\n\t\tTHREE.warn( 'THREE.Int16Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead.' );\r\n\t\treturn new THREE.BufferAttribute( data, itemSize );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Uint16Attribute = function ( data, itemSize ) {\r\n\t\r\n\t\tTHREE.warn( 'THREE.Uint16Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead.' );\r\n\t\treturn new THREE.BufferAttribute( data, itemSize );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Int32Attribute = function ( data, itemSize ) {\r\n\t\r\n\t\tTHREE.warn( 'THREE.Int32Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead.' );\r\n\t\treturn new THREE.BufferAttribute( data, itemSize );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Uint32Attribute = function ( data, itemSize ) {\r\n\t\r\n\t\tTHREE.warn( 'THREE.Uint32Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead.' );\r\n\t\treturn new THREE.BufferAttribute( data, itemSize );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Float32Attribute = function ( data, itemSize ) {\r\n\t\r\n\t\tTHREE.warn( 'THREE.Float32Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead.' );\r\n\t\treturn new THREE.BufferAttribute( data, itemSize );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Float64Attribute = function ( data, itemSize ) {\r\n\t\r\n\t\tTHREE.warn( 'THREE.Float64Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead.' );\r\n\t\treturn new THREE.BufferAttribute( data, itemSize );\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/core/DynamicBufferAttribute.js\r\n\t\r\n\t/**\r\n\t * @author benaadams / https://twitter.com/ben_a_adams\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tTHREE.DynamicBufferAttribute = function ( array, itemSize ) {\r\n\t\r\n\t\tTHREE.BufferAttribute.call( this, array, itemSize );\r\n\t\r\n\t\tthis.updateRange = { offset: 0, count: -1 };\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.DynamicBufferAttribute.prototype = Object.create( THREE.BufferAttribute.prototype );\r\n\tTHREE.DynamicBufferAttribute.prototype.constructor = THREE.DynamicBufferAttribute;\r\n\t\r\n\tTHREE.DynamicBufferAttribute.prototype.clone = function () {\r\n\t\r\n\t\treturn new THREE.DynamicBufferAttribute( new this.array.constructor( this.array ), this.itemSize );\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/core/BufferGeometry.js\r\n\t\r\n\t/**\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tTHREE.BufferGeometry = function () {\r\n\t\r\n\t\tObject.defineProperty( this, 'id', { value: THREE.GeometryIdCount ++ } );\r\n\t\r\n\t\tthis.uuid = THREE.Math.generateUUID();\r\n\t\r\n\t\tthis.name = '';\r\n\t\tthis.type = 'BufferGeometry';\r\n\t\r\n\t\tthis.attributes = {};\r\n\t\tthis.attributesKeys = [];\r\n\t\r\n\t\tthis.drawcalls = [];\r\n\t\tthis.offsets = this.drawcalls; // backwards compatibility\r\n\t\r\n\t\tthis.boundingBox = null;\r\n\t\tthis.boundingSphere = null;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.BufferGeometry.prototype = {\r\n\t\r\n\t\tconstructor: THREE.BufferGeometry,\r\n\t\r\n\t\taddAttribute: function ( name, attribute ) {\r\n\t\r\n\t\t\tif ( attribute instanceof THREE.BufferAttribute === false ) {\r\n\t\r\n\t\t\t\tTHREE.warn( 'THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).' );\r\n\t\r\n\t\t\t\tthis.attributes[ name ] = { array: arguments[ 1 ], itemSize: arguments[ 2 ] };\r\n\t\r\n\t\t\t\treturn;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tthis.attributes[ name ] = attribute;\r\n\t\t\tthis.attributesKeys = Object.keys( this.attributes );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tgetAttribute: function ( name ) {\r\n\t\r\n\t\t\treturn this.attributes[ name ];\r\n\t\r\n\t\t},\r\n\t\r\n\t\taddDrawCall: function ( start, count, indexOffset ) {\r\n\t\r\n\t\t\tthis.drawcalls.push( {\r\n\t\r\n\t\t\t\tstart: start,\r\n\t\t\t\tcount: count,\r\n\t\t\t\tindex: indexOffset !== undefined ? indexOffset : 0\r\n\t\r\n\t\t\t} );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tapplyMatrix: function ( matrix ) {\r\n\t\r\n\t\t\tvar position = this.attributes.position;\r\n\t\r\n\t\t\tif ( position !== undefined ) {\r\n\t\r\n\t\t\t\tmatrix.applyToVector3Array( position.array );\r\n\t\t\t\tposition.needsUpdate = true;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar normal = this.attributes.normal;\r\n\t\r\n\t\t\tif ( normal !== undefined ) {\r\n\t\r\n\t\t\t\tvar normalMatrix = new THREE.Matrix3().getNormalMatrix( matrix );\r\n\t\r\n\t\t\t\tnormalMatrix.applyToVector3Array( normal.array );\r\n\t\t\t\tnormal.needsUpdate = true;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( this.boundingBox !== null ) {\r\n\t\r\n\t\t\t\tthis.computeBoundingBox();\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( this.boundingSphere !== null ) {\r\n\t\r\n\t\t\t\tthis.computeBoundingSphere();\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcenter: function () {\r\n\t\r\n\t\t\tthis.computeBoundingBox();\r\n\t\r\n\t\t\tvar offset = this.boundingBox.center().negate();\r\n\t\r\n\t\t\tthis.applyMatrix( new THREE.Matrix4().setPosition( offset ) );\r\n\t\r\n\t\t\treturn offset;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tfromGeometry: function ( geometry, settings ) {\r\n\t\r\n\t\t\tsettings = settings || { 'vertexColors': THREE.NoColors };\r\n\t\r\n\t\t\tvar vertices = geometry.vertices;\r\n\t\t\tvar faces = geometry.faces;\r\n\t\t\tvar faceVertexUvs = geometry.faceVertexUvs;\r\n\t\t\tvar vertexColors = settings.vertexColors;\r\n\t\t\tvar hasFaceVertexUv = faceVertexUvs[ 0 ].length > 0;\r\n\t\t\tvar hasFaceVertexNormals = faces[ 0 ].vertexNormals.length == 3;\r\n\t\r\n\t\t\tvar positions = new Float32Array( faces.length * 3 * 3 );\r\n\t\t\tthis.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );\r\n\t\r\n\t\t\tvar normals = new Float32Array( faces.length * 3 * 3 );\r\n\t\t\tthis.addAttribute( 'normal', new THREE.BufferAttribute( normals, 3 ) );\r\n\t\r\n\t\t\tif ( vertexColors !== THREE.NoColors ) {\r\n\t\r\n\t\t\t\tvar colors = new Float32Array( faces.length * 3 * 3 );\r\n\t\t\t\tthis.addAttribute( 'color', new THREE.BufferAttribute( colors, 3 ) );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( hasFaceVertexUv === true ) {\r\n\t\r\n\t\t\t\tvar uvs = new Float32Array( faces.length * 3 * 2 );\r\n\t\t\t\tthis.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ) );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tfor ( var i = 0, i2 = 0, i3 = 0; i < faces.length; i ++, i2 += 6, i3 += 9 ) {\r\n\t\r\n\t\t\t\tvar face = faces[ i ];\r\n\t\r\n\t\t\t\tvar a = vertices[ face.a ];\r\n\t\t\t\tvar b = vertices[ face.b ];\r\n\t\t\t\tvar c = vertices[ face.c ];\r\n\t\r\n\t\t\t\tpositions[ i3     ] = a.x;\r\n\t\t\t\tpositions[ i3 + 1 ] = a.y;\r\n\t\t\t\tpositions[ i3 + 2 ] = a.z;\r\n\t\r\n\t\t\t\tpositions[ i3 + 3 ] = b.x;\r\n\t\t\t\tpositions[ i3 + 4 ] = b.y;\r\n\t\t\t\tpositions[ i3 + 5 ] = b.z;\r\n\t\r\n\t\t\t\tpositions[ i3 + 6 ] = c.x;\r\n\t\t\t\tpositions[ i3 + 7 ] = c.y;\r\n\t\t\t\tpositions[ i3 + 8 ] = c.z;\r\n\t\r\n\t\t\t\tif ( hasFaceVertexNormals === true ) {\r\n\t\r\n\t\t\t\t\tvar na = face.vertexNormals[ 0 ];\r\n\t\t\t\t\tvar nb = face.vertexNormals[ 1 ];\r\n\t\t\t\t\tvar nc = face.vertexNormals[ 2 ];\r\n\t\r\n\t\t\t\t\tnormals[ i3     ] = na.x;\r\n\t\t\t\t\tnormals[ i3 + 1 ] = na.y;\r\n\t\t\t\t\tnormals[ i3 + 2 ] = na.z;\r\n\t\r\n\t\t\t\t\tnormals[ i3 + 3 ] = nb.x;\r\n\t\t\t\t\tnormals[ i3 + 4 ] = nb.y;\r\n\t\t\t\t\tnormals[ i3 + 5 ] = nb.z;\r\n\t\r\n\t\t\t\t\tnormals[ i3 + 6 ] = nc.x;\r\n\t\t\t\t\tnormals[ i3 + 7 ] = nc.y;\r\n\t\t\t\t\tnormals[ i3 + 8 ] = nc.z;\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tvar n = face.normal;\r\n\t\r\n\t\t\t\t\tnormals[ i3     ] = n.x;\r\n\t\t\t\t\tnormals[ i3 + 1 ] = n.y;\r\n\t\t\t\t\tnormals[ i3 + 2 ] = n.z;\r\n\t\r\n\t\t\t\t\tnormals[ i3 + 3 ] = n.x;\r\n\t\t\t\t\tnormals[ i3 + 4 ] = n.y;\r\n\t\t\t\t\tnormals[ i3 + 5 ] = n.z;\r\n\t\r\n\t\t\t\t\tnormals[ i3 + 6 ] = n.x;\r\n\t\t\t\t\tnormals[ i3 + 7 ] = n.y;\r\n\t\t\t\t\tnormals[ i3 + 8 ] = n.z;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( vertexColors === THREE.FaceColors ) {\r\n\t\r\n\t\t\t\t\tvar fc = face.color;\r\n\t\r\n\t\t\t\t\tcolors[ i3     ] = fc.r;\r\n\t\t\t\t\tcolors[ i3 + 1 ] = fc.g;\r\n\t\t\t\t\tcolors[ i3 + 2 ] = fc.b;\r\n\t\r\n\t\t\t\t\tcolors[ i3 + 3 ] = fc.r;\r\n\t\t\t\t\tcolors[ i3 + 4 ] = fc.g;\r\n\t\t\t\t\tcolors[ i3 + 5 ] = fc.b;\r\n\t\r\n\t\t\t\t\tcolors[ i3 + 6 ] = fc.r;\r\n\t\t\t\t\tcolors[ i3 + 7 ] = fc.g;\r\n\t\t\t\t\tcolors[ i3 + 8 ] = fc.b;\r\n\t\r\n\t\t\t\t} else if ( vertexColors === THREE.VertexColors ) {\r\n\t\r\n\t\t\t\t\tvar vca = face.vertexColors[ 0 ];\r\n\t\t\t\t\tvar vcb = face.vertexColors[ 1 ];\r\n\t\t\t\t\tvar vcc = face.vertexColors[ 2 ];\r\n\t\r\n\t\t\t\t\tcolors[ i3     ] = vca.r;\r\n\t\t\t\t\tcolors[ i3 + 1 ] = vca.g;\r\n\t\t\t\t\tcolors[ i3 + 2 ] = vca.b;\r\n\t\r\n\t\t\t\t\tcolors[ i3 + 3 ] = vcb.r;\r\n\t\t\t\t\tcolors[ i3 + 4 ] = vcb.g;\r\n\t\t\t\t\tcolors[ i3 + 5 ] = vcb.b;\r\n\t\r\n\t\t\t\t\tcolors[ i3 + 6 ] = vcc.r;\r\n\t\t\t\t\tcolors[ i3 + 7 ] = vcc.g;\r\n\t\t\t\t\tcolors[ i3 + 8 ] = vcc.b;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( hasFaceVertexUv === true ) {\r\n\t\r\n\t\t\t\t\tvar uva = faceVertexUvs[ 0 ][ i ][ 0 ];\r\n\t\t\t\t\tvar uvb = faceVertexUvs[ 0 ][ i ][ 1 ];\r\n\t\t\t\t\tvar uvc = faceVertexUvs[ 0 ][ i ][ 2 ];\r\n\t\r\n\t\t\t\t\tuvs[ i2     ] = uva.x;\r\n\t\t\t\t\tuvs[ i2 + 1 ] = uva.y;\r\n\t\r\n\t\t\t\t\tuvs[ i2 + 2 ] = uvb.x;\r\n\t\t\t\t\tuvs[ i2 + 3 ] = uvb.y;\r\n\t\r\n\t\t\t\t\tuvs[ i2 + 4 ] = uvc.x;\r\n\t\t\t\t\tuvs[ i2 + 5 ] = uvc.y;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tthis.computeBoundingSphere()\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcomputeBoundingBox: function () {\r\n\t\r\n\t\t\tvar vector = new THREE.Vector3();\r\n\t\r\n\t\t\treturn function () {\r\n\t\r\n\t\t\t\tif ( this.boundingBox === null ) {\r\n\t\r\n\t\t\t\t\tthis.boundingBox = new THREE.Box3();\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tvar positions = this.attributes.position.array;\r\n\t\r\n\t\t\t\tif ( positions ) {\r\n\t\r\n\t\t\t\t\tvar bb = this.boundingBox;\r\n\t\t\t\t\tbb.makeEmpty();\r\n\t\r\n\t\t\t\t\tfor ( var i = 0, il = positions.length; i < il; i += 3 ) {\r\n\t\r\n\t\t\t\t\t\tvector.set( positions[ i ], positions[ i + 1 ], positions[ i + 2 ] );\r\n\t\t\t\t\t\tbb.expandByPoint( vector );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( positions === undefined || positions.length === 0 ) {\r\n\t\r\n\t\t\t\t\tthis.boundingBox.min.set( 0, 0, 0 );\r\n\t\t\t\t\tthis.boundingBox.max.set( 0, 0, 0 );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( isNaN( this.boundingBox.min.x ) || isNaN( this.boundingBox.min.y ) || isNaN( this.boundingBox.min.z ) ) {\r\n\t\r\n\t\t\t\t\tTHREE.error( 'THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The \"position\" attribute is likely to have NaN values.' );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tcomputeBoundingSphere: function () {\r\n\t\r\n\t\t\tvar box = new THREE.Box3();\r\n\t\t\tvar vector = new THREE.Vector3();\r\n\t\r\n\t\t\treturn function () {\r\n\t\r\n\t\t\t\tif ( this.boundingSphere === null ) {\r\n\t\r\n\t\t\t\t\tthis.boundingSphere = new THREE.Sphere();\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tvar positions = this.attributes.position.array;\r\n\t\r\n\t\t\t\tif ( positions ) {\r\n\t\r\n\t\t\t\t\tbox.makeEmpty();\r\n\t\r\n\t\t\t\t\tvar center = this.boundingSphere.center;\r\n\t\r\n\t\t\t\t\tfor ( var i = 0, il = positions.length; i < il; i += 3 ) {\r\n\t\r\n\t\t\t\t\t\tvector.set( positions[ i ], positions[ i + 1 ], positions[ i + 2 ] );\r\n\t\t\t\t\t\tbox.expandByPoint( vector );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tbox.center( center );\r\n\t\r\n\t\t\t\t\t// hoping to find a boundingSphere with a radius smaller than the\r\n\t\t\t\t\t// boundingSphere of the boundingBox:  sqrt(3) smaller in the best case\r\n\t\r\n\t\t\t\t\tvar maxRadiusSq = 0;\r\n\t\r\n\t\t\t\t\tfor ( var i = 0, il = positions.length; i < il; i += 3 ) {\r\n\t\r\n\t\t\t\t\t\tvector.set( positions[ i ], positions[ i + 1 ], positions[ i + 2 ] );\r\n\t\t\t\t\t\tmaxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( vector ) );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tthis.boundingSphere.radius = Math.sqrt( maxRadiusSq );\r\n\t\r\n\t\t\t\t\tif ( isNaN( this.boundingSphere.radius ) ) {\r\n\t\r\n\t\t\t\t\t\tTHREE.error( 'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The \"position\" attribute is likely to have NaN values.' );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tcomputeFaceNormals: function () {\r\n\t\r\n\t\t\t// backwards compatibility\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcomputeVertexNormals: function () {\r\n\t\r\n\t\t\tvar attributes = this.attributes;\r\n\t\r\n\t\t\tif ( attributes.position ) {\r\n\t\r\n\t\t\t\tvar positions = attributes.position.array;\r\n\t\r\n\t\t\t\tif ( attributes.normal === undefined ) {\r\n\t\r\n\t\t\t\t\tthis.addAttribute( 'normal', new THREE.BufferAttribute( new Float32Array( positions.length ), 3 ) );\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t// reset existing normals to zero\r\n\t\r\n\t\t\t\t\tvar normals = attributes.normal.array;\r\n\t\r\n\t\t\t\t\tfor ( var i = 0, il = normals.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\t\t\tnormals[ i ] = 0;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tvar normals = attributes.normal.array;\r\n\t\r\n\t\t\t\tvar vA, vB, vC,\r\n\t\r\n\t\t\t\tpA = new THREE.Vector3(),\r\n\t\t\t\tpB = new THREE.Vector3(),\r\n\t\t\t\tpC = new THREE.Vector3(),\r\n\t\r\n\t\t\t\tcb = new THREE.Vector3(),\r\n\t\t\t\tab = new THREE.Vector3();\r\n\t\r\n\t\t\t\t// indexed elements\r\n\t\r\n\t\t\t\tif ( attributes.index ) {\r\n\t\r\n\t\t\t\t\tvar indices = attributes.index.array;\r\n\t\r\n\t\t\t\t\tvar offsets = ( this.offsets.length > 0 ? this.offsets : [ { start: 0, count: indices.length, index: 0 } ] );\r\n\t\r\n\t\t\t\t\tfor ( var j = 0, jl = offsets.length; j < jl; ++ j ) {\r\n\t\r\n\t\t\t\t\t\tvar start = offsets[ j ].start;\r\n\t\t\t\t\t\tvar count = offsets[ j ].count;\r\n\t\t\t\t\t\tvar index = offsets[ j ].index;\r\n\t\r\n\t\t\t\t\t\tfor ( var i = start, il = start + count; i < il; i += 3 ) {\r\n\t\r\n\t\t\t\t\t\t\tvA = ( index + indices[ i     ] ) * 3;\r\n\t\t\t\t\t\t\tvB = ( index + indices[ i + 1 ] ) * 3;\r\n\t\t\t\t\t\t\tvC = ( index + indices[ i + 2 ] ) * 3;\r\n\t\r\n\t\t\t\t\t\t\tpA.fromArray( positions, vA );\r\n\t\t\t\t\t\t\tpB.fromArray( positions, vB );\r\n\t\t\t\t\t\t\tpC.fromArray( positions, vC );\r\n\t\r\n\t\t\t\t\t\t\tcb.subVectors( pC, pB );\r\n\t\t\t\t\t\t\tab.subVectors( pA, pB );\r\n\t\t\t\t\t\t\tcb.cross( ab );\r\n\t\r\n\t\t\t\t\t\t\tnormals[ vA     ] += cb.x;\r\n\t\t\t\t\t\t\tnormals[ vA + 1 ] += cb.y;\r\n\t\t\t\t\t\t\tnormals[ vA + 2 ] += cb.z;\r\n\t\r\n\t\t\t\t\t\t\tnormals[ vB     ] += cb.x;\r\n\t\t\t\t\t\t\tnormals[ vB + 1 ] += cb.y;\r\n\t\t\t\t\t\t\tnormals[ vB + 2 ] += cb.z;\r\n\t\r\n\t\t\t\t\t\t\tnormals[ vC     ] += cb.x;\r\n\t\t\t\t\t\t\tnormals[ vC + 1 ] += cb.y;\r\n\t\t\t\t\t\t\tnormals[ vC + 2 ] += cb.z;\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t// non-indexed elements (unconnected triangle soup)\r\n\t\r\n\t\t\t\t\tfor ( var i = 0, il = positions.length; i < il; i += 9 ) {\r\n\t\r\n\t\t\t\t\t\tpA.fromArray( positions, i );\r\n\t\t\t\t\t\tpB.fromArray( positions, i + 3 );\r\n\t\t\t\t\t\tpC.fromArray( positions, i + 6 );\r\n\t\r\n\t\t\t\t\t\tcb.subVectors( pC, pB );\r\n\t\t\t\t\t\tab.subVectors( pA, pB );\r\n\t\t\t\t\t\tcb.cross( ab );\r\n\t\r\n\t\t\t\t\t\tnormals[ i     ] = cb.x;\r\n\t\t\t\t\t\tnormals[ i + 1 ] = cb.y;\r\n\t\t\t\t\t\tnormals[ i + 2 ] = cb.z;\r\n\t\r\n\t\t\t\t\t\tnormals[ i + 3 ] = cb.x;\r\n\t\t\t\t\t\tnormals[ i + 4 ] = cb.y;\r\n\t\t\t\t\t\tnormals[ i + 5 ] = cb.z;\r\n\t\r\n\t\t\t\t\t\tnormals[ i + 6 ] = cb.x;\r\n\t\t\t\t\t\tnormals[ i + 7 ] = cb.y;\r\n\t\t\t\t\t\tnormals[ i + 8 ] = cb.z;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tthis.normalizeNormals();\r\n\t\r\n\t\t\t\tattributes.normal.needsUpdate = true;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcomputeTangents: function () {\r\n\t\r\n\t\t\t// based on http://www.terathon.com/code/tangent.html\r\n\t\t\t// (per vertex tangents)\r\n\t\r\n\t\t\tif ( this.attributes.index === undefined ||\r\n\t\t\t\t this.attributes.position === undefined ||\r\n\t\t\t\t this.attributes.normal === undefined ||\r\n\t\t\t\t this.attributes.uv === undefined ) {\r\n\t\r\n\t\t\t\tTHREE.warn( 'THREE.BufferGeometry: Missing required attributes (index, position, normal or uv) in BufferGeometry.computeTangents()' );\r\n\t\t\t\treturn;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar indices = this.attributes.index.array;\r\n\t\t\tvar positions = this.attributes.position.array;\r\n\t\t\tvar normals = this.attributes.normal.array;\r\n\t\t\tvar uvs = this.attributes.uv.array;\r\n\t\r\n\t\t\tvar nVertices = positions.length / 3;\r\n\t\r\n\t\t\tif ( this.attributes.tangent === undefined ) {\r\n\t\r\n\t\t\t\tthis.addAttribute( 'tangent', new THREE.BufferAttribute( new Float32Array( 4 * nVertices ), 4 ) );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar tangents = this.attributes.tangent.array;\r\n\t\r\n\t\t\tvar tan1 = [], tan2 = [];\r\n\t\r\n\t\t\tfor ( var k = 0; k < nVertices; k ++ ) {\r\n\t\r\n\t\t\t\ttan1[ k ] = new THREE.Vector3();\r\n\t\t\t\ttan2[ k ] = new THREE.Vector3();\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar vA = new THREE.Vector3(),\r\n\t\t\t\tvB = new THREE.Vector3(),\r\n\t\t\t\tvC = new THREE.Vector3(),\r\n\t\r\n\t\t\t\tuvA = new THREE.Vector2(),\r\n\t\t\t\tuvB = new THREE.Vector2(),\r\n\t\t\t\tuvC = new THREE.Vector2(),\r\n\t\r\n\t\t\t\tx1, x2, y1, y2, z1, z2,\r\n\t\t\t\ts1, s2, t1, t2, r;\r\n\t\r\n\t\t\tvar sdir = new THREE.Vector3(), tdir = new THREE.Vector3();\r\n\t\r\n\t\t\tfunction handleTriangle( a, b, c ) {\r\n\t\r\n\t\t\t\tvA.fromArray( positions, a * 3 );\r\n\t\t\t\tvB.fromArray( positions, b * 3 );\r\n\t\t\t\tvC.fromArray( positions, c * 3 );\r\n\t\r\n\t\t\t\tuvA.fromArray( uvs, a * 2 );\r\n\t\t\t\tuvB.fromArray( uvs, b * 2 );\r\n\t\t\t\tuvC.fromArray( uvs, c * 2 );\r\n\t\r\n\t\t\t\tx1 = vB.x - vA.x;\r\n\t\t\t\tx2 = vC.x - vA.x;\r\n\t\r\n\t\t\t\ty1 = vB.y - vA.y;\r\n\t\t\t\ty2 = vC.y - vA.y;\r\n\t\r\n\t\t\t\tz1 = vB.z - vA.z;\r\n\t\t\t\tz2 = vC.z - vA.z;\r\n\t\r\n\t\t\t\ts1 = uvB.x - uvA.x;\r\n\t\t\t\ts2 = uvC.x - uvA.x;\r\n\t\r\n\t\t\t\tt1 = uvB.y - uvA.y;\r\n\t\t\t\tt2 = uvC.y - uvA.y;\r\n\t\r\n\t\t\t\tr = 1.0 / ( s1 * t2 - s2 * t1 );\r\n\t\r\n\t\t\t\tsdir.set(\r\n\t\t\t\t\t( t2 * x1 - t1 * x2 ) * r,\r\n\t\t\t\t\t( t2 * y1 - t1 * y2 ) * r,\r\n\t\t\t\t\t( t2 * z1 - t1 * z2 ) * r\r\n\t\t\t\t);\r\n\t\r\n\t\t\t\ttdir.set(\r\n\t\t\t\t\t( s1 * x2 - s2 * x1 ) * r,\r\n\t\t\t\t\t( s1 * y2 - s2 * y1 ) * r,\r\n\t\t\t\t\t( s1 * z2 - s2 * z1 ) * r\r\n\t\t\t\t);\r\n\t\r\n\t\t\t\ttan1[ a ].add( sdir );\r\n\t\t\t\ttan1[ b ].add( sdir );\r\n\t\t\t\ttan1[ c ].add( sdir );\r\n\t\r\n\t\t\t\ttan2[ a ].add( tdir );\r\n\t\t\t\ttan2[ b ].add( tdir );\r\n\t\t\t\ttan2[ c ].add( tdir );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar i, il;\r\n\t\t\tvar j, jl;\r\n\t\t\tvar iA, iB, iC;\r\n\t\r\n\t\t\tif ( this.drawcalls.length === 0 ) {\r\n\t\r\n\t\t\t\tthis.addDrawCall( 0, indices.length, 0 );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar drawcalls = this.drawcalls;\r\n\t\r\n\t\t\tfor ( j = 0, jl = drawcalls.length; j < jl; ++ j ) {\r\n\t\r\n\t\t\t\tvar start = drawcalls[ j ].start;\r\n\t\t\t\tvar count = drawcalls[ j ].count;\r\n\t\t\t\tvar index = drawcalls[ j ].index;\r\n\t\r\n\t\t\t\tfor ( i = start, il = start + count; i < il; i += 3 ) {\r\n\t\r\n\t\t\t\t\tiA = index + indices[ i ];\r\n\t\t\t\t\tiB = index + indices[ i + 1 ];\r\n\t\t\t\t\tiC = index + indices[ i + 2 ];\r\n\t\r\n\t\t\t\t\thandleTriangle( iA, iB, iC );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar tmp = new THREE.Vector3(), tmp2 = new THREE.Vector3();\r\n\t\t\tvar n = new THREE.Vector3(), n2 = new THREE.Vector3();\r\n\t\t\tvar w, t, test;\r\n\t\r\n\t\t\tfunction handleVertex( v ) {\r\n\t\r\n\t\t\t\tn.fromArray( normals, v * 3 );\r\n\t\t\t\tn2.copy( n );\r\n\t\r\n\t\t\t\tt = tan1[ v ];\r\n\t\r\n\t\t\t\t// Gram-Schmidt orthogonalize\r\n\t\r\n\t\t\t\ttmp.copy( t );\r\n\t\t\t\ttmp.sub( n.multiplyScalar( n.dot( t ) ) ).normalize();\r\n\t\r\n\t\t\t\t// Calculate handedness\r\n\t\r\n\t\t\t\ttmp2.crossVectors( n2, t );\r\n\t\t\t\ttest = tmp2.dot( tan2[ v ] );\r\n\t\t\t\tw = ( test < 0.0 ) ? - 1.0 : 1.0;\r\n\t\r\n\t\t\t\ttangents[ v * 4     ] = tmp.x;\r\n\t\t\t\ttangents[ v * 4 + 1 ] = tmp.y;\r\n\t\t\t\ttangents[ v * 4 + 2 ] = tmp.z;\r\n\t\t\t\ttangents[ v * 4 + 3 ] = w;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tfor ( j = 0, jl = drawcalls.length; j < jl; ++ j ) {\r\n\t\r\n\t\t\t\tvar start = drawcalls[ j ].start;\r\n\t\t\t\tvar count = drawcalls[ j ].count;\r\n\t\t\t\tvar index = drawcalls[ j ].index;\r\n\t\r\n\t\t\t\tfor ( i = start, il = start + count; i < il; i += 3 ) {\r\n\t\r\n\t\t\t\t\tiA = index + indices[ i ];\r\n\t\t\t\t\tiB = index + indices[ i + 1 ];\r\n\t\t\t\t\tiC = index + indices[ i + 2 ];\r\n\t\r\n\t\t\t\t\thandleVertex( iA );\r\n\t\t\t\t\thandleVertex( iB );\r\n\t\t\t\t\thandleVertex( iC );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t},\r\n\t\r\n\t\t/*\r\n\t\tCompute the draw offset for large models by chunking the index buffer into chunks of 65k addressable vertices.\r\n\t\tThis method will effectively rewrite the index buffer and remap all attributes to match the new indices.\r\n\t\tWARNING: This method will also expand the vertex count to prevent sprawled triangles across draw offsets.\r\n\t\tsize - Defaults to 65535, but allows for larger or smaller chunks.\r\n\t\t*/\r\n\t\tcomputeOffsets: function ( size ) {\r\n\t\r\n\t\t\tif ( size === undefined ) size = 65535; // WebGL limits type of index buffer values to 16-bit.\r\n\t\r\n\t\t\tvar indices = this.attributes.index.array;\r\n\t\t\tvar vertices = this.attributes.position.array;\r\n\t\r\n\t\t\tvar facesCount = ( indices.length / 3 );\r\n\t\r\n\t\t\t/*\r\n\t\t\tconsole.log(\"Computing buffers in offsets of \"+size+\" -> indices:\"+indices.length+\" vertices:\"+vertices.length);\r\n\t\t\tconsole.log(\"Faces to process: \"+(indices.length/3));\r\n\t\t\tconsole.log(\"Reordering \"+verticesCount+\" vertices.\");\r\n\t\t\t*/\r\n\t\r\n\t\t\tvar sortedIndices = new Uint16Array( indices.length ); //16-bit buffers\r\n\t\t\tvar indexPtr = 0;\r\n\t\t\tvar vertexPtr = 0;\r\n\t\r\n\t\t\tvar offsets = [ { start:0, count:0, index:0 } ];\r\n\t\t\tvar offset = offsets[ 0 ];\r\n\t\r\n\t\t\tvar duplicatedVertices = 0;\r\n\t\t\tvar newVerticeMaps = 0;\r\n\t\t\tvar faceVertices = new Int32Array( 6 );\r\n\t\t\tvar vertexMap = new Int32Array( vertices.length );\r\n\t\t\tvar revVertexMap = new Int32Array( vertices.length );\r\n\t\t\tfor ( var j = 0; j < vertices.length; j ++ ) { vertexMap[ j ] = - 1; revVertexMap[ j ] = - 1; }\r\n\t\r\n\t\t\t/*\r\n\t\t\t\tTraverse every face and reorder vertices in the proper offsets of 65k.\r\n\t\t\t\tWe can have more than 65k entries in the index buffer per offset, but only reference 65k values.\r\n\t\t\t*/\r\n\t\t\tfor ( var findex = 0; findex < facesCount; findex ++ ) {\r\n\t\t\t\tnewVerticeMaps = 0;\r\n\t\r\n\t\t\t\tfor ( var vo = 0; vo < 3; vo ++ ) {\r\n\t\t\t\t\tvar vid = indices[ findex * 3 + vo ];\r\n\t\t\t\t\tif ( vertexMap[ vid ] == - 1 ) {\r\n\t\t\t\t\t\t//Unmapped vertice\r\n\t\t\t\t\t\tfaceVertices[ vo * 2 ] = vid;\r\n\t\t\t\t\t\tfaceVertices[ vo * 2 + 1 ] = - 1;\r\n\t\t\t\t\t\tnewVerticeMaps ++;\r\n\t\t\t\t\t} else if ( vertexMap[ vid ] < offset.index ) {\r\n\t\t\t\t\t\t//Reused vertices from previous block (duplicate)\r\n\t\t\t\t\t\tfaceVertices[ vo * 2 ] = vid;\r\n\t\t\t\t\t\tfaceVertices[ vo * 2 + 1 ] = - 1;\r\n\t\t\t\t\t\tduplicatedVertices ++;\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\t//Reused vertice in the current block\r\n\t\t\t\t\t\tfaceVertices[ vo * 2 ] = vid;\r\n\t\t\t\t\t\tfaceVertices[ vo * 2 + 1 ] = vertexMap[ vid ];\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tvar faceMax = vertexPtr + newVerticeMaps;\r\n\t\t\t\tif ( faceMax > ( offset.index + size ) ) {\r\n\t\t\t\t\tvar new_offset = { start:indexPtr, count:0, index:vertexPtr };\r\n\t\t\t\t\toffsets.push( new_offset );\r\n\t\t\t\t\toffset = new_offset;\r\n\t\r\n\t\t\t\t\t//Re-evaluate reused vertices in light of new offset.\r\n\t\t\t\t\tfor ( var v = 0; v < 6; v += 2 ) {\r\n\t\t\t\t\t\tvar new_vid = faceVertices[ v + 1 ];\r\n\t\t\t\t\t\tif ( new_vid > - 1 && new_vid < offset.index )\r\n\t\t\t\t\t\t\tfaceVertices[ v + 1 ] = - 1;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\t//Reindex the face.\r\n\t\t\t\tfor ( var v = 0; v < 6; v += 2 ) {\r\n\t\t\t\t\tvar vid = faceVertices[ v ];\r\n\t\t\t\t\tvar new_vid = faceVertices[ v + 1 ];\r\n\t\r\n\t\t\t\t\tif ( new_vid === - 1 )\r\n\t\t\t\t\t\tnew_vid = vertexPtr ++;\r\n\t\r\n\t\t\t\t\tvertexMap[ vid ] = new_vid;\r\n\t\t\t\t\trevVertexMap[ new_vid ] = vid;\r\n\t\t\t\t\tsortedIndices[ indexPtr ++ ] = new_vid - offset.index; //XXX overflows at 16bit\r\n\t\t\t\t\toffset.count ++;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\r\n\t\t\t/* Move all attribute values to map to the new computed indices , also expand the vertice stack to match our new vertexPtr. */\r\n\t\t\tthis.reorderBuffers( sortedIndices, revVertexMap, vertexPtr );\r\n\t\t\tthis.offsets = offsets; // TODO: Deprecate\r\n\t\t\tthis.drawcalls = offsets;\r\n\t\r\n\t\t\t/*\r\n\t\t\tvar orderTime = Date.now();\r\n\t\t\tconsole.log(\"Reorder time: \"+(orderTime-s)+\"ms\");\r\n\t\t\tconsole.log(\"Duplicated \"+duplicatedVertices+\" vertices.\");\r\n\t\t\tconsole.log(\"Compute Buffers time: \"+(Date.now()-s)+\"ms\");\r\n\t\t\tconsole.log(\"Draw offsets: \"+offsets.length);\r\n\t\t\t*/\r\n\t\r\n\t\t\treturn offsets;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tmerge: function ( geometry, offset ) {\r\n\t\r\n\t\t\tif ( geometry instanceof THREE.BufferGeometry === false ) {\r\n\t\r\n\t\t\t\tTHREE.error( 'THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.', geometry );\r\n\t\t\t\treturn;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( offset === undefined ) offset = 0;\r\n\t\r\n\t\t\tvar attributes = this.attributes;\r\n\t\r\n\t\t\tfor ( var key in attributes ) {\r\n\t\r\n\t\t\t\tif ( geometry.attributes[ key ] === undefined ) continue;\r\n\t\r\n\t\t\t\tvar attribute1 = attributes[ key ];\r\n\t\t\t\tvar attributeArray1 = attribute1.array;\r\n\t\r\n\t\t\t\tvar attribute2 = geometry.attributes[ key ];\r\n\t\t\t\tvar attributeArray2 = attribute2.array;\r\n\t\r\n\t\t\t\tvar attributeSize = attribute2.itemSize;\r\n\t\r\n\t\t\t\tfor ( var i = 0, j = attributeSize * offset; i < attributeArray2.length; i ++, j ++ ) {\r\n\t\r\n\t\t\t\t\tattributeArray1[ j ] = attributeArray2[ i ];\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tnormalizeNormals: function () {\r\n\t\r\n\t\t\tvar normals = this.attributes.normal.array;\r\n\t\r\n\t\t\tvar x, y, z, n;\r\n\t\r\n\t\t\tfor ( var i = 0, il = normals.length; i < il; i += 3 ) {\r\n\t\r\n\t\t\t\tx = normals[ i ];\r\n\t\t\t\ty = normals[ i + 1 ];\r\n\t\t\t\tz = normals[ i + 2 ];\r\n\t\r\n\t\t\t\tn = 1.0 / Math.sqrt( x * x + y * y + z * z );\r\n\t\r\n\t\t\t\tnormals[ i     ] *= n;\r\n\t\t\t\tnormals[ i + 1 ] *= n;\r\n\t\t\t\tnormals[ i + 2 ] *= n;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t},\r\n\t\r\n\t\t/*\r\n\t\t\treoderBuffers:\r\n\t\t\tReorder attributes based on a new indexBuffer and indexMap.\r\n\t\t\tindexBuffer - Uint16Array of the new ordered indices.\r\n\t\t\tindexMap - Int32Array where the position is the new vertex ID and the value the old vertex ID for each vertex.\r\n\t\t\tvertexCount - Amount of total vertices considered in this reordering (in case you want to grow the vertice stack).\r\n\t\t*/\r\n\t\treorderBuffers: function ( indexBuffer, indexMap, vertexCount ) {\r\n\t\r\n\t\t\t/* Create a copy of all attributes for reordering. */\r\n\t\t\tvar sortedAttributes = {};\r\n\t\t\tfor ( var attr in this.attributes ) {\r\n\t\t\t\tif ( attr == 'index' )\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\tvar sourceArray = this.attributes[ attr ].array;\r\n\t\t\t\tsortedAttributes[ attr ] = new sourceArray.constructor( this.attributes[ attr ].itemSize * vertexCount );\r\n\t\t\t}\r\n\t\r\n\t\t\t/* Move attribute positions based on the new index map */\r\n\t\t\tfor ( var new_vid = 0; new_vid < vertexCount; new_vid ++ ) {\r\n\t\t\t\tvar vid = indexMap[ new_vid ];\r\n\t\t\t\tfor ( var attr in this.attributes ) {\r\n\t\t\t\t\tif ( attr == 'index' )\r\n\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\tvar attrArray = this.attributes[ attr ].array;\r\n\t\t\t\t\tvar attrSize = this.attributes[ attr ].itemSize;\r\n\t\t\t\t\tvar sortedAttr = sortedAttributes[ attr ];\r\n\t\t\t\t\tfor ( var k = 0; k < attrSize; k ++ )\r\n\t\t\t\t\t\tsortedAttr[ new_vid * attrSize + k ] = attrArray[ vid * attrSize + k ];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\r\n\t\t\t/* Carry the new sorted buffers locally */\r\n\t\t\tthis.attributes[ 'index' ].array = indexBuffer;\r\n\t\t\tfor ( var attr in this.attributes ) {\r\n\t\t\t\tif ( attr == 'index' )\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\tthis.attributes[ attr ].array = sortedAttributes[ attr ];\r\n\t\t\t\tthis.attributes[ attr ].numItems = this.attributes[ attr ].itemSize * vertexCount;\r\n\t\t\t}\r\n\t\t},\r\n\t\r\n\t\ttoJSON: function () {\r\n\t\r\n\t\t\tvar output = {\r\n\t\t\t\tmetadata: {\r\n\t\t\t\t\tversion: 4.0,\r\n\t\t\t\t\ttype: 'BufferGeometry',\r\n\t\t\t\t\tgenerator: 'BufferGeometryExporter'\r\n\t\t\t\t},\r\n\t\t\t\tuuid: this.uuid,\r\n\t\t\t\ttype: this.type,\r\n\t\t\t\tdata: {\r\n\t\t\t\t\tattributes: {}\r\n\t\t\t\t}\r\n\t\t\t};\r\n\t\r\n\t\t\tvar attributes = this.attributes;\r\n\t\t\tvar offsets = this.offsets;\r\n\t\t\tvar boundingSphere = this.boundingSphere;\r\n\t\r\n\t\t\tfor ( var key in attributes ) {\r\n\t\r\n\t\t\t\tvar attribute = attributes[ key ];\r\n\t\r\n\t\t\t\tvar array = Array.prototype.slice.call( attribute.array );\r\n\t\r\n\t\t\t\toutput.data.attributes[ key ] = {\r\n\t\t\t\t\titemSize: attribute.itemSize,\r\n\t\t\t\t\ttype: attribute.array.constructor.name,\r\n\t\t\t\t\tarray: array\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( offsets.length > 0 ) {\r\n\t\r\n\t\t\t\toutput.data.offsets = JSON.parse( JSON.stringify( offsets ) );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( boundingSphere !== null ) {\r\n\t\r\n\t\t\t\toutput.data.boundingSphere = {\r\n\t\t\t\t\tcenter: boundingSphere.center.toArray(),\r\n\t\t\t\t\tradius: boundingSphere.radius\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn output;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tclone: function () {\r\n\t\r\n\t\t\tvar geometry = new THREE.BufferGeometry();\r\n\t\r\n\t\t\tfor ( var attr in this.attributes ) {\r\n\t\r\n\t\t\t\tvar sourceAttr = this.attributes[ attr ];\r\n\t\t\t\tgeometry.addAttribute( attr, sourceAttr.clone() );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tfor ( var i = 0, il = this.offsets.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\tvar offset = this.offsets[ i ];\r\n\t\r\n\t\t\t\tgeometry.offsets.push( {\r\n\t\r\n\t\t\t\t\tstart: offset.start,\r\n\t\t\t\t\tindex: offset.index,\r\n\t\t\t\t\tcount: offset.count\r\n\t\r\n\t\t\t\t} );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn geometry;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tdispose: function () {\r\n\t\r\n\t\t\tthis.dispatchEvent( { type: 'dispose' } );\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.EventDispatcher.prototype.apply( THREE.BufferGeometry.prototype );\r\n\t\r\n\t// File:src/core/Geometry.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t * @author kile / http://kile.stravaganza.org/\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t * @author mikael emtinger / http://gomo.se/\r\n\t * @author zz85 / http://www.lab4games.net/zz85/blog\r\n\t * @author bhouston / http://exocortex.com\r\n\t */\r\n\t\r\n\tTHREE.Geometry = function () {\r\n\t\r\n\t\tObject.defineProperty( this, 'id', { value: THREE.GeometryIdCount ++ } );\r\n\t\r\n\t\tthis.uuid = THREE.Math.generateUUID();\r\n\t\r\n\t\tthis.name = '';\r\n\t\tthis.type = 'Geometry';\r\n\t\r\n\t\tthis.vertices = [];\r\n\t\tthis.colors = [];  // one-to-one vertex colors, used in Points and Line\r\n\t\r\n\t\tthis.faces = [];\r\n\t\r\n\t\tthis.faceVertexUvs = [ [] ];\r\n\t\r\n\t\tthis.morphTargets = [];\r\n\t\tthis.morphColors = [];\r\n\t\tthis.morphNormals = [];\r\n\t\r\n\t\tthis.skinWeights = [];\r\n\t\tthis.skinIndices = [];\r\n\t\r\n\t\tthis.lineDistances = [];\r\n\t\r\n\t\tthis.boundingBox = null;\r\n\t\tthis.boundingSphere = null;\r\n\t\r\n\t\tthis.hasTangents = false;\r\n\t\r\n\t\tthis.dynamic = true; // the intermediate typed arrays will be deleted when set to false\r\n\t\r\n\t\t// update flags\r\n\t\r\n\t\tthis.verticesNeedUpdate = false;\r\n\t\tthis.elementsNeedUpdate = false;\r\n\t\tthis.uvsNeedUpdate = false;\r\n\t\tthis.normalsNeedUpdate = false;\r\n\t\tthis.tangentsNeedUpdate = false;\r\n\t\tthis.colorsNeedUpdate = false;\r\n\t\tthis.lineDistancesNeedUpdate = false;\r\n\t\r\n\t\tthis.groupsNeedUpdate = false;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Geometry.prototype = {\r\n\t\r\n\t\tconstructor: THREE.Geometry,\r\n\t\r\n\t\tapplyMatrix: function ( matrix ) {\r\n\t\r\n\t\t\tvar normalMatrix = new THREE.Matrix3().getNormalMatrix( matrix );\r\n\t\r\n\t\t\tfor ( var i = 0, il = this.vertices.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\tvar vertex = this.vertices[ i ];\r\n\t\t\t\tvertex.applyMatrix4( matrix );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tfor ( var i = 0, il = this.faces.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\tvar face = this.faces[ i ];\r\n\t\t\t\tface.normal.applyMatrix3( normalMatrix ).normalize();\r\n\t\r\n\t\t\t\tfor ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {\r\n\t\r\n\t\t\t\t\tface.vertexNormals[ j ].applyMatrix3( normalMatrix ).normalize();\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( this.boundingBox !== null ) {\r\n\t\r\n\t\t\t\tthis.computeBoundingBox();\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( this.boundingSphere !== null ) {\r\n\t\r\n\t\t\t\tthis.computeBoundingSphere();\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tthis.verticesNeedUpdate = true;\r\n\t\t\tthis.normalsNeedUpdate = true;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tfromBufferGeometry: function ( geometry ) {\r\n\t\r\n\t\t\tvar scope = this;\r\n\t\r\n\t\t\tvar attributes = geometry.attributes;\r\n\t\r\n\t\t\tvar vertices = attributes.position.array;\r\n\t\t\tvar indices = attributes.index !== undefined ? attributes.index.array : undefined;\r\n\t\t\tvar normals = attributes.normal !== undefined ? attributes.normal.array : undefined;\r\n\t\t\tvar colors = attributes.color !== undefined ? attributes.color.array : undefined;\r\n\t\t\tvar uvs = attributes.uv !== undefined ? attributes.uv.array : undefined;\r\n\t\r\n\t\t\tvar tempNormals = [];\r\n\t\t\tvar tempUVs = [];\r\n\t\r\n\t\t\tfor ( var i = 0, j = 0; i < vertices.length; i += 3, j += 2 ) {\r\n\t\r\n\t\t\t\tscope.vertices.push( new THREE.Vector3( vertices[ i ], vertices[ i + 1 ], vertices[ i + 2 ] ) );\r\n\t\r\n\t\t\t\tif ( normals !== undefined ) {\r\n\t\r\n\t\t\t\t\ttempNormals.push( new THREE.Vector3( normals[ i ], normals[ i + 1 ], normals[ i + 2 ] ) );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( colors !== undefined ) {\r\n\t\r\n\t\t\t\t\tscope.colors.push( new THREE.Color( colors[ i ], colors[ i + 1 ], colors[ i + 2 ] ) );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( uvs !== undefined ) {\r\n\t\r\n\t\t\t\t\ttempUVs.push( new THREE.Vector2( uvs[ j ], uvs[ j + 1 ] ) );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar addFace = function ( a, b, c ) {\r\n\t\r\n\t\t\t\tvar vertexNormals = normals !== undefined ? [ tempNormals[ a ].clone(), tempNormals[ b ].clone(), tempNormals[ c ].clone() ] : [];\r\n\t\t\t\tvar vertexColors = colors !== undefined ? [ scope.colors[ a ].clone(), scope.colors[ b ].clone(), scope.colors[ c ].clone() ] : [];\r\n\t\r\n\t\t\t\tscope.faces.push( new THREE.Face3( a, b, c, vertexNormals, vertexColors ) );\r\n\t\r\n\t\t\t\tif ( uvs !== undefined ) {\r\n\t\r\n\t\t\t\t\tscope.faceVertexUvs[ 0 ].push( [ tempUVs[ a ].clone(), tempUVs[ b ].clone(), tempUVs[ c ].clone() ] );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t\tif ( indices !== undefined ) {\r\n\t\r\n\t\t\t\tvar drawcalls = geometry.drawcalls;\r\n\t\r\n\t\t\t\tif ( drawcalls.length > 0 ) {\r\n\t\r\n\t\t\t\t\tfor ( var i = 0; i < drawcalls.length; i ++ ) {\r\n\t\r\n\t\t\t\t\t\tvar drawcall = drawcalls[ i ];\r\n\t\r\n\t\t\t\t\t\tvar start = drawcall.start;\r\n\t\t\t\t\t\tvar count = drawcall.count;\r\n\t\t\t\t\t\tvar index = drawcall.index;\r\n\t\r\n\t\t\t\t\t\tfor ( var j = start, jl = start + count; j < jl; j += 3 ) {\r\n\t\r\n\t\t\t\t\t\t\taddFace( index + indices[ j ], index + indices[ j + 1 ], index + indices[ j + 2 ] );\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tfor ( var i = 0; i < indices.length; i += 3 ) {\r\n\t\r\n\t\t\t\t\t\taddFace( indices[ i ], indices[ i + 1 ], indices[ i + 2 ] );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\tfor ( var i = 0; i < vertices.length / 3; i += 3 ) {\r\n\t\r\n\t\t\t\t\taddFace( i, i + 1, i + 2 );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tthis.computeFaceNormals();\r\n\t\r\n\t\t\tif ( geometry.boundingBox !== null ) {\r\n\t\r\n\t\t\t\tthis.boundingBox = geometry.boundingBox.clone();\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( geometry.boundingSphere !== null ) {\r\n\t\r\n\t\t\t\tthis.boundingSphere = geometry.boundingSphere.clone();\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcenter: function () {\r\n\t\r\n\t\t\tthis.computeBoundingBox();\r\n\t\r\n\t\t\tvar offset = this.boundingBox.center().negate();\r\n\t\r\n\t\t\tthis.applyMatrix( new THREE.Matrix4().setPosition( offset ) );\r\n\t\r\n\t\t\treturn offset;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcomputeFaceNormals: function () {\r\n\t\r\n\t\t\tvar cb = new THREE.Vector3(), ab = new THREE.Vector3();\r\n\t\r\n\t\t\tfor ( var f = 0, fl = this.faces.length; f < fl; f ++ ) {\r\n\t\r\n\t\t\t\tvar face = this.faces[ f ];\r\n\t\r\n\t\t\t\tvar vA = this.vertices[ face.a ];\r\n\t\t\t\tvar vB = this.vertices[ face.b ];\r\n\t\t\t\tvar vC = this.vertices[ face.c ];\r\n\t\r\n\t\t\t\tcb.subVectors( vC, vB );\r\n\t\t\t\tab.subVectors( vA, vB );\r\n\t\t\t\tcb.cross( ab );\r\n\t\r\n\t\t\t\tcb.normalize();\r\n\t\r\n\t\t\t\tface.normal.copy( cb );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcomputeVertexNormals: function ( areaWeighted ) {\r\n\t\r\n\t\t\tvar v, vl, f, fl, face, vertices;\r\n\t\r\n\t\t\tvertices = new Array( this.vertices.length );\r\n\t\r\n\t\t\tfor ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {\r\n\t\r\n\t\t\t\tvertices[ v ] = new THREE.Vector3();\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( areaWeighted ) {\r\n\t\r\n\t\t\t\t// vertex normals weighted by triangle areas\r\n\t\t\t\t// http://www.iquilezles.org/www/articles/normals/normals.htm\r\n\t\r\n\t\t\t\tvar vA, vB, vC;\r\n\t\t\t\tvar cb = new THREE.Vector3(), ab = new THREE.Vector3();\r\n\t\r\n\t\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\r\n\t\r\n\t\t\t\t\tface = this.faces[ f ];\r\n\t\r\n\t\t\t\t\tvA = this.vertices[ face.a ];\r\n\t\t\t\t\tvB = this.vertices[ face.b ];\r\n\t\t\t\t\tvC = this.vertices[ face.c ];\r\n\t\r\n\t\t\t\t\tcb.subVectors( vC, vB );\r\n\t\t\t\t\tab.subVectors( vA, vB );\r\n\t\t\t\t\tcb.cross( ab );\r\n\t\r\n\t\t\t\t\tvertices[ face.a ].add( cb );\r\n\t\t\t\t\tvertices[ face.b ].add( cb );\r\n\t\t\t\t\tvertices[ face.c ].add( cb );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\r\n\t\r\n\t\t\t\t\tface = this.faces[ f ];\r\n\t\r\n\t\t\t\t\tvertices[ face.a ].add( face.normal );\r\n\t\t\t\t\tvertices[ face.b ].add( face.normal );\r\n\t\t\t\t\tvertices[ face.c ].add( face.normal );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tfor ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {\r\n\t\r\n\t\t\t\tvertices[ v ].normalize();\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\r\n\t\r\n\t\t\t\tface = this.faces[ f ];\r\n\t\r\n\t\t\t\tface.vertexNormals[ 0 ] = vertices[ face.a ].clone();\r\n\t\t\t\tface.vertexNormals[ 1 ] = vertices[ face.b ].clone();\r\n\t\t\t\tface.vertexNormals[ 2 ] = vertices[ face.c ].clone();\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcomputeMorphNormals: function () {\r\n\t\r\n\t\t\tvar i, il, f, fl, face;\r\n\t\r\n\t\t\t// save original normals\r\n\t\t\t// - create temp variables on first access\r\n\t\t\t//   otherwise just copy (for faster repeated calls)\r\n\t\r\n\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\r\n\t\r\n\t\t\t\tface = this.faces[ f ];\r\n\t\r\n\t\t\t\tif ( ! face.__originalFaceNormal ) {\r\n\t\r\n\t\t\t\t\tface.__originalFaceNormal = face.normal.clone();\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tface.__originalFaceNormal.copy( face.normal );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( ! face.__originalVertexNormals ) face.__originalVertexNormals = [];\r\n\t\r\n\t\t\t\tfor ( i = 0, il = face.vertexNormals.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\t\tif ( ! face.__originalVertexNormals[ i ] ) {\r\n\t\r\n\t\t\t\t\t\tface.__originalVertexNormals[ i ] = face.vertexNormals[ i ].clone();\r\n\t\r\n\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\tface.__originalVertexNormals[ i ].copy( face.vertexNormals[ i ] );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// use temp geometry to compute face and vertex normals for each morph\r\n\t\r\n\t\t\tvar tmpGeo = new THREE.Geometry();\r\n\t\t\ttmpGeo.faces = this.faces;\r\n\t\r\n\t\t\tfor ( i = 0, il = this.morphTargets.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\t// create on first access\r\n\t\r\n\t\t\t\tif ( ! this.morphNormals[ i ] ) {\r\n\t\r\n\t\t\t\t\tthis.morphNormals[ i ] = {};\r\n\t\t\t\t\tthis.morphNormals[ i ].faceNormals = [];\r\n\t\t\t\t\tthis.morphNormals[ i ].vertexNormals = [];\r\n\t\r\n\t\t\t\t\tvar dstNormalsFace = this.morphNormals[ i ].faceNormals;\r\n\t\t\t\t\tvar dstNormalsVertex = this.morphNormals[ i ].vertexNormals;\r\n\t\r\n\t\t\t\t\tvar faceNormal, vertexNormals;\r\n\t\r\n\t\t\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\r\n\t\r\n\t\t\t\t\t\tfaceNormal = new THREE.Vector3();\r\n\t\t\t\t\t\tvertexNormals = { a: new THREE.Vector3(), b: new THREE.Vector3(), c: new THREE.Vector3() };\r\n\t\r\n\t\t\t\t\t\tdstNormalsFace.push( faceNormal );\r\n\t\t\t\t\t\tdstNormalsVertex.push( vertexNormals );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tvar morphNormals = this.morphNormals[ i ];\r\n\t\r\n\t\t\t\t// set vertices to morph target\r\n\t\r\n\t\t\t\ttmpGeo.vertices = this.morphTargets[ i ].vertices;\r\n\t\r\n\t\t\t\t// compute morph normals\r\n\t\r\n\t\t\t\ttmpGeo.computeFaceNormals();\r\n\t\t\t\ttmpGeo.computeVertexNormals();\r\n\t\r\n\t\t\t\t// store morph normals\r\n\t\r\n\t\t\t\tvar faceNormal, vertexNormals;\r\n\t\r\n\t\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\r\n\t\r\n\t\t\t\t\tface = this.faces[ f ];\r\n\t\r\n\t\t\t\t\tfaceNormal = morphNormals.faceNormals[ f ];\r\n\t\t\t\t\tvertexNormals = morphNormals.vertexNormals[ f ];\r\n\t\r\n\t\t\t\t\tfaceNormal.copy( face.normal );\r\n\t\r\n\t\t\t\t\tvertexNormals.a.copy( face.vertexNormals[ 0 ] );\r\n\t\t\t\t\tvertexNormals.b.copy( face.vertexNormals[ 1 ] );\r\n\t\t\t\t\tvertexNormals.c.copy( face.vertexNormals[ 2 ] );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// restore original normals\r\n\t\r\n\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\r\n\t\r\n\t\t\t\tface = this.faces[ f ];\r\n\t\r\n\t\t\t\tface.normal = face.__originalFaceNormal;\r\n\t\t\t\tface.vertexNormals = face.__originalVertexNormals;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcomputeTangents: function () {\r\n\t\r\n\t\t\t// based on http://www.terathon.com/code/tangent.html\r\n\t\t\t// tangents go to vertices\r\n\t\r\n\t\t\tvar f, fl, v, vl, i, vertexIndex,\r\n\t\t\t\tface, uv, vA, vB, vC, uvA, uvB, uvC,\r\n\t\t\t\tx1, x2, y1, y2, z1, z2,\r\n\t\t\t\ts1, s2, t1, t2, r, t, test,\r\n\t\t\t\ttan1 = [], tan2 = [],\r\n\t\t\t\tsdir = new THREE.Vector3(), tdir = new THREE.Vector3(),\r\n\t\t\t\ttmp = new THREE.Vector3(), tmp2 = new THREE.Vector3(),\r\n\t\t\t\tn = new THREE.Vector3(), w;\r\n\t\r\n\t\t\tfor ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {\r\n\t\r\n\t\t\t\ttan1[ v ] = new THREE.Vector3();\r\n\t\t\t\ttan2[ v ] = new THREE.Vector3();\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tfunction handleTriangle( context, a, b, c, ua, ub, uc ) {\r\n\t\r\n\t\t\t\tvA = context.vertices[ a ];\r\n\t\t\t\tvB = context.vertices[ b ];\r\n\t\t\t\tvC = context.vertices[ c ];\r\n\t\r\n\t\t\t\tuvA = uv[ ua ];\r\n\t\t\t\tuvB = uv[ ub ];\r\n\t\t\t\tuvC = uv[ uc ];\r\n\t\r\n\t\t\t\tx1 = vB.x - vA.x;\r\n\t\t\t\tx2 = vC.x - vA.x;\r\n\t\t\t\ty1 = vB.y - vA.y;\r\n\t\t\t\ty2 = vC.y - vA.y;\r\n\t\t\t\tz1 = vB.z - vA.z;\r\n\t\t\t\tz2 = vC.z - vA.z;\r\n\t\r\n\t\t\t\ts1 = uvB.x - uvA.x;\r\n\t\t\t\ts2 = uvC.x - uvA.x;\r\n\t\t\t\tt1 = uvB.y - uvA.y;\r\n\t\t\t\tt2 = uvC.y - uvA.y;\r\n\t\r\n\t\t\t\tr = 1.0 / ( s1 * t2 - s2 * t1 );\r\n\t\t\t\tsdir.set( ( t2 * x1 - t1 * x2 ) * r,\r\n\t\t\t\t\t\t  ( t2 * y1 - t1 * y2 ) * r,\r\n\t\t\t\t\t\t  ( t2 * z1 - t1 * z2 ) * r );\r\n\t\t\t\ttdir.set( ( s1 * x2 - s2 * x1 ) * r,\r\n\t\t\t\t\t\t  ( s1 * y2 - s2 * y1 ) * r,\r\n\t\t\t\t\t\t  ( s1 * z2 - s2 * z1 ) * r );\r\n\t\r\n\t\t\t\ttan1[ a ].add( sdir );\r\n\t\t\t\ttan1[ b ].add( sdir );\r\n\t\t\t\ttan1[ c ].add( sdir );\r\n\t\r\n\t\t\t\ttan2[ a ].add( tdir );\r\n\t\t\t\ttan2[ b ].add( tdir );\r\n\t\t\t\ttan2[ c ].add( tdir );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\r\n\t\r\n\t\t\t\tface = this.faces[ f ];\r\n\t\t\t\tuv = this.faceVertexUvs[ 0 ][ f ]; // use UV layer 0 for tangents\r\n\t\r\n\t\t\t\thandleTriangle( this, face.a, face.b, face.c, 0, 1, 2 );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar faceIndex = [ 'a', 'b', 'c', 'd' ];\r\n\t\r\n\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\r\n\t\r\n\t\t\t\tface = this.faces[ f ];\r\n\t\r\n\t\t\t\tfor ( i = 0; i < Math.min( face.vertexNormals.length, 3 ); i ++ ) {\r\n\t\r\n\t\t\t\t\tn.copy( face.vertexNormals[ i ] );\r\n\t\r\n\t\t\t\t\tvertexIndex = face[ faceIndex[ i ] ];\r\n\t\r\n\t\t\t\t\tt = tan1[ vertexIndex ];\r\n\t\r\n\t\t\t\t\t// Gram-Schmidt orthogonalize\r\n\t\r\n\t\t\t\t\ttmp.copy( t );\r\n\t\t\t\t\ttmp.sub( n.multiplyScalar( n.dot( t ) ) ).normalize();\r\n\t\r\n\t\t\t\t\t// Calculate handedness\r\n\t\r\n\t\t\t\t\ttmp2.crossVectors( face.vertexNormals[ i ], t );\r\n\t\t\t\t\ttest = tmp2.dot( tan2[ vertexIndex ] );\r\n\t\t\t\t\tw = ( test < 0.0 ) ? - 1.0 : 1.0;\r\n\t\r\n\t\t\t\t\tface.vertexTangents[ i ] = new THREE.Vector4( tmp.x, tmp.y, tmp.z, w );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tthis.hasTangents = true;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcomputeLineDistances: function () {\r\n\t\r\n\t\t\tvar d = 0;\r\n\t\t\tvar vertices = this.vertices;\r\n\t\r\n\t\t\tfor ( var i = 0, il = vertices.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\tif ( i > 0 ) {\r\n\t\r\n\t\t\t\t\td += vertices[ i ].distanceTo( vertices[ i - 1 ] );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tthis.lineDistances[ i ] = d;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcomputeBoundingBox: function () {\r\n\t\r\n\t\t\tif ( this.boundingBox === null ) {\r\n\t\r\n\t\t\t\tthis.boundingBox = new THREE.Box3();\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tthis.boundingBox.setFromPoints( this.vertices );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcomputeBoundingSphere: function () {\r\n\t\r\n\t\t\tif ( this.boundingSphere === null ) {\r\n\t\r\n\t\t\t\tthis.boundingSphere = new THREE.Sphere();\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tthis.boundingSphere.setFromPoints( this.vertices );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tmerge: function ( geometry, matrix, materialIndexOffset ) {\r\n\t\r\n\t\t\tif ( geometry instanceof THREE.Geometry === false ) {\r\n\t\r\n\t\t\t\tTHREE.error( 'THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.', geometry );\r\n\t\t\t\treturn;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar normalMatrix,\r\n\t\t\tvertexOffset = this.vertices.length,\r\n\t\t\tvertices1 = this.vertices,\r\n\t\t\tvertices2 = geometry.vertices,\r\n\t\t\tfaces1 = this.faces,\r\n\t\t\tfaces2 = geometry.faces,\r\n\t\t\tuvs1 = this.faceVertexUvs[ 0 ],\r\n\t\t\tuvs2 = geometry.faceVertexUvs[ 0 ];\r\n\t\r\n\t\t\tif ( materialIndexOffset === undefined ) materialIndexOffset = 0;\r\n\t\r\n\t\t\tif ( matrix !== undefined ) {\r\n\t\r\n\t\t\t\tnormalMatrix = new THREE.Matrix3().getNormalMatrix( matrix );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// vertices\r\n\t\r\n\t\t\tfor ( var i = 0, il = vertices2.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\tvar vertex = vertices2[ i ];\r\n\t\r\n\t\t\t\tvar vertexCopy = vertex.clone();\r\n\t\r\n\t\t\t\tif ( matrix !== undefined ) vertexCopy.applyMatrix4( matrix );\r\n\t\r\n\t\t\t\tvertices1.push( vertexCopy );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// faces\r\n\t\r\n\t\t\tfor ( i = 0, il = faces2.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\tvar face = faces2[ i ], faceCopy, normal, color,\r\n\t\t\t\tfaceVertexNormals = face.vertexNormals,\r\n\t\t\t\tfaceVertexColors = face.vertexColors;\r\n\t\r\n\t\t\t\tfaceCopy = new THREE.Face3( face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset );\r\n\t\t\t\tfaceCopy.normal.copy( face.normal );\r\n\t\r\n\t\t\t\tif ( normalMatrix !== undefined ) {\r\n\t\r\n\t\t\t\t\tfaceCopy.normal.applyMatrix3( normalMatrix ).normalize();\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tfor ( var j = 0, jl = faceVertexNormals.length; j < jl; j ++ ) {\r\n\t\r\n\t\t\t\t\tnormal = faceVertexNormals[ j ].clone();\r\n\t\r\n\t\t\t\t\tif ( normalMatrix !== undefined ) {\r\n\t\r\n\t\t\t\t\t\tnormal.applyMatrix3( normalMatrix ).normalize();\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tfaceCopy.vertexNormals.push( normal );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tfaceCopy.color.copy( face.color );\r\n\t\r\n\t\t\t\tfor ( var j = 0, jl = faceVertexColors.length; j < jl; j ++ ) {\r\n\t\r\n\t\t\t\t\tcolor = faceVertexColors[ j ];\r\n\t\t\t\t\tfaceCopy.vertexColors.push( color.clone() );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tfaceCopy.materialIndex = face.materialIndex + materialIndexOffset;\r\n\t\r\n\t\t\t\tfaces1.push( faceCopy );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// uvs\r\n\t\r\n\t\t\tfor ( i = 0, il = uvs2.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\tvar uv = uvs2[ i ], uvCopy = [];\r\n\t\r\n\t\t\t\tif ( uv === undefined ) {\r\n\t\r\n\t\t\t\t\tcontinue;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tfor ( var j = 0, jl = uv.length; j < jl; j ++ ) {\r\n\t\r\n\t\t\t\t\tuvCopy.push( uv[ j ].clone() );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tuvs1.push( uvCopy );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t},\r\n\t\r\n\t\tmergeMesh: function ( mesh ) {\r\n\t\r\n\t\t\tif ( mesh instanceof THREE.Mesh === false ) {\r\n\t\r\n\t\t\t\tTHREE.error( 'THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.', mesh );\r\n\t\t\t\treturn;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tmesh.matrixAutoUpdate && mesh.updateMatrix();\r\n\t\r\n\t\t\tthis.merge( mesh.geometry, mesh.matrix );\r\n\t\r\n\t\t},\r\n\t\r\n\t\t/*\r\n\t\t * Checks for duplicate vertices with hashmap.\r\n\t\t * Duplicated vertices are removed\r\n\t\t * and faces' vertices are updated.\r\n\t\t */\r\n\t\r\n\t\tmergeVertices: function () {\r\n\t\r\n\t\t\tvar verticesMap = {}; // Hashmap for looking up vertice by position coordinates (and making sure they are unique)\r\n\t\t\tvar unique = [], changes = [];\r\n\t\r\n\t\t\tvar v, key;\r\n\t\t\tvar precisionPoints = 4; // number of decimal points, eg. 4 for epsilon of 0.0001\r\n\t\t\tvar precision = Math.pow( 10, precisionPoints );\r\n\t\t\tvar i, il, face;\r\n\t\t\tvar indices, j, jl;\r\n\t\r\n\t\t\tfor ( i = 0, il = this.vertices.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\tv = this.vertices[ i ];\r\n\t\t\t\tkey = Math.round( v.x * precision ) + '_' + Math.round( v.y * precision ) + '_' + Math.round( v.z * precision );\r\n\t\r\n\t\t\t\tif ( verticesMap[ key ] === undefined ) {\r\n\t\r\n\t\t\t\t\tverticesMap[ key ] = i;\r\n\t\t\t\t\tunique.push( this.vertices[ i ] );\r\n\t\t\t\t\tchanges[ i ] = unique.length - 1;\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t//console.log('Duplicate vertex found. ', i, ' could be using ', verticesMap[key]);\r\n\t\t\t\t\tchanges[ i ] = changes[ verticesMap[ key ] ];\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\r\n\t\t\t// if faces are completely degenerate after merging vertices, we\r\n\t\t\t// have to remove them from the geometry.\r\n\t\t\tvar faceIndicesToRemove = [];\r\n\t\r\n\t\t\tfor ( i = 0, il = this.faces.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\tface = this.faces[ i ];\r\n\t\r\n\t\t\t\tface.a = changes[ face.a ];\r\n\t\t\t\tface.b = changes[ face.b ];\r\n\t\t\t\tface.c = changes[ face.c ];\r\n\t\r\n\t\t\t\tindices = [ face.a, face.b, face.c ];\r\n\t\r\n\t\t\t\tvar dupIndex = - 1;\r\n\t\r\n\t\t\t\t// if any duplicate vertices are found in a Face3\r\n\t\t\t\t// we have to remove the face as nothing can be saved\r\n\t\t\t\tfor ( var n = 0; n < 3; n ++ ) {\r\n\t\t\t\t\tif ( indices[ n ] == indices[ ( n + 1 ) % 3 ] ) {\r\n\t\r\n\t\t\t\t\t\tdupIndex = n;\r\n\t\t\t\t\t\tfaceIndicesToRemove.push( i );\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tfor ( i = faceIndicesToRemove.length - 1; i >= 0; i -- ) {\r\n\t\t\t\tvar idx = faceIndicesToRemove[ i ];\r\n\t\r\n\t\t\t\tthis.faces.splice( idx, 1 );\r\n\t\r\n\t\t\t\tfor ( j = 0, jl = this.faceVertexUvs.length; j < jl; j ++ ) {\r\n\t\r\n\t\t\t\t\tthis.faceVertexUvs[ j ].splice( idx, 1 );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// Use unique set of vertices\r\n\t\r\n\t\t\tvar diff = this.vertices.length - unique.length;\r\n\t\t\tthis.vertices = unique;\r\n\t\t\treturn diff;\r\n\t\r\n\t\t},\r\n\t\r\n\t\ttoJSON: function () {\r\n\t\r\n\t\t\tvar output = {\r\n\t\t\t\tmetadata: {\r\n\t\t\t\t\tversion: 4.0,\r\n\t\t\t\t\ttype: 'BufferGeometry',\r\n\t\t\t\t\tgenerator: 'BufferGeometryExporter'\r\n\t\t\t\t},\r\n\t\t\t\tuuid: this.uuid,\r\n\t\t\t\ttype: this.type\r\n\t\t\t};\r\n\t\r\n\t\t\tif ( this.name !== \"\" ) output.name = this.name;\r\n\t\r\n\t\t\tif ( this.parameters !== undefined ) {\r\n\t\r\n\t\t\t\tvar parameters = this.parameters;\r\n\t\r\n\t\t\t\tfor ( var key in parameters ) {\r\n\t\r\n\t\t\t\t\tif ( parameters[ key ] !== undefined ) output[ key ] = parameters[ key ];\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\treturn output;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar vertices = [];\r\n\t\r\n\t\t\tfor ( var i = 0; i < this.vertices.length; i ++ ) {\r\n\t\r\n\t\t\t\tvar vertex = this.vertices[ i ];\r\n\t\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar faces = [];\r\n\t\t\tvar normals = [];\r\n\t\t\tvar normalsHash = {};\r\n\t\t\tvar colors = [];\r\n\t\t\tvar colorsHash = {};\r\n\t\t\tvar uvs = [];\r\n\t\t\tvar uvsHash = {};\r\n\t\r\n\t\t\tfor ( var i = 0; i < this.faces.length; i ++ ) {\r\n\t\r\n\t\t\t\tvar face = this.faces[ i ];\r\n\t\r\n\t\t\t\tvar hasMaterial = false; // face.materialIndex !== undefined;\r\n\t\t\t\tvar hasFaceUv = false; // deprecated\r\n\t\t\t\tvar hasFaceVertexUv = this.faceVertexUvs[ 0 ][ i ] !== undefined;\r\n\t\t\t\tvar hasFaceNormal = face.normal.length() > 0;\r\n\t\t\t\tvar hasFaceVertexNormal = face.vertexNormals.length > 0;\r\n\t\t\t\tvar hasFaceColor = face.color.r !== 1 || face.color.g !== 1 || face.color.b !== 1;\r\n\t\t\t\tvar hasFaceVertexColor = face.vertexColors.length > 0;\r\n\t\r\n\t\t\t\tvar faceType = 0;\r\n\t\r\n\t\t\t\tfaceType = setBit( faceType, 0, 0 );\r\n\t\t\t\tfaceType = setBit( faceType, 1, hasMaterial );\r\n\t\t\t\tfaceType = setBit( faceType, 2, hasFaceUv );\r\n\t\t\t\tfaceType = setBit( faceType, 3, hasFaceVertexUv );\r\n\t\t\t\tfaceType = setBit( faceType, 4, hasFaceNormal );\r\n\t\t\t\tfaceType = setBit( faceType, 5, hasFaceVertexNormal );\r\n\t\t\t\tfaceType = setBit( faceType, 6, hasFaceColor );\r\n\t\t\t\tfaceType = setBit( faceType, 7, hasFaceVertexColor );\r\n\t\r\n\t\t\t\tfaces.push( faceType );\r\n\t\t\t\tfaces.push( face.a, face.b, face.c );\r\n\t\r\n\t\r\n\t\t\t\t/*\r\n\t\t\t\tif ( hasMaterial ) {\r\n\t\r\n\t\t\t\t\tfaces.push( face.materialIndex );\r\n\t\r\n\t\t\t\t}\r\n\t\t\t\t*/\r\n\t\r\n\t\t\t\tif ( hasFaceVertexUv ) {\r\n\t\r\n\t\t\t\t\tvar faceVertexUvs = this.faceVertexUvs[ 0 ][ i ];\r\n\t\r\n\t\t\t\t\tfaces.push(\r\n\t\t\t\t\t\tgetUvIndex( faceVertexUvs[ 0 ] ),\r\n\t\t\t\t\t\tgetUvIndex( faceVertexUvs[ 1 ] ),\r\n\t\t\t\t\t\tgetUvIndex( faceVertexUvs[ 2 ] )\r\n\t\t\t\t\t);\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( hasFaceNormal ) {\r\n\t\r\n\t\t\t\t\tfaces.push( getNormalIndex( face.normal ) );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( hasFaceVertexNormal ) {\r\n\t\r\n\t\t\t\t\tvar vertexNormals = face.vertexNormals;\r\n\t\r\n\t\t\t\t\tfaces.push(\r\n\t\t\t\t\t\tgetNormalIndex( vertexNormals[ 0 ] ),\r\n\t\t\t\t\t\tgetNormalIndex( vertexNormals[ 1 ] ),\r\n\t\t\t\t\t\tgetNormalIndex( vertexNormals[ 2 ] )\r\n\t\t\t\t\t);\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( hasFaceColor ) {\r\n\t\r\n\t\t\t\t\tfaces.push( getColorIndex( face.color ) );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( hasFaceVertexColor ) {\r\n\t\r\n\t\t\t\t\tvar vertexColors = face.vertexColors;\r\n\t\r\n\t\t\t\t\tfaces.push(\r\n\t\t\t\t\t\tgetColorIndex( vertexColors[ 0 ] ),\r\n\t\t\t\t\t\tgetColorIndex( vertexColors[ 1 ] ),\r\n\t\t\t\t\t\tgetColorIndex( vertexColors[ 2 ] )\r\n\t\t\t\t\t);\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tfunction setBit( value, position, enabled ) {\r\n\t\r\n\t\t\t\treturn enabled ? value | ( 1 << position ) : value & ( ~ ( 1 << position) );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tfunction getNormalIndex( normal ) {\r\n\t\r\n\t\t\t\tvar hash = normal.x.toString() + normal.y.toString() + normal.z.toString();\r\n\t\r\n\t\t\t\tif ( normalsHash[ hash ] !== undefined ) {\r\n\t\r\n\t\t\t\t\treturn normalsHash[ hash ];\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tnormalsHash[ hash ] = normals.length / 3;\r\n\t\t\t\tnormals.push( normal.x, normal.y, normal.z );\r\n\t\r\n\t\t\t\treturn normalsHash[ hash ];\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tfunction getColorIndex( color ) {\r\n\t\r\n\t\t\t\tvar hash = color.r.toString() + color.g.toString() + color.b.toString();\r\n\t\r\n\t\t\t\tif ( colorsHash[ hash ] !== undefined ) {\r\n\t\r\n\t\t\t\t\treturn colorsHash[ hash ];\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tcolorsHash[ hash ] = colors.length;\r\n\t\t\t\tcolors.push( color.getHex() );\r\n\t\r\n\t\t\t\treturn colorsHash[ hash ];\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tfunction getUvIndex( uv ) {\r\n\t\r\n\t\t\t\tvar hash = uv.x.toString() + uv.y.toString();\r\n\t\r\n\t\t\t\tif ( uvsHash[ hash ] !== undefined ) {\r\n\t\r\n\t\t\t\t\treturn uvsHash[ hash ];\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tuvsHash[ hash ] = uvs.length / 2;\r\n\t\t\t\tuvs.push( uv.x, uv.y );\r\n\t\r\n\t\t\t\treturn uvsHash[ hash ];\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\toutput.data = {};\r\n\t\r\n\t\t\toutput.data.vertices = vertices;\r\n\t\t\toutput.data.normals = normals;\r\n\t\t\tif ( colors.length > 0 ) output.data.colors = colors;\r\n\t\t\tif ( uvs.length > 0 ) output.data.uvs = [ uvs ]; // temporal backward compatibility\r\n\t\t\toutput.data.faces = faces;\r\n\t\r\n\t\t\t//\r\n\t\r\n\t\t\treturn output;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tclone: function () {\r\n\t\r\n\t\t\tvar geometry = new THREE.Geometry();\r\n\t\r\n\t\t\tvar vertices = this.vertices;\r\n\t\r\n\t\t\tfor ( var i = 0, il = vertices.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\tgeometry.vertices.push( vertices[ i ].clone() );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar faces = this.faces;\r\n\t\r\n\t\t\tfor ( var i = 0, il = faces.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\tgeometry.faces.push( faces[ i ].clone() );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tfor ( var i = 0, il = this.faceVertexUvs.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\tvar faceVertexUvs = this.faceVertexUvs[ i ];\r\n\t\r\n\t\t\t\tif ( geometry.faceVertexUvs[ i ] === undefined ) {\r\n\t\r\n\t\t\t\t\tgeometry.faceVertexUvs[ i ] = [];\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tfor ( var j = 0, jl = faceVertexUvs.length; j < jl; j ++ ) {\r\n\t\r\n\t\t\t\t\tvar uvs = faceVertexUvs[ j ], uvsCopy = [];\r\n\t\r\n\t\t\t\t\tfor ( var k = 0, kl = uvs.length; k < kl; k ++ ) {\r\n\t\r\n\t\t\t\t\t\tvar uv = uvs[ k ];\r\n\t\r\n\t\t\t\t\t\tuvsCopy.push( uv.clone() );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tgeometry.faceVertexUvs[ i ].push( uvsCopy );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn geometry;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tdispose: function () {\r\n\t\r\n\t\t\tthis.dispatchEvent( { type: 'dispose' } );\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.EventDispatcher.prototype.apply( THREE.Geometry.prototype );\r\n\t\r\n\tTHREE.GeometryIdCount = 0;\r\n\t\r\n\t// File:src/cameras/Camera.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t * @author mikael emtinger / http://gomo.se/\r\n\t * @author WestLangley / http://github.com/WestLangley\r\n\t*/\r\n\t\r\n\tTHREE.Camera = function () {\r\n\t\r\n\t\tTHREE.Object3D.call( this );\r\n\t\r\n\t\tthis.type = 'Camera';\r\n\t\r\n\t\tthis.matrixWorldInverse = new THREE.Matrix4();\r\n\t\tthis.projectionMatrix = new THREE.Matrix4();\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Camera.prototype = Object.create( THREE.Object3D.prototype );\r\n\tTHREE.Camera.prototype.constructor = THREE.Camera;\r\n\t\r\n\tTHREE.Camera.prototype.getWorldDirection = function () {\r\n\t\r\n\t\tvar quaternion = new THREE.Quaternion();\r\n\t\r\n\t\treturn function ( optionalTarget ) {\r\n\t\r\n\t\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\t\r\n\t\t\tthis.getWorldQuaternion( quaternion );\r\n\t\r\n\t\t\treturn result.set( 0, 0, - 1 ).applyQuaternion( quaternion );\r\n\t\r\n\t\t}\r\n\t\r\n\t}();\r\n\t\r\n\tTHREE.Camera.prototype.lookAt = function () {\r\n\t\r\n\t\t// This routine does not support cameras with rotated and/or translated parent(s)\r\n\t\r\n\t\tvar m1 = new THREE.Matrix4();\r\n\t\r\n\t\treturn function ( vector ) {\r\n\t\r\n\t\t\tm1.lookAt( this.position, vector, this.up );\r\n\t\r\n\t\t\tthis.quaternion.setFromRotationMatrix( m1 );\r\n\t\r\n\t\t};\r\n\t\r\n\t}();\r\n\t\r\n\tTHREE.Camera.prototype.clone = function ( camera ) {\r\n\t\r\n\t\tif ( camera === undefined ) camera = new THREE.Camera();\r\n\t\r\n\t\tTHREE.Object3D.prototype.clone.call( this, camera );\r\n\t\r\n\t\tcamera.matrixWorldInverse.copy( this.matrixWorldInverse );\r\n\t\tcamera.projectionMatrix.copy( this.projectionMatrix );\r\n\t\r\n\t\treturn camera;\r\n\t};\r\n\t\r\n\t// File:src/cameras/CubeCamera.js\r\n\t\r\n\t/**\r\n\t * Camera for rendering cube maps\r\n\t *\t- renders scene into axis-aligned cube\r\n\t *\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t */\r\n\t\r\n\tTHREE.CubeCamera = function ( near, far, cubeResolution ) {\r\n\t\r\n\t\tTHREE.Object3D.call( this );\r\n\t\r\n\t\tthis.type = 'CubeCamera';\r\n\t\r\n\t\tvar fov = 90, aspect = 1;\r\n\t\r\n\t\tvar cameraPX = new THREE.PerspectiveCamera( fov, aspect, near, far );\r\n\t\tcameraPX.up.set( 0, - 1, 0 );\r\n\t\tcameraPX.lookAt( new THREE.Vector3( 1, 0, 0 ) );\r\n\t\tthis.add( cameraPX );\r\n\t\r\n\t\tvar cameraNX = new THREE.PerspectiveCamera( fov, aspect, near, far );\r\n\t\tcameraNX.up.set( 0, - 1, 0 );\r\n\t\tcameraNX.lookAt( new THREE.Vector3( - 1, 0, 0 ) );\r\n\t\tthis.add( cameraNX );\r\n\t\r\n\t\tvar cameraPY = new THREE.PerspectiveCamera( fov, aspect, near, far );\r\n\t\tcameraPY.up.set( 0, 0, 1 );\r\n\t\tcameraPY.lookAt( new THREE.Vector3( 0, 1, 0 ) );\r\n\t\tthis.add( cameraPY );\r\n\t\r\n\t\tvar cameraNY = new THREE.PerspectiveCamera( fov, aspect, near, far );\r\n\t\tcameraNY.up.set( 0, 0, - 1 );\r\n\t\tcameraNY.lookAt( new THREE.Vector3( 0, - 1, 0 ) );\r\n\t\tthis.add( cameraNY );\r\n\t\r\n\t\tvar cameraPZ = new THREE.PerspectiveCamera( fov, aspect, near, far );\r\n\t\tcameraPZ.up.set( 0, - 1, 0 );\r\n\t\tcameraPZ.lookAt( new THREE.Vector3( 0, 0, 1 ) );\r\n\t\tthis.add( cameraPZ );\r\n\t\r\n\t\tvar cameraNZ = new THREE.PerspectiveCamera( fov, aspect, near, far );\r\n\t\tcameraNZ.up.set( 0, - 1, 0 );\r\n\t\tcameraNZ.lookAt( new THREE.Vector3( 0, 0, - 1 ) );\r\n\t\tthis.add( cameraNZ );\r\n\t\r\n\t\tthis.renderTarget = new THREE.WebGLRenderTargetCube( cubeResolution, cubeResolution, { format: THREE.RGBFormat, magFilter: THREE.LinearFilter, minFilter: THREE.LinearFilter } );\r\n\t\r\n\t\tthis.updateCubeMap = function ( renderer, scene ) {\r\n\t\r\n\t\t\tvar renderTarget = this.renderTarget;\r\n\t\t\tvar generateMipmaps = renderTarget.generateMipmaps;\r\n\t\r\n\t\t\trenderTarget.generateMipmaps = false;\r\n\t\r\n\t\t\trenderTarget.activeCubeFace = 0;\r\n\t\t\trenderer.render( scene, cameraPX, renderTarget );\r\n\t\r\n\t\t\trenderTarget.activeCubeFace = 1;\r\n\t\t\trenderer.render( scene, cameraNX, renderTarget );\r\n\t\r\n\t\t\trenderTarget.activeCubeFace = 2;\r\n\t\t\trenderer.render( scene, cameraPY, renderTarget );\r\n\t\r\n\t\t\trenderTarget.activeCubeFace = 3;\r\n\t\t\trenderer.render( scene, cameraNY, renderTarget );\r\n\t\r\n\t\t\trenderTarget.activeCubeFace = 4;\r\n\t\t\trenderer.render( scene, cameraPZ, renderTarget );\r\n\t\r\n\t\t\trenderTarget.generateMipmaps = generateMipmaps;\r\n\t\r\n\t\t\trenderTarget.activeCubeFace = 5;\r\n\t\t\trenderer.render( scene, cameraNZ, renderTarget );\r\n\t\r\n\t\t};\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.CubeCamera.prototype = Object.create( THREE.Object3D.prototype );\r\n\tTHREE.CubeCamera.prototype.constructor = THREE.CubeCamera;\r\n\t\r\n\t// File:src/cameras/OrthographicCamera.js\r\n\t\r\n\t/**\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t */\r\n\t\r\n\tTHREE.OrthographicCamera = function ( left, right, top, bottom, near, far ) {\r\n\t\r\n\t\tTHREE.Camera.call( this );\r\n\t\r\n\t\tthis.type = 'OrthographicCamera';\r\n\t\r\n\t\tthis.zoom = 1;\r\n\t\r\n\t\tthis.left = left;\r\n\t\tthis.right = right;\r\n\t\tthis.top = top;\r\n\t\tthis.bottom = bottom;\r\n\t\r\n\t\tthis.near = ( near !== undefined ) ? near : 0.1;\r\n\t\tthis.far = ( far !== undefined ) ? far : 2000;\r\n\t\r\n\t\tthis.updateProjectionMatrix();\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.OrthographicCamera.prototype = Object.create( THREE.Camera.prototype );\r\n\tTHREE.OrthographicCamera.prototype.constructor = THREE.OrthographicCamera;\r\n\t\r\n\tTHREE.OrthographicCamera.prototype.updateProjectionMatrix = function () {\r\n\t\r\n\t\tvar dx = ( this.right - this.left ) / ( 2 * this.zoom );\r\n\t\tvar dy = ( this.top - this.bottom ) / ( 2 * this.zoom );\r\n\t\tvar cx = ( this.right + this.left ) / 2;\r\n\t\tvar cy = ( this.top + this.bottom ) / 2;\r\n\t\r\n\t\tthis.projectionMatrix.makeOrthographic( cx - dx, cx + dx, cy + dy, cy - dy, this.near, this.far );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.OrthographicCamera.prototype.clone = function () {\r\n\t\r\n\t\tvar camera = new THREE.OrthographicCamera();\r\n\t\r\n\t\tTHREE.Camera.prototype.clone.call( this, camera );\r\n\t\r\n\t\tcamera.zoom = this.zoom;\r\n\t\r\n\t\tcamera.left = this.left;\r\n\t\tcamera.right = this.right;\r\n\t\tcamera.top = this.top;\r\n\t\tcamera.bottom = this.bottom;\r\n\t\r\n\t\tcamera.near = this.near;\r\n\t\tcamera.far = this.far;\r\n\t\r\n\t\tcamera.projectionMatrix.copy( this.projectionMatrix );\r\n\t\r\n\t\treturn camera;\r\n\t};\r\n\t\r\n\t// File:src/cameras/PerspectiveCamera.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t * @author greggman / http://games.greggman.com/\r\n\t * @author zz85 / http://www.lab4games.net/zz85/blog\r\n\t */\r\n\t\r\n\tTHREE.PerspectiveCamera = function ( fov, aspect, near, far ) {\r\n\t\r\n\t\tTHREE.Camera.call( this );\r\n\t\r\n\t\tthis.type = 'PerspectiveCamera';\r\n\t\r\n\t\tthis.zoom = 1;\r\n\t\r\n\t\tthis.fov = fov !== undefined ? fov : 50;\r\n\t\tthis.aspect = aspect !== undefined ? aspect : 1;\r\n\t\tthis.near = near !== undefined ? near : 0.1;\r\n\t\tthis.far = far !== undefined ? far : 2000;\r\n\t\r\n\t\tthis.updateProjectionMatrix();\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.PerspectiveCamera.prototype = Object.create( THREE.Camera.prototype );\r\n\tTHREE.PerspectiveCamera.prototype.constructor = THREE.PerspectiveCamera;\r\n\t\r\n\t\r\n\t/**\r\n\t * Uses Focal Length (in mm) to estimate and set FOV\r\n\t * 35mm (fullframe) camera is used if frame size is not specified;\r\n\t * Formula based on http://www.bobatkins.com/photography/technical/field_of_view.html\r\n\t */\r\n\t\r\n\tTHREE.PerspectiveCamera.prototype.setLens = function ( focalLength, frameHeight ) {\r\n\t\r\n\t\tif ( frameHeight === undefined ) frameHeight = 24;\r\n\t\r\n\t\tthis.fov = 2 * THREE.Math.radToDeg( Math.atan( frameHeight / ( focalLength * 2 ) ) );\r\n\t\tthis.updateProjectionMatrix();\r\n\t\r\n\t}\r\n\t\r\n\t\r\n\t/**\r\n\t * Sets an offset in a larger frustum. This is useful for multi-window or\r\n\t * multi-monitor/multi-machine setups.\r\n\t *\r\n\t * For example, if you have 3x2 monitors and each monitor is 1920x1080 and\r\n\t * the monitors are in grid like this\r\n\t *\r\n\t *   +---+---+---+\r\n\t *   | A | B | C |\r\n\t *   +---+---+---+\r\n\t *   | D | E | F |\r\n\t *   +---+---+---+\r\n\t *\r\n\t * then for each monitor you would call it like this\r\n\t *\r\n\t *   var w = 1920;\r\n\t *   var h = 1080;\r\n\t *   var fullWidth = w * 3;\r\n\t *   var fullHeight = h * 2;\r\n\t *\r\n\t *   --A--\r\n\t *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );\r\n\t *   --B--\r\n\t *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );\r\n\t *   --C--\r\n\t *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );\r\n\t *   --D--\r\n\t *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );\r\n\t *   --E--\r\n\t *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );\r\n\t *   --F--\r\n\t *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );\r\n\t *\r\n\t *   Note there is no reason monitors have to be the same size or in a grid.\r\n\t */\r\n\t\r\n\tTHREE.PerspectiveCamera.prototype.setViewOffset = function ( fullWidth, fullHeight, x, y, width, height ) {\r\n\t\r\n\t\tthis.fullWidth = fullWidth;\r\n\t\tthis.fullHeight = fullHeight;\r\n\t\tthis.x = x;\r\n\t\tthis.y = y;\r\n\t\tthis.width = width;\r\n\t\tthis.height = height;\r\n\t\r\n\t\tthis.updateProjectionMatrix();\r\n\t\r\n\t};\r\n\t\r\n\t\r\n\tTHREE.PerspectiveCamera.prototype.updateProjectionMatrix = function () {\r\n\t\r\n\t\tvar fov = THREE.Math.radToDeg( 2 * Math.atan( Math.tan( THREE.Math.degToRad( this.fov ) * 0.5 ) / this.zoom ) );\r\n\t\r\n\t\tif ( this.fullWidth ) {\r\n\t\r\n\t\t\tvar aspect = this.fullWidth / this.fullHeight;\r\n\t\t\tvar top = Math.tan( THREE.Math.degToRad( fov * 0.5 ) ) * this.near;\r\n\t\t\tvar bottom = - top;\r\n\t\t\tvar left = aspect * bottom;\r\n\t\t\tvar right = aspect * top;\r\n\t\t\tvar width = Math.abs( right - left );\r\n\t\t\tvar height = Math.abs( top - bottom );\r\n\t\r\n\t\t\tthis.projectionMatrix.makeFrustum(\r\n\t\t\t\tleft + this.x * width / this.fullWidth,\r\n\t\t\t\tleft + ( this.x + this.width ) * width / this.fullWidth,\r\n\t\t\t\ttop - ( this.y + this.height ) * height / this.fullHeight,\r\n\t\t\t\ttop - this.y * height / this.fullHeight,\r\n\t\t\t\tthis.near,\r\n\t\t\t\tthis.far\r\n\t\t\t);\r\n\t\r\n\t\t} else {\r\n\t\r\n\t\t\tthis.projectionMatrix.makePerspective( fov, this.aspect, this.near, this.far );\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.PerspectiveCamera.prototype.clone = function () {\r\n\t\r\n\t\tvar camera = new THREE.PerspectiveCamera();\r\n\t\r\n\t\tTHREE.Camera.prototype.clone.call( this, camera );\r\n\t\r\n\t\tcamera.zoom = this.zoom;\r\n\t\r\n\t\tcamera.fov = this.fov;\r\n\t\tcamera.aspect = this.aspect;\r\n\t\tcamera.near = this.near;\r\n\t\tcamera.far = this.far;\r\n\t\r\n\t\tcamera.projectionMatrix.copy( this.projectionMatrix );\r\n\t\r\n\t\treturn camera;\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/lights/Light.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t */\r\n\t\r\n\tTHREE.Light = function ( color ) {\r\n\t\r\n\t\tTHREE.Object3D.call( this );\r\n\t\r\n\t\tthis.type = 'Light';\r\n\t\t\r\n\t\tthis.color = new THREE.Color( color );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Light.prototype = Object.create( THREE.Object3D.prototype );\r\n\tTHREE.Light.prototype.constructor = THREE.Light;\r\n\t\r\n\tTHREE.Light.prototype.clone = function ( light ) {\r\n\t\r\n\t\tif ( light === undefined ) light = new THREE.Light();\r\n\t\r\n\t\tTHREE.Object3D.prototype.clone.call( this, light );\r\n\t\r\n\t\tlight.color.copy( this.color );\r\n\t\r\n\t\treturn light;\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/lights/AmbientLight.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tTHREE.AmbientLight = function ( color ) {\r\n\t\r\n\t\tTHREE.Light.call( this, color );\r\n\t\r\n\t\tthis.type = 'AmbientLight';\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.AmbientLight.prototype = Object.create( THREE.Light.prototype );\r\n\tTHREE.AmbientLight.prototype.constructor = THREE.AmbientLight;\r\n\t\r\n\tTHREE.AmbientLight.prototype.clone = function () {\r\n\t\r\n\t\tvar light = new THREE.AmbientLight();\r\n\t\r\n\t\tTHREE.Light.prototype.clone.call( this, light );\r\n\t\r\n\t\treturn light;\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/lights/AreaLight.js\r\n\t\r\n\t/**\r\n\t * @author MPanknin / http://www.redplant.de/\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t */\r\n\t\r\n\tTHREE.AreaLight = function ( color, intensity ) {\r\n\t\r\n\t\tTHREE.Light.call( this, color );\r\n\t\r\n\t\tthis.type = 'AreaLight';\r\n\t\r\n\t\tthis.normal = new THREE.Vector3( 0, - 1, 0 );\r\n\t\tthis.right = new THREE.Vector3( 1, 0, 0 );\r\n\t\r\n\t\tthis.intensity = ( intensity !== undefined ) ? intensity : 1;\r\n\t\r\n\t\tthis.width = 1.0;\r\n\t\tthis.height = 1.0;\r\n\t\r\n\t\tthis.constantAttenuation = 1.5;\r\n\t\tthis.linearAttenuation = 0.5;\r\n\t\tthis.quadraticAttenuation = 0.1;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.AreaLight.prototype = Object.create( THREE.Light.prototype );\r\n\tTHREE.AreaLight.prototype.constructor = THREE.AreaLight;\r\n\t\r\n\t\r\n\t// File:src/lights/DirectionalLight.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t */\r\n\t\r\n\tTHREE.DirectionalLight = function ( color, intensity ) {\r\n\t\r\n\t\tTHREE.Light.call( this, color );\r\n\t\r\n\t\tthis.type = 'DirectionalLight';\r\n\t\r\n\t\tthis.position.set( 0, 1, 0 );\r\n\t\tthis.target = new THREE.Object3D();\r\n\t\r\n\t\tthis.intensity = ( intensity !== undefined ) ? intensity : 1;\r\n\t\r\n\t\tthis.castShadow = false;\r\n\t\tthis.onlyShadow = false;\r\n\t\r\n\t\t//\r\n\t\r\n\t\tthis.shadowCameraNear = 50;\r\n\t\tthis.shadowCameraFar = 5000;\r\n\t\r\n\t\tthis.shadowCameraLeft = - 500;\r\n\t\tthis.shadowCameraRight = 500;\r\n\t\tthis.shadowCameraTop = 500;\r\n\t\tthis.shadowCameraBottom = - 500;\r\n\t\r\n\t\tthis.shadowCameraVisible = false;\r\n\t\r\n\t\tthis.shadowBias = 0;\r\n\t\tthis.shadowDarkness = 0.5;\r\n\t\r\n\t\tthis.shadowMapWidth = 512;\r\n\t\tthis.shadowMapHeight = 512;\r\n\t\r\n\t\t//\r\n\t\r\n\t\tthis.shadowCascade = false;\r\n\t\r\n\t\tthis.shadowCascadeOffset = new THREE.Vector3( 0, 0, - 1000 );\r\n\t\tthis.shadowCascadeCount = 2;\r\n\t\r\n\t\tthis.shadowCascadeBias = [ 0, 0, 0 ];\r\n\t\tthis.shadowCascadeWidth = [ 512, 512, 512 ];\r\n\t\tthis.shadowCascadeHeight = [ 512, 512, 512 ];\r\n\t\r\n\t\tthis.shadowCascadeNearZ = [ - 1.000, 0.990, 0.998 ];\r\n\t\tthis.shadowCascadeFarZ  = [ 0.990, 0.998, 1.000 ];\r\n\t\r\n\t\tthis.shadowCascadeArray = [];\r\n\t\r\n\t\t//\r\n\t\r\n\t\tthis.shadowMap = null;\r\n\t\tthis.shadowMapSize = null;\r\n\t\tthis.shadowCamera = null;\r\n\t\tthis.shadowMatrix = null;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.DirectionalLight.prototype = Object.create( THREE.Light.prototype );\r\n\tTHREE.DirectionalLight.prototype.constructor = THREE.DirectionalLight;\r\n\t\r\n\tTHREE.DirectionalLight.prototype.clone = function () {\r\n\t\r\n\t\tvar light = new THREE.DirectionalLight();\r\n\t\r\n\t\tTHREE.Light.prototype.clone.call( this, light );\r\n\t\r\n\t\tlight.target = this.target.clone();\r\n\t\r\n\t\tlight.intensity = this.intensity;\r\n\t\r\n\t\tlight.castShadow = this.castShadow;\r\n\t\tlight.onlyShadow = this.onlyShadow;\r\n\t\r\n\t\t//\r\n\t\r\n\t\tlight.shadowCameraNear = this.shadowCameraNear;\r\n\t\tlight.shadowCameraFar = this.shadowCameraFar;\r\n\t\r\n\t\tlight.shadowCameraLeft = this.shadowCameraLeft;\r\n\t\tlight.shadowCameraRight = this.shadowCameraRight;\r\n\t\tlight.shadowCameraTop = this.shadowCameraTop;\r\n\t\tlight.shadowCameraBottom = this.shadowCameraBottom;\r\n\t\r\n\t\tlight.shadowCameraVisible = this.shadowCameraVisible;\r\n\t\r\n\t\tlight.shadowBias = this.shadowBias;\r\n\t\tlight.shadowDarkness = this.shadowDarkness;\r\n\t\r\n\t\tlight.shadowMapWidth = this.shadowMapWidth;\r\n\t\tlight.shadowMapHeight = this.shadowMapHeight;\r\n\t\r\n\t\t//\r\n\t\r\n\t\tlight.shadowCascade = this.shadowCascade;\r\n\t\r\n\t\tlight.shadowCascadeOffset.copy( this.shadowCascadeOffset );\r\n\t\tlight.shadowCascadeCount = this.shadowCascadeCount;\r\n\t\r\n\t\tlight.shadowCascadeBias = this.shadowCascadeBias.slice( 0 );\r\n\t\tlight.shadowCascadeWidth = this.shadowCascadeWidth.slice( 0 );\r\n\t\tlight.shadowCascadeHeight = this.shadowCascadeHeight.slice( 0 );\r\n\t\r\n\t\tlight.shadowCascadeNearZ = this.shadowCascadeNearZ.slice( 0 );\r\n\t\tlight.shadowCascadeFarZ  = this.shadowCascadeFarZ.slice( 0 );\r\n\t\r\n\t\treturn light;\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/lights/HemisphereLight.js\r\n\t\r\n\t/**\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t */\r\n\t\r\n\tTHREE.HemisphereLight = function ( skyColor, groundColor, intensity ) {\r\n\t\r\n\t\tTHREE.Light.call( this, skyColor );\r\n\t\r\n\t\tthis.type = 'HemisphereLight';\r\n\t\r\n\t\tthis.position.set( 0, 100, 0 );\r\n\t\r\n\t\tthis.groundColor = new THREE.Color( groundColor );\r\n\t\tthis.intensity = ( intensity !== undefined ) ? intensity : 1;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.HemisphereLight.prototype = Object.create( THREE.Light.prototype );\r\n\tTHREE.HemisphereLight.prototype.constructor = THREE.HemisphereLight;\r\n\t\r\n\tTHREE.HemisphereLight.prototype.clone = function () {\r\n\t\r\n\t\tvar light = new THREE.HemisphereLight();\r\n\t\r\n\t\tTHREE.Light.prototype.clone.call( this, light );\r\n\t\r\n\t\tlight.groundColor.copy( this.groundColor );\r\n\t\tlight.intensity = this.intensity;\r\n\t\r\n\t\treturn light;\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/lights/PointLight.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tTHREE.PointLight = function ( color, intensity, distance, decay ) {\r\n\t\r\n\t\tTHREE.Light.call( this, color );\r\n\t\r\n\t\tthis.type = 'PointLight';\r\n\t\r\n\t\tthis.intensity = ( intensity !== undefined ) ? intensity : 1;\r\n\t\tthis.distance = ( distance !== undefined ) ? distance : 0;\r\n\t\tthis.decay = ( decay !== undefined ) ? decay : 1;\t// for physically correct lights, should be 2.\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.PointLight.prototype = Object.create( THREE.Light.prototype );\r\n\tTHREE.PointLight.prototype.constructor = THREE.PointLight;\r\n\t\r\n\tTHREE.PointLight.prototype.clone = function () {\r\n\t\r\n\t\tvar light = new THREE.PointLight();\r\n\t\r\n\t\tTHREE.Light.prototype.clone.call( this, light );\r\n\t\r\n\t\tlight.intensity = this.intensity;\r\n\t\tlight.distance = this.distance;\r\n\t\tlight.decay = this.decay;\r\n\t\r\n\t\treturn light;\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/lights/SpotLight.js\r\n\t\r\n\t/**\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t */\r\n\t\r\n\tTHREE.SpotLight = function ( color, intensity, distance, angle, exponent, decay ) {\r\n\t\r\n\t\tTHREE.Light.call( this, color );\r\n\t\r\n\t\tthis.type = 'SpotLight';\r\n\t\r\n\t\tthis.position.set( 0, 1, 0 );\r\n\t\tthis.target = new THREE.Object3D();\r\n\t\r\n\t\tthis.intensity = ( intensity !== undefined ) ? intensity : 1;\r\n\t\tthis.distance = ( distance !== undefined ) ? distance : 0;\r\n\t\tthis.angle = ( angle !== undefined ) ? angle : Math.PI / 3;\r\n\t\tthis.exponent = ( exponent !== undefined ) ? exponent : 10;\r\n\t\tthis.decay = ( decay !== undefined ) ? decay : 1;\t// for physically correct lights, should be 2.\r\n\t\r\n\t\tthis.castShadow = false;\r\n\t\tthis.onlyShadow = false;\r\n\t\r\n\t\t//\r\n\t\r\n\t\tthis.shadowCameraNear = 50;\r\n\t\tthis.shadowCameraFar = 5000;\r\n\t\tthis.shadowCameraFov = 50;\r\n\t\r\n\t\tthis.shadowCameraVisible = false;\r\n\t\r\n\t\tthis.shadowBias = 0;\r\n\t\tthis.shadowDarkness = 0.5;\r\n\t\r\n\t\tthis.shadowMapWidth = 512;\r\n\t\tthis.shadowMapHeight = 512;\r\n\t\r\n\t\t//\r\n\t\r\n\t\tthis.shadowMap = null;\r\n\t\tthis.shadowMapSize = null;\r\n\t\tthis.shadowCamera = null;\r\n\t\tthis.shadowMatrix = null;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.SpotLight.prototype = Object.create( THREE.Light.prototype );\r\n\tTHREE.SpotLight.prototype.constructor = THREE.SpotLight;\r\n\t\r\n\tTHREE.SpotLight.prototype.clone = function () {\r\n\t\r\n\t\tvar light = new THREE.SpotLight();\r\n\t\r\n\t\tTHREE.Light.prototype.clone.call( this, light );\r\n\t\r\n\t\tlight.target = this.target.clone();\r\n\t\r\n\t\tlight.intensity = this.intensity;\r\n\t\tlight.distance = this.distance;\r\n\t\tlight.angle = this.angle;\r\n\t\tlight.exponent = this.exponent;\r\n\t\tlight.decay = this.decay;\r\n\t\r\n\t\tlight.castShadow = this.castShadow;\r\n\t\tlight.onlyShadow = this.onlyShadow;\r\n\t\r\n\t\t//\r\n\t\r\n\t\tlight.shadowCameraNear = this.shadowCameraNear;\r\n\t\tlight.shadowCameraFar = this.shadowCameraFar;\r\n\t\tlight.shadowCameraFov = this.shadowCameraFov;\r\n\t\r\n\t\tlight.shadowCameraVisible = this.shadowCameraVisible;\r\n\t\r\n\t\tlight.shadowBias = this.shadowBias;\r\n\t\tlight.shadowDarkness = this.shadowDarkness;\r\n\t\r\n\t\tlight.shadowMapWidth = this.shadowMapWidth;\r\n\t\tlight.shadowMapHeight = this.shadowMapHeight;\r\n\t\r\n\t\treturn light;\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/loaders/Cache.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tTHREE.Cache = {\r\n\t\r\n\t\tfiles: {},\r\n\t\r\n\t\tadd: function ( key, file ) {\r\n\t\r\n\t\t\t// console.log( 'THREE.Cache', 'Adding key:', key );\r\n\t\r\n\t\t\tthis.files[ key ] = file;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tget: function ( key ) {\r\n\t\r\n\t\t\t// console.log( 'THREE.Cache', 'Checking key:', key );\r\n\t\r\n\t\t\treturn this.files[ key ];\r\n\t\r\n\t\t},\r\n\t\r\n\t\tremove: function ( key ) {\r\n\t\r\n\t\t\tdelete this.files[ key ];\r\n\t\r\n\t\t},\r\n\t\r\n\t\tclear: function () {\r\n\t\r\n\t\t\tthis.files = {}\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/loaders/Loader.js\r\n\t\r\n\t/**\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t */\r\n\t\r\n\tTHREE.Loader = function ( showStatus ) {\r\n\t\r\n\t\tthis.showStatus = showStatus;\r\n\t\tthis.statusDomElement = showStatus ? THREE.Loader.prototype.addStatusElement() : null;\r\n\t\r\n\t\tthis.imageLoader = new THREE.ImageLoader();\r\n\t\r\n\t\tthis.onLoadStart = function () {};\r\n\t\tthis.onLoadProgress = function () {};\r\n\t\tthis.onLoadComplete = function () {};\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Loader.prototype = {\r\n\t\r\n\t\tconstructor: THREE.Loader,\r\n\t\r\n\t\tcrossOrigin: undefined,\r\n\t\r\n\t\taddStatusElement: function () {\r\n\t\r\n\t\t\tvar e = document.createElement( 'div' );\r\n\t\r\n\t\t\te.style.position = 'absolute';\r\n\t\t\te.style.right = '0px';\r\n\t\t\te.style.top = '0px';\r\n\t\t\te.style.fontSize = '0.8em';\r\n\t\t\te.style.textAlign = 'left';\r\n\t\t\te.style.background = 'rgba(0,0,0,0.25)';\r\n\t\t\te.style.color = '#fff';\r\n\t\t\te.style.width = '120px';\r\n\t\t\te.style.padding = '0.5em 0.5em 0.5em 0.5em';\r\n\t\t\te.style.zIndex = 1000;\r\n\t\r\n\t\t\te.innerHTML = 'Loading ...';\r\n\t\r\n\t\t\treturn e;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tupdateProgress: function ( progress ) {\r\n\t\r\n\t\t\tvar message = 'Loaded ';\r\n\t\r\n\t\t\tif ( progress.total ) {\r\n\t\r\n\t\t\t\tmessage += ( 100 * progress.loaded / progress.total ).toFixed( 0 ) + '%';\r\n\t\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\tmessage += ( progress.loaded / 1024 ).toFixed( 2 ) + ' KB';\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tthis.statusDomElement.innerHTML = message;\r\n\t\r\n\t\t},\r\n\t\r\n\t\textractUrlBase: function ( url ) {\r\n\t\r\n\t\t\tvar parts = url.split( '/' );\r\n\t\r\n\t\t\tif ( parts.length === 1 ) return './';\r\n\t\r\n\t\t\tparts.pop();\r\n\t\r\n\t\t\treturn parts.join( '/' ) + '/';\r\n\t\r\n\t\t},\r\n\t\r\n\t\tinitMaterials: function ( materials, texturePath ) {\r\n\t\r\n\t\t\tvar array = [];\r\n\t\r\n\t\t\tfor ( var i = 0; i < materials.length; ++ i ) {\r\n\t\r\n\t\t\t\tarray[ i ] = this.createMaterial( materials[ i ], texturePath );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn array;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tneedsTangents: function ( materials ) {\r\n\t\r\n\t\t\tfor ( var i = 0, il = materials.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\tvar m = materials[ i ];\r\n\t\r\n\t\t\t\tif ( m instanceof THREE.ShaderMaterial ) return true;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn false;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcreateMaterial: function ( m, texturePath ) {\r\n\t\r\n\t\t\tvar scope = this;\r\n\t\r\n\t\t\tfunction nearest_pow2( n ) {\r\n\t\r\n\t\t\t\tvar l = Math.log( n ) / Math.LN2;\r\n\t\t\t\treturn Math.pow( 2, Math.round(  l ) );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tfunction create_texture( where, name, sourceFile, repeat, offset, wrap, anisotropy ) {\r\n\t\r\n\t\t\t\tvar fullPath = texturePath + sourceFile;\r\n\t\r\n\t\t\t\tvar texture;\r\n\t\r\n\t\t\t\tvar loader = THREE.Loader.Handlers.get( fullPath );\r\n\t\r\n\t\t\t\tif ( loader !== null ) {\r\n\t\r\n\t\t\t\t\ttexture = loader.load( fullPath );\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\ttexture = new THREE.Texture();\r\n\t\r\n\t\t\t\t\tloader = scope.imageLoader;\r\n\t\t\t\t\tloader.crossOrigin = scope.crossOrigin;\r\n\t\t\t\t\tloader.load( fullPath, function ( image ) {\r\n\t\r\n\t\t\t\t\t\tif ( THREE.Math.isPowerOfTwo( image.width ) === false ||\r\n\t\t\t\t\t\t\t THREE.Math.isPowerOfTwo( image.height ) === false ) {\r\n\t\r\n\t\t\t\t\t\t\tvar width = nearest_pow2( image.width );\r\n\t\t\t\t\t\t\tvar height = nearest_pow2( image.height );\r\n\t\r\n\t\t\t\t\t\t\tvar canvas = document.createElement( 'canvas' );\r\n\t\t\t\t\t\t\tcanvas.width = width;\r\n\t\t\t\t\t\t\tcanvas.height = height;\r\n\t\r\n\t\t\t\t\t\t\tvar context = canvas.getContext( '2d' );\r\n\t\t\t\t\t\t\tcontext.drawImage( image, 0, 0, width, height );\r\n\t\r\n\t\t\t\t\t\t\ttexture.image = canvas;\r\n\t\r\n\t\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\t\ttexture.image = image;\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\ttexture.needsUpdate = true;\r\n\t\r\n\t\t\t\t\t} );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\ttexture.sourceFile = sourceFile;\r\n\t\r\n\t\t\t\tif ( repeat ) {\r\n\t\r\n\t\t\t\t\ttexture.repeat.set( repeat[ 0 ], repeat[ 1 ] );\r\n\t\r\n\t\t\t\t\tif ( repeat[ 0 ] !== 1 ) texture.wrapS = THREE.RepeatWrapping;\r\n\t\t\t\t\tif ( repeat[ 1 ] !== 1 ) texture.wrapT = THREE.RepeatWrapping;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( offset ) {\r\n\t\r\n\t\t\t\t\ttexture.offset.set( offset[ 0 ], offset[ 1 ] );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( wrap ) {\r\n\t\r\n\t\t\t\t\tvar wrapMap = {\r\n\t\t\t\t\t\t'repeat': THREE.RepeatWrapping,\r\n\t\t\t\t\t\t'mirror': THREE.MirroredRepeatWrapping\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tif ( wrapMap[ wrap[ 0 ] ] !== undefined ) texture.wrapS = wrapMap[ wrap[ 0 ] ];\r\n\t\t\t\t\tif ( wrapMap[ wrap[ 1 ] ] !== undefined ) texture.wrapT = wrapMap[ wrap[ 1 ] ];\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( anisotropy ) {\r\n\t\r\n\t\t\t\t\ttexture.anisotropy = anisotropy;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\twhere[ name ] = texture;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tfunction rgb2hex( rgb ) {\r\n\t\r\n\t\t\t\treturn ( rgb[ 0 ] * 255 << 16 ) + ( rgb[ 1 ] * 255 << 8 ) + rgb[ 2 ] * 255;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// defaults\r\n\t\r\n\t\t\tvar mtype = 'MeshLambertMaterial';\r\n\t\t\tvar mpars = { color: 0xeeeeee, opacity: 1.0, map: null, lightMap: null, normalMap: null, bumpMap: null, wireframe: false };\r\n\t\r\n\t\t\t// parameters from model file\r\n\t\r\n\t\t\tif ( m.shading ) {\r\n\t\r\n\t\t\t\tvar shading = m.shading.toLowerCase();\r\n\t\r\n\t\t\t\tif ( shading === 'phong' ) mtype = 'MeshPhongMaterial';\r\n\t\t\t\telse if ( shading === 'basic' ) mtype = 'MeshBasicMaterial';\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( m.blending !== undefined && THREE[ m.blending ] !== undefined ) {\r\n\t\r\n\t\t\t\tmpars.blending = THREE[ m.blending ];\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( m.transparent !== undefined ) {\r\n\t\r\n\t\t\t\tmpars.transparent = m.transparent;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( m.opacity !== undefined && m.opacity < 1.0 ) {\r\n\t\r\n\t\t\t\tmpars.transparent = true;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( m.depthTest !== undefined ) {\r\n\t\r\n\t\t\t\tmpars.depthTest = m.depthTest;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( m.depthWrite !== undefined ) {\r\n\t\r\n\t\t\t\tmpars.depthWrite = m.depthWrite;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( m.visible !== undefined ) {\r\n\t\r\n\t\t\t\tmpars.visible = m.visible;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( m.flipSided !== undefined ) {\r\n\t\r\n\t\t\t\tmpars.side = THREE.BackSide;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( m.doubleSided !== undefined ) {\r\n\t\r\n\t\t\t\tmpars.side = THREE.DoubleSide;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( m.wireframe !== undefined ) {\r\n\t\r\n\t\t\t\tmpars.wireframe = m.wireframe;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( m.vertexColors !== undefined ) {\r\n\t\r\n\t\t\t\tif ( m.vertexColors === 'face' ) {\r\n\t\r\n\t\t\t\t\tmpars.vertexColors = THREE.FaceColors;\r\n\t\r\n\t\t\t\t} else if ( m.vertexColors ) {\r\n\t\r\n\t\t\t\t\tmpars.vertexColors = THREE.VertexColors;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// colors\r\n\t\r\n\t\t\tif ( m.colorDiffuse ) {\r\n\t\r\n\t\t\t\tmpars.color = rgb2hex( m.colorDiffuse );\r\n\t\r\n\t\t\t} else if ( m.DbgColor ) {\r\n\t\r\n\t\t\t\tmpars.color = m.DbgColor;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( m.colorSpecular ) {\r\n\t\r\n\t\t\t\tmpars.specular = rgb2hex( m.colorSpecular );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( m.colorEmissive ) {\r\n\t\r\n\t\t\t\tmpars.emissive = rgb2hex( m.colorEmissive );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// modifiers\r\n\t\r\n\t\t\tif ( m.transparency !== undefined ) {\r\n\t\r\n\t\t\t\tconsole.warn( 'THREE.Loader: transparency has been renamed to opacity' );\r\n\t\t\t\tm.opacity = m.transparency;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( m.opacity !== undefined ) {\r\n\t\r\n\t\t\t\tmpars.opacity = m.opacity;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( m.specularCoef ) {\r\n\t\r\n\t\t\t\tmpars.shininess = m.specularCoef;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// textures\r\n\t\r\n\t\t\tif ( m.mapDiffuse && texturePath ) {\r\n\t\r\n\t\t\t\tcreate_texture( mpars, 'map', m.mapDiffuse, m.mapDiffuseRepeat, m.mapDiffuseOffset, m.mapDiffuseWrap, m.mapDiffuseAnisotropy );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( m.mapLight && texturePath ) {\r\n\t\r\n\t\t\t\tcreate_texture( mpars, 'lightMap', m.mapLight, m.mapLightRepeat, m.mapLightOffset, m.mapLightWrap, m.mapLightAnisotropy );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( m.mapBump && texturePath ) {\r\n\t\r\n\t\t\t\tcreate_texture( mpars, 'bumpMap', m.mapBump, m.mapBumpRepeat, m.mapBumpOffset, m.mapBumpWrap, m.mapBumpAnisotropy );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( m.mapNormal && texturePath ) {\r\n\t\r\n\t\t\t\tcreate_texture( mpars, 'normalMap', m.mapNormal, m.mapNormalRepeat, m.mapNormalOffset, m.mapNormalWrap, m.mapNormalAnisotropy );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( m.mapSpecular && texturePath ) {\r\n\t\r\n\t\t\t\tcreate_texture( mpars, 'specularMap', m.mapSpecular, m.mapSpecularRepeat, m.mapSpecularOffset, m.mapSpecularWrap, m.mapSpecularAnisotropy );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( m.mapAlpha && texturePath ) {\r\n\t\r\n\t\t\t\tcreate_texture( mpars, 'alphaMap', m.mapAlpha, m.mapAlphaRepeat, m.mapAlphaOffset, m.mapAlphaWrap, m.mapAlphaAnisotropy );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t//\r\n\t\r\n\t\t\tif ( m.mapBumpScale ) {\r\n\t\r\n\t\t\t\tmpars.bumpScale = m.mapBumpScale;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( m.mapNormalFactor ) {\r\n\t\r\n\t\t\t\tmpars.normalScale = new THREE.Vector2( m.mapNormalFactor, m.mapNormalFactor );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar material = new THREE[ mtype ]( mpars );\r\n\t\r\n\t\t\tif ( m.DbgName !== undefined ) material.name = m.DbgName;\r\n\t\r\n\t\t\treturn material;\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Loader.Handlers = {\r\n\t\r\n\t\thandlers: [],\r\n\t\r\n\t\tadd: function ( regex, loader ) {\r\n\t\r\n\t\t\tthis.handlers.push( regex, loader );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tget: function ( file ) {\r\n\t\r\n\t\t\tfor ( var i = 0, l = this.handlers.length; i < l; i += 2 ) {\r\n\t\r\n\t\t\t\tvar regex = this.handlers[ i ];\r\n\t\t\t\tvar loader  = this.handlers[ i + 1 ];\r\n\t\r\n\t\t\t\tif ( regex.test( file ) ) {\r\n\t\r\n\t\t\t\t\treturn loader;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn null;\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/loaders/XHRLoader.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tTHREE.XHRLoader = function ( manager ) {\r\n\t\r\n\t\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.XHRLoader.prototype = {\r\n\t\r\n\t\tconstructor: THREE.XHRLoader,\r\n\t\r\n\t\tload: function ( url, onLoad, onProgress, onError ) {\r\n\t\r\n\t\t\tvar scope = this;\r\n\t\r\n\t\t\tvar cached = THREE.Cache.get( url );\r\n\t\r\n\t\t\tif ( cached !== undefined ) {\r\n\t\r\n\t\t\t\tif ( onLoad ) onLoad( cached );\r\n\t\t\t\treturn;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar request = new XMLHttpRequest();\r\n\t\t\trequest.open( 'GET', url, true );\r\n\t\r\n\t\t\trequest.addEventListener( 'load', function ( event ) {\r\n\t\r\n\t\t\t\tTHREE.Cache.add( url, this.response );\r\n\t\r\n\t\t\t\tif ( onLoad ) onLoad( this.response );\r\n\t\r\n\t\t\t\tscope.manager.itemEnd( url );\r\n\t\r\n\t\t\t}, false );\r\n\t\r\n\t\t\tif ( onProgress !== undefined ) {\r\n\t\r\n\t\t\t\trequest.addEventListener( 'progress', function ( event ) {\r\n\t\r\n\t\t\t\t\tonProgress( event );\r\n\t\r\n\t\t\t\t}, false );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( onError !== undefined ) {\r\n\t\r\n\t\t\t\trequest.addEventListener( 'error', function ( event ) {\r\n\t\r\n\t\t\t\t\tonError( event );\r\n\t\r\n\t\t\t\t}, false );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( this.crossOrigin !== undefined ) request.crossOrigin = this.crossOrigin;\r\n\t\t\tif ( this.responseType !== undefined ) request.responseType = this.responseType;\r\n\t\r\n\t\t\trequest.send( null );\r\n\t\r\n\t\t\tscope.manager.itemStart( url );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetResponseType: function ( value ) {\r\n\t\r\n\t\t\tthis.responseType = value;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetCrossOrigin: function ( value ) {\r\n\t\r\n\t\t\tthis.crossOrigin = value;\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/loaders/ImageLoader.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tTHREE.ImageLoader = function ( manager ) {\r\n\t\r\n\t\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.ImageLoader.prototype = {\r\n\t\r\n\t\tconstructor: THREE.ImageLoader,\r\n\t\r\n\t\tload: function ( url, onLoad, onProgress, onError ) {\r\n\t\r\n\t\t\tvar scope = this;\r\n\t\r\n\t\t\tvar cached = THREE.Cache.get( url );\r\n\t\r\n\t\t\tif ( cached !== undefined ) {\r\n\t\r\n\t\t\t\tonLoad( cached );\r\n\t\t\t\treturn;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar image = document.createElement( 'img' );\r\n\t\r\n\t\t\timage.addEventListener( 'load', function ( event ) {\r\n\t\r\n\t\t\t\tTHREE.Cache.add( url, this );\r\n\t\r\n\t\t\t\tif ( onLoad ) onLoad( this );\r\n\t\t\t\t\r\n\t\t\t\tscope.manager.itemEnd( url );\r\n\t\r\n\t\t\t}, false );\r\n\t\r\n\t\t\tif ( onProgress !== undefined ) {\r\n\t\r\n\t\t\t\timage.addEventListener( 'progress', function ( event ) {\r\n\t\r\n\t\t\t\t\tonProgress( event );\r\n\t\r\n\t\t\t\t}, false );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( onError !== undefined ) {\r\n\t\r\n\t\t\t\timage.addEventListener( 'error', function ( event ) {\r\n\t\r\n\t\t\t\t\tonError( event );\r\n\t\r\n\t\t\t\t}, false );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( this.crossOrigin !== undefined ) image.crossOrigin = this.crossOrigin;\r\n\t\r\n\t\t\timage.src = url;\r\n\t\r\n\t\t\tscope.manager.itemStart( url );\r\n\t\r\n\t\t\treturn image;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetCrossOrigin: function ( value ) {\r\n\t\r\n\t\t\tthis.crossOrigin = value;\r\n\t\r\n\t\t}\r\n\t\r\n\t}\r\n\t\r\n\t// File:src/loaders/JSONLoader.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t */\r\n\t\r\n\tTHREE.JSONLoader = function ( showStatus ) {\r\n\t\r\n\t\tTHREE.Loader.call( this, showStatus );\r\n\t\r\n\t\tthis.withCredentials = false;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.JSONLoader.prototype = Object.create( THREE.Loader.prototype );\r\n\tTHREE.JSONLoader.prototype.constructor = THREE.JSONLoader;\r\n\t\r\n\tTHREE.JSONLoader.prototype.load = function ( url, callback, texturePath ) {\r\n\t\r\n\t\t// todo: unify load API to for easier SceneLoader use\r\n\t\r\n\t\ttexturePath = texturePath && ( typeof texturePath === 'string' ) ? texturePath : this.extractUrlBase( url );\r\n\t\r\n\t\tthis.onLoadStart();\r\n\t\tthis.loadAjaxJSON( this, url, callback, texturePath );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.JSONLoader.prototype.loadAjaxJSON = function ( context, url, callback, texturePath, callbackProgress ) {\r\n\t\r\n\t\tvar xhr = new XMLHttpRequest();\r\n\t\r\n\t\tvar length = 0;\r\n\t\r\n\t\txhr.onreadystatechange = function () {\r\n\t\r\n\t\t\tif ( xhr.readyState === xhr.DONE ) {\r\n\t\r\n\t\t\t\tif ( xhr.status === 200 || xhr.status === 0 ) {\r\n\t\r\n\t\t\t\t\tif ( xhr.responseText ) {\r\n\t\r\n\t\t\t\t\t\tvar json = JSON.parse( xhr.responseText );\r\n\t\t\t\t\t\tvar metadata = json.metadata;\r\n\t\r\n\t\t\t\t\t\tif ( metadata !== undefined ) {\r\n\t\r\n\t\t\t\t\t\t\tif ( metadata.type === 'object' ) {\r\n\t\r\n\t\t\t\t\t\t\t\tTHREE.error( 'THREE.JSONLoader: ' + url + ' should be loaded with THREE.ObjectLoader instead.' );\r\n\t\t\t\t\t\t\t\treturn;\r\n\t\r\n\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t\tif ( metadata.type === 'scene' ) {\r\n\t\r\n\t\t\t\t\t\t\t\tTHREE.error( 'THREE.JSONLoader: ' + url + ' seems to be a Scene. Use THREE.SceneLoader instead.' );\r\n\t\t\t\t\t\t\t\treturn;\r\n\t\r\n\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\tvar result = context.parse( json, texturePath );\r\n\t\t\t\t\t\tcallback( result.geometry, result.materials );\r\n\t\r\n\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\tTHREE.error( 'THREE.JSONLoader: ' + url + ' seems to be unreachable or the file is empty.' );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t// in context of more complex asset initialization\r\n\t\t\t\t\t// do not block on single failed file\r\n\t\t\t\t\t// maybe should go even one more level up\r\n\t\r\n\t\t\t\t\tcontext.onLoadComplete();\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tTHREE.error( 'THREE.JSONLoader: Couldn\\'t load ' + url + ' (' + xhr.status + ')' );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t} else if ( xhr.readyState === xhr.LOADING ) {\r\n\t\r\n\t\t\t\tif ( callbackProgress ) {\r\n\t\r\n\t\t\t\t\tif ( length === 0 ) {\r\n\t\r\n\t\t\t\t\t\tlength = xhr.getResponseHeader( 'Content-Length' );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tcallbackProgress( { total: length, loaded: xhr.responseText.length } );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t} else if ( xhr.readyState === xhr.HEADERS_RECEIVED ) {\r\n\t\r\n\t\t\t\tif ( callbackProgress !== undefined ) {\r\n\t\r\n\t\t\t\t\tlength = xhr.getResponseHeader( 'Content-Length' );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t\txhr.open( 'GET', url, true );\r\n\t\txhr.withCredentials = this.withCredentials;\r\n\t\txhr.send( null );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.JSONLoader.prototype.parse = function ( json, texturePath ) {\r\n\t\r\n\t\tvar geometry = new THREE.Geometry(),\r\n\t\tscale = ( json.scale !== undefined ) ? 1.0 / json.scale : 1.0;\r\n\t\r\n\t\tparseModel( scale );\r\n\t\r\n\t\tparseSkin();\r\n\t\tparseMorphing( scale );\r\n\t\r\n\t\tgeometry.computeFaceNormals();\r\n\t\tgeometry.computeBoundingSphere();\r\n\t\r\n\t\tfunction parseModel( scale ) {\r\n\t\r\n\t\t\tfunction isBitSet( value, position ) {\r\n\t\r\n\t\t\t\treturn value & ( 1 << position );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar i, j, fi,\r\n\t\r\n\t\t\toffset, zLength,\r\n\t\r\n\t\t\tcolorIndex, normalIndex, uvIndex, materialIndex,\r\n\t\r\n\t\t\ttype,\r\n\t\t\tisQuad,\r\n\t\t\thasMaterial,\r\n\t\t\thasFaceVertexUv,\r\n\t\t\thasFaceNormal, hasFaceVertexNormal,\r\n\t\t\thasFaceColor, hasFaceVertexColor,\r\n\t\r\n\t\t\tvertex, face, faceA, faceB, hex, normal,\r\n\t\r\n\t\t\tuvLayer, uv, u, v,\r\n\t\r\n\t\t\tfaces = json.faces,\r\n\t\t\tvertices = json.vertices,\r\n\t\t\tnormals = json.normals,\r\n\t\t\tcolors = json.colors,\r\n\t\r\n\t\t\tnUvLayers = 0;\r\n\t\r\n\t\t\tif ( json.uvs !== undefined ) {\r\n\t\r\n\t\t\t\t// disregard empty arrays\r\n\t\r\n\t\t\t\tfor ( i = 0; i < json.uvs.length; i ++ ) {\r\n\t\r\n\t\t\t\t\tif ( json.uvs[ i ].length ) nUvLayers ++;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tfor ( i = 0; i < nUvLayers; i ++ ) {\r\n\t\r\n\t\t\t\t\tgeometry.faceVertexUvs[ i ] = [];\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\toffset = 0;\r\n\t\t\tzLength = vertices.length;\r\n\t\r\n\t\t\twhile ( offset < zLength ) {\r\n\t\r\n\t\t\t\tvertex = new THREE.Vector3();\r\n\t\r\n\t\t\t\tvertex.x = vertices[ offset ++ ] * scale;\r\n\t\t\t\tvertex.y = vertices[ offset ++ ] * scale;\r\n\t\t\t\tvertex.z = vertices[ offset ++ ] * scale;\r\n\t\r\n\t\t\t\tgeometry.vertices.push( vertex );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\toffset = 0;\r\n\t\t\tzLength = faces.length;\r\n\t\r\n\t\t\twhile ( offset < zLength ) {\r\n\t\r\n\t\t\t\ttype = faces[ offset ++ ];\r\n\t\r\n\t\r\n\t\t\t\tisQuad              = isBitSet( type, 0 );\r\n\t\t\t\thasMaterial         = isBitSet( type, 1 );\r\n\t\t\t\thasFaceVertexUv     = isBitSet( type, 3 );\r\n\t\t\t\thasFaceNormal       = isBitSet( type, 4 );\r\n\t\t\t\thasFaceVertexNormal = isBitSet( type, 5 );\r\n\t\t\t\thasFaceColor\t     = isBitSet( type, 6 );\r\n\t\t\t\thasFaceVertexColor  = isBitSet( type, 7 );\r\n\t\r\n\t\t\t\t// console.log(\"type\", type, \"bits\", isQuad, hasMaterial, hasFaceVertexUv, hasFaceNormal, hasFaceVertexNormal, hasFaceColor, hasFaceVertexColor);\r\n\t\r\n\t\t\t\tif ( isQuad ) {\r\n\t\r\n\t\t\t\t\tfaceA = new THREE.Face3();\r\n\t\t\t\t\tfaceA.a = faces[ offset ];\r\n\t\t\t\t\tfaceA.b = faces[ offset + 1 ];\r\n\t\t\t\t\tfaceA.c = faces[ offset + 3 ];\r\n\t\r\n\t\t\t\t\tfaceB = new THREE.Face3();\r\n\t\t\t\t\tfaceB.a = faces[ offset + 1 ];\r\n\t\t\t\t\tfaceB.b = faces[ offset + 2 ];\r\n\t\t\t\t\tfaceB.c = faces[ offset + 3 ];\r\n\t\r\n\t\t\t\t\toffset += 4;\r\n\t\r\n\t\t\t\t\tif ( hasMaterial ) {\r\n\t\r\n\t\t\t\t\t\tmaterialIndex = faces[ offset ++ ];\r\n\t\t\t\t\t\tfaceA.materialIndex = materialIndex;\r\n\t\t\t\t\t\tfaceB.materialIndex = materialIndex;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t// to get face <=> uv index correspondence\r\n\t\r\n\t\t\t\t\tfi = geometry.faces.length;\r\n\t\r\n\t\t\t\t\tif ( hasFaceVertexUv ) {\r\n\t\r\n\t\t\t\t\t\tfor ( i = 0; i < nUvLayers; i ++ ) {\r\n\t\r\n\t\t\t\t\t\t\tuvLayer = json.uvs[ i ];\r\n\t\r\n\t\t\t\t\t\t\tgeometry.faceVertexUvs[ i ][ fi ] = [];\r\n\t\t\t\t\t\t\tgeometry.faceVertexUvs[ i ][ fi + 1 ] = []\r\n\t\r\n\t\t\t\t\t\t\tfor ( j = 0; j < 4; j ++ ) {\r\n\t\r\n\t\t\t\t\t\t\t\tuvIndex = faces[ offset ++ ];\r\n\t\r\n\t\t\t\t\t\t\t\tu = uvLayer[ uvIndex * 2 ];\r\n\t\t\t\t\t\t\t\tv = uvLayer[ uvIndex * 2 + 1 ];\r\n\t\r\n\t\t\t\t\t\t\t\tuv = new THREE.Vector2( u, v );\r\n\t\r\n\t\t\t\t\t\t\t\tif ( j !== 2 ) geometry.faceVertexUvs[ i ][ fi ].push( uv );\r\n\t\t\t\t\t\t\t\tif ( j !== 0 ) geometry.faceVertexUvs[ i ][ fi + 1 ].push( uv );\r\n\t\r\n\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tif ( hasFaceNormal ) {\r\n\t\r\n\t\t\t\t\t\tnormalIndex = faces[ offset ++ ] * 3;\r\n\t\r\n\t\t\t\t\t\tfaceA.normal.set(\r\n\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\r\n\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\r\n\t\t\t\t\t\t\tnormals[ normalIndex ]\r\n\t\t\t\t\t\t);\r\n\t\r\n\t\t\t\t\t\tfaceB.normal.copy( faceA.normal );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tif ( hasFaceVertexNormal ) {\r\n\t\r\n\t\t\t\t\t\tfor ( i = 0; i < 4; i ++ ) {\r\n\t\r\n\t\t\t\t\t\t\tnormalIndex = faces[ offset ++ ] * 3;\r\n\t\r\n\t\t\t\t\t\t\tnormal = new THREE.Vector3(\r\n\t\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\r\n\t\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\r\n\t\t\t\t\t\t\t\tnormals[ normalIndex ]\r\n\t\t\t\t\t\t\t);\r\n\t\r\n\t\r\n\t\t\t\t\t\t\tif ( i !== 2 ) faceA.vertexNormals.push( normal );\r\n\t\t\t\t\t\t\tif ( i !== 0 ) faceB.vertexNormals.push( normal );\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\r\n\t\t\t\t\tif ( hasFaceColor ) {\r\n\t\r\n\t\t\t\t\t\tcolorIndex = faces[ offset ++ ];\r\n\t\t\t\t\t\thex = colors[ colorIndex ];\r\n\t\r\n\t\t\t\t\t\tfaceA.color.setHex( hex );\r\n\t\t\t\t\t\tfaceB.color.setHex( hex );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\r\n\t\t\t\t\tif ( hasFaceVertexColor ) {\r\n\t\r\n\t\t\t\t\t\tfor ( i = 0; i < 4; i ++ ) {\r\n\t\r\n\t\t\t\t\t\t\tcolorIndex = faces[ offset ++ ];\r\n\t\t\t\t\t\t\thex = colors[ colorIndex ];\r\n\t\r\n\t\t\t\t\t\t\tif ( i !== 2 ) faceA.vertexColors.push( new THREE.Color( hex ) );\r\n\t\t\t\t\t\t\tif ( i !== 0 ) faceB.vertexColors.push( new THREE.Color( hex ) );\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tgeometry.faces.push( faceA );\r\n\t\t\t\t\tgeometry.faces.push( faceB );\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tface = new THREE.Face3();\r\n\t\t\t\t\tface.a = faces[ offset ++ ];\r\n\t\t\t\t\tface.b = faces[ offset ++ ];\r\n\t\t\t\t\tface.c = faces[ offset ++ ];\r\n\t\r\n\t\t\t\t\tif ( hasMaterial ) {\r\n\t\r\n\t\t\t\t\t\tmaterialIndex = faces[ offset ++ ];\r\n\t\t\t\t\t\tface.materialIndex = materialIndex;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t// to get face <=> uv index correspondence\r\n\t\r\n\t\t\t\t\tfi = geometry.faces.length;\r\n\t\r\n\t\t\t\t\tif ( hasFaceVertexUv ) {\r\n\t\r\n\t\t\t\t\t\tfor ( i = 0; i < nUvLayers; i ++ ) {\r\n\t\r\n\t\t\t\t\t\t\tuvLayer = json.uvs[ i ];\r\n\t\r\n\t\t\t\t\t\t\tgeometry.faceVertexUvs[ i ][ fi ] = [];\r\n\t\r\n\t\t\t\t\t\t\tfor ( j = 0; j < 3; j ++ ) {\r\n\t\r\n\t\t\t\t\t\t\t\tuvIndex = faces[ offset ++ ];\r\n\t\r\n\t\t\t\t\t\t\t\tu = uvLayer[ uvIndex * 2 ];\r\n\t\t\t\t\t\t\t\tv = uvLayer[ uvIndex * 2 + 1 ];\r\n\t\r\n\t\t\t\t\t\t\t\tuv = new THREE.Vector2( u, v );\r\n\t\r\n\t\t\t\t\t\t\t\tgeometry.faceVertexUvs[ i ][ fi ].push( uv );\r\n\t\r\n\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tif ( hasFaceNormal ) {\r\n\t\r\n\t\t\t\t\t\tnormalIndex = faces[ offset ++ ] * 3;\r\n\t\r\n\t\t\t\t\t\tface.normal.set(\r\n\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\r\n\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\r\n\t\t\t\t\t\t\tnormals[ normalIndex ]\r\n\t\t\t\t\t\t);\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tif ( hasFaceVertexNormal ) {\r\n\t\r\n\t\t\t\t\t\tfor ( i = 0; i < 3; i ++ ) {\r\n\t\r\n\t\t\t\t\t\t\tnormalIndex = faces[ offset ++ ] * 3;\r\n\t\r\n\t\t\t\t\t\t\tnormal = new THREE.Vector3(\r\n\t\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\r\n\t\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\r\n\t\t\t\t\t\t\t\tnormals[ normalIndex ]\r\n\t\t\t\t\t\t\t);\r\n\t\r\n\t\t\t\t\t\t\tface.vertexNormals.push( normal );\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\r\n\t\t\t\t\tif ( hasFaceColor ) {\r\n\t\r\n\t\t\t\t\t\tcolorIndex = faces[ offset ++ ];\r\n\t\t\t\t\t\tface.color.setHex( colors[ colorIndex ] );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\r\n\t\t\t\t\tif ( hasFaceVertexColor ) {\r\n\t\r\n\t\t\t\t\t\tfor ( i = 0; i < 3; i ++ ) {\r\n\t\r\n\t\t\t\t\t\t\tcolorIndex = faces[ offset ++ ];\r\n\t\t\t\t\t\t\tface.vertexColors.push( new THREE.Color( colors[ colorIndex ] ) );\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tgeometry.faces.push( face );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t\tfunction parseSkin() {\r\n\t\t\tvar influencesPerVertex = ( json.influencesPerVertex !== undefined ) ? json.influencesPerVertex : 2;\r\n\t\r\n\t\t\tif ( json.skinWeights ) {\r\n\t\r\n\t\t\t\tfor ( var i = 0, l = json.skinWeights.length; i < l; i += influencesPerVertex ) {\r\n\t\r\n\t\t\t\t\tvar x =                               json.skinWeights[ i     ];\r\n\t\t\t\t\tvar y = ( influencesPerVertex > 1 ) ? json.skinWeights[ i + 1 ] : 0;\r\n\t\t\t\t\tvar z = ( influencesPerVertex > 2 ) ? json.skinWeights[ i + 2 ] : 0;\r\n\t\t\t\t\tvar w = ( influencesPerVertex > 3 ) ? json.skinWeights[ i + 3 ] : 0;\r\n\t\r\n\t\t\t\t\tgeometry.skinWeights.push( new THREE.Vector4( x, y, z, w ) );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( json.skinIndices ) {\r\n\t\r\n\t\t\t\tfor ( var i = 0, l = json.skinIndices.length; i < l; i += influencesPerVertex ) {\r\n\t\r\n\t\t\t\t\tvar a =                               json.skinIndices[ i     ];\r\n\t\t\t\t\tvar b = ( influencesPerVertex > 1 ) ? json.skinIndices[ i + 1 ] : 0;\r\n\t\t\t\t\tvar c = ( influencesPerVertex > 2 ) ? json.skinIndices[ i + 2 ] : 0;\r\n\t\t\t\t\tvar d = ( influencesPerVertex > 3 ) ? json.skinIndices[ i + 3 ] : 0;\r\n\t\r\n\t\t\t\t\tgeometry.skinIndices.push( new THREE.Vector4( a, b, c, d ) );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tgeometry.bones = json.bones;\r\n\t\r\n\t\t\tif ( geometry.bones && geometry.bones.length > 0 && ( geometry.skinWeights.length !== geometry.skinIndices.length || geometry.skinIndices.length !== geometry.vertices.length ) ) {\r\n\t\r\n\t\t\t\tTHREE.warn( 'THREE.JSONLoader: When skinning, number of vertices (' + geometry.vertices.length + '), skinIndices (' +\r\n\t\t\t\t\t\tgeometry.skinIndices.length + '), and skinWeights (' + geometry.skinWeights.length + ') should match.' );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\r\n\t\t\t// could change this to json.animations[0] or remove completely\r\n\t\r\n\t\t\tgeometry.animation = json.animation;\r\n\t\t\tgeometry.animations = json.animations;\r\n\t\r\n\t\t};\r\n\t\r\n\t\tfunction parseMorphing( scale ) {\r\n\t\r\n\t\t\tif ( json.morphTargets !== undefined ) {\r\n\t\r\n\t\t\t\tvar i, l, v, vl, dstVertices, srcVertices;\r\n\t\r\n\t\t\t\tfor ( i = 0, l = json.morphTargets.length; i < l; i ++ ) {\r\n\t\r\n\t\t\t\t\tgeometry.morphTargets[ i ] = {};\r\n\t\t\t\t\tgeometry.morphTargets[ i ].name = json.morphTargets[ i ].name;\r\n\t\t\t\t\tgeometry.morphTargets[ i ].vertices = [];\r\n\t\r\n\t\t\t\t\tdstVertices = geometry.morphTargets[ i ].vertices;\r\n\t\t\t\t\tsrcVertices = json.morphTargets [ i ].vertices;\r\n\t\r\n\t\t\t\t\tfor ( v = 0, vl = srcVertices.length; v < vl; v += 3 ) {\r\n\t\r\n\t\t\t\t\t\tvar vertex = new THREE.Vector3();\r\n\t\t\t\t\t\tvertex.x = srcVertices[ v ] * scale;\r\n\t\t\t\t\t\tvertex.y = srcVertices[ v + 1 ] * scale;\r\n\t\t\t\t\t\tvertex.z = srcVertices[ v + 2 ] * scale;\r\n\t\r\n\t\t\t\t\t\tdstVertices.push( vertex );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( json.morphColors !== undefined ) {\r\n\t\r\n\t\t\t\tvar i, l, c, cl, dstColors, srcColors, color;\r\n\t\r\n\t\t\t\tfor ( i = 0, l = json.morphColors.length; i < l; i ++ ) {\r\n\t\r\n\t\t\t\t\tgeometry.morphColors[ i ] = {};\r\n\t\t\t\t\tgeometry.morphColors[ i ].name = json.morphColors[ i ].name;\r\n\t\t\t\t\tgeometry.morphColors[ i ].colors = [];\r\n\t\r\n\t\t\t\t\tdstColors = geometry.morphColors[ i ].colors;\r\n\t\t\t\t\tsrcColors = json.morphColors [ i ].colors;\r\n\t\r\n\t\t\t\t\tfor ( c = 0, cl = srcColors.length; c < cl; c += 3 ) {\r\n\t\r\n\t\t\t\t\t\tcolor = new THREE.Color( 0xffaa00 );\r\n\t\t\t\t\t\tcolor.setRGB( srcColors[ c ], srcColors[ c + 1 ], srcColors[ c + 2 ] );\r\n\t\t\t\t\t\tdstColors.push( color );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t\tif ( json.materials === undefined || json.materials.length === 0 ) {\r\n\t\r\n\t\t\treturn { geometry: geometry };\r\n\t\r\n\t\t} else {\r\n\t\r\n\t\t\tvar materials = this.initMaterials( json.materials, texturePath );\r\n\t\r\n\t\t\tif ( this.needsTangents( materials ) ) {\r\n\t\r\n\t\t\t\tgeometry.computeTangents();\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn { geometry: geometry, materials: materials };\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/loaders/LoadingManager.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tTHREE.LoadingManager = function ( onLoad, onProgress, onError ) {\r\n\t\r\n\t\tvar scope = this;\r\n\t\r\n\t\tvar loaded = 0, total = 0;\r\n\t\r\n\t\tthis.onLoad = onLoad;\r\n\t\tthis.onProgress = onProgress;\r\n\t\tthis.onError = onError;\r\n\t\r\n\t\tthis.itemStart = function ( url ) {\r\n\t\r\n\t\t\ttotal ++;\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.itemEnd = function ( url ) {\r\n\t\r\n\t\t\tloaded ++;\r\n\t\r\n\t\t\tif ( scope.onProgress !== undefined ) {\r\n\t\r\n\t\t\t\tscope.onProgress( url, loaded, total );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( loaded === total && scope.onLoad !== undefined ) {\r\n\t\r\n\t\t\t\tscope.onLoad();\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.DefaultLoadingManager = new THREE.LoadingManager();\r\n\t\r\n\t// File:src/loaders/BufferGeometryLoader.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tTHREE.BufferGeometryLoader = function ( manager ) {\r\n\t\r\n\t\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.BufferGeometryLoader.prototype = {\r\n\t\r\n\t\tconstructor: THREE.BufferGeometryLoader,\r\n\t\r\n\t\tload: function ( url, onLoad, onProgress, onError ) {\r\n\t\r\n\t\t\tvar scope = this;\r\n\t\r\n\t\t\tvar loader = new THREE.XHRLoader( scope.manager );\r\n\t\t\tloader.setCrossOrigin( this.crossOrigin );\r\n\t\t\tloader.load( url, function ( text ) {\r\n\t\r\n\t\t\t\tonLoad( scope.parse( JSON.parse( text ) ) );\r\n\t\r\n\t\t\t}, onProgress, onError );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetCrossOrigin: function ( value ) {\r\n\t\r\n\t\t\tthis.crossOrigin = value;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tparse: function ( json ) {\r\n\t\r\n\t\t\tvar geometry = new THREE.BufferGeometry();\r\n\t\r\n\t\t\tvar attributes = json.data.attributes;\r\n\t\r\n\t\t\tfor ( var key in attributes ) {\r\n\t\r\n\t\t\t\tvar attribute = attributes[ key ];\r\n\t\t\t\tvar typedArray = new self[ attribute.type ]( attribute.array );\r\n\t\r\n\t\t\t\tgeometry.addAttribute( key, new THREE.BufferAttribute( typedArray, attribute.itemSize ) );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar offsets = json.data.offsets;\r\n\t\r\n\t\t\tif ( offsets !== undefined ) {\r\n\t\r\n\t\t\t\tgeometry.offsets = JSON.parse( JSON.stringify( offsets ) );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar boundingSphere = json.data.boundingSphere;\r\n\t\r\n\t\t\tif ( boundingSphere !== undefined ) {\r\n\t\r\n\t\t\t\tvar center = new THREE.Vector3();\r\n\t\r\n\t\t\t\tif ( boundingSphere.center !== undefined ) {\r\n\t\r\n\t\t\t\t\tcenter.fromArray( boundingSphere.center );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tgeometry.boundingSphere = new THREE.Sphere( center, boundingSphere.radius );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn geometry;\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/loaders/MaterialLoader.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tTHREE.MaterialLoader = function ( manager ) {\r\n\t\r\n\t\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.MaterialLoader.prototype = {\r\n\t\r\n\t\tconstructor: THREE.MaterialLoader,\r\n\t\r\n\t\tload: function ( url, onLoad, onProgress, onError ) {\r\n\t\r\n\t\t\tvar scope = this;\r\n\t\r\n\t\t\tvar loader = new THREE.XHRLoader( scope.manager );\r\n\t\t\tloader.setCrossOrigin( this.crossOrigin );\r\n\t\t\tloader.load( url, function ( text ) {\r\n\t\r\n\t\t\t\tonLoad( scope.parse( JSON.parse( text ) ) );\r\n\t\r\n\t\t\t}, onProgress, onError );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetCrossOrigin: function ( value ) {\r\n\t\r\n\t\t\tthis.crossOrigin = value;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tparse: function ( json ) {\r\n\t\r\n\t\t\tvar material = new THREE[ json.type ];\r\n\t\r\n\t\t\tif ( json.color !== undefined ) material.color.setHex( json.color );\r\n\t\t\tif ( json.emissive !== undefined ) material.emissive.setHex( json.emissive );\r\n\t\t\tif ( json.specular !== undefined ) material.specular.setHex( json.specular );\r\n\t\t\tif ( json.shininess !== undefined ) material.shininess = json.shininess;\r\n\t\t\tif ( json.uniforms !== undefined ) material.uniforms = json.uniforms;\r\n\t\t\tif ( json.vertexShader !== undefined ) material.vertexShader = json.vertexShader;\r\n\t\t\tif ( json.fragmentShader !== undefined ) material.fragmentShader = json.fragmentShader;\r\n\t\t\tif ( json.vertexColors !== undefined ) material.vertexColors = json.vertexColors;\r\n\t\t\tif ( json.shading !== undefined ) material.shading = json.shading;\r\n\t\t\tif ( json.blending !== undefined ) material.blending = json.blending;\r\n\t\t\tif ( json.side !== undefined ) material.side = json.side;\r\n\t\t\tif ( json.opacity !== undefined ) material.opacity = json.opacity;\r\n\t\t\tif ( json.transparent !== undefined ) material.transparent = json.transparent;\r\n\t\t\tif ( json.wireframe !== undefined ) material.wireframe = json.wireframe;\r\n\t\r\n\t\t\t// for PointCloudMaterial\r\n\t\t\tif ( json.size !== undefined ) material.size = json.size;\r\n\t\t\tif ( json.sizeAttenuation !== undefined ) material.sizeAttenuation = json.sizeAttenuation;\r\n\t\r\n\t\t\tif ( json.materials !== undefined ) {\r\n\t\r\n\t\t\t\tfor ( var i = 0, l = json.materials.length; i < l; i ++ ) {\r\n\t\r\n\t\t\t\t\tmaterial.materials.push( this.parse( json.materials[ i ] ) );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn material;\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/loaders/ObjectLoader.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tTHREE.ObjectLoader = function ( manager ) {\r\n\t\r\n\t\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\r\n\t\tthis.texturePath = '';\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.ObjectLoader.prototype = {\r\n\t\r\n\t\tconstructor: THREE.ObjectLoader,\r\n\t\r\n\t\tload: function ( url, onLoad, onProgress, onError ) {\r\n\t\r\n\t\t\tif ( this.texturePath === '' ) {\r\n\t\r\n\t\t\t\tthis.texturePath = url.substring( 0, url.lastIndexOf( '/' ) + 1 );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar scope = this;\r\n\t\r\n\t\t\tvar loader = new THREE.XHRLoader( scope.manager );\r\n\t\t\tloader.setCrossOrigin( this.crossOrigin );\r\n\t\t\tloader.load( url, function ( text ) {\r\n\t\r\n\t\t\t\tscope.parse( JSON.parse( text ), onLoad );\r\n\t\r\n\t\t\t}, onProgress, onError );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetTexturePath: function ( value ) {\r\n\t\r\n\t\t\tthis.texturePath = value;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetCrossOrigin: function ( value ) {\r\n\t\r\n\t\t\tthis.crossOrigin = value;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tparse: function ( json, onLoad ) {\r\n\t\r\n\t\t\tvar geometries = this.parseGeometries( json.geometries );\r\n\t\r\n\t\t\tvar images = this.parseImages( json.images, function () {\r\n\t\r\n\t\t\t\tif ( onLoad !== undefined ) onLoad( object );\r\n\t\r\n\t\t\t} );\r\n\t\t\tvar textures  = this.parseTextures( json.textures, images );\r\n\t\t\tvar materials = this.parseMaterials( json.materials, textures );\r\n\t\t\tvar object = this.parseObject( json.object, geometries, materials );\r\n\t\r\n\t\t\tif ( json.images === undefined || json.images.length === 0 ) {\r\n\t\r\n\t\t\t\tif ( onLoad !== undefined ) onLoad( object );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn object;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tparseGeometries: function ( json ) {\r\n\t\r\n\t\t\tvar geometries = {};\r\n\t\r\n\t\t\tif ( json !== undefined ) {\r\n\t\r\n\t\t\t\tvar geometryLoader = new THREE.JSONLoader();\r\n\t\t\t\tvar bufferGeometryLoader = new THREE.BufferGeometryLoader();\r\n\t\r\n\t\t\t\tfor ( var i = 0, l = json.length; i < l; i ++ ) {\r\n\t\r\n\t\t\t\t\tvar geometry;\r\n\t\t\t\t\tvar data = json[ i ];\r\n\t\r\n\t\t\t\t\tswitch ( data.type ) {\r\n\t\r\n\t\t\t\t\t\tcase 'PlaneGeometry':\r\n\t\t\t\t\t\tcase 'PlaneBufferGeometry':\r\n\t\r\n\t\t\t\t\t\t\tgeometry = new THREE[ data.type ](\r\n\t\t\t\t\t\t\t\tdata.width,\r\n\t\t\t\t\t\t\t\tdata.height,\r\n\t\t\t\t\t\t\t\tdata.widthSegments,\r\n\t\t\t\t\t\t\t\tdata.heightSegments\r\n\t\t\t\t\t\t\t);\r\n\t\r\n\t\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\t\tcase 'BoxGeometry':\r\n\t\t\t\t\t\tcase 'CubeGeometry': // backwards compatible\r\n\t\r\n\t\t\t\t\t\t\tgeometry = new THREE.BoxGeometry(\r\n\t\t\t\t\t\t\t\tdata.width,\r\n\t\t\t\t\t\t\t\tdata.height,\r\n\t\t\t\t\t\t\t\tdata.depth,\r\n\t\t\t\t\t\t\t\tdata.widthSegments,\r\n\t\t\t\t\t\t\t\tdata.heightSegments,\r\n\t\t\t\t\t\t\t\tdata.depthSegments\r\n\t\t\t\t\t\t\t);\r\n\t\r\n\t\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\t\tcase 'CircleGeometry':\r\n\t\r\n\t\t\t\t\t\t\tgeometry = new THREE.CircleGeometry(\r\n\t\t\t\t\t\t\t\tdata.radius,\r\n\t\t\t\t\t\t\t\tdata.segments\r\n\t\t\t\t\t\t\t);\r\n\t\r\n\t\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\t\tcase 'CylinderGeometry':\r\n\t\r\n\t\t\t\t\t\t\tgeometry = new THREE.CylinderGeometry(\r\n\t\t\t\t\t\t\t\tdata.radiusTop,\r\n\t\t\t\t\t\t\t\tdata.radiusBottom,\r\n\t\t\t\t\t\t\t\tdata.height,\r\n\t\t\t\t\t\t\t\tdata.radialSegments,\r\n\t\t\t\t\t\t\t\tdata.heightSegments,\r\n\t\t\t\t\t\t\t\tdata.openEnded\r\n\t\t\t\t\t\t\t);\r\n\t\r\n\t\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\t\tcase 'SphereGeometry':\r\n\t\r\n\t\t\t\t\t\t\tgeometry = new THREE.SphereGeometry(\r\n\t\t\t\t\t\t\t\tdata.radius,\r\n\t\t\t\t\t\t\t\tdata.widthSegments,\r\n\t\t\t\t\t\t\t\tdata.heightSegments,\r\n\t\t\t\t\t\t\t\tdata.phiStart,\r\n\t\t\t\t\t\t\t\tdata.phiLength,\r\n\t\t\t\t\t\t\t\tdata.thetaStart,\r\n\t\t\t\t\t\t\t\tdata.thetaLength\r\n\t\t\t\t\t\t\t);\r\n\t\r\n\t\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\t\tcase 'IcosahedronGeometry':\r\n\t\r\n\t\t\t\t\t\t\tgeometry = new THREE.IcosahedronGeometry(\r\n\t\t\t\t\t\t\t\tdata.radius,\r\n\t\t\t\t\t\t\t\tdata.detail\r\n\t\t\t\t\t\t\t);\r\n\t\r\n\t\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\t\tcase 'TorusGeometry':\r\n\t\r\n\t\t\t\t\t\t\tgeometry = new THREE.TorusGeometry(\r\n\t\t\t\t\t\t\t\tdata.radius,\r\n\t\t\t\t\t\t\t\tdata.tube,\r\n\t\t\t\t\t\t\t\tdata.radialSegments,\r\n\t\t\t\t\t\t\t\tdata.tubularSegments,\r\n\t\t\t\t\t\t\t\tdata.arc\r\n\t\t\t\t\t\t\t);\r\n\t\r\n\t\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\t\tcase 'TorusKnotGeometry':\r\n\t\r\n\t\t\t\t\t\t\tgeometry = new THREE.TorusKnotGeometry(\r\n\t\t\t\t\t\t\t\tdata.radius,\r\n\t\t\t\t\t\t\t\tdata.tube,\r\n\t\t\t\t\t\t\t\tdata.radialSegments,\r\n\t\t\t\t\t\t\t\tdata.tubularSegments,\r\n\t\t\t\t\t\t\t\tdata.p,\r\n\t\t\t\t\t\t\t\tdata.q,\r\n\t\t\t\t\t\t\t\tdata.heightScale\r\n\t\t\t\t\t\t\t);\r\n\t\r\n\t\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\t\tcase 'BufferGeometry':\r\n\t\r\n\t\t\t\t\t\t\tgeometry = bufferGeometryLoader.parse( data );\r\n\t\r\n\t\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\t\tcase 'Geometry':\r\n\t\r\n\t\t\t\t\t\t\tgeometry = geometryLoader.parse( data.data ).geometry;\r\n\t\r\n\t\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tgeometry.uuid = data.uuid;\r\n\t\r\n\t\t\t\t\tif ( data.name !== undefined ) geometry.name = data.name;\r\n\t\r\n\t\t\t\t\tgeometries[ data.uuid ] = geometry;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn geometries;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tparseMaterials: function ( json, textures ) {\r\n\t\r\n\t\t\tvar materials = {};\r\n\t\r\n\t\t\tif ( json !== undefined ) {\r\n\t\r\n\t\t\t\tvar getTexture = function ( name ) {\r\n\t\r\n\t\t\t\t\tif ( textures[ name ] === undefined ) {\r\n\t\r\n\t\t\t\t\t\tTHREE.warn( 'THREE.ObjectLoader: Undefined texture', name );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\treturn textures[ name ];\r\n\t\r\n\t\t\t\t};\r\n\t\r\n\t\t\t\tvar loader = new THREE.MaterialLoader();\r\n\t\r\n\t\t\t\tfor ( var i = 0, l = json.length; i < l; i ++ ) {\r\n\t\r\n\t\t\t\t\tvar data = json[ i ];\r\n\t\t\t\t\tvar material = loader.parse( data );\r\n\t\r\n\t\t\t\t\tmaterial.uuid = data.uuid;\r\n\t\r\n\t\t\t\t\tif ( data.name !== undefined ) material.name = data.name;\r\n\t\r\n\t\t\t\t\tif ( data.map !== undefined ) {\r\n\t\r\n\t\t\t\t\t\tmaterial.map = getTexture( data.map );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tif ( data.bumpMap !== undefined ) {\r\n\t\r\n\t\t\t\t\t\tmaterial.bumpMap = getTexture( data.bumpMap );\r\n\t\t\t\t\t\tif ( data.bumpScale ) {\r\n\t\t\t\t\t\t\tmaterial.bumpScale = new THREE.Vector2( data.bumpScale, data.bumpScale );\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tif ( data.alphaMap !== undefined ) {\r\n\t\r\n\t\t\t\t\t\tmaterial.alphaMap = getTexture( data.alphaMap );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tif ( data.envMap !== undefined ) {\r\n\t\r\n\t\t\t\t\t\tmaterial.envMap = getTexture( data.envMap );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tif ( data.normalMap !== undefined ) {\r\n\t\r\n\t\t\t\t\t\tmaterial.normalMap = getTexture( data.normalMap );\r\n\t\t\t\t\t\tif ( data.normalScale ) {\r\n\t\t\t\t\t\t\tmaterial.normalScale = new THREE.Vector2( data.normalScale, data.normalScale );\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tif ( data.lightMap !== undefined ) {\r\n\t\r\n\t\t\t\t\t\tmaterial.lightMap = getTexture( data.lightMap );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tif ( data.specularMap !== undefined ) {\r\n\t\r\n\t\t\t\t\t\tmaterial.specularMap = getTexture( data.specularMap );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tmaterials[ data.uuid ] = material;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn materials;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tparseImages: function ( json, onLoad ) {\r\n\t\r\n\t\t\tvar scope = this;\r\n\t\t\tvar images = {};\r\n\t\r\n\t\t\tif ( json !== undefined && json.length > 0 ) {\r\n\t\r\n\t\t\t\tvar manager = new THREE.LoadingManager( onLoad );\r\n\t\r\n\t\t\t\tvar loader = new THREE.ImageLoader( manager );\r\n\t\t\t\tloader.setCrossOrigin( this.crossOrigin );\r\n\t\r\n\t\t\t\tvar loadImage = function ( url ) {\r\n\t\r\n\t\t\t\t\tscope.manager.itemStart( url );\r\n\t\r\n\t\t\t\t\treturn loader.load( url, function () {\r\n\t\r\n\t\t\t\t\t\tscope.manager.itemEnd( url );\r\n\t\r\n\t\t\t\t\t} );\r\n\t\r\n\t\t\t\t};\r\n\t\r\n\t\t\t\tfor ( var i = 0, l = json.length; i < l; i ++ ) {\r\n\t\r\n\t\t\t\t\tvar image = json[ i ];\r\n\t\t\t\t\tvar path = /^(\\/\\/)|([a-z]+:(\\/\\/)?)/i.test( image.url ) ? image.url : scope.texturePath + image.url;\r\n\t\r\n\t\t\t\t\timages[ image.uuid ] = loadImage( path );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn images;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tparseTextures: function ( json, images ) {\r\n\t\r\n\t\t\tvar textures = {};\r\n\t\r\n\t\t\tif ( json !== undefined ) {\r\n\t\r\n\t\t\t\tfor ( var i = 0, l = json.length; i < l; i ++ ) {\r\n\t\r\n\t\t\t\t\tvar data = json[ i ];\r\n\t\r\n\t\t\t\t\tif ( data.image === undefined ) {\r\n\t\r\n\t\t\t\t\t\tTHREE.warn( 'THREE.ObjectLoader: No \"image\" speficied for', data.uuid );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tif ( images[ data.image ] === undefined ) {\r\n\t\r\n\t\t\t\t\t\tTHREE.warn( 'THREE.ObjectLoader: Undefined image', data.image );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tvar texture = new THREE.Texture( images[ data.image ] );\r\n\t\t\t\t\ttexture.needsUpdate = true;\r\n\t\r\n\t\t\t\t\ttexture.uuid = data.uuid;\r\n\t\r\n\t\t\t\t\tif ( data.name !== undefined ) texture.name = data.name;\r\n\t\t\t\t\tif ( data.repeat !== undefined ) texture.repeat = new THREE.Vector2( data.repeat[ 0 ], data.repeat[ 1 ] );\r\n\t\t\t\t\tif ( data.minFilter !== undefined ) texture.minFilter = THREE[ data.minFilter ];\r\n\t\t\t\t\tif ( data.magFilter !== undefined ) texture.magFilter = THREE[ data.magFilter ];\r\n\t\t\t\t\tif ( data.anisotropy !== undefined ) texture.anisotropy = data.anisotropy;\r\n\t\t\t\t\tif ( data.wrap instanceof Array ) {\r\n\t\r\n\t\t\t\t\t\ttexture.wrapS = THREE[ data.wrap[ 0 ] ];\r\n\t\t\t\t\t\ttexture.wrapT = THREE[ data.wrap[ 1 ] ];\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\ttextures[ data.uuid ] = texture;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn textures;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tparseObject: function () {\r\n\t\r\n\t\t\tvar matrix = new THREE.Matrix4();\r\n\t\r\n\t\t\treturn function ( data, geometries, materials ) {\r\n\t\r\n\t\t\t\tvar object;\r\n\t\r\n\t\t\t\tvar getGeometry = function ( name ) {\r\n\t\r\n\t\t\t\t\tif ( geometries[ name ] === undefined ) {\r\n\t\r\n\t\t\t\t\t\tTHREE.warn( 'THREE.ObjectLoader: Undefined geometry', name );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\treturn geometries[ name ];\r\n\t\r\n\t\t\t\t};\r\n\t\r\n\t\t\t\tvar getMaterial = function ( name ) {\r\n\t\r\n\t\t\t\t\tif ( materials[ name ] === undefined ) {\r\n\t\r\n\t\t\t\t\t\tTHREE.warn( 'THREE.ObjectLoader: Undefined material', name );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\treturn materials[ name ];\r\n\t\r\n\t\t\t\t};\r\n\t\r\n\t\t\t\tswitch ( data.type ) {\r\n\t\r\n\t\t\t\t\tcase 'Scene':\r\n\t\r\n\t\t\t\t\t\tobject = new THREE.Scene();\r\n\t\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\tcase 'PerspectiveCamera':\r\n\t\r\n\t\t\t\t\t\tobject = new THREE.PerspectiveCamera( data.fov, data.aspect, data.near, data.far );\r\n\t\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\tcase 'OrthographicCamera':\r\n\t\r\n\t\t\t\t\t\tobject = new THREE.OrthographicCamera( data.left, data.right, data.top, data.bottom, data.near, data.far );\r\n\t\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\tcase 'AmbientLight':\r\n\t\r\n\t\t\t\t\t\tobject = new THREE.AmbientLight( data.color );\r\n\t\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\tcase 'DirectionalLight':\r\n\t\r\n\t\t\t\t\t\tobject = new THREE.DirectionalLight( data.color, data.intensity );\r\n\t\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\tcase 'PointLight':\r\n\t\r\n\t\t\t\t\t\tobject = new THREE.PointLight( data.color, data.intensity, data.distance, data.decay );\r\n\t\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\tcase 'SpotLight':\r\n\t\r\n\t\t\t\t\t\tobject = new THREE.SpotLight( data.color, data.intensity, data.distance, data.angle, data.exponent, data.decay );\r\n\t\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\tcase 'HemisphereLight':\r\n\t\r\n\t\t\t\t\t\tobject = new THREE.HemisphereLight( data.color, data.groundColor, data.intensity );\r\n\t\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\tcase 'Mesh':\r\n\t\r\n\t\t\t\t\t\tobject = new THREE.Mesh( getGeometry( data.geometry ), getMaterial( data.material ) );\r\n\t\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\tcase 'Line':\r\n\t\r\n\t\t\t\t\t\tobject = new THREE.Line( getGeometry( data.geometry ), getMaterial( data.material ), data.mode );\r\n\t\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\tcase 'PointCloud':\r\n\t\r\n\t\t\t\t\t\tobject = new THREE.PointCloud( getGeometry( data.geometry ), getMaterial( data.material ) );\r\n\t\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\tcase 'Sprite':\r\n\t\r\n\t\t\t\t\t\tobject = new THREE.Sprite( getMaterial( data.material ) );\r\n\t\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\tcase 'Group':\r\n\t\r\n\t\t\t\t\t\tobject = new THREE.Group();\r\n\t\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\tdefault:\r\n\t\r\n\t\t\t\t\t\tobject = new THREE.Object3D();\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tobject.uuid = data.uuid;\r\n\t\r\n\t\t\t\tif ( data.name !== undefined ) object.name = data.name;\r\n\t\t\t\tif ( data.matrix !== undefined ) {\r\n\t\r\n\t\t\t\t\tmatrix.fromArray( data.matrix );\r\n\t\t\t\t\tmatrix.decompose( object.position, object.quaternion, object.scale );\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tif ( data.position !== undefined ) object.position.fromArray( data.position );\r\n\t\t\t\t\tif ( data.rotation !== undefined ) object.rotation.fromArray( data.rotation );\r\n\t\t\t\t\tif ( data.scale !== undefined ) object.scale.fromArray( data.scale );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( data.visible !== undefined ) object.visible = data.visible;\r\n\t\t\t\tif ( data.userData !== undefined ) object.userData = data.userData;\r\n\t\r\n\t\t\t\tif ( data.children !== undefined ) {\r\n\t\r\n\t\t\t\t\tfor ( var child in data.children ) {\r\n\t\r\n\t\t\t\t\t\tobject.add( this.parseObject( data.children[ child ], geometries, materials ) );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\treturn object;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}()\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/loaders/TextureLoader.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tTHREE.TextureLoader = function ( manager ) {\r\n\t\r\n\t\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.TextureLoader.prototype = {\r\n\t\r\n\t\tconstructor: THREE.TextureLoader,\r\n\t\r\n\t\tload: function ( url, onLoad, onProgress, onError ) {\r\n\t\r\n\t\t\tvar scope = this;\r\n\t\r\n\t\t\tvar loader = new THREE.ImageLoader( scope.manager );\r\n\t\t\tloader.setCrossOrigin( this.crossOrigin );\r\n\t\t\tloader.load( url, function ( image ) {\r\n\t\r\n\t\t\t\tvar texture = new THREE.Texture( image );\r\n\t\t\t\ttexture.needsUpdate = true;\r\n\t\r\n\t\t\t\tif ( onLoad !== undefined ) {\r\n\t\r\n\t\t\t\t\tonLoad( texture );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}, onProgress, onError );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetCrossOrigin: function ( value ) {\r\n\t\r\n\t\t\tthis.crossOrigin = value;\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/loaders/BinaryTextureLoader.js\r\n\t\r\n\t/**\r\n\t * @author Nikos M. / https://github.com/foo123/\r\n\t *\r\n\t * Abstract Base class to load generic binary textures formats (rgbe, hdr, ...)\r\n\t */\r\n\t\r\n\tTHREE.DataTextureLoader = THREE.BinaryTextureLoader = function () {\r\n\t\r\n\t\t// override in sub classes\r\n\t\tthis._parser = null;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.BinaryTextureLoader.prototype = {\r\n\t\r\n\t\tconstructor: THREE.BinaryTextureLoader,\r\n\t\r\n\t\tload: function ( url, onLoad, onProgress, onError ) {\r\n\t\r\n\t\t\tvar scope = this;\r\n\t\r\n\t\t\tvar texture = new THREE.DataTexture( );\r\n\t\r\n\t\t\tvar loader = new THREE.XHRLoader();\r\n\t\t\tloader.setResponseType( 'arraybuffer' );\r\n\t\r\n\t\t\tloader.load( url, function ( buffer ) {\r\n\t\r\n\t\t\t\tvar texData = scope._parser( buffer );\r\n\t\r\n\t\t\t\tif ( !texData ) return;\r\n\t\r\n\t\t\t\tif ( undefined !== texData.image ) {\r\n\t\r\n\t\t\t\t\ttexture.image = texData.image;\r\n\t\r\n\t\t\t\t} else if ( undefined !== texData.data ) {\r\n\t\r\n\t\t\t\t\ttexture.image.width = texData.width;\r\n\t\t\t\t\ttexture.image.height = texData.height;\r\n\t\t\t\t\ttexture.image.data = texData.data;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\ttexture.wrapS = undefined !== texData.wrapS ? texData.wrapS : THREE.ClampToEdgeWrapping;\r\n\t\t\t\ttexture.wrapT = undefined !== texData.wrapT ? texData.wrapT : THREE.ClampToEdgeWrapping;\r\n\t\r\n\t\t\t\ttexture.magFilter = undefined !== texData.magFilter ? texData.magFilter : THREE.LinearFilter;\r\n\t\t\t\ttexture.minFilter = undefined !== texData.minFilter ? texData.minFilter : THREE.LinearMipMapLinearFilter;\r\n\t\r\n\t\t\t\ttexture.anisotropy = undefined !== texData.anisotropy ? texData.anisotropy : 1;\r\n\t\r\n\t\t\t\tif ( undefined !== texData.format ) {\r\n\t\r\n\t\t\t\t\ttexture.format = texData.format;\r\n\t\r\n\t\t\t\t}\r\n\t\t\t\tif ( undefined !== texData.type ) {\r\n\t\r\n\t\t\t\t\ttexture.type = texData.type;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( undefined !== texData.mipmaps ) {\r\n\t\r\n\t\t\t\t\ttexture.mipmaps = texData.mipmaps;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( 1 === texData.mipmapCount ) {\r\n\t\r\n\t\t\t\t\ttexture.minFilter = THREE.LinearFilter;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\ttexture.needsUpdate = true;\r\n\t\r\n\t\t\t\tif ( onLoad ) onLoad( texture, texData );\r\n\t\r\n\t\t\t}, onProgress, onError );\r\n\t\r\n\t\r\n\t\t\treturn texture;\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/loaders/CompressedTextureLoader.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t *\r\n\t * Abstract Base class to block based textures loader (dds, pvr, ...)\r\n\t */\r\n\t\r\n\tTHREE.CompressedTextureLoader = function () {\r\n\t\r\n\t\t// override in sub classes\r\n\t\tthis._parser = null;\r\n\t\r\n\t};\r\n\t\r\n\t\r\n\tTHREE.CompressedTextureLoader.prototype = {\r\n\t\r\n\t\tconstructor: THREE.CompressedTextureLoader,\r\n\t\r\n\t\tload: function ( url, onLoad, onError ) {\r\n\t\r\n\t\t\tvar scope = this;\r\n\t\r\n\t\t\tvar images = [];\r\n\t\r\n\t\t\tvar texture = new THREE.CompressedTexture();\r\n\t\t\ttexture.image = images;\r\n\t\r\n\t\t\tvar loader = new THREE.XHRLoader();\r\n\t\t\tloader.setResponseType( 'arraybuffer' );\r\n\t\r\n\t\t\tif ( url instanceof Array ) {\r\n\t\r\n\t\t\t\tvar loaded = 0;\r\n\t\r\n\t\t\t\tvar loadTexture = function ( i ) {\r\n\t\r\n\t\t\t\t\tloader.load( url[ i ], function ( buffer ) {\r\n\t\r\n\t\t\t\t\t\tvar texDatas = scope._parser( buffer, true );\r\n\t\r\n\t\t\t\t\t\timages[ i ] = {\r\n\t\t\t\t\t\t\twidth: texDatas.width,\r\n\t\t\t\t\t\t\theight: texDatas.height,\r\n\t\t\t\t\t\t\tformat: texDatas.format,\r\n\t\t\t\t\t\t\tmipmaps: texDatas.mipmaps\r\n\t\t\t\t\t\t};\r\n\t\r\n\t\t\t\t\t\tloaded += 1;\r\n\t\r\n\t\t\t\t\t\tif ( loaded === 6 ) {\r\n\t\r\n\t\t\t\t\t\t\tif (texDatas.mipmapCount == 1)\r\n\t \t\t\t\t\t\t\ttexture.minFilter = THREE.LinearFilter;\r\n\t\r\n\t\t\t\t\t\t\ttexture.format = texDatas.format;\r\n\t\t\t\t\t\t\ttexture.needsUpdate = true;\r\n\t\r\n\t\t\t\t\t\t\tif ( onLoad ) onLoad( texture );\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t} );\r\n\t\r\n\t\t\t\t};\r\n\t\r\n\t\t\t\tfor ( var i = 0, il = url.length; i < il; ++ i ) {\r\n\t\r\n\t\t\t\t\tloadTexture( i );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\t// compressed cubemap texture stored in a single DDS file\r\n\t\r\n\t\t\t\tloader.load( url, function ( buffer ) {\r\n\t\r\n\t\t\t\t\tvar texDatas = scope._parser( buffer, true );\r\n\t\r\n\t\t\t\t\tif ( texDatas.isCubemap ) {\r\n\t\r\n\t\t\t\t\t\tvar faces = texDatas.mipmaps.length / texDatas.mipmapCount;\r\n\t\r\n\t\t\t\t\t\tfor ( var f = 0; f < faces; f ++ ) {\r\n\t\r\n\t\t\t\t\t\t\timages[ f ] = { mipmaps : [] };\r\n\t\r\n\t\t\t\t\t\t\tfor ( var i = 0; i < texDatas.mipmapCount; i ++ ) {\r\n\t\r\n\t\t\t\t\t\t\t\timages[ f ].mipmaps.push( texDatas.mipmaps[ f * texDatas.mipmapCount + i ] );\r\n\t\t\t\t\t\t\t\timages[ f ].format = texDatas.format;\r\n\t\t\t\t\t\t\t\timages[ f ].width = texDatas.width;\r\n\t\t\t\t\t\t\t\timages[ f ].height = texDatas.height;\r\n\t\r\n\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\ttexture.image.width = texDatas.width;\r\n\t\t\t\t\t\ttexture.image.height = texDatas.height;\r\n\t\t\t\t\t\ttexture.mipmaps = texDatas.mipmaps;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tif ( texDatas.mipmapCount === 1 ) {\r\n\t\r\n\t\t\t\t\t\ttexture.minFilter = THREE.LinearFilter;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\ttexture.format = texDatas.format;\r\n\t\t\t\t\ttexture.needsUpdate = true;\r\n\t\r\n\t\t\t\t\tif ( onLoad ) onLoad( texture );\r\n\t\r\n\t\t\t\t} );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn texture;\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/materials/Material.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t */\r\n\t\r\n\tTHREE.Material = function () {\r\n\t\r\n\t\tObject.defineProperty( this, 'id', { value: THREE.MaterialIdCount ++ } );\r\n\t\r\n\t\tthis.uuid = THREE.Math.generateUUID();\r\n\t\r\n\t\tthis.name = '';\r\n\t\tthis.type = 'Material';\r\n\t\r\n\t\tthis.side = THREE.FrontSide;\r\n\t\r\n\t\tthis.opacity = 1;\r\n\t\tthis.transparent = false;\r\n\t\r\n\t\tthis.blending = THREE.NormalBlending;\r\n\t\r\n\t\tthis.blendSrc = THREE.SrcAlphaFactor;\r\n\t\tthis.blendDst = THREE.OneMinusSrcAlphaFactor;\r\n\t\tthis.blendEquation = THREE.AddEquation;\r\n\t\tthis.blendSrcAlpha = null;\r\n\t\tthis.blendDstAlpha = null;\r\n\t\tthis.blendEquationAlpha = null;\r\n\t\r\n\t\tthis.depthTest = true;\r\n\t\tthis.depthWrite = true;\r\n\t\r\n\t\tthis.colorWrite = true;\r\n\t\r\n\t\tthis.polygonOffset = false;\r\n\t\tthis.polygonOffsetFactor = 0;\r\n\t\tthis.polygonOffsetUnits = 0;\r\n\t\r\n\t\tthis.alphaTest = 0;\r\n\t\r\n\t\tthis.overdraw = 0; // Overdrawn pixels (typically between 0 and 1) for fixing antialiasing gaps in CanvasRenderer\r\n\t\r\n\t\tthis.visible = true;\r\n\t\r\n\t\tthis._needsUpdate = true;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Material.prototype = {\r\n\t\r\n\t\tconstructor: THREE.Material,\r\n\t\r\n\t\tget needsUpdate () {\r\n\t\r\n\t\t\treturn this._needsUpdate;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tset needsUpdate ( value ) {\r\n\t\r\n\t\t\tif ( value === true ) this.update();\r\n\t\r\n\t\t\tthis._needsUpdate = value;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetValues: function ( values ) {\r\n\t\r\n\t\t\tif ( values === undefined ) return;\r\n\t\r\n\t\t\tfor ( var key in values ) {\r\n\t\r\n\t\t\t\tvar newValue = values[ key ];\r\n\t\r\n\t\t\t\tif ( newValue === undefined ) {\r\n\t\r\n\t\t\t\t\tTHREE.warn( \"THREE.Material: '\" + key + \"' parameter is undefined.\" );\r\n\t\t\t\t\tcontinue;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( key in this ) {\r\n\t\r\n\t\t\t\t\tvar currentValue = this[ key ];\r\n\t\r\n\t\t\t\t\tif ( currentValue instanceof THREE.Color ) {\r\n\t\r\n\t\t\t\t\t\tcurrentValue.set( newValue );\r\n\t\r\n\t\t\t\t\t} else if ( currentValue instanceof THREE.Vector3 && newValue instanceof THREE.Vector3 ) {\r\n\t\r\n\t\t\t\t\t\tcurrentValue.copy( newValue );\r\n\t\r\n\t\t\t\t\t} else if ( key == 'overdraw' ) {\r\n\t\r\n\t\t\t\t\t\t// ensure overdraw is backwards-compatable with legacy boolean type\r\n\t\t\t\t\t\tthis[ key ] = Number( newValue );\r\n\t\r\n\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\tthis[ key ] = newValue;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t},\r\n\t\r\n\t\ttoJSON: function () {\r\n\t\r\n\t\t\tvar output = {\r\n\t\t\t\tmetadata: {\r\n\t\t\t\t\tversion: 4.2,\r\n\t\t\t\t\ttype: 'material',\r\n\t\t\t\t\tgenerator: 'MaterialExporter'\r\n\t\t\t\t},\r\n\t\t\t\tuuid: this.uuid,\r\n\t\t\t\ttype: this.type\r\n\t\t\t};\r\n\t\r\n\t\t\tif ( this.name !== \"\" ) output.name = this.name;\r\n\t\r\n\t\t\tif ( this instanceof THREE.MeshBasicMaterial ) {\r\n\t\r\n\t\t\t\toutput.color = this.color.getHex();\r\n\t\t\t\tif ( this.vertexColors !== THREE.NoColors ) output.vertexColors = this.vertexColors;\r\n\t\t\t\tif ( this.blending !== THREE.NormalBlending ) output.blending = this.blending;\r\n\t\t\t\tif ( this.side !== THREE.FrontSide ) output.side = this.side;\r\n\t\r\n\t\t\t} else if ( this instanceof THREE.MeshLambertMaterial ) {\r\n\t\r\n\t\t\t\toutput.color = this.color.getHex();\r\n\t\t\t\toutput.emissive = this.emissive.getHex();\r\n\t\t\t\tif ( this.vertexColors !== THREE.NoColors ) output.vertexColors = this.vertexColors;\r\n\t\t\t\tif ( this.shading !== THREE.SmoothShading ) output.shading = this.shading;\r\n\t\t\t\tif ( this.blending !== THREE.NormalBlending ) output.blending = this.blending;\r\n\t\t\t\tif ( this.side !== THREE.FrontSide ) output.side = this.side;\r\n\t\r\n\t\t\t} else if ( this instanceof THREE.MeshPhongMaterial ) {\r\n\t\r\n\t\t\t\toutput.color = this.color.getHex();\r\n\t\t\t\toutput.emissive = this.emissive.getHex();\r\n\t\t\t\toutput.specular = this.specular.getHex();\r\n\t\t\t\toutput.shininess = this.shininess;\r\n\t\t\t\tif ( this.vertexColors !== THREE.NoColors ) output.vertexColors = this.vertexColors;\r\n\t\t\t\tif ( this.shading !== THREE.SmoothShading ) output.shading = this.shading;\r\n\t\t\t\tif ( this.blending !== THREE.NormalBlending ) output.blending = this.blending;\r\n\t\t\t\tif ( this.side !== THREE.FrontSide ) output.side = this.side;\r\n\t\r\n\t\t\t} else if ( this instanceof THREE.MeshNormalMaterial ) {\r\n\t\r\n\t\t\t\tif ( this.blending !== THREE.NormalBlending ) output.blending = this.blending;\r\n\t\t\t\tif ( this.side !== THREE.FrontSide ) output.side = this.side;\r\n\t\r\n\t\t\t} else if ( this instanceof THREE.MeshDepthMaterial ) {\r\n\t\r\n\t\t\t\tif ( this.blending !== THREE.NormalBlending ) output.blending = this.blending;\r\n\t\t\t\tif ( this.side !== THREE.FrontSide ) output.side = this.side;\r\n\t\r\n\t\t\t} else if ( this instanceof THREE.PointCloudMaterial ) {\r\n\t\r\n\t\t\t\toutput.size  = this.size;\r\n\t\t\t\toutput.sizeAttenuation = this.sizeAttenuation;\r\n\t\t\t\toutput.color = this.color.getHex();\r\n\t\r\n\t\t\t\tif ( this.vertexColors !== THREE.NoColors ) output.vertexColors = this.vertexColors;\r\n\t\t\t\tif ( this.blending !== THREE.NormalBlending ) output.blending = this.blending;\r\n\t\r\n\t\t\t} else if ( this instanceof THREE.ShaderMaterial ) {\r\n\t\r\n\t\t\t\toutput.uniforms = this.uniforms;\r\n\t\t\t\toutput.vertexShader = this.vertexShader;\r\n\t\t\t\toutput.fragmentShader = this.fragmentShader;\r\n\t\r\n\t\t\t} else if ( this instanceof THREE.SpriteMaterial ) {\r\n\t\r\n\t\t\t\toutput.color = this.color.getHex();\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( this.opacity < 1 ) output.opacity = this.opacity;\r\n\t\t\tif ( this.transparent !== false ) output.transparent = this.transparent;\r\n\t\t\tif ( this.wireframe !== false ) output.wireframe = this.wireframe;\r\n\t\r\n\t\t\treturn output;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tclone: function ( material ) {\r\n\t\r\n\t\t\tif ( material === undefined ) material = new THREE.Material();\r\n\t\r\n\t\t\tmaterial.name = this.name;\r\n\t\r\n\t\t\tmaterial.side = this.side;\r\n\t\r\n\t\t\tmaterial.opacity = this.opacity;\r\n\t\t\tmaterial.transparent = this.transparent;\r\n\t\r\n\t\t\tmaterial.blending = this.blending;\r\n\t\r\n\t\t\tmaterial.blendSrc = this.blendSrc;\r\n\t\t\tmaterial.blendDst = this.blendDst;\r\n\t\t\tmaterial.blendEquation = this.blendEquation;\r\n\t\t\tmaterial.blendSrcAlpha = this.blendSrcAlpha;\r\n\t\t\tmaterial.blendDstAlpha = this.blendDstAlpha;\r\n\t\t\tmaterial.blendEquationAlpha = this.blendEquationAlpha;\r\n\t\r\n\t\t\tmaterial.depthTest = this.depthTest;\r\n\t\t\tmaterial.depthWrite = this.depthWrite;\r\n\t\r\n\t\t\tmaterial.polygonOffset = this.polygonOffset;\r\n\t\t\tmaterial.polygonOffsetFactor = this.polygonOffsetFactor;\r\n\t\t\tmaterial.polygonOffsetUnits = this.polygonOffsetUnits;\r\n\t\r\n\t\t\tmaterial.alphaTest = this.alphaTest;\r\n\t\r\n\t\t\tmaterial.overdraw = this.overdraw;\r\n\t\r\n\t\t\tmaterial.visible = this.visible;\r\n\t\r\n\t\t\treturn material;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tupdate: function () {\r\n\t\r\n\t\t\tthis.dispatchEvent( { type: 'update' } );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tdispose: function () {\r\n\t\r\n\t\t\tthis.dispatchEvent( { type: 'dispose' } );\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.EventDispatcher.prototype.apply( THREE.Material.prototype );\r\n\t\r\n\tTHREE.MaterialIdCount = 0;\r\n\t\r\n\t// File:src/materials/LineBasicMaterial.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t *\r\n\t * parameters = {\r\n\t *  color: <hex>,\r\n\t *  opacity: <float>,\r\n\t *\r\n\t *  blending: THREE.NormalBlending,\r\n\t *  depthTest: <bool>,\r\n\t *  depthWrite: <bool>,\r\n\t *\r\n\t *  linewidth: <float>,\r\n\t *  linecap: \"round\",\r\n\t *  linejoin: \"round\",\r\n\t *\r\n\t *  vertexColors: <bool>\r\n\t *\r\n\t *  fog: <bool>\r\n\t * }\r\n\t */\r\n\t\r\n\tTHREE.LineBasicMaterial = function ( parameters ) {\r\n\t\r\n\t\tTHREE.Material.call( this );\r\n\t\r\n\t\tthis.type = 'LineBasicMaterial';\r\n\t\r\n\t\tthis.color = new THREE.Color( 0xffffff );\r\n\t\r\n\t\tthis.linewidth = 1;\r\n\t\tthis.linecap = 'round';\r\n\t\tthis.linejoin = 'round';\r\n\t\r\n\t\tthis.vertexColors = THREE.NoColors;\r\n\t\r\n\t\tthis.fog = true;\r\n\t\r\n\t\tthis.setValues( parameters );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.LineBasicMaterial.prototype = Object.create( THREE.Material.prototype );\r\n\tTHREE.LineBasicMaterial.prototype.constructor = THREE.LineBasicMaterial;\r\n\t\r\n\tTHREE.LineBasicMaterial.prototype.clone = function () {\r\n\t\r\n\t\tvar material = new THREE.LineBasicMaterial();\r\n\t\r\n\t\tTHREE.Material.prototype.clone.call( this, material );\r\n\t\r\n\t\tmaterial.color.copy( this.color );\r\n\t\r\n\t\tmaterial.linewidth = this.linewidth;\r\n\t\tmaterial.linecap = this.linecap;\r\n\t\tmaterial.linejoin = this.linejoin;\r\n\t\r\n\t\tmaterial.vertexColors = this.vertexColors;\r\n\t\r\n\t\tmaterial.fog = this.fog;\r\n\t\r\n\t\treturn material;\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/materials/LineDashedMaterial.js\r\n\t\r\n\t/**\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t *\r\n\t * parameters = {\r\n\t *  color: <hex>,\r\n\t *  opacity: <float>,\r\n\t *\r\n\t *  blending: THREE.NormalBlending,\r\n\t *  depthTest: <bool>,\r\n\t *  depthWrite: <bool>,\r\n\t *\r\n\t *  linewidth: <float>,\r\n\t *\r\n\t *  scale: <float>,\r\n\t *  dashSize: <float>,\r\n\t *  gapSize: <float>,\r\n\t *\r\n\t *  vertexColors: <bool>\r\n\t *\r\n\t *  fog: <bool>\r\n\t * }\r\n\t */\r\n\t\r\n\tTHREE.LineDashedMaterial = function ( parameters ) {\r\n\t\r\n\t\tTHREE.Material.call( this );\r\n\t\r\n\t\tthis.type = 'LineDashedMaterial';\r\n\t\r\n\t\tthis.color = new THREE.Color( 0xffffff );\r\n\t\r\n\t\tthis.linewidth = 1;\r\n\t\r\n\t\tthis.scale = 1;\r\n\t\tthis.dashSize = 3;\r\n\t\tthis.gapSize = 1;\r\n\t\r\n\t\tthis.vertexColors = false;\r\n\t\r\n\t\tthis.fog = true;\r\n\t\r\n\t\tthis.setValues( parameters );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.LineDashedMaterial.prototype = Object.create( THREE.Material.prototype );\r\n\tTHREE.LineDashedMaterial.prototype.constructor = THREE.LineDashedMaterial;\r\n\t\r\n\tTHREE.LineDashedMaterial.prototype.clone = function () {\r\n\t\r\n\t\tvar material = new THREE.LineDashedMaterial();\r\n\t\r\n\t\tTHREE.Material.prototype.clone.call( this, material );\r\n\t\r\n\t\tmaterial.color.copy( this.color );\r\n\t\r\n\t\tmaterial.linewidth = this.linewidth;\r\n\t\r\n\t\tmaterial.scale = this.scale;\r\n\t\tmaterial.dashSize = this.dashSize;\r\n\t\tmaterial.gapSize = this.gapSize;\r\n\t\r\n\t\tmaterial.vertexColors = this.vertexColors;\r\n\t\r\n\t\tmaterial.fog = this.fog;\r\n\t\r\n\t\treturn material;\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/materials/MeshBasicMaterial.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t *\r\n\t * parameters = {\r\n\t *  color: <hex>,\r\n\t *  opacity: <float>,\r\n\t *  map: new THREE.Texture( <Image> ),\r\n\t *\r\n\t *  lightMap: new THREE.Texture( <Image> ),\r\n\t *\r\n\t *  specularMap: new THREE.Texture( <Image> ),\r\n\t *\r\n\t *  alphaMap: new THREE.Texture( <Image> ),\r\n\t *\r\n\t *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),\r\n\t *  combine: THREE.Multiply,\r\n\t *  reflectivity: <float>,\r\n\t *  refractionRatio: <float>,\r\n\t *\r\n\t *  shading: THREE.SmoothShading,\r\n\t *  blending: THREE.NormalBlending,\r\n\t *  depthTest: <bool>,\r\n\t *  depthWrite: <bool>,\r\n\t *\r\n\t *  wireframe: <boolean>,\r\n\t *  wireframeLinewidth: <float>,\r\n\t *\r\n\t *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,\r\n\t *\r\n\t *  skinning: <bool>,\r\n\t *  morphTargets: <bool>,\r\n\t *\r\n\t *  fog: <bool>\r\n\t * }\r\n\t */\r\n\t\r\n\tTHREE.MeshBasicMaterial = function ( parameters ) {\r\n\t\r\n\t\tTHREE.Material.call( this );\r\n\t\r\n\t\tthis.type = 'MeshBasicMaterial';\r\n\t\r\n\t\tthis.color = new THREE.Color( 0xffffff ); // emissive\r\n\t\r\n\t\tthis.map = null;\r\n\t\r\n\t\tthis.lightMap = null;\r\n\t\r\n\t\tthis.specularMap = null;\r\n\t\r\n\t\tthis.alphaMap = null;\r\n\t\r\n\t\tthis.envMap = null;\r\n\t\tthis.combine = THREE.MultiplyOperation;\r\n\t\tthis.reflectivity = 1;\r\n\t\tthis.refractionRatio = 0.98;\r\n\t\r\n\t\tthis.fog = true;\r\n\t\r\n\t\tthis.shading = THREE.SmoothShading;\r\n\t\r\n\t\tthis.wireframe = false;\r\n\t\tthis.wireframeLinewidth = 1;\r\n\t\tthis.wireframeLinecap = 'round';\r\n\t\tthis.wireframeLinejoin = 'round';\r\n\t\r\n\t\tthis.vertexColors = THREE.NoColors;\r\n\t\r\n\t\tthis.skinning = false;\r\n\t\tthis.morphTargets = false;\r\n\t\r\n\t\tthis.setValues( parameters );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.MeshBasicMaterial.prototype = Object.create( THREE.Material.prototype );\r\n\tTHREE.MeshBasicMaterial.prototype.constructor = THREE.MeshBasicMaterial;\r\n\t\r\n\tTHREE.MeshBasicMaterial.prototype.clone = function () {\r\n\t\r\n\t\tvar material = new THREE.MeshBasicMaterial();\r\n\t\r\n\t\tTHREE.Material.prototype.clone.call( this, material );\r\n\t\r\n\t\tmaterial.color.copy( this.color );\r\n\t\r\n\t\tmaterial.map = this.map;\r\n\t\r\n\t\tmaterial.lightMap = this.lightMap;\r\n\t\r\n\t\tmaterial.specularMap = this.specularMap;\r\n\t\r\n\t\tmaterial.alphaMap = this.alphaMap;\r\n\t\r\n\t\tmaterial.envMap = this.envMap;\r\n\t\tmaterial.combine = this.combine;\r\n\t\tmaterial.reflectivity = this.reflectivity;\r\n\t\tmaterial.refractionRatio = this.refractionRatio;\r\n\t\r\n\t\tmaterial.fog = this.fog;\r\n\t\r\n\t\tmaterial.shading = this.shading;\r\n\t\r\n\t\tmaterial.wireframe = this.wireframe;\r\n\t\tmaterial.wireframeLinewidth = this.wireframeLinewidth;\r\n\t\tmaterial.wireframeLinecap = this.wireframeLinecap;\r\n\t\tmaterial.wireframeLinejoin = this.wireframeLinejoin;\r\n\t\r\n\t\tmaterial.vertexColors = this.vertexColors;\r\n\t\r\n\t\tmaterial.skinning = this.skinning;\r\n\t\tmaterial.morphTargets = this.morphTargets;\r\n\t\r\n\t\treturn material;\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/materials/MeshLambertMaterial.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t *\r\n\t * parameters = {\r\n\t *  color: <hex>,\r\n\t *  emissive: <hex>,\r\n\t *  opacity: <float>,\r\n\t *\r\n\t *  map: new THREE.Texture( <Image> ),\r\n\t *\r\n\t *  lightMap: new THREE.Texture( <Image> ),\r\n\t *\r\n\t *  specularMap: new THREE.Texture( <Image> ),\r\n\t *\r\n\t *  alphaMap: new THREE.Texture( <Image> ),\r\n\t *\r\n\t *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),\r\n\t *  combine: THREE.Multiply,\r\n\t *  reflectivity: <float>,\r\n\t *  refractionRatio: <float>,\r\n\t *\r\n\t *  shading: THREE.SmoothShading,\r\n\t *  blending: THREE.NormalBlending,\r\n\t *  depthTest: <bool>,\r\n\t *  depthWrite: <bool>,\r\n\t *\r\n\t *  wireframe: <boolean>,\r\n\t *  wireframeLinewidth: <float>,\r\n\t *\r\n\t *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,\r\n\t *\r\n\t *  skinning: <bool>,\r\n\t *  morphTargets: <bool>,\r\n\t *  morphNormals: <bool>,\r\n\t *\r\n\t *\tfog: <bool>\r\n\t * }\r\n\t */\r\n\t\r\n\tTHREE.MeshLambertMaterial = function ( parameters ) {\r\n\t\r\n\t\tTHREE.Material.call( this );\r\n\t\r\n\t\tthis.type = 'MeshLambertMaterial';\r\n\t\r\n\t\tthis.color = new THREE.Color( 0xffffff ); // diffuse\r\n\t\tthis.emissive = new THREE.Color( 0x000000 );\r\n\t\r\n\t\tthis.wrapAround = false;\r\n\t\tthis.wrapRGB = new THREE.Vector3( 1, 1, 1 );\r\n\t\r\n\t\tthis.map = null;\r\n\t\r\n\t\tthis.lightMap = null;\r\n\t\r\n\t\tthis.specularMap = null;\r\n\t\r\n\t\tthis.alphaMap = null;\r\n\t\r\n\t\tthis.envMap = null;\r\n\t\tthis.combine = THREE.MultiplyOperation;\r\n\t\tthis.reflectivity = 1;\r\n\t\tthis.refractionRatio = 0.98;\r\n\t\r\n\t\tthis.fog = true;\r\n\t\r\n\t\tthis.shading = THREE.SmoothShading;\r\n\t\r\n\t\tthis.wireframe = false;\r\n\t\tthis.wireframeLinewidth = 1;\r\n\t\tthis.wireframeLinecap = 'round';\r\n\t\tthis.wireframeLinejoin = 'round';\r\n\t\r\n\t\tthis.vertexColors = THREE.NoColors;\r\n\t\r\n\t\tthis.skinning = false;\r\n\t\tthis.morphTargets = false;\r\n\t\tthis.morphNormals = false;\r\n\t\r\n\t\tthis.setValues( parameters );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.MeshLambertMaterial.prototype = Object.create( THREE.Material.prototype );\r\n\tTHREE.MeshLambertMaterial.prototype.constructor = THREE.MeshLambertMaterial;\r\n\t\r\n\tTHREE.MeshLambertMaterial.prototype.clone = function () {\r\n\t\r\n\t\tvar material = new THREE.MeshLambertMaterial();\r\n\t\r\n\t\tTHREE.Material.prototype.clone.call( this, material );\r\n\t\r\n\t\tmaterial.color.copy( this.color );\r\n\t\tmaterial.emissive.copy( this.emissive );\r\n\t\r\n\t\tmaterial.wrapAround = this.wrapAround;\r\n\t\tmaterial.wrapRGB.copy( this.wrapRGB );\r\n\t\r\n\t\tmaterial.map = this.map;\r\n\t\r\n\t\tmaterial.lightMap = this.lightMap;\r\n\t\r\n\t\tmaterial.specularMap = this.specularMap;\r\n\t\r\n\t\tmaterial.alphaMap = this.alphaMap;\r\n\t\r\n\t\tmaterial.envMap = this.envMap;\r\n\t\tmaterial.combine = this.combine;\r\n\t\tmaterial.reflectivity = this.reflectivity;\r\n\t\tmaterial.refractionRatio = this.refractionRatio;\r\n\t\r\n\t\tmaterial.fog = this.fog;\r\n\t\r\n\t\tmaterial.shading = this.shading;\r\n\t\r\n\t\tmaterial.wireframe = this.wireframe;\r\n\t\tmaterial.wireframeLinewidth = this.wireframeLinewidth;\r\n\t\tmaterial.wireframeLinecap = this.wireframeLinecap;\r\n\t\tmaterial.wireframeLinejoin = this.wireframeLinejoin;\r\n\t\r\n\t\tmaterial.vertexColors = this.vertexColors;\r\n\t\r\n\t\tmaterial.skinning = this.skinning;\r\n\t\tmaterial.morphTargets = this.morphTargets;\r\n\t\tmaterial.morphNormals = this.morphNormals;\r\n\t\r\n\t\treturn material;\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/materials/MeshPhongMaterial.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t *\r\n\t * parameters = {\r\n\t *  color: <hex>,\r\n\t *  emissive: <hex>,\r\n\t *  specular: <hex>,\r\n\t *  shininess: <float>,\r\n\t *  opacity: <float>,\r\n\t *\r\n\t *  map: new THREE.Texture( <Image> ),\r\n\t *\r\n\t *  lightMap: new THREE.Texture( <Image> ),\r\n\t *\r\n\t *  bumpMap: new THREE.Texture( <Image> ),\r\n\t *  bumpScale: <float>,\r\n\t *\r\n\t *  normalMap: new THREE.Texture( <Image> ),\r\n\t *  normalScale: <Vector2>,\r\n\t *\r\n\t *  specularMap: new THREE.Texture( <Image> ),\r\n\t *\r\n\t *  alphaMap: new THREE.Texture( <Image> ),\r\n\t *\r\n\t *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),\r\n\t *  combine: THREE.Multiply,\r\n\t *  reflectivity: <float>,\r\n\t *  refractionRatio: <float>,\r\n\t *\r\n\t *  shading: THREE.SmoothShading,\r\n\t *  blending: THREE.NormalBlending,\r\n\t *  depthTest: <bool>,\r\n\t *  depthWrite: <bool>,\r\n\t *\r\n\t *  wireframe: <boolean>,\r\n\t *  wireframeLinewidth: <float>,\r\n\t *\r\n\t *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,\r\n\t *\r\n\t *  skinning: <bool>,\r\n\t *  morphTargets: <bool>,\r\n\t *  morphNormals: <bool>,\r\n\t *\r\n\t *\tfog: <bool>\r\n\t * }\r\n\t */\r\n\t\r\n\tTHREE.MeshPhongMaterial = function ( parameters ) {\r\n\t\r\n\t\tTHREE.Material.call( this );\r\n\t\r\n\t\tthis.type = 'MeshPhongMaterial';\r\n\t\r\n\t\tthis.color = new THREE.Color( 0xffffff ); // diffuse\r\n\t\tthis.emissive = new THREE.Color( 0x000000 );\r\n\t\tthis.specular = new THREE.Color( 0x111111 );\r\n\t\tthis.shininess = 30;\r\n\t\r\n\t\tthis.metal = false;\r\n\t\r\n\t\tthis.wrapAround = false;\r\n\t\tthis.wrapRGB = new THREE.Vector3( 1, 1, 1 );\r\n\t\r\n\t\tthis.map = null;\r\n\t\r\n\t\tthis.lightMap = null;\r\n\t\r\n\t\tthis.bumpMap = null;\r\n\t\tthis.bumpScale = 1;\r\n\t\r\n\t\tthis.normalMap = null;\r\n\t\tthis.normalScale = new THREE.Vector2( 1, 1 );\r\n\t\r\n\t\tthis.specularMap = null;\r\n\t\r\n\t\tthis.alphaMap = null;\r\n\t\r\n\t\tthis.envMap = null;\r\n\t\tthis.combine = THREE.MultiplyOperation;\r\n\t\tthis.reflectivity = 1;\r\n\t\tthis.refractionRatio = 0.98;\r\n\t\r\n\t\tthis.fog = true;\r\n\t\r\n\t\tthis.shading = THREE.SmoothShading;\r\n\t\r\n\t\tthis.wireframe = false;\r\n\t\tthis.wireframeLinewidth = 1;\r\n\t\tthis.wireframeLinecap = 'round';\r\n\t\tthis.wireframeLinejoin = 'round';\r\n\t\r\n\t\tthis.vertexColors = THREE.NoColors;\r\n\t\r\n\t\tthis.skinning = false;\r\n\t\tthis.morphTargets = false;\r\n\t\tthis.morphNormals = false;\r\n\t\r\n\t\tthis.setValues( parameters );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.MeshPhongMaterial.prototype = Object.create( THREE.Material.prototype );\r\n\tTHREE.MeshPhongMaterial.prototype.constructor = THREE.MeshPhongMaterial;\r\n\t\r\n\tTHREE.MeshPhongMaterial.prototype.clone = function () {\r\n\t\r\n\t\tvar material = new THREE.MeshPhongMaterial();\r\n\t\r\n\t\tTHREE.Material.prototype.clone.call( this, material );\r\n\t\r\n\t\tmaterial.color.copy( this.color );\r\n\t\tmaterial.emissive.copy( this.emissive );\r\n\t\tmaterial.specular.copy( this.specular );\r\n\t\tmaterial.shininess = this.shininess;\r\n\t\r\n\t\tmaterial.metal = this.metal;\r\n\t\r\n\t\tmaterial.wrapAround = this.wrapAround;\r\n\t\tmaterial.wrapRGB.copy( this.wrapRGB );\r\n\t\r\n\t\tmaterial.map = this.map;\r\n\t\r\n\t\tmaterial.lightMap = this.lightMap;\r\n\t\r\n\t\tmaterial.bumpMap = this.bumpMap;\r\n\t\tmaterial.bumpScale = this.bumpScale;\r\n\t\r\n\t\tmaterial.normalMap = this.normalMap;\r\n\t\tmaterial.normalScale.copy( this.normalScale );\r\n\t\r\n\t\tmaterial.specularMap = this.specularMap;\r\n\t\r\n\t\tmaterial.alphaMap = this.alphaMap;\r\n\t\r\n\t\tmaterial.envMap = this.envMap;\r\n\t\tmaterial.combine = this.combine;\r\n\t\tmaterial.reflectivity = this.reflectivity;\r\n\t\tmaterial.refractionRatio = this.refractionRatio;\r\n\t\r\n\t\tmaterial.fog = this.fog;\r\n\t\r\n\t\tmaterial.shading = this.shading;\r\n\t\r\n\t\tmaterial.wireframe = this.wireframe;\r\n\t\tmaterial.wireframeLinewidth = this.wireframeLinewidth;\r\n\t\tmaterial.wireframeLinecap = this.wireframeLinecap;\r\n\t\tmaterial.wireframeLinejoin = this.wireframeLinejoin;\r\n\t\r\n\t\tmaterial.vertexColors = this.vertexColors;\r\n\t\r\n\t\tmaterial.skinning = this.skinning;\r\n\t\tmaterial.morphTargets = this.morphTargets;\r\n\t\tmaterial.morphNormals = this.morphNormals;\r\n\t\r\n\t\treturn material;\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/materials/MeshDepthMaterial.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t *\r\n\t * parameters = {\r\n\t *  opacity: <float>,\r\n\t *\r\n\t *  blending: THREE.NormalBlending,\r\n\t *  depthTest: <bool>,\r\n\t *  depthWrite: <bool>,\r\n\t *\r\n\t *  wireframe: <boolean>,\r\n\t *  wireframeLinewidth: <float>\r\n\t * }\r\n\t */\r\n\t\r\n\tTHREE.MeshDepthMaterial = function ( parameters ) {\r\n\t\r\n\t\tTHREE.Material.call( this );\r\n\t\r\n\t\tthis.type = 'MeshDepthMaterial';\r\n\t\r\n\t\tthis.morphTargets = false;\r\n\t\tthis.wireframe = false;\r\n\t\tthis.wireframeLinewidth = 1;\r\n\t\r\n\t\tthis.setValues( parameters );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.MeshDepthMaterial.prototype = Object.create( THREE.Material.prototype );\r\n\tTHREE.MeshDepthMaterial.prototype.constructor = THREE.MeshDepthMaterial;\r\n\t\r\n\tTHREE.MeshDepthMaterial.prototype.clone = function () {\r\n\t\r\n\t\tvar material = new THREE.MeshDepthMaterial();\r\n\t\r\n\t\tTHREE.Material.prototype.clone.call( this, material );\r\n\t\r\n\t\tmaterial.wireframe = this.wireframe;\r\n\t\tmaterial.wireframeLinewidth = this.wireframeLinewidth;\r\n\t\r\n\t\treturn material;\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/materials/MeshNormalMaterial.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t *\r\n\t * parameters = {\r\n\t *  opacity: <float>,\r\n\t *\r\n\t *  shading: THREE.FlatShading,\r\n\t *  blending: THREE.NormalBlending,\r\n\t *  depthTest: <bool>,\r\n\t *  depthWrite: <bool>,\r\n\t *\r\n\t *  wireframe: <boolean>,\r\n\t *  wireframeLinewidth: <float>\r\n\t * }\r\n\t */\r\n\t\r\n\tTHREE.MeshNormalMaterial = function ( parameters ) {\r\n\t\r\n\t\tTHREE.Material.call( this, parameters );\r\n\t\r\n\t\tthis.type = 'MeshNormalMaterial';\r\n\t\r\n\t\tthis.wireframe = false;\r\n\t\tthis.wireframeLinewidth = 1;\r\n\t\r\n\t\tthis.morphTargets = false;\r\n\t\r\n\t\tthis.setValues( parameters );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.MeshNormalMaterial.prototype = Object.create( THREE.Material.prototype );\r\n\tTHREE.MeshNormalMaterial.prototype.constructor = THREE.MeshNormalMaterial;\r\n\t\r\n\tTHREE.MeshNormalMaterial.prototype.clone = function () {\r\n\t\r\n\t\tvar material = new THREE.MeshNormalMaterial();\r\n\t\r\n\t\tTHREE.Material.prototype.clone.call( this, material );\r\n\t\r\n\t\tmaterial.wireframe = this.wireframe;\r\n\t\tmaterial.wireframeLinewidth = this.wireframeLinewidth;\r\n\t\r\n\t\treturn material;\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/materials/MeshFaceMaterial.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tTHREE.MeshFaceMaterial = function ( materials ) {\r\n\t\r\n\t\tthis.uuid = THREE.Math.generateUUID();\r\n\t\r\n\t\tthis.type = 'MeshFaceMaterial';\r\n\t\t\r\n\t\tthis.materials = materials instanceof Array ? materials : [];\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.MeshFaceMaterial.prototype = {\r\n\t\r\n\t\tconstructor: THREE.MeshFaceMaterial,\r\n\t\r\n\t\ttoJSON: function () {\r\n\t\r\n\t\t\tvar output = {\r\n\t\t\t\tmetadata: {\r\n\t\t\t\t\tversion: 4.2,\r\n\t\t\t\t\ttype: 'material',\r\n\t\t\t\t\tgenerator: 'MaterialExporter'\r\n\t\t\t\t},\r\n\t\t\t\tuuid: this.uuid,\r\n\t\t\t\ttype: this.type,\r\n\t\t\t\tmaterials: []\r\n\t\t\t};\r\n\t\r\n\t\t\tfor ( var i = 0, l = this.materials.length; i < l; i ++ ) {\r\n\t\r\n\t\t\t\toutput.materials.push( this.materials[ i ].toJSON() );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn output;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tclone: function () {\r\n\t\r\n\t\t\tvar material = new THREE.MeshFaceMaterial();\r\n\t\r\n\t\t\tfor ( var i = 0; i < this.materials.length; i ++ ) {\r\n\t\r\n\t\t\t\tmaterial.materials.push( this.materials[ i ].clone() );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn material;\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/materials/PointCloudMaterial.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t *\r\n\t * parameters = {\r\n\t *  color: <hex>,\r\n\t *  opacity: <float>,\r\n\t *  map: new THREE.Texture( <Image> ),\r\n\t *\r\n\t *  size: <float>,\r\n\t *  sizeAttenuation: <bool>,\r\n\t *\r\n\t *  blending: THREE.NormalBlending,\r\n\t *  depthTest: <bool>,\r\n\t *  depthWrite: <bool>,\r\n\t *\r\n\t *  vertexColors: <bool>,\r\n\t *\r\n\t *  fog: <bool>\r\n\t * }\r\n\t */\r\n\t\r\n\tTHREE.PointCloudMaterial = function ( parameters ) {\r\n\t\r\n\t\tTHREE.Material.call( this );\r\n\t\r\n\t\tthis.type = 'PointCloudMaterial';\r\n\t\r\n\t\tthis.color = new THREE.Color( 0xffffff );\r\n\t\r\n\t\tthis.map = null;\r\n\t\r\n\t\tthis.size = 1;\r\n\t\tthis.sizeAttenuation = true;\r\n\t\r\n\t\tthis.vertexColors = THREE.NoColors;\r\n\t\r\n\t\tthis.fog = true;\r\n\t\r\n\t\tthis.setValues( parameters );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.PointCloudMaterial.prototype = Object.create( THREE.Material.prototype );\r\n\tTHREE.PointCloudMaterial.prototype.constructor = THREE.PointCloudMaterial;\r\n\t\r\n\tTHREE.PointCloudMaterial.prototype.clone = function () {\r\n\t\r\n\t\tvar material = new THREE.PointCloudMaterial();\r\n\t\r\n\t\tTHREE.Material.prototype.clone.call( this, material );\r\n\t\r\n\t\tmaterial.color.copy( this.color );\r\n\t\r\n\t\tmaterial.map = this.map;\r\n\t\r\n\t\tmaterial.size = this.size;\r\n\t\tmaterial.sizeAttenuation = this.sizeAttenuation;\r\n\t\r\n\t\tmaterial.vertexColors = this.vertexColors;\r\n\t\r\n\t\tmaterial.fog = this.fog;\r\n\t\r\n\t\treturn material;\r\n\t\r\n\t};\r\n\t\r\n\t// backwards compatibility\r\n\t\r\n\tTHREE.ParticleBasicMaterial = function ( parameters ) {\r\n\t\r\n\t\tTHREE.warn( 'THREE.ParticleBasicMaterial has been renamed to THREE.PointCloudMaterial.' );\r\n\t\treturn new THREE.PointCloudMaterial( parameters );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.ParticleSystemMaterial = function ( parameters ) {\r\n\t\r\n\t\tTHREE.warn( 'THREE.ParticleSystemMaterial has been renamed to THREE.PointCloudMaterial.' );\r\n\t\treturn new THREE.PointCloudMaterial( parameters );\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/materials/ShaderMaterial.js\r\n\t\r\n\t/**\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t *\r\n\t * parameters = {\r\n\t *  defines: { \"label\" : \"value\" },\r\n\t *  uniforms: { \"parameter1\": { type: \"f\", value: 1.0 }, \"parameter2\": { type: \"i\" value2: 2 } },\r\n\t *\r\n\t *  fragmentShader: <string>,\r\n\t *  vertexShader: <string>,\r\n\t *\r\n\t *  shading: THREE.SmoothShading,\r\n\t *  blending: THREE.NormalBlending,\r\n\t *  depthTest: <bool>,\r\n\t *  depthWrite: <bool>,\r\n\t *\r\n\t *  wireframe: <boolean>,\r\n\t *  wireframeLinewidth: <float>,\r\n\t *\r\n\t *  lights: <bool>,\r\n\t *\r\n\t *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,\r\n\t *\r\n\t *  skinning: <bool>,\r\n\t *  morphTargets: <bool>,\r\n\t *  morphNormals: <bool>,\r\n\t *\r\n\t *\tfog: <bool>\r\n\t * }\r\n\t */\r\n\t\r\n\tTHREE.ShaderMaterial = function ( parameters ) {\r\n\t\r\n\t\tTHREE.Material.call( this );\r\n\t\r\n\t\tthis.type = 'ShaderMaterial';\r\n\t\r\n\t\tthis.defines = {};\r\n\t\tthis.uniforms = {};\r\n\t\tthis.attributes = null;\r\n\t\r\n\t\tthis.vertexShader = 'void main() {\\n\\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n}';\r\n\t\tthis.fragmentShader = 'void main() {\\n\\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\\n}';\r\n\t\r\n\t\tthis.shading = THREE.SmoothShading;\r\n\t\r\n\t\tthis.linewidth = 1;\r\n\t\r\n\t\tthis.wireframe = false;\r\n\t\tthis.wireframeLinewidth = 1;\r\n\t\r\n\t\tthis.fog = false; // set to use scene fog\r\n\t\r\n\t\tthis.lights = false; // set to use scene lights\r\n\t\r\n\t\tthis.vertexColors = THREE.NoColors; // set to use \"color\" attribute stream\r\n\t\r\n\t\tthis.skinning = false; // set to use skinning attribute streams\r\n\t\r\n\t\tthis.morphTargets = false; // set to use morph targets\r\n\t\tthis.morphNormals = false; // set to use morph normals\r\n\t\r\n\t\t// When rendered geometry doesn't include these attributes but the material does,\r\n\t\t// use these default values in WebGL. This avoids errors when buffer data is missing.\r\n\t\tthis.defaultAttributeValues = {\r\n\t\t\t'color': [ 1, 1, 1 ],\r\n\t\t\t'uv': [ 0, 0 ],\r\n\t\t\t'uv2': [ 0, 0 ]\r\n\t\t};\r\n\t\r\n\t\tthis.index0AttributeName = undefined;\r\n\t\r\n\t\tthis.setValues( parameters );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.ShaderMaterial.prototype = Object.create( THREE.Material.prototype );\r\n\tTHREE.ShaderMaterial.prototype.constructor = THREE.ShaderMaterial;\r\n\t\r\n\tTHREE.ShaderMaterial.prototype.clone = function () {\r\n\t\r\n\t\tvar material = new THREE.ShaderMaterial();\r\n\t\r\n\t\tTHREE.Material.prototype.clone.call( this, material );\r\n\t\r\n\t\tmaterial.fragmentShader = this.fragmentShader;\r\n\t\tmaterial.vertexShader = this.vertexShader;\r\n\t\r\n\t\tmaterial.uniforms = THREE.UniformsUtils.clone( this.uniforms );\r\n\t\r\n\t\tmaterial.attributes = this.attributes;\r\n\t\tmaterial.defines = this.defines;\r\n\t\r\n\t\tmaterial.shading = this.shading;\r\n\t\r\n\t\tmaterial.wireframe = this.wireframe;\r\n\t\tmaterial.wireframeLinewidth = this.wireframeLinewidth;\r\n\t\r\n\t\tmaterial.fog = this.fog;\r\n\t\r\n\t\tmaterial.lights = this.lights;\r\n\t\r\n\t\tmaterial.vertexColors = this.vertexColors;\r\n\t\r\n\t\tmaterial.skinning = this.skinning;\r\n\t\r\n\t\tmaterial.morphTargets = this.morphTargets;\r\n\t\tmaterial.morphNormals = this.morphNormals;\r\n\t\r\n\t\treturn material;\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/materials/RawShaderMaterial.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tTHREE.RawShaderMaterial = function ( parameters ) {\r\n\t\r\n\t\tTHREE.ShaderMaterial.call( this, parameters );\r\n\t\r\n\t\tthis.type = 'RawShaderMaterial';\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.RawShaderMaterial.prototype = Object.create( THREE.ShaderMaterial.prototype );\r\n\tTHREE.RawShaderMaterial.prototype.constructor = THREE.RawShaderMaterial;\r\n\t\r\n\tTHREE.RawShaderMaterial.prototype.clone = function () {\r\n\t\r\n\t\tvar material = new THREE.RawShaderMaterial();\r\n\t\r\n\t\tTHREE.ShaderMaterial.prototype.clone.call( this, material );\r\n\t\r\n\t\treturn material;\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/materials/SpriteMaterial.js\r\n\t\r\n\t/**\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t *\r\n\t * parameters = {\r\n\t *  color: <hex>,\r\n\t *  opacity: <float>,\r\n\t *  map: new THREE.Texture( <Image> ),\r\n\t *\r\n\t *  blending: THREE.NormalBlending,\r\n\t *  depthTest: <bool>,\r\n\t *  depthWrite: <bool>,\r\n\t *\r\n\t *\tuvOffset: new THREE.Vector2(),\r\n\t *\tuvScale: new THREE.Vector2(),\r\n\t *\r\n\t *  fog: <bool>\r\n\t * }\r\n\t */\r\n\t\r\n\tTHREE.SpriteMaterial = function ( parameters ) {\r\n\t\r\n\t\tTHREE.Material.call( this );\r\n\t\r\n\t\tthis.type = 'SpriteMaterial';\r\n\t\r\n\t\tthis.color = new THREE.Color( 0xffffff );\r\n\t\tthis.map = null;\r\n\t\r\n\t\tthis.rotation = 0;\r\n\t\r\n\t\tthis.fog = false;\r\n\t\r\n\t\t// set parameters\r\n\t\r\n\t\tthis.setValues( parameters );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.SpriteMaterial.prototype = Object.create( THREE.Material.prototype );\r\n\tTHREE.SpriteMaterial.prototype.constructor = THREE.SpriteMaterial;\r\n\t\r\n\tTHREE.SpriteMaterial.prototype.clone = function () {\r\n\t\r\n\t\tvar material = new THREE.SpriteMaterial();\r\n\t\r\n\t\tTHREE.Material.prototype.clone.call( this, material );\r\n\t\r\n\t\tmaterial.color.copy( this.color );\r\n\t\tmaterial.map = this.map;\r\n\t\r\n\t\tmaterial.rotation = this.rotation;\r\n\t\r\n\t\tmaterial.fog = this.fog;\r\n\t\r\n\t\treturn material;\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/textures/Texture.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t * @author szimek / https://github.com/szimek/\r\n\t */\r\n\t\r\n\tTHREE.Texture = function ( image, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {\r\n\t\r\n\t\tObject.defineProperty( this, 'id', { value: THREE.TextureIdCount ++ } );\r\n\t\r\n\t\tthis.uuid = THREE.Math.generateUUID();\r\n\t\r\n\t\tthis.name = '';\r\n\t\tthis.sourceFile = '';\r\n\t\r\n\t\tthis.image = image !== undefined ? image : THREE.Texture.DEFAULT_IMAGE;\r\n\t\tthis.mipmaps = [];\r\n\t\r\n\t\tthis.mapping = mapping !== undefined ? mapping : THREE.Texture.DEFAULT_MAPPING;\r\n\t\r\n\t\tthis.wrapS = wrapS !== undefined ? wrapS : THREE.ClampToEdgeWrapping;\r\n\t\tthis.wrapT = wrapT !== undefined ? wrapT : THREE.ClampToEdgeWrapping;\r\n\t\r\n\t\tthis.magFilter = magFilter !== undefined ? magFilter : THREE.LinearFilter;\r\n\t\tthis.minFilter = minFilter !== undefined ? minFilter : THREE.LinearMipMapLinearFilter;\r\n\t\r\n\t\tthis.anisotropy = anisotropy !== undefined ? anisotropy : 1;\r\n\t\r\n\t\tthis.format = format !== undefined ? format : THREE.RGBAFormat;\r\n\t\tthis.type = type !== undefined ? type : THREE.UnsignedByteType;\r\n\t\r\n\t\tthis.offset = new THREE.Vector2( 0, 0 );\r\n\t\tthis.repeat = new THREE.Vector2( 1, 1 );\r\n\t\r\n\t\tthis.generateMipmaps = true;\r\n\t\tthis.premultiplyAlpha = false;\r\n\t\tthis.flipY = true;\r\n\t\tthis.unpackAlignment = 4; // valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)\r\n\t\r\n\t\tthis._needsUpdate = false;\r\n\t\tthis.onUpdate = null;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Texture.DEFAULT_IMAGE = undefined;\r\n\tTHREE.Texture.DEFAULT_MAPPING = THREE.UVMapping;\r\n\t\r\n\tTHREE.Texture.prototype = {\r\n\t\r\n\t\tconstructor: THREE.Texture,\r\n\t\r\n\t\tget needsUpdate () {\r\n\t\r\n\t\t\treturn this._needsUpdate;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tset needsUpdate ( value ) {\r\n\t\r\n\t\t\tif ( value === true ) this.update();\r\n\t\r\n\t\t\tthis._needsUpdate = value;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tclone: function ( texture ) {\r\n\t\r\n\t\t\tif ( texture === undefined ) texture = new THREE.Texture();\r\n\t\r\n\t\t\ttexture.image = this.image;\r\n\t\t\ttexture.mipmaps = this.mipmaps.slice( 0 );\r\n\t\r\n\t\t\ttexture.mapping = this.mapping;\r\n\t\r\n\t\t\ttexture.wrapS = this.wrapS;\r\n\t\t\ttexture.wrapT = this.wrapT;\r\n\t\r\n\t\t\ttexture.magFilter = this.magFilter;\r\n\t\t\ttexture.minFilter = this.minFilter;\r\n\t\r\n\t\t\ttexture.anisotropy = this.anisotropy;\r\n\t\r\n\t\t\ttexture.format = this.format;\r\n\t\t\ttexture.type = this.type;\r\n\t\r\n\t\t\ttexture.offset.copy( this.offset );\r\n\t\t\ttexture.repeat.copy( this.repeat );\r\n\t\r\n\t\t\ttexture.generateMipmaps = this.generateMipmaps;\r\n\t\t\ttexture.premultiplyAlpha = this.premultiplyAlpha;\r\n\t\t\ttexture.flipY = this.flipY;\r\n\t\t\ttexture.unpackAlignment = this.unpackAlignment;\r\n\t\r\n\t\t\treturn texture;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tupdate: function () {\r\n\t\r\n\t\t\tthis.dispatchEvent( { type: 'update' } );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tdispose: function () {\r\n\t\r\n\t\t\tthis.dispatchEvent( { type: 'dispose' } );\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.EventDispatcher.prototype.apply( THREE.Texture.prototype );\r\n\t\r\n\tTHREE.TextureIdCount = 0;\r\n\t\r\n\t// File:src/textures/CubeTexture.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tTHREE.CubeTexture = function ( images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {\r\n\t\r\n\t\tmapping = mapping !== undefined ? mapping : THREE.CubeReflectionMapping;\r\n\t\t\r\n\t\tTHREE.Texture.call( this, images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );\r\n\t\r\n\t\tthis.images = images;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.CubeTexture.prototype = Object.create( THREE.Texture.prototype );\r\n\tTHREE.CubeTexture.prototype.constructor = THREE.CubeTexture;\r\n\t\r\n\tTHREE.CubeTexture.clone = function ( texture ) {\r\n\t\r\n\t\tif ( texture === undefined ) texture = new THREE.CubeTexture();\r\n\t\r\n\t\tTHREE.Texture.prototype.clone.call( this, texture );\r\n\t\r\n\t\ttexture.images = this.images;\r\n\t\r\n\t\treturn texture;\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/textures/CompressedTexture.js\r\n\t\r\n\t/**\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t */\r\n\t\r\n\tTHREE.CompressedTexture = function ( mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy ) {\r\n\t\r\n\t\tTHREE.Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );\r\n\t\r\n\t\tthis.image = { width: width, height: height };\r\n\t\tthis.mipmaps = mipmaps;\r\n\t\r\n\t\t// no flipping for cube textures\r\n\t\t// (also flipping doesn't work for compressed textures )\r\n\t\r\n\t\tthis.flipY = false;\r\n\t\r\n\t\t// can't generate mipmaps for compressed textures\r\n\t\t// mips must be embedded in DDS files\r\n\t\r\n\t\tthis.generateMipmaps = false;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.CompressedTexture.prototype = Object.create( THREE.Texture.prototype );\r\n\tTHREE.CompressedTexture.prototype.constructor = THREE.CompressedTexture;\r\n\t\r\n\tTHREE.CompressedTexture.prototype.clone = function () {\r\n\t\r\n\t\tvar texture = new THREE.CompressedTexture();\r\n\t\r\n\t\tTHREE.Texture.prototype.clone.call( this, texture );\r\n\t\r\n\t\treturn texture;\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/textures/DataTexture.js\r\n\t\r\n\t/**\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t */\r\n\t\r\n\tTHREE.DataTexture = function ( data, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy ) {\r\n\t\r\n\t\tTHREE.Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );\r\n\t\r\n\t\tthis.image = { data: data, width: width, height: height };\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.DataTexture.prototype = Object.create( THREE.Texture.prototype );\r\n\tTHREE.DataTexture.prototype.constructor = THREE.DataTexture;\r\n\t\r\n\tTHREE.DataTexture.prototype.clone = function () {\r\n\t\r\n\t\tvar texture = new THREE.DataTexture();\r\n\t\r\n\t\tTHREE.Texture.prototype.clone.call( this, texture );\r\n\t\r\n\t\treturn texture;\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/textures/VideoTexture.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tTHREE.VideoTexture = function ( video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {\r\n\t\r\n\t\tTHREE.Texture.call( this, video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );\r\n\t\r\n\t\tthis.generateMipmaps = false;\r\n\t\r\n\t\tvar scope = this;\r\n\t\r\n\t\tvar update = function () {\r\n\t\r\n\t\t\trequestAnimationFrame( update );\r\n\t\r\n\t\t\tif ( video.readyState === video.HAVE_ENOUGH_DATA ) {\r\n\t\r\n\t\t\t\tscope.needsUpdate = true;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t\tupdate();\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.VideoTexture.prototype = Object.create( THREE.Texture.prototype );\r\n\tTHREE.VideoTexture.prototype.constructor = THREE.VideoTexture;\r\n\t\r\n\t// File:src/objects/Group.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tTHREE.Group = function () {\r\n\t\r\n\t\tTHREE.Object3D.call( this );\r\n\t\r\n\t\tthis.type = 'Group';\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Group.prototype = Object.create( THREE.Object3D.prototype );\r\n\tTHREE.Group.prototype.constructor = THREE.Group;\r\n\t\r\n\t// File:src/objects/PointCloud.js\r\n\t\r\n\t/**\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t */\r\n\t\r\n\tTHREE.PointCloud = function ( geometry, material ) {\r\n\t\r\n\t\tTHREE.Object3D.call( this );\r\n\t\r\n\t\tthis.type = 'PointCloud';\r\n\t\r\n\t\tthis.geometry = geometry !== undefined ? geometry : new THREE.Geometry();\r\n\t\tthis.material = material !== undefined ? material : new THREE.PointCloudMaterial( { color: Math.random() * 0xffffff } );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.PointCloud.prototype = Object.create( THREE.Object3D.prototype );\r\n\tTHREE.PointCloud.prototype.constructor = THREE.PointCloud;\r\n\t\r\n\tTHREE.PointCloud.prototype.raycast = ( function () {\r\n\t\r\n\t\tvar inverseMatrix = new THREE.Matrix4();\r\n\t\tvar ray = new THREE.Ray();\r\n\t\r\n\t\treturn function ( raycaster, intersects ) {\r\n\t\r\n\t\t\tvar object = this;\r\n\t\t\tvar geometry = object.geometry;\r\n\t\t\tvar threshold = raycaster.params.PointCloud.threshold;\r\n\t\r\n\t\t\tinverseMatrix.getInverse( this.matrixWorld );\r\n\t\t\tray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );\r\n\t\r\n\t\t\tif ( geometry.boundingBox !== null ) {\r\n\t\r\n\t\t\t\tif ( ray.isIntersectionBox( geometry.boundingBox ) === false ) {\r\n\t\r\n\t\t\t\t\treturn;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar localThreshold = threshold / ( ( this.scale.x + this.scale.y + this.scale.z ) / 3 );\r\n\t\t\tvar position = new THREE.Vector3();\r\n\t\r\n\t\t\tvar testPoint = function ( point, index ) {\r\n\t\r\n\t\t\t\tvar rayPointDistance = ray.distanceToPoint( point );\r\n\t\r\n\t\t\t\tif ( rayPointDistance < localThreshold ) {\r\n\t\r\n\t\t\t\t\tvar intersectPoint = ray.closestPointToPoint( point );\r\n\t\t\t\t\tintersectPoint.applyMatrix4( object.matrixWorld );\r\n\t\r\n\t\t\t\t\tvar distance = raycaster.ray.origin.distanceTo( intersectPoint );\r\n\t\r\n\t\t\t\t\tintersects.push( {\r\n\t\r\n\t\t\t\t\t\tdistance: distance,\r\n\t\t\t\t\t\tdistanceToRay: rayPointDistance,\r\n\t\t\t\t\t\tpoint: intersectPoint.clone(),\r\n\t\t\t\t\t\tindex: index,\r\n\t\t\t\t\t\tface: null,\r\n\t\t\t\t\t\tobject: object\r\n\t\r\n\t\t\t\t\t} );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t\tif ( geometry instanceof THREE.BufferGeometry ) {\r\n\t\r\n\t\t\t\tvar attributes = geometry.attributes;\r\n\t\t\t\tvar positions = attributes.position.array;\r\n\t\r\n\t\t\t\tif ( attributes.index !== undefined ) {\r\n\t\r\n\t\t\t\t\tvar indices = attributes.index.array;\r\n\t\t\t\t\tvar offsets = geometry.offsets;\r\n\t\r\n\t\t\t\t\tif ( offsets.length === 0 ) {\r\n\t\r\n\t\t\t\t\t\tvar offset = {\r\n\t\t\t\t\t\t\tstart: 0,\r\n\t\t\t\t\t\t\tcount: indices.length,\r\n\t\t\t\t\t\t\tindex: 0\r\n\t\t\t\t\t\t};\r\n\t\r\n\t\t\t\t\t\toffsets = [ offset ];\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tfor ( var oi = 0, ol = offsets.length; oi < ol; ++ oi ) {\r\n\t\r\n\t\t\t\t\t\tvar start = offsets[ oi ].start;\r\n\t\t\t\t\t\tvar count = offsets[ oi ].count;\r\n\t\t\t\t\t\tvar index = offsets[ oi ].index;\r\n\t\r\n\t\t\t\t\t\tfor ( var i = start, il = start + count; i < il; i ++ ) {\r\n\t\r\n\t\t\t\t\t\t\tvar a = index + indices[ i ];\r\n\t\r\n\t\t\t\t\t\t\tposition.fromArray( positions, a * 3 );\r\n\t\r\n\t\t\t\t\t\t\ttestPoint( position, a );\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tvar pointCount = positions.length / 3;\r\n\t\r\n\t\t\t\t\tfor ( var i = 0; i < pointCount; i ++ ) {\r\n\t\r\n\t\t\t\t\t\tposition.set(\r\n\t\t\t\t\t\t\tpositions[ 3 * i ],\r\n\t\t\t\t\t\t\tpositions[ 3 * i + 1 ],\r\n\t\t\t\t\t\t\tpositions[ 3 * i + 2 ]\r\n\t\t\t\t\t\t);\r\n\t\r\n\t\t\t\t\t\ttestPoint( position, i );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\tvar vertices = this.geometry.vertices;\r\n\t\r\n\t\t\t\tfor ( var i = 0; i < vertices.length; i ++ ) {\r\n\t\r\n\t\t\t\t\ttestPoint( vertices[ i ], i );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t}() );\r\n\t\r\n\tTHREE.PointCloud.prototype.clone = function ( object ) {\r\n\t\r\n\t\tif ( object === undefined ) object = new THREE.PointCloud( this.geometry, this.material );\r\n\t\r\n\t\tTHREE.Object3D.prototype.clone.call( this, object );\r\n\t\r\n\t\treturn object;\r\n\t\r\n\t};\r\n\t\r\n\t// Backwards compatibility\r\n\t\r\n\tTHREE.ParticleSystem = function ( geometry, material ) {\r\n\t\r\n\t\tTHREE.warn( 'THREE.ParticleSystem has been renamed to THREE.PointCloud.' );\r\n\t\treturn new THREE.PointCloud( geometry, material );\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/objects/Line.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tTHREE.Line = function ( geometry, material, mode ) {\r\n\t\r\n\t\tTHREE.Object3D.call( this );\r\n\t\r\n\t\tthis.type = 'Line';\r\n\t\r\n\t\tthis.geometry = geometry !== undefined ? geometry : new THREE.Geometry();\r\n\t\tthis.material = material !== undefined ? material : new THREE.LineBasicMaterial( { color: Math.random() * 0xffffff } );\r\n\t\r\n\t\tthis.mode = mode !== undefined ? mode : THREE.LineStrip;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.LineStrip = 0;\r\n\tTHREE.LinePieces = 1;\r\n\t\r\n\tTHREE.Line.prototype = Object.create( THREE.Object3D.prototype );\r\n\tTHREE.Line.prototype.constructor = THREE.Line;\r\n\t\r\n\tTHREE.Line.prototype.raycast = ( function () {\r\n\t\r\n\t\tvar inverseMatrix = new THREE.Matrix4();\r\n\t\tvar ray = new THREE.Ray();\r\n\t\tvar sphere = new THREE.Sphere();\r\n\t\r\n\t\treturn function ( raycaster, intersects ) {\r\n\t\r\n\t\t\tvar precision = raycaster.linePrecision;\r\n\t\t\tvar precisionSq = precision * precision;\r\n\t\r\n\t\t\tvar geometry = this.geometry;\r\n\t\r\n\t\t\tif ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();\r\n\t\r\n\t\t\t// Checking boundingSphere distance to ray\r\n\t\r\n\t\t\tsphere.copy( geometry.boundingSphere );\r\n\t\t\tsphere.applyMatrix4( this.matrixWorld );\r\n\t\r\n\t\t\tif ( raycaster.ray.isIntersectionSphere( sphere ) === false ) {\r\n\t\r\n\t\t\t\treturn;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tinverseMatrix.getInverse( this.matrixWorld );\r\n\t\t\tray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );\r\n\t\r\n\t\t\tvar vStart = new THREE.Vector3();\r\n\t\t\tvar vEnd = new THREE.Vector3();\r\n\t\t\tvar interSegment = new THREE.Vector3();\r\n\t\t\tvar interRay = new THREE.Vector3();\r\n\t\t\tvar step = this.mode === THREE.LineStrip ? 1 : 2;\r\n\t\r\n\t\t\tif ( geometry instanceof THREE.BufferGeometry ) {\r\n\t\r\n\t\t\t\tvar attributes = geometry.attributes;\r\n\t\r\n\t\t\t\tif ( attributes.index !== undefined ) {\r\n\t\r\n\t\t\t\t\tvar indices = attributes.index.array;\r\n\t\t\t\t\tvar positions = attributes.position.array;\r\n\t\t\t\t\tvar offsets = geometry.offsets;\r\n\t\r\n\t\t\t\t\tif ( offsets.length === 0 ) {\r\n\t\r\n\t\t\t\t\t\toffsets = [ { start: 0, count: indices.length, index: 0 } ];\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tfor ( var oi = 0; oi < offsets.length; oi ++) {\r\n\t\r\n\t\t\t\t\t\tvar start = offsets[ oi ].start;\r\n\t\t\t\t\t\tvar count = offsets[ oi ].count;\r\n\t\t\t\t\t\tvar index = offsets[ oi ].index;\r\n\t\r\n\t\t\t\t\t\tfor ( var i = start; i < start + count - 1; i += step ) {\r\n\t\r\n\t\t\t\t\t\t\tvar a = index + indices[ i ];\r\n\t\t\t\t\t\t\tvar b = index + indices[ i + 1 ];\r\n\t\r\n\t\t\t\t\t\t\tvStart.fromArray( positions, a * 3 );\r\n\t\t\t\t\t\t\tvEnd.fromArray( positions, b * 3 );\r\n\t\r\n\t\t\t\t\t\t\tvar distSq = ray.distanceSqToSegment( vStart, vEnd, interRay, interSegment );\r\n\t\r\n\t\t\t\t\t\t\tif ( distSq > precisionSq ) continue;\r\n\t\r\n\t\t\t\t\t\t\tvar distance = ray.origin.distanceTo( interRay );\r\n\t\r\n\t\t\t\t\t\t\tif ( distance < raycaster.near || distance > raycaster.far ) continue;\r\n\t\r\n\t\t\t\t\t\t\tintersects.push( {\r\n\t\r\n\t\t\t\t\t\t\t\tdistance: distance,\r\n\t\t\t\t\t\t\t\t// What do we want? intersection point on the ray or on the segment??\r\n\t\t\t\t\t\t\t\t// point: raycaster.ray.at( distance ),\r\n\t\t\t\t\t\t\t\tpoint: interSegment.clone().applyMatrix4( this.matrixWorld ),\r\n\t\t\t\t\t\t\t\tindex: i,\r\n\t\t\t\t\t\t\t\toffsetIndex: oi,\r\n\t\t\t\t\t\t\t\tface: null,\r\n\t\t\t\t\t\t\t\tfaceIndex: null,\r\n\t\t\t\t\t\t\t\tobject: this\r\n\t\r\n\t\t\t\t\t\t\t} );\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tvar positions = attributes.position.array;\r\n\t\r\n\t\t\t\t\tfor ( var i = 0; i < positions.length / 3 - 1; i += step ) {\r\n\t\r\n\t\t\t\t\t\tvStart.fromArray( positions, 3 * i );\r\n\t\t\t\t\t\tvEnd.fromArray( positions, 3 * i + 3 );\r\n\t\r\n\t\t\t\t\t\tvar distSq = ray.distanceSqToSegment( vStart, vEnd, interRay, interSegment );\r\n\t\r\n\t\t\t\t\t\tif ( distSq > precisionSq ) continue;\r\n\t\r\n\t\t\t\t\t\tvar distance = ray.origin.distanceTo( interRay );\r\n\t\r\n\t\t\t\t\t\tif ( distance < raycaster.near || distance > raycaster.far ) continue;\r\n\t\r\n\t\t\t\t\t\tintersects.push( {\r\n\t\r\n\t\t\t\t\t\t\tdistance: distance,\r\n\t\t\t\t\t\t\t// What do we want? intersection point on the ray or on the segment??\r\n\t\t\t\t\t\t\t// point: raycaster.ray.at( distance ),\r\n\t\t\t\t\t\t\tpoint: interSegment.clone().applyMatrix4( this.matrixWorld ),\r\n\t\t\t\t\t\t\tindex: i,\r\n\t\t\t\t\t\t\tface: null,\r\n\t\t\t\t\t\t\tfaceIndex: null,\r\n\t\t\t\t\t\t\tobject: this\r\n\t\r\n\t\t\t\t\t\t} );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t} else if ( geometry instanceof THREE.Geometry ) {\r\n\t\r\n\t\t\t\tvar vertices = geometry.vertices;\r\n\t\t\t\tvar nbVertices = vertices.length;\r\n\t\r\n\t\t\t\tfor ( var i = 0; i < nbVertices - 1; i += step ) {\r\n\t\r\n\t\t\t\t\tvar distSq = ray.distanceSqToSegment( vertices[ i ], vertices[ i + 1 ], interRay, interSegment );\r\n\t\r\n\t\t\t\t\tif ( distSq > precisionSq ) continue;\r\n\t\r\n\t\t\t\t\tvar distance = ray.origin.distanceTo( interRay );\r\n\t\r\n\t\t\t\t\tif ( distance < raycaster.near || distance > raycaster.far ) continue;\r\n\t\r\n\t\t\t\t\tintersects.push( {\r\n\t\r\n\t\t\t\t\t\tdistance: distance,\r\n\t\t\t\t\t\t// What do we want? intersection point on the ray or on the segment??\r\n\t\t\t\t\t\t// point: raycaster.ray.at( distance ),\r\n\t\t\t\t\t\tpoint: interSegment.clone().applyMatrix4( this.matrixWorld ),\r\n\t\t\t\t\t\tindex: i,\r\n\t\t\t\t\t\tface: null,\r\n\t\t\t\t\t\tfaceIndex: null,\r\n\t\t\t\t\t\tobject: this\r\n\t\r\n\t\t\t\t\t} );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t}() );\r\n\t\r\n\tTHREE.Line.prototype.clone = function ( object ) {\r\n\t\r\n\t\tif ( object === undefined ) object = new THREE.Line( this.geometry, this.material, this.mode );\r\n\t\r\n\t\tTHREE.Object3D.prototype.clone.call( this, object );\r\n\t\r\n\t\treturn object;\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/objects/Mesh.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t * @author mikael emtinger / http://gomo.se/\r\n\t * @author jonobr1 / http://jonobr1.com/\r\n\t */\r\n\t\r\n\tTHREE.Mesh = function ( geometry, material ) {\r\n\t\r\n\t\tTHREE.Object3D.call( this );\r\n\t\r\n\t\tthis.type = 'Mesh';\r\n\t\t\r\n\t\tthis.geometry = geometry !== undefined ? geometry : new THREE.Geometry();\r\n\t\tthis.material = material !== undefined ? material : new THREE.MeshBasicMaterial( { color: Math.random() * 0xffffff } );\r\n\t\r\n\t\tthis.updateMorphTargets();\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Mesh.prototype = Object.create( THREE.Object3D.prototype );\r\n\tTHREE.Mesh.prototype.constructor = THREE.Mesh;\r\n\t\r\n\tTHREE.Mesh.prototype.updateMorphTargets = function () {\r\n\t\r\n\t\tif ( this.geometry.morphTargets !== undefined && this.geometry.morphTargets.length > 0 ) {\r\n\t\r\n\t\t\tthis.morphTargetBase = - 1;\r\n\t\t\tthis.morphTargetForcedOrder = [];\r\n\t\t\tthis.morphTargetInfluences = [];\r\n\t\t\tthis.morphTargetDictionary = {};\r\n\t\r\n\t\t\tfor ( var m = 0, ml = this.geometry.morphTargets.length; m < ml; m ++ ) {\r\n\t\r\n\t\t\t\tthis.morphTargetInfluences.push( 0 );\r\n\t\t\t\tthis.morphTargetDictionary[ this.geometry.morphTargets[ m ].name ] = m;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Mesh.prototype.getMorphTargetIndexByName = function ( name ) {\r\n\t\r\n\t\tif ( this.morphTargetDictionary[ name ] !== undefined ) {\r\n\t\r\n\t\t\treturn this.morphTargetDictionary[ name ];\r\n\t\r\n\t\t}\r\n\t\r\n\t\tTHREE.warn( 'THREE.Mesh.getMorphTargetIndexByName: morph target ' + name + ' does not exist. Returning 0.' );\r\n\t\r\n\t\treturn 0;\r\n\t\r\n\t};\r\n\t\r\n\t\r\n\tTHREE.Mesh.prototype.raycast = ( function () {\r\n\t\r\n\t\tvar inverseMatrix = new THREE.Matrix4();\r\n\t\tvar ray = new THREE.Ray();\r\n\t\tvar sphere = new THREE.Sphere();\r\n\t\r\n\t\tvar vA = new THREE.Vector3();\r\n\t\tvar vB = new THREE.Vector3();\r\n\t\tvar vC = new THREE.Vector3();\r\n\t\r\n\t\treturn function ( raycaster, intersects ) {\r\n\t\r\n\t\t\tvar geometry = this.geometry;\r\n\t\r\n\t\t\t// Checking boundingSphere distance to ray\r\n\t\r\n\t\t\tif ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();\r\n\t\r\n\t\t\tsphere.copy( geometry.boundingSphere );\r\n\t\t\tsphere.applyMatrix4( this.matrixWorld );\r\n\t\r\n\t\t\tif ( raycaster.ray.isIntersectionSphere( sphere ) === false ) {\r\n\t\r\n\t\t\t\treturn;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// Check boundingBox before continuing\r\n\t\r\n\t\t\tinverseMatrix.getInverse( this.matrixWorld );\r\n\t\t\tray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );\r\n\t\r\n\t\t\tif ( geometry.boundingBox !== null ) {\r\n\t\r\n\t\t\t\tif ( ray.isIntersectionBox( geometry.boundingBox ) === false ) {\r\n\t\r\n\t\t\t\t\treturn;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( geometry instanceof THREE.BufferGeometry ) {\r\n\t\r\n\t\t\t\tvar material = this.material;\r\n\t\r\n\t\t\t\tif ( material === undefined ) return;\r\n\t\r\n\t\t\t\tvar attributes = geometry.attributes;\r\n\t\r\n\t\t\t\tvar a, b, c;\r\n\t\t\t\tvar precision = raycaster.precision;\r\n\t\r\n\t\t\t\tif ( attributes.index !== undefined ) {\r\n\t\r\n\t\t\t\t\tvar indices = attributes.index.array;\r\n\t\t\t\t\tvar positions = attributes.position.array;\r\n\t\t\t\t\tvar offsets = geometry.offsets;\r\n\t\r\n\t\t\t\t\tif ( offsets.length === 0 ) {\r\n\t\r\n\t\t\t\t\t\toffsets = [ { start: 0, count: indices.length, index: 0 } ];\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tfor ( var oi = 0, ol = offsets.length; oi < ol; ++ oi ) {\r\n\t\r\n\t\t\t\t\t\tvar start = offsets[ oi ].start;\r\n\t\t\t\t\t\tvar count = offsets[ oi ].count;\r\n\t\t\t\t\t\tvar index = offsets[ oi ].index;\r\n\t\r\n\t\t\t\t\t\tfor ( var i = start, il = start + count; i < il; i += 3 ) {\r\n\t\r\n\t\t\t\t\t\t\ta = index + indices[ i ];\r\n\t\t\t\t\t\t\tb = index + indices[ i + 1 ];\r\n\t\t\t\t\t\t\tc = index + indices[ i + 2 ];\r\n\t\r\n\t\t\t\t\t\t\tvA.fromArray( positions, a * 3 );\r\n\t\t\t\t\t\t\tvB.fromArray( positions, b * 3 );\r\n\t\t\t\t\t\t\tvC.fromArray( positions, c * 3 );\r\n\t\r\n\t\t\t\t\t\t\tif ( material.side === THREE.BackSide ) {\r\n\t\r\n\t\t\t\t\t\t\t\tvar intersectionPoint = ray.intersectTriangle( vC, vB, vA, true );\r\n\t\r\n\t\t\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\t\t\tvar intersectionPoint = ray.intersectTriangle( vA, vB, vC, material.side !== THREE.DoubleSide );\r\n\t\r\n\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t\tif ( intersectionPoint === null ) continue;\r\n\t\r\n\t\t\t\t\t\t\tintersectionPoint.applyMatrix4( this.matrixWorld );\r\n\t\r\n\t\t\t\t\t\t\tvar distance = raycaster.ray.origin.distanceTo( intersectionPoint );\r\n\t\r\n\t\t\t\t\t\t\tif ( distance < precision || distance < raycaster.near || distance > raycaster.far ) continue;\r\n\t\r\n\t\t\t\t\t\t\tintersects.push( {\r\n\t\r\n\t\t\t\t\t\t\t\tdistance: distance,\r\n\t\t\t\t\t\t\t\tpoint: intersectionPoint,\r\n\t\t\t\t\t\t\t\tface: new THREE.Face3( a, b, c, THREE.Triangle.normal( vA, vB, vC ) ),\r\n\t\t\t\t\t\t\t\tfaceIndex: null,\r\n\t\t\t\t\t\t\t\tobject: this\r\n\t\r\n\t\t\t\t\t\t\t} );\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tvar positions = attributes.position.array;\r\n\t\r\n\t\t\t\t\tfor ( var i = 0, j = 0, il = positions.length; i < il; i += 3, j += 9 ) {\r\n\t\r\n\t\t\t\t\t\ta = i;\r\n\t\t\t\t\t\tb = i + 1;\r\n\t\t\t\t\t\tc = i + 2;\r\n\t\r\n\t\t\t\t\t\tvA.fromArray( positions, j );\r\n\t\t\t\t\t\tvB.fromArray( positions, j + 3 );\r\n\t\t\t\t\t\tvC.fromArray( positions, j + 6 );\r\n\t\r\n\t\t\t\t\t\tif ( material.side === THREE.BackSide ) {\r\n\t\r\n\t\t\t\t\t\t\tvar intersectionPoint = ray.intersectTriangle( vC, vB, vA, true );\r\n\t\r\n\t\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\t\tvar intersectionPoint = ray.intersectTriangle( vA, vB, vC, material.side !== THREE.DoubleSide );\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\tif ( intersectionPoint === null ) continue;\r\n\t\r\n\t\t\t\t\t\tintersectionPoint.applyMatrix4( this.matrixWorld );\r\n\t\r\n\t\t\t\t\t\tvar distance = raycaster.ray.origin.distanceTo( intersectionPoint );\r\n\t\r\n\t\t\t\t\t\tif ( distance < precision || distance < raycaster.near || distance > raycaster.far ) continue;\r\n\t\r\n\t\t\t\t\t\tintersects.push( {\r\n\t\r\n\t\t\t\t\t\t\tdistance: distance,\r\n\t\t\t\t\t\t\tpoint: intersectionPoint,\r\n\t\t\t\t\t\t\tface: new THREE.Face3( a, b, c, THREE.Triangle.normal( vA, vB, vC ) ),\r\n\t\t\t\t\t\t\tfaceIndex: null,\r\n\t\t\t\t\t\t\tobject: this\r\n\t\r\n\t\t\t\t\t\t} );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t} else if ( geometry instanceof THREE.Geometry ) {\r\n\t\r\n\t\t\t\tvar isFaceMaterial = this.material instanceof THREE.MeshFaceMaterial;\r\n\t\t\t\tvar objectMaterials = isFaceMaterial === true ? this.material.materials : null;\r\n\t\r\n\t\t\t\tvar a, b, c;\r\n\t\t\t\tvar precision = raycaster.precision;\r\n\t\r\n\t\t\t\tvar vertices = geometry.vertices;\r\n\t\r\n\t\t\t\tfor ( var f = 0, fl = geometry.faces.length; f < fl; f ++ ) {\r\n\t\r\n\t\t\t\t\tvar face = geometry.faces[ f ];\r\n\t\r\n\t\t\t\t\tvar material = isFaceMaterial === true ? objectMaterials[ face.materialIndex ] : this.material;\r\n\t\r\n\t\t\t\t\tif ( material === undefined ) continue;\r\n\t\r\n\t\t\t\t\ta = vertices[ face.a ];\r\n\t\t\t\t\tb = vertices[ face.b ];\r\n\t\t\t\t\tc = vertices[ face.c ];\r\n\t\r\n\t\t\t\t\tif ( material.morphTargets === true ) {\r\n\t\r\n\t\t\t\t\t\tvar morphTargets = geometry.morphTargets;\r\n\t\t\t\t\t\tvar morphInfluences = this.morphTargetInfluences;\r\n\t\r\n\t\t\t\t\t\tvA.set( 0, 0, 0 );\r\n\t\t\t\t\t\tvB.set( 0, 0, 0 );\r\n\t\t\t\t\t\tvC.set( 0, 0, 0 );\r\n\t\r\n\t\t\t\t\t\tfor ( var t = 0, tl = morphTargets.length; t < tl; t ++ ) {\r\n\t\r\n\t\t\t\t\t\t\tvar influence = morphInfluences[ t ];\r\n\t\r\n\t\t\t\t\t\t\tif ( influence === 0 ) continue;\r\n\t\r\n\t\t\t\t\t\t\tvar targets = morphTargets[ t ].vertices;\r\n\t\r\n\t\t\t\t\t\t\tvA.x += ( targets[ face.a ].x - a.x ) * influence;\r\n\t\t\t\t\t\t\tvA.y += ( targets[ face.a ].y - a.y ) * influence;\r\n\t\t\t\t\t\t\tvA.z += ( targets[ face.a ].z - a.z ) * influence;\r\n\t\r\n\t\t\t\t\t\t\tvB.x += ( targets[ face.b ].x - b.x ) * influence;\r\n\t\t\t\t\t\t\tvB.y += ( targets[ face.b ].y - b.y ) * influence;\r\n\t\t\t\t\t\t\tvB.z += ( targets[ face.b ].z - b.z ) * influence;\r\n\t\r\n\t\t\t\t\t\t\tvC.x += ( targets[ face.c ].x - c.x ) * influence;\r\n\t\t\t\t\t\t\tvC.y += ( targets[ face.c ].y - c.y ) * influence;\r\n\t\t\t\t\t\t\tvC.z += ( targets[ face.c ].z - c.z ) * influence;\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\tvA.add( a );\r\n\t\t\t\t\t\tvB.add( b );\r\n\t\t\t\t\t\tvC.add( c );\r\n\t\r\n\t\t\t\t\t\ta = vA;\r\n\t\t\t\t\t\tb = vB;\r\n\t\t\t\t\t\tc = vC;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tif ( material.side === THREE.BackSide ) {\r\n\t\r\n\t\t\t\t\t\tvar intersectionPoint = ray.intersectTriangle( c, b, a, true );\r\n\t\r\n\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\tvar intersectionPoint = ray.intersectTriangle( a, b, c, material.side !== THREE.DoubleSide );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tif ( intersectionPoint === null ) continue;\r\n\t\r\n\t\t\t\t\tintersectionPoint.applyMatrix4( this.matrixWorld );\r\n\t\r\n\t\t\t\t\tvar distance = raycaster.ray.origin.distanceTo( intersectionPoint );\r\n\t\r\n\t\t\t\t\tif ( distance < precision || distance < raycaster.near || distance > raycaster.far ) continue;\r\n\t\r\n\t\t\t\t\tintersects.push( {\r\n\t\r\n\t\t\t\t\t\tdistance: distance,\r\n\t\t\t\t\t\tpoint: intersectionPoint,\r\n\t\t\t\t\t\tface: face,\r\n\t\t\t\t\t\tfaceIndex: f,\r\n\t\t\t\t\t\tobject: this\r\n\t\r\n\t\t\t\t\t} );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t}() );\r\n\t\r\n\tTHREE.Mesh.prototype.clone = function ( object, recursive ) {\r\n\t\r\n\t\tif ( object === undefined ) object = new THREE.Mesh( this.geometry, this.material );\r\n\t\r\n\t\tTHREE.Object3D.prototype.clone.call( this, object, recursive );\r\n\t\r\n\t\treturn object;\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/objects/Bone.js\r\n\t\r\n\t/**\r\n\t * @author mikael emtinger / http://gomo.se/\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t * @author ikerr / http://verold.com\r\n\t */\r\n\t\r\n\tTHREE.Bone = function ( skin ) {\r\n\t\r\n\t\tTHREE.Object3D.call( this );\r\n\t\r\n\t\tthis.type = 'Bone';\r\n\t\r\n\t\tthis.skin = skin;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Bone.prototype = Object.create( THREE.Object3D.prototype );\r\n\tTHREE.Bone.prototype.constructor = THREE.Bone;\r\n\t\r\n\t// File:src/objects/Skeleton.js\r\n\t\r\n\t/**\r\n\t * @author mikael emtinger / http://gomo.se/\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t * @author michael guerrero / http://realitymeltdown.com\r\n\t * @author ikerr / http://verold.com\r\n\t */\r\n\t\r\n\tTHREE.Skeleton = function ( bones, boneInverses, useVertexTexture ) {\r\n\t\r\n\t\tthis.useVertexTexture = useVertexTexture !== undefined ? useVertexTexture : true;\r\n\t\r\n\t\tthis.identityMatrix = new THREE.Matrix4();\r\n\t\r\n\t\t// copy the bone array\r\n\t\r\n\t\tbones = bones || [];\r\n\t\r\n\t\tthis.bones = bones.slice( 0 );\r\n\t\r\n\t\t// create a bone texture or an array of floats\r\n\t\r\n\t\tif ( this.useVertexTexture ) {\r\n\t\r\n\t\t\t// layout (1 matrix = 4 pixels)\r\n\t\t\t//      RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)\r\n\t\t\t//  with  8x8  pixel texture max   16 bones  (8 * 8  / 4)\r\n\t\t\t//       16x16 pixel texture max   64 bones (16 * 16 / 4)\r\n\t\t\t//       32x32 pixel texture max  256 bones (32 * 32 / 4)\r\n\t\t\t//       64x64 pixel texture max 1024 bones (64 * 64 / 4)\r\n\t\r\n\t\t\tvar size;\r\n\t\r\n\t\t\tif ( this.bones.length > 256 )\r\n\t\t\t\tsize = 64;\r\n\t\t\telse if ( this.bones.length > 64 )\r\n\t\t\t\tsize = 32;\r\n\t\t\telse if ( this.bones.length > 16 )\r\n\t\t\t\tsize = 16;\r\n\t\t\telse\r\n\t\t\t\tsize = 8;\r\n\t\r\n\t\t\tthis.boneTextureWidth = size;\r\n\t\t\tthis.boneTextureHeight = size;\r\n\t\r\n\t\t\tthis.boneMatrices = new Float32Array( this.boneTextureWidth * this.boneTextureHeight * 4 ); // 4 floats per RGBA pixel\r\n\t\t\tthis.boneTexture = new THREE.DataTexture( this.boneMatrices, this.boneTextureWidth, this.boneTextureHeight, THREE.RGBAFormat, THREE.FloatType );\r\n\t\t\tthis.boneTexture.minFilter = THREE.NearestFilter;\r\n\t\t\tthis.boneTexture.magFilter = THREE.NearestFilter;\r\n\t\t\tthis.boneTexture.generateMipmaps = false;\r\n\t\t\tthis.boneTexture.flipY = false;\r\n\t\r\n\t\t} else {\r\n\t\r\n\t\t\tthis.boneMatrices = new Float32Array( 16 * this.bones.length );\r\n\t\r\n\t\t}\r\n\t\r\n\t\t// use the supplied bone inverses or calculate the inverses\r\n\t\r\n\t\tif ( boneInverses === undefined ) {\r\n\t\r\n\t\t\tthis.calculateInverses();\r\n\t\r\n\t\t} else {\r\n\t\r\n\t\t\tif ( this.bones.length === boneInverses.length ) {\r\n\t\r\n\t\t\t\tthis.boneInverses = boneInverses.slice( 0 );\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\tTHREE.warn( 'THREE.Skeleton bonInverses is the wrong length.' );\r\n\t\r\n\t\t\t\tthis.boneInverses = [];\r\n\t\r\n\t\t\t\tfor ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {\r\n\t\r\n\t\t\t\t\tthis.boneInverses.push( new THREE.Matrix4() );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Skeleton.prototype.calculateInverses = function () {\r\n\t\r\n\t\tthis.boneInverses = [];\r\n\t\r\n\t\tfor ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {\r\n\t\r\n\t\t\tvar inverse = new THREE.Matrix4();\r\n\t\r\n\t\t\tif ( this.bones[ b ] ) {\r\n\t\r\n\t\t\t\tinverse.getInverse( this.bones[ b ].matrixWorld );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tthis.boneInverses.push( inverse );\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Skeleton.prototype.pose = function () {\r\n\t\r\n\t\tvar bone;\r\n\t\r\n\t\t// recover the bind-time world matrices\r\n\t\r\n\t\tfor ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {\r\n\t\r\n\t\t\tbone = this.bones[ b ];\r\n\t\r\n\t\t\tif ( bone ) {\r\n\t\r\n\t\t\t\tbone.matrixWorld.getInverse( this.boneInverses[ b ] );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\t// compute the local matrices, positions, rotations and scales\r\n\t\r\n\t\tfor ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {\r\n\t\r\n\t\t\tbone = this.bones[ b ];\r\n\t\r\n\t\t\tif ( bone ) {\r\n\t\r\n\t\t\t\tif ( bone.parent ) {\r\n\t\r\n\t\t\t\t\tbone.matrix.getInverse( bone.parent.matrixWorld );\r\n\t\t\t\t\tbone.matrix.multiply( bone.matrixWorld );\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tbone.matrix.copy( bone.matrixWorld );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tbone.matrix.decompose( bone.position, bone.quaternion, bone.scale );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Skeleton.prototype.update = ( function () {\r\n\t\r\n\t\tvar offsetMatrix = new THREE.Matrix4();\r\n\t\t\r\n\t\treturn function () {\r\n\t\r\n\t\t\t// flatten bone matrices to array\r\n\t\r\n\t\t\tfor ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {\r\n\t\r\n\t\t\t\t// compute the offset between the current and the original transform\r\n\t\r\n\t\t\t\tvar matrix = this.bones[ b ] ? this.bones[ b ].matrixWorld : this.identityMatrix;\r\n\t\r\n\t\t\t\toffsetMatrix.multiplyMatrices( matrix, this.boneInverses[ b ] );\r\n\t\t\t\toffsetMatrix.flattenToArrayOffset( this.boneMatrices, b * 16 );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( this.useVertexTexture ) {\r\n\t\r\n\t\t\t\tthis.boneTexture.needsUpdate = true;\r\n\t\r\n\t\t\t}\r\n\t\t\t\r\n\t\t};\r\n\t\r\n\t} )();\r\n\t\r\n\t\r\n\t// File:src/objects/SkinnedMesh.js\r\n\t\r\n\t/**\r\n\t * @author mikael emtinger / http://gomo.se/\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t * @author ikerr / http://verold.com\r\n\t */\r\n\t\r\n\tTHREE.SkinnedMesh = function ( geometry, material, useVertexTexture ) {\r\n\t\r\n\t\tTHREE.Mesh.call( this, geometry, material );\r\n\t\r\n\t\tthis.type = 'SkinnedMesh';\r\n\t\r\n\t\tthis.bindMode = \"attached\";\r\n\t\tthis.bindMatrix = new THREE.Matrix4();\r\n\t\tthis.bindMatrixInverse = new THREE.Matrix4();\r\n\t\r\n\t\t// init bones\r\n\t\r\n\t\t// TODO: remove bone creation as there is no reason (other than\r\n\t\t// convenience) for THREE.SkinnedMesh to do this.\r\n\t\r\n\t\tvar bones = [];\r\n\t\r\n\t\tif ( this.geometry && this.geometry.bones !== undefined ) {\r\n\t\r\n\t\t\tvar bone, gbone, p, q, s;\r\n\t\r\n\t\t\tfor ( var b = 0, bl = this.geometry.bones.length; b < bl; ++ b ) {\r\n\t\r\n\t\t\t\tgbone = this.geometry.bones[ b ];\r\n\t\r\n\t\t\t\tp = gbone.pos;\r\n\t\t\t\tq = gbone.rotq;\r\n\t\t\t\ts = gbone.scl;\r\n\t\r\n\t\t\t\tbone = new THREE.Bone( this );\r\n\t\t\t\tbones.push( bone );\r\n\t\r\n\t\t\t\tbone.name = gbone.name;\r\n\t\t\t\tbone.position.set( p[ 0 ], p[ 1 ], p[ 2 ] );\r\n\t\t\t\tbone.quaternion.set( q[ 0 ], q[ 1 ], q[ 2 ], q[ 3 ] );\r\n\t\r\n\t\t\t\tif ( s !== undefined ) {\r\n\t\r\n\t\t\t\t\tbone.scale.set( s[ 0 ], s[ 1 ], s[ 2 ] );\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tbone.scale.set( 1, 1, 1 );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tfor ( var b = 0, bl = this.geometry.bones.length; b < bl; ++ b ) {\r\n\t\r\n\t\t\t\tgbone = this.geometry.bones[ b ];\r\n\t\r\n\t\t\t\tif ( gbone.parent !== - 1 ) {\r\n\t\r\n\t\t\t\t\tbones[ gbone.parent ].add( bones[ b ] );\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tthis.add( bones[ b ] );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\tthis.normalizeSkinWeights();\r\n\t\r\n\t\tthis.updateMatrixWorld( true );\r\n\t\tthis.bind( new THREE.Skeleton( bones, undefined, useVertexTexture ) );\r\n\t\r\n\t};\r\n\t\r\n\t\r\n\tTHREE.SkinnedMesh.prototype = Object.create( THREE.Mesh.prototype );\r\n\tTHREE.SkinnedMesh.prototype.constructor = THREE.SkinnedMesh;\r\n\t\r\n\tTHREE.SkinnedMesh.prototype.bind = function( skeleton, bindMatrix ) {\r\n\t\r\n\t\tthis.skeleton = skeleton;\r\n\t\r\n\t\tif ( bindMatrix === undefined ) {\r\n\t\r\n\t\t\tthis.updateMatrixWorld( true );\r\n\t\r\n\t\t\tbindMatrix = this.matrixWorld;\r\n\t\r\n\t\t}\r\n\t\r\n\t\tthis.bindMatrix.copy( bindMatrix );\r\n\t\tthis.bindMatrixInverse.getInverse( bindMatrix );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.SkinnedMesh.prototype.pose = function () {\r\n\t\r\n\t\tthis.skeleton.pose();\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.SkinnedMesh.prototype.normalizeSkinWeights = function () {\r\n\t\r\n\t\tif ( this.geometry instanceof THREE.Geometry ) {\r\n\t\r\n\t\t\tfor ( var i = 0; i < this.geometry.skinIndices.length; i ++ ) {\r\n\t\r\n\t\t\t\tvar sw = this.geometry.skinWeights[ i ];\r\n\t\r\n\t\t\t\tvar scale = 1.0 / sw.lengthManhattan();\r\n\t\r\n\t\t\t\tif ( scale !== Infinity ) {\r\n\t\r\n\t\t\t\t\tsw.multiplyScalar( scale );\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tsw.set( 1 ); // this will be normalized by the shader anyway\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t} else {\r\n\t\r\n\t\t\t// skinning weights assumed to be normalized for THREE.BufferGeometry\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.SkinnedMesh.prototype.updateMatrixWorld = function( force ) {\r\n\t\r\n\t\tTHREE.Mesh.prototype.updateMatrixWorld.call( this, true );\r\n\t\r\n\t\tif ( this.bindMode === \"attached\" ) {\r\n\t\r\n\t\t\tthis.bindMatrixInverse.getInverse( this.matrixWorld );\r\n\t\r\n\t\t} else if ( this.bindMode === \"detached\" ) {\r\n\t\r\n\t\t\tthis.bindMatrixInverse.getInverse( this.bindMatrix );\r\n\t\r\n\t\t} else {\r\n\t\r\n\t\t\tTHREE.warn( 'THREE.SkinnedMesh unreckognized bindMode: ' + this.bindMode );\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.SkinnedMesh.prototype.clone = function( object ) {\r\n\t\r\n\t\tif ( object === undefined ) {\r\n\t\r\n\t\t\tobject = new THREE.SkinnedMesh( this.geometry, this.material, this.useVertexTexture );\r\n\t\r\n\t\t}\r\n\t\r\n\t\tTHREE.Mesh.prototype.clone.call( this, object );\r\n\t\r\n\t\treturn object;\r\n\t\r\n\t};\r\n\t\r\n\t\r\n\t// File:src/objects/MorphAnimMesh.js\r\n\t\r\n\t/**\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t */\r\n\t\r\n\tTHREE.MorphAnimMesh = function ( geometry, material ) {\r\n\t\r\n\t\tTHREE.Mesh.call( this, geometry, material );\r\n\t\r\n\t\tthis.type = 'MorphAnimMesh';\r\n\t\r\n\t\t// API\r\n\t\r\n\t\tthis.duration = 1000; // milliseconds\r\n\t\tthis.mirroredLoop = false;\r\n\t\tthis.time = 0;\r\n\t\r\n\t\t// internals\r\n\t\r\n\t\tthis.lastKeyframe = 0;\r\n\t\tthis.currentKeyframe = 0;\r\n\t\r\n\t\tthis.direction = 1;\r\n\t\tthis.directionBackwards = false;\r\n\t\r\n\t\tthis.setFrameRange( 0, this.geometry.morphTargets.length - 1 );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.MorphAnimMesh.prototype = Object.create( THREE.Mesh.prototype );\r\n\tTHREE.MorphAnimMesh.prototype.constructor = THREE.MorphAnimMesh;\r\n\t\r\n\tTHREE.MorphAnimMesh.prototype.setFrameRange = function ( start, end ) {\r\n\t\r\n\t\tthis.startKeyframe = start;\r\n\t\tthis.endKeyframe = end;\r\n\t\r\n\t\tthis.length = this.endKeyframe - this.startKeyframe + 1;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.MorphAnimMesh.prototype.setDirectionForward = function () {\r\n\t\r\n\t\tthis.direction = 1;\r\n\t\tthis.directionBackwards = false;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.MorphAnimMesh.prototype.setDirectionBackward = function () {\r\n\t\r\n\t\tthis.direction = - 1;\r\n\t\tthis.directionBackwards = true;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.MorphAnimMesh.prototype.parseAnimations = function () {\r\n\t\r\n\t\tvar geometry = this.geometry;\r\n\t\r\n\t\tif ( ! geometry.animations ) geometry.animations = {};\r\n\t\r\n\t\tvar firstAnimation, animations = geometry.animations;\r\n\t\r\n\t\tvar pattern = /([a-z]+)_?(\\d+)/;\r\n\t\r\n\t\tfor ( var i = 0, il = geometry.morphTargets.length; i < il; i ++ ) {\r\n\t\r\n\t\t\tvar morph = geometry.morphTargets[ i ];\r\n\t\t\tvar parts = morph.name.match( pattern );\r\n\t\r\n\t\t\tif ( parts && parts.length > 1 ) {\r\n\t\r\n\t\t\t\tvar label = parts[ 1 ];\r\n\t\r\n\t\t\t\tif ( ! animations[ label ] ) animations[ label ] = { start: Infinity, end: - Infinity };\r\n\t\r\n\t\t\t\tvar animation = animations[ label ];\r\n\t\r\n\t\t\t\tif ( i < animation.start ) animation.start = i;\r\n\t\t\t\tif ( i > animation.end ) animation.end = i;\r\n\t\r\n\t\t\t\tif ( ! firstAnimation ) firstAnimation = label;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\tgeometry.firstAnimation = firstAnimation;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.MorphAnimMesh.prototype.setAnimationLabel = function ( label, start, end ) {\r\n\t\r\n\t\tif ( ! this.geometry.animations ) this.geometry.animations = {};\r\n\t\r\n\t\tthis.geometry.animations[ label ] = { start: start, end: end };\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.MorphAnimMesh.prototype.playAnimation = function ( label, fps ) {\r\n\t\r\n\t\tvar animation = this.geometry.animations[ label ];\r\n\t\r\n\t\tif ( animation ) {\r\n\t\r\n\t\t\tthis.setFrameRange( animation.start, animation.end );\r\n\t\t\tthis.duration = 1000 * ( ( animation.end - animation.start ) / fps );\r\n\t\t\tthis.time = 0;\r\n\t\r\n\t\t} else {\r\n\t\r\n\t\t\tTHREE.warn( 'THREE.MorphAnimMesh: animation[' + label + '] undefined in .playAnimation()' );\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.MorphAnimMesh.prototype.updateAnimation = function ( delta ) {\r\n\t\r\n\t\tvar frameTime = this.duration / this.length;\r\n\t\r\n\t\tthis.time += this.direction * delta;\r\n\t\r\n\t\tif ( this.mirroredLoop ) {\r\n\t\r\n\t\t\tif ( this.time > this.duration || this.time < 0 ) {\r\n\t\r\n\t\t\t\tthis.direction *= - 1;\r\n\t\r\n\t\t\t\tif ( this.time > this.duration ) {\r\n\t\r\n\t\t\t\t\tthis.time = this.duration;\r\n\t\t\t\t\tthis.directionBackwards = true;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( this.time < 0 ) {\r\n\t\r\n\t\t\t\t\tthis.time = 0;\r\n\t\t\t\t\tthis.directionBackwards = false;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t} else {\r\n\t\r\n\t\t\tthis.time = this.time % this.duration;\r\n\t\r\n\t\t\tif ( this.time < 0 ) this.time += this.duration;\r\n\t\r\n\t\t}\r\n\t\r\n\t\tvar keyframe = this.startKeyframe + THREE.Math.clamp( Math.floor( this.time / frameTime ), 0, this.length - 1 );\r\n\t\r\n\t\tif ( keyframe !== this.currentKeyframe ) {\r\n\t\r\n\t\t\tthis.morphTargetInfluences[ this.lastKeyframe ] = 0;\r\n\t\t\tthis.morphTargetInfluences[ this.currentKeyframe ] = 1;\r\n\t\r\n\t\t\tthis.morphTargetInfluences[ keyframe ] = 0;\r\n\t\r\n\t\t\tthis.lastKeyframe = this.currentKeyframe;\r\n\t\t\tthis.currentKeyframe = keyframe;\r\n\t\r\n\t\t}\r\n\t\r\n\t\tvar mix = ( this.time % frameTime ) / frameTime;\r\n\t\r\n\t\tif ( this.directionBackwards ) {\r\n\t\r\n\t\t\tmix = 1 - mix;\r\n\t\r\n\t\t}\r\n\t\r\n\t\tthis.morphTargetInfluences[ this.currentKeyframe ] = mix;\r\n\t\tthis.morphTargetInfluences[ this.lastKeyframe ] = 1 - mix;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.MorphAnimMesh.prototype.interpolateTargets = function ( a, b, t ) {\r\n\t\r\n\t\tvar influences = this.morphTargetInfluences;\r\n\t\r\n\t\tfor ( var i = 0, l = influences.length; i < l; i ++ ) {\r\n\t\r\n\t\t\tinfluences[ i ] = 0;\r\n\t\r\n\t\t}\r\n\t\r\n\t\tif ( a > -1 ) influences[ a ] = 1 - t;\r\n\t\tif ( b > -1 ) influences[ b ] = t;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.MorphAnimMesh.prototype.clone = function ( object ) {\r\n\t\r\n\t\tif ( object === undefined ) object = new THREE.MorphAnimMesh( this.geometry, this.material );\r\n\t\r\n\t\tobject.duration = this.duration;\r\n\t\tobject.mirroredLoop = this.mirroredLoop;\r\n\t\tobject.time = this.time;\r\n\t\r\n\t\tobject.lastKeyframe = this.lastKeyframe;\r\n\t\tobject.currentKeyframe = this.currentKeyframe;\r\n\t\r\n\t\tobject.direction = this.direction;\r\n\t\tobject.directionBackwards = this.directionBackwards;\r\n\t\r\n\t\tTHREE.Mesh.prototype.clone.call( this, object );\r\n\t\r\n\t\treturn object;\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/objects/LOD.js\r\n\t\r\n\t/**\r\n\t * @author mikael emtinger / http://gomo.se/\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tTHREE.LOD = function () {\r\n\t\r\n\t\tTHREE.Object3D.call( this );\r\n\t\r\n\t\tthis.objects = [];\r\n\t\r\n\t};\r\n\t\r\n\t\r\n\tTHREE.LOD.prototype = Object.create( THREE.Object3D.prototype );\r\n\tTHREE.LOD.prototype.constructor = THREE.LOD;\r\n\t\r\n\tTHREE.LOD.prototype.addLevel = function ( object, distance ) {\r\n\t\r\n\t\tif ( distance === undefined ) distance = 0;\r\n\t\r\n\t\tdistance = Math.abs( distance );\r\n\t\r\n\t\tfor ( var l = 0; l < this.objects.length; l ++ ) {\r\n\t\r\n\t\t\tif ( distance < this.objects[ l ].distance ) {\r\n\t\r\n\t\t\t\tbreak;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\tthis.objects.splice( l, 0, { distance: distance, object: object } );\r\n\t\tthis.add( object );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.LOD.prototype.getObjectForDistance = function ( distance ) {\r\n\t\r\n\t\tfor ( var i = 1, l = this.objects.length; i < l; i ++ ) {\r\n\t\r\n\t\t\tif ( distance < this.objects[ i ].distance ) {\r\n\t\r\n\t\t\t\tbreak;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\treturn this.objects[ i - 1 ].object;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.LOD.prototype.raycast = ( function () {\r\n\t\r\n\t\tvar matrixPosition = new THREE.Vector3();\r\n\t\r\n\t\treturn function ( raycaster, intersects ) {\r\n\t\r\n\t\t\tmatrixPosition.setFromMatrixPosition( this.matrixWorld );\r\n\t\r\n\t\t\tvar distance = raycaster.ray.origin.distanceTo( matrixPosition );\r\n\t\r\n\t\t\tthis.getObjectForDistance( distance ).raycast( raycaster, intersects );\r\n\t\r\n\t\t};\r\n\t\r\n\t}() );\r\n\t\r\n\tTHREE.LOD.prototype.update = function () {\r\n\t\r\n\t\tvar v1 = new THREE.Vector3();\r\n\t\tvar v2 = new THREE.Vector3();\r\n\t\r\n\t\treturn function ( camera ) {\r\n\t\r\n\t\t\tif ( this.objects.length > 1 ) {\r\n\t\r\n\t\t\t\tv1.setFromMatrixPosition( camera.matrixWorld );\r\n\t\t\t\tv2.setFromMatrixPosition( this.matrixWorld );\r\n\t\r\n\t\t\t\tvar distance = v1.distanceTo( v2 );\r\n\t\r\n\t\t\t\tthis.objects[ 0 ].object.visible = true;\r\n\t\r\n\t\t\t\tfor ( var i = 1, l = this.objects.length; i < l; i ++ ) {\r\n\t\r\n\t\t\t\t\tif ( distance >= this.objects[ i ].distance ) {\r\n\t\r\n\t\t\t\t\t\tthis.objects[ i - 1 ].object.visible = false;\r\n\t\t\t\t\t\tthis.objects[ i     ].object.visible = true;\r\n\t\r\n\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tfor ( ; i < l; i ++ ) {\r\n\t\r\n\t\t\t\t\tthis.objects[ i ].object.visible = false;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t}();\r\n\t\r\n\tTHREE.LOD.prototype.clone = function ( object ) {\r\n\t\r\n\t\tif ( object === undefined ) object = new THREE.LOD();\r\n\t\r\n\t\tTHREE.Object3D.prototype.clone.call( this, object );\r\n\t\r\n\t\tfor ( var i = 0, l = this.objects.length; i < l; i ++ ) {\r\n\t\t\tvar x = this.objects[ i ].object.clone();\r\n\t\t\tx.visible = i === 0;\r\n\t\t\tobject.addLevel( x, this.objects[ i ].distance );\r\n\t\t}\r\n\t\r\n\t\treturn object;\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/objects/Sprite.js\r\n\t\r\n\t/**\r\n\t * @author mikael emtinger / http://gomo.se/\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t */\r\n\t\r\n\tTHREE.Sprite = ( function () {\r\n\t\r\n\t\tvar indices = new Uint16Array( [ 0, 1, 2,  0, 2, 3 ] );\r\n\t\tvar vertices = new Float32Array( [ - 0.5, - 0.5, 0,   0.5, - 0.5, 0,   0.5, 0.5, 0,   - 0.5, 0.5, 0 ] );\r\n\t\tvar uvs = new Float32Array( [ 0, 0,   1, 0,   1, 1,   0, 1 ] );\r\n\t\r\n\t\tvar geometry = new THREE.BufferGeometry();\r\n\t\tgeometry.addAttribute( 'index', new THREE.BufferAttribute( indices, 1 ) );\r\n\t\tgeometry.addAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );\r\n\t\tgeometry.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ) );\r\n\t\r\n\t\treturn function ( material ) {\r\n\t\r\n\t\t\tTHREE.Object3D.call( this );\r\n\t\r\n\t\t\tthis.type = 'Sprite';\r\n\t\r\n\t\t\tthis.geometry = geometry;\r\n\t\t\tthis.material = ( material !== undefined ) ? material : new THREE.SpriteMaterial();\r\n\t\r\n\t\t};\r\n\t\r\n\t} )();\r\n\t\r\n\tTHREE.Sprite.prototype = Object.create( THREE.Object3D.prototype );\r\n\tTHREE.Sprite.prototype.constructor = THREE.Sprite;\r\n\t\r\n\tTHREE.Sprite.prototype.raycast = ( function () {\r\n\t\r\n\t\tvar matrixPosition = new THREE.Vector3();\r\n\t\r\n\t\treturn function ( raycaster, intersects ) {\r\n\t\r\n\t\t\tmatrixPosition.setFromMatrixPosition( this.matrixWorld );\r\n\t\r\n\t\t\tvar distance = raycaster.ray.distanceToPoint( matrixPosition );\r\n\t\r\n\t\t\tif ( distance > this.scale.x ) {\r\n\t\r\n\t\t\t\treturn;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tintersects.push( {\r\n\t\r\n\t\t\t\tdistance: distance,\r\n\t\t\t\tpoint: this.position,\r\n\t\t\t\tface: null,\r\n\t\t\t\tobject: this\r\n\t\r\n\t\t\t} );\r\n\t\r\n\t\t};\r\n\t\r\n\t}() );\r\n\t\r\n\tTHREE.Sprite.prototype.clone = function ( object ) {\r\n\t\r\n\t\tif ( object === undefined ) object = new THREE.Sprite( this.material );\r\n\t\r\n\t\tTHREE.Object3D.prototype.clone.call( this, object );\r\n\t\r\n\t\treturn object;\r\n\t\r\n\t};\r\n\t\r\n\t// Backwards compatibility\r\n\t\r\n\tTHREE.Particle = THREE.Sprite;\r\n\t\r\n\t// File:src/objects/LensFlare.js\r\n\t\r\n\t/**\r\n\t * @author mikael emtinger / http://gomo.se/\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t */\r\n\t\r\n\tTHREE.LensFlare = function ( texture, size, distance, blending, color ) {\r\n\t\r\n\t\tTHREE.Object3D.call( this );\r\n\t\r\n\t\tthis.lensFlares = [];\r\n\t\r\n\t\tthis.positionScreen = new THREE.Vector3();\r\n\t\tthis.customUpdateCallback = undefined;\r\n\t\r\n\t\tif ( texture !== undefined ) {\r\n\t\r\n\t\t\tthis.add( texture, size, distance, blending, color );\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.LensFlare.prototype = Object.create( THREE.Object3D.prototype );\r\n\tTHREE.LensFlare.prototype.constructor = THREE.LensFlare;\r\n\t\r\n\t\r\n\t/*\r\n\t * Add: adds another flare\r\n\t */\r\n\t\r\n\tTHREE.LensFlare.prototype.add = function ( texture, size, distance, blending, color, opacity ) {\r\n\t\r\n\t\tif ( size === undefined ) size = - 1;\r\n\t\tif ( distance === undefined ) distance = 0;\r\n\t\tif ( opacity === undefined ) opacity = 1;\r\n\t\tif ( color === undefined ) color = new THREE.Color( 0xffffff );\r\n\t\tif ( blending === undefined ) blending = THREE.NormalBlending;\r\n\t\r\n\t\tdistance = Math.min( distance, Math.max( 0, distance ) );\r\n\t\r\n\t\tthis.lensFlares.push( {\r\n\t\t\ttexture: texture, \t\t\t// THREE.Texture\r\n\t\t\tsize: size, \t\t\t\t// size in pixels (-1 = use texture.width)\r\n\t\t\tdistance: distance, \t\t// distance (0-1) from light source (0=at light source)\r\n\t\t\tx: 0, y: 0, z: 0,\t\t\t// screen position (-1 => 1) z = 0 is ontop z = 1 is back\r\n\t\t\tscale: 1, \t\t\t\t\t// scale\r\n\t\t\trotation: 1, \t\t\t\t// rotation\r\n\t\t\topacity: opacity,\t\t\t// opacity\r\n\t\t\tcolor: color,\t\t\t\t// color\r\n\t\t\tblending: blending\t\t\t// blending\r\n\t\t} );\r\n\t\r\n\t};\r\n\t\r\n\t/*\r\n\t * Update lens flares update positions on all flares based on the screen position\r\n\t * Set myLensFlare.customUpdateCallback to alter the flares in your project specific way.\r\n\t */\r\n\t\r\n\tTHREE.LensFlare.prototype.updateLensFlares = function () {\r\n\t\r\n\t\tvar f, fl = this.lensFlares.length;\r\n\t\tvar flare;\r\n\t\tvar vecX = - this.positionScreen.x * 2;\r\n\t\tvar vecY = - this.positionScreen.y * 2;\r\n\t\r\n\t\tfor ( f = 0; f < fl; f ++ ) {\r\n\t\r\n\t\t\tflare = this.lensFlares[ f ];\r\n\t\r\n\t\t\tflare.x = this.positionScreen.x + vecX * flare.distance;\r\n\t\t\tflare.y = this.positionScreen.y + vecY * flare.distance;\r\n\t\r\n\t\t\tflare.wantedRotation = flare.x * Math.PI * 0.25;\r\n\t\t\tflare.rotation += ( flare.wantedRotation - flare.rotation ) * 0.25;\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t\r\n\t// File:src/scenes/Scene.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tTHREE.Scene = function () {\r\n\t\r\n\t\tTHREE.Object3D.call( this );\r\n\t\r\n\t\tthis.type = 'Scene';\r\n\t\r\n\t\tthis.fog = null;\r\n\t\tthis.overrideMaterial = null;\r\n\t\r\n\t\tthis.autoUpdate = true; // checked by the renderer\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Scene.prototype = Object.create( THREE.Object3D.prototype );\r\n\tTHREE.Scene.prototype.constructor = THREE.Scene;\r\n\t\r\n\tTHREE.Scene.prototype.clone = function ( object ) {\r\n\t\r\n\t\tif ( object === undefined ) object = new THREE.Scene();\r\n\t\r\n\t\tTHREE.Object3D.prototype.clone.call( this, object );\r\n\t\r\n\t\tif ( this.fog !== null ) object.fog = this.fog.clone();\r\n\t\tif ( this.overrideMaterial !== null ) object.overrideMaterial = this.overrideMaterial.clone();\r\n\t\r\n\t\tobject.autoUpdate = this.autoUpdate;\r\n\t\tobject.matrixAutoUpdate = this.matrixAutoUpdate;\r\n\t\r\n\t\treturn object;\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/scenes/Fog.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t */\r\n\t\r\n\tTHREE.Fog = function ( color, near, far ) {\r\n\t\r\n\t\tthis.name = '';\r\n\t\r\n\t\tthis.color = new THREE.Color( color );\r\n\t\r\n\t\tthis.near = ( near !== undefined ) ? near : 1;\r\n\t\tthis.far = ( far !== undefined ) ? far : 1000;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Fog.prototype.clone = function () {\r\n\t\r\n\t\treturn new THREE.Fog( this.color.getHex(), this.near, this.far );\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/scenes/FogExp2.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t */\r\n\t\r\n\tTHREE.FogExp2 = function ( color, density ) {\r\n\t\r\n\t\tthis.name = '';\r\n\t\r\n\t\tthis.color = new THREE.Color( color );\r\n\t\tthis.density = ( density !== undefined ) ? density : 0.00025;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.FogExp2.prototype.clone = function () {\r\n\t\r\n\t\treturn new THREE.FogExp2( this.color.getHex(), this.density );\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk.js\r\n\t\r\n\tTHREE.ShaderChunk = {};\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/common.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'common'] = \"#define PI 3.14159\\n#define PI2 6.28318\\n#define RECIPROCAL_PI2 0.15915494\\n#define LOG2 1.442695\\n#define EPSILON 1e-6\\n\\nfloat square( in float a ) { return a*a; }\\nvec2  square( in vec2 a )  { return vec2( a.x*a.x, a.y*a.y ); }\\nvec3  square( in vec3 a )  { return vec3( a.x*a.x, a.y*a.y, a.z*a.z ); }\\nvec4  square( in vec4 a )  { return vec4( a.x*a.x, a.y*a.y, a.z*a.z, a.w*a.w ); }\\nfloat saturate( in float a ) { return clamp( a, 0.0, 1.0 ); }\\nvec2  saturate( in vec2 a )  { return clamp( a, 0.0, 1.0 ); }\\nvec3  saturate( in vec3 a )  { return clamp( a, 0.0, 1.0 ); }\\nvec4  saturate( in vec4 a )  { return clamp( a, 0.0, 1.0 ); }\\nfloat average( in float a ) { return a; }\\nfloat average( in vec2 a )  { return ( a.x + a.y) * 0.5; }\\nfloat average( in vec3 a )  { return ( a.x + a.y + a.z) / 3.0; }\\nfloat average( in vec4 a )  { return ( a.x + a.y + a.z + a.w) * 0.25; }\\nfloat whiteCompliment( in float a ) { return saturate( 1.0 - a ); }\\nvec2  whiteCompliment( in vec2 a )  { return saturate( vec2(1.0) - a ); }\\nvec3  whiteCompliment( in vec3 a )  { return saturate( vec3(1.0) - a ); }\\nvec4  whiteCompliment( in vec4 a )  { return saturate( vec4(1.0) - a ); }\\nvec3 transformDirection( in vec3 normal, in mat4 matrix ) {\\n\treturn normalize( ( matrix * vec4( normal, 0.0 ) ).xyz );\\n}\\n// http://en.wikibooks.org/wiki/GLSL_Programming/Applying_Matrix_Transformations\\nvec3 inverseTransformDirection( in vec3 normal, in mat4 matrix ) {\\n\treturn normalize( ( vec4( normal, 0.0 ) * matrix ).xyz );\\n}\\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal) {\\n\tfloat distance = dot( planeNormal, point-pointOnPlane );\\n\treturn point - distance * planeNormal;\\n}\\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\\n}\\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\\n\treturn pointOnLine + lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) );\\n}\\nfloat calcLightAttenuation( float lightDistance, float cutoffDistance, float decayExponent ) {\\n\tif ( decayExponent > 0.0 ) {\\n\t  return pow( saturate( 1.0 - lightDistance / cutoffDistance ), decayExponent );\\n\t}\\n\treturn 1.0;\\n}\\n\\nvec3 inputToLinear( in vec3 a ) {\\n#ifdef GAMMA_INPUT\\n\treturn pow( a, vec3( float( GAMMA_FACTOR ) ) );\\n#else\\n\treturn a;\\n#endif\\n}\\nvec3 linearToOutput( in vec3 a ) {\\n#ifdef GAMMA_OUTPUT\\n\treturn pow( a, vec3( 1.0 / float( GAMMA_FACTOR ) ) );\\n#else\\n\treturn a;\\n#endif\\n}\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/alphatest_fragment.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'alphatest_fragment'] = \"#ifdef ALPHATEST\\n\\n\tif ( diffuseColor.a < ALPHATEST ) discard;\\n\\n#endif\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/lights_lambert_vertex.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'lights_lambert_vertex'] = \"vLightFront = vec3( 0.0 );\\n\\n#ifdef DOUBLE_SIDED\\n\\n\tvLightBack = vec3( 0.0 );\\n\\n#endif\\n\\ntransformedNormal = normalize( transformedNormal );\\n\\n#if MAX_DIR_LIGHTS > 0\\n\\nfor( int i = 0; i < MAX_DIR_LIGHTS; i ++ ) {\\n\\n\tvec3 dirVector = transformDirection( directionalLightDirection[ i ], viewMatrix );\\n\\n\tfloat dotProduct = dot( transformedNormal, dirVector );\\n\tvec3 directionalLightWeighting = vec3( max( dotProduct, 0.0 ) );\\n\\n\t#ifdef DOUBLE_SIDED\\n\\n\t\tvec3 directionalLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );\\n\\n\t\t#ifdef WRAP_AROUND\\n\\n\t\t\tvec3 directionalLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );\\n\\n\t\t#endif\\n\\n\t#endif\\n\\n\t#ifdef WRAP_AROUND\\n\\n\t\tvec3 directionalLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );\\n\t\tdirectionalLightWeighting = mix( directionalLightWeighting, directionalLightWeightingHalf, wrapRGB );\\n\\n\t\t#ifdef DOUBLE_SIDED\\n\\n\t\t\tdirectionalLightWeightingBack = mix( directionalLightWeightingBack, directionalLightWeightingHalfBack, wrapRGB );\\n\\n\t\t#endif\\n\\n\t#endif\\n\\n\tvLightFront += directionalLightColor[ i ] * directionalLightWeighting;\\n\\n\t#ifdef DOUBLE_SIDED\\n\\n\t\tvLightBack += directionalLightColor[ i ] * directionalLightWeightingBack;\\n\\n\t#endif\\n\\n}\\n\\n#endif\\n\\n#if MAX_POINT_LIGHTS > 0\\n\\n\tfor( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {\\n\\n\t\tvec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );\\n\t\tvec3 lVector = lPosition.xyz - mvPosition.xyz;\\n\\n\t\tfloat attenuation = calcLightAttenuation( length( lVector ), pointLightDistance[ i ], pointLightDecay[ i ] );\\n\\n\t\tlVector = normalize( lVector );\\n\t\tfloat dotProduct = dot( transformedNormal, lVector );\\n\\n\t\tvec3 pointLightWeighting = vec3( max( dotProduct, 0.0 ) );\\n\\n\t\t#ifdef DOUBLE_SIDED\\n\\n\t\t\tvec3 pointLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );\\n\\n\t\t\t#ifdef WRAP_AROUND\\n\\n\t\t\t\tvec3 pointLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );\\n\\n\t\t\t#endif\\n\\n\t\t#endif\\n\\n\t\t#ifdef WRAP_AROUND\\n\\n\t\t\tvec3 pointLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );\\n\t\t\tpointLightWeighting = mix( pointLightWeighting, pointLightWeightingHalf, wrapRGB );\\n\\n\t\t\t#ifdef DOUBLE_SIDED\\n\\n\t\t\t\tpointLightWeightingBack = mix( pointLightWeightingBack, pointLightWeightingHalfBack, wrapRGB );\\n\\n\t\t\t#endif\\n\\n\t\t#endif\\n\\n\t\tvLightFront += pointLightColor[ i ] * pointLightWeighting * attenuation;\\n\\n\t\t#ifdef DOUBLE_SIDED\\n\\n\t\t\tvLightBack += pointLightColor[ i ] * pointLightWeightingBack * attenuation;\\n\\n\t\t#endif\\n\\n\t}\\n\\n#endif\\n\\n#if MAX_SPOT_LIGHTS > 0\\n\\n\tfor( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {\\n\\n\t\tvec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );\\n\t\tvec3 lVector = lPosition.xyz - mvPosition.xyz;\\n\\n\t\tfloat spotEffect = dot( spotLightDirection[ i ], normalize( spotLightPosition[ i ] - worldPosition.xyz ) );\\n\\n\t\tif ( spotEffect > spotLightAngleCos[ i ] ) {\\n\\n\t\t\tspotEffect = max( pow( max( spotEffect, 0.0 ), spotLightExponent[ i ] ), 0.0 );\\n\\n\t\t\tfloat attenuation = calcLightAttenuation( length( lVector ), spotLightDistance[ i ], spotLightDecay[ i ] );\\n\\n\t\t\tlVector = normalize( lVector );\\n\\n\t\t\tfloat dotProduct = dot( transformedNormal, lVector );\\n\t\t\tvec3 spotLightWeighting = vec3( max( dotProduct, 0.0 ) );\\n\\n\t\t\t#ifdef DOUBLE_SIDED\\n\\n\t\t\t\tvec3 spotLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );\\n\\n\t\t\t\t#ifdef WRAP_AROUND\\n\\n\t\t\t\t\tvec3 spotLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );\\n\\n\t\t\t\t#endif\\n\\n\t\t\t#endif\\n\\n\t\t\t#ifdef WRAP_AROUND\\n\\n\t\t\t\tvec3 spotLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );\\n\t\t\t\tspotLightWeighting = mix( spotLightWeighting, spotLightWeightingHalf, wrapRGB );\\n\\n\t\t\t\t#ifdef DOUBLE_SIDED\\n\\n\t\t\t\t\tspotLightWeightingBack = mix( spotLightWeightingBack, spotLightWeightingHalfBack, wrapRGB );\\n\\n\t\t\t\t#endif\\n\\n\t\t\t#endif\\n\\n\t\t\tvLightFront += spotLightColor[ i ] * spotLightWeighting * attenuation * spotEffect;\\n\\n\t\t\t#ifdef DOUBLE_SIDED\\n\\n\t\t\t\tvLightBack += spotLightColor[ i ] * spotLightWeightingBack * attenuation * spotEffect;\\n\\n\t\t\t#endif\\n\\n\t\t}\\n\\n\t}\\n\\n#endif\\n\\n#if MAX_HEMI_LIGHTS > 0\\n\\n\tfor( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {\\n\\n\t\tvec3 lVector = transformDirection( hemisphereLightDirection[ i ], viewMatrix );\\n\\n\t\tfloat dotProduct = dot( transformedNormal, lVector );\\n\\n\t\tfloat hemiDiffuseWeight = 0.5 * dotProduct + 0.5;\\n\t\tfloat hemiDiffuseWeightBack = -0.5 * dotProduct + 0.5;\\n\\n\t\tvLightFront += mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );\\n\\n\t\t#ifdef DOUBLE_SIDED\\n\\n\t\t\tvLightBack += mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeightBack );\\n\\n\t\t#endif\\n\\n\t}\\n\\n#endif\\n\\nvLightFront += ambientLightColor;\\n\\n#ifdef DOUBLE_SIDED\\n\\n\tvLightBack += ambientLightColor;\\n\\n#endif\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/map_particle_pars_fragment.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'map_particle_pars_fragment'] = \"#ifdef USE_MAP\\n\\n\tuniform vec4 offsetRepeat;\\n\tuniform sampler2D map;\\n\\n#endif\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/default_vertex.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'default_vertex'] = \"#ifdef USE_SKINNING\\n\\n\tvec4 mvPosition = modelViewMatrix * skinned;\\n\\n#elif defined( USE_MORPHTARGETS )\\n\\n\tvec4 mvPosition = modelViewMatrix * vec4( morphed, 1.0 );\\n\\n#else\\n\\n\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\\n\\n#endif\\n\\ngl_Position = projectionMatrix * mvPosition;\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/map_pars_fragment.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'map_pars_fragment'] = \"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP )\\n\\n\tvarying vec2 vUv;\\n\\n#endif\\n\\n#ifdef USE_MAP\\n\\n\tuniform sampler2D map;\\n\\n#endif\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/skinnormal_vertex.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'skinnormal_vertex'] = \"#ifdef USE_SKINNING\\n\\n\tmat4 skinMatrix = mat4( 0.0 );\\n\tskinMatrix += skinWeight.x * boneMatX;\\n\tskinMatrix += skinWeight.y * boneMatY;\\n\tskinMatrix += skinWeight.z * boneMatZ;\\n\tskinMatrix += skinWeight.w * boneMatW;\\n\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\\n\\n\t#ifdef USE_MORPHNORMALS\\n\\n\tvec4 skinnedNormal = skinMatrix * vec4( morphedNormal, 0.0 );\\n\\n\t#else\\n\\n\tvec4 skinnedNormal = skinMatrix * vec4( normal, 0.0 );\\n\\n\t#endif\\n\\n#endif\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/logdepthbuf_pars_vertex.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'logdepthbuf_pars_vertex'] = \"#ifdef USE_LOGDEPTHBUF\\n\\n\t#ifdef USE_LOGDEPTHBUF_EXT\\n\\n\t\tvarying float vFragDepth;\\n\\n\t#endif\\n\\n\tuniform float logDepthBufFC;\\n\\n#endif\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/lightmap_pars_vertex.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'lightmap_pars_vertex'] = \"#ifdef USE_LIGHTMAP\\n\\n\tvarying vec2 vUv2;\\n\\n#endif\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/lights_phong_fragment.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'lights_phong_fragment'] = \"#ifndef FLAT_SHADED\\n\\n\tvec3 normal = normalize( vNormal );\\n\\n\t#ifdef DOUBLE_SIDED\\n\\n\t\tnormal = normal * ( -1.0 + 2.0 * float( gl_FrontFacing ) );\\n\\n\t#endif\\n\\n#else\\n\\n\tvec3 fdx = dFdx( vViewPosition );\\n\tvec3 fdy = dFdy( vViewPosition );\\n\tvec3 normal = normalize( cross( fdx, fdy ) );\\n\\n#endif\\n\\nvec3 viewPosition = normalize( vViewPosition );\\n\\n#ifdef USE_NORMALMAP\\n\\n\tnormal = perturbNormal2Arb( -vViewPosition, normal );\\n\\n#elif defined( USE_BUMPMAP )\\n\\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\\n\\n#endif\\n\\nvec3 totalDiffuseLight = vec3( 0.0 );\\nvec3 totalSpecularLight = vec3( 0.0 );\\n\\n#if MAX_POINT_LIGHTS > 0\\n\\n\tfor ( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {\\n\\n\t\tvec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );\\n\t\tvec3 lVector = lPosition.xyz + vViewPosition.xyz;\\n\\n\t\tfloat attenuation = calcLightAttenuation( length( lVector ), pointLightDistance[ i ], pointLightDecay[ i ] );\\n\\n\t\tlVector = normalize( lVector );\\n\\n\t\t// diffuse\\n\\n\t\tfloat dotProduct = dot( normal, lVector );\\n\\n\t\t#ifdef WRAP_AROUND\\n\\n\t\t\tfloat pointDiffuseWeightFull = max( dotProduct, 0.0 );\\n\t\t\tfloat pointDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );\\n\\n\t\t\tvec3 pointDiffuseWeight = mix( vec3( pointDiffuseWeightFull ), vec3( pointDiffuseWeightHalf ), wrapRGB );\\n\\n\t\t#else\\n\\n\t\t\tfloat pointDiffuseWeight = max( dotProduct, 0.0 );\\n\\n\t\t#endif\\n\\n\t\ttotalDiffuseLight += pointLightColor[ i ] * pointDiffuseWeight * attenuation;\\n\\n\t\t\t\t// specular\\n\\n\t\tvec3 pointHalfVector = normalize( lVector + viewPosition );\\n\t\tfloat pointDotNormalHalf = max( dot( normal, pointHalfVector ), 0.0 );\\n\t\tfloat pointSpecularWeight = specularStrength * max( pow( pointDotNormalHalf, shininess ), 0.0 );\\n\\n\t\tfloat specularNormalization = ( shininess + 2.0 ) / 8.0;\\n\\n\t\tvec3 schlick = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( lVector, pointHalfVector ), 0.0 ), 5.0 );\\n\t\ttotalSpecularLight += schlick * pointLightColor[ i ] * pointSpecularWeight * pointDiffuseWeight * attenuation * specularNormalization;\\n\\n\t}\\n\\n#endif\\n\\n#if MAX_SPOT_LIGHTS > 0\\n\\n\tfor ( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {\\n\\n\t\tvec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );\\n\t\tvec3 lVector = lPosition.xyz + vViewPosition.xyz;\\n\\n\t\tfloat attenuation = calcLightAttenuation( length( lVector ), spotLightDistance[ i ], spotLightDecay[ i ] );\\n\\n\t\tlVector = normalize( lVector );\\n\\n\t\tfloat spotEffect = dot( spotLightDirection[ i ], normalize( spotLightPosition[ i ] - vWorldPosition ) );\\n\\n\t\tif ( spotEffect > spotLightAngleCos[ i ] ) {\\n\\n\t\t\tspotEffect = max( pow( max( spotEffect, 0.0 ), spotLightExponent[ i ] ), 0.0 );\\n\\n\t\t\t// diffuse\\n\\n\t\t\tfloat dotProduct = dot( normal, lVector );\\n\\n\t\t\t#ifdef WRAP_AROUND\\n\\n\t\t\t\tfloat spotDiffuseWeightFull = max( dotProduct, 0.0 );\\n\t\t\t\tfloat spotDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );\\n\\n\t\t\t\tvec3 spotDiffuseWeight = mix( vec3( spotDiffuseWeightFull ), vec3( spotDiffuseWeightHalf ), wrapRGB );\\n\\n\t\t\t#else\\n\\n\t\t\t\tfloat spotDiffuseWeight = max( dotProduct, 0.0 );\\n\\n\t\t\t#endif\\n\\n\t\t\ttotalDiffuseLight += spotLightColor[ i ] * spotDiffuseWeight * attenuation * spotEffect;\\n\\n\t\t\t// specular\\n\\n\t\t\tvec3 spotHalfVector = normalize( lVector + viewPosition );\\n\t\t\tfloat spotDotNormalHalf = max( dot( normal, spotHalfVector ), 0.0 );\\n\t\t\tfloat spotSpecularWeight = specularStrength * max( pow( spotDotNormalHalf, shininess ), 0.0 );\\n\\n\t\t\tfloat specularNormalization = ( shininess + 2.0 ) / 8.0;\\n\\n\t\t\tvec3 schlick = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( lVector, spotHalfVector ), 0.0 ), 5.0 );\\n\t\t\ttotalSpecularLight += schlick * spotLightColor[ i ] * spotSpecularWeight * spotDiffuseWeight * attenuation * specularNormalization * spotEffect;\\n\\n\t\t}\\n\\n\t}\\n\\n#endif\\n\\n#if MAX_DIR_LIGHTS > 0\\n\\n\tfor( int i = 0; i < MAX_DIR_LIGHTS; i ++ ) {\\n\\n\t\tvec3 dirVector = transformDirection( directionalLightDirection[ i ], viewMatrix );\\n\\n\t\t// diffuse\\n\\n\t\tfloat dotProduct = dot( normal, dirVector );\\n\\n\t\t#ifdef WRAP_AROUND\\n\\n\t\t\tfloat dirDiffuseWeightFull = max( dotProduct, 0.0 );\\n\t\t\tfloat dirDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );\\n\\n\t\t\tvec3 dirDiffuseWeight = mix( vec3( dirDiffuseWeightFull ), vec3( dirDiffuseWeightHalf ), wrapRGB );\\n\\n\t\t#else\\n\\n\t\t\tfloat dirDiffuseWeight = max( dotProduct, 0.0 );\\n\\n\t\t#endif\\n\\n\t\ttotalDiffuseLight += directionalLightColor[ i ] * dirDiffuseWeight;\\n\\n\t\t// specular\\n\\n\t\tvec3 dirHalfVector = normalize( dirVector + viewPosition );\\n\t\tfloat dirDotNormalHalf = max( dot( normal, dirHalfVector ), 0.0 );\\n\t\tfloat dirSpecularWeight = specularStrength * max( pow( dirDotNormalHalf, shininess ), 0.0 );\\n\\n\t\t/*\\n\t\t// fresnel term from skin shader\\n\t\tconst float F0 = 0.128;\\n\\n\t\tfloat base = 1.0 - dot( viewPosition, dirHalfVector );\\n\t\tfloat exponential = pow( base, 5.0 );\\n\\n\t\tfloat fresnel = exponential + F0 * ( 1.0 - exponential );\\n\t\t*/\\n\\n\t\t/*\\n\t\t// fresnel term from fresnel shader\\n\t\tconst float mFresnelBias = 0.08;\\n\t\tconst float mFresnelScale = 0.3;\\n\t\tconst float mFresnelPower = 5.0;\\n\\n\t\tfloat fresnel = mFresnelBias + mFresnelScale * pow( 1.0 + dot( normalize( -viewPosition ), normal ), mFresnelPower );\\n\t\t*/\\n\\n\t\tfloat specularNormalization = ( shininess + 2.0 ) / 8.0;\\n\\n\t\t// \t\tdirSpecular += specular * directionalLightColor[ i ] * dirSpecularWeight * dirDiffuseWeight * specularNormalization * fresnel;\\n\\n\t\tvec3 schlick = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( dirVector, dirHalfVector ), 0.0 ), 5.0 );\\n\t\ttotalSpecularLight += schlick * directionalLightColor[ i ] * dirSpecularWeight * dirDiffuseWeight * specularNormalization;\\n\\n\\n\t}\\n\\n#endif\\n\\n#if MAX_HEMI_LIGHTS > 0\\n\\n\tfor( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {\\n\\n\t\tvec3 lVector = transformDirection( hemisphereLightDirection[ i ], viewMatrix );\\n\\n\t\t// diffuse\\n\\n\t\tfloat dotProduct = dot( normal, lVector );\\n\t\tfloat hemiDiffuseWeight = 0.5 * dotProduct + 0.5;\\n\\n\t\tvec3 hemiColor = mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );\\n\\n\t\ttotalDiffuseLight += hemiColor;\\n\\n\t\t// specular (sky light)\\n\\n\t\tvec3 hemiHalfVectorSky = normalize( lVector + viewPosition );\\n\t\tfloat hemiDotNormalHalfSky = 0.5 * dot( normal, hemiHalfVectorSky ) + 0.5;\\n\t\tfloat hemiSpecularWeightSky = specularStrength * max( pow( max( hemiDotNormalHalfSky, 0.0 ), shininess ), 0.0 );\\n\\n\t\t// specular (ground light)\\n\\n\t\tvec3 lVectorGround = -lVector;\\n\\n\t\tvec3 hemiHalfVectorGround = normalize( lVectorGround + viewPosition );\\n\t\tfloat hemiDotNormalHalfGround = 0.5 * dot( normal, hemiHalfVectorGround ) + 0.5;\\n\t\tfloat hemiSpecularWeightGround = specularStrength * max( pow( max( hemiDotNormalHalfGround, 0.0 ), shininess ), 0.0 );\\n\\n\t\tfloat dotProductGround = dot( normal, lVectorGround );\\n\\n\t\tfloat specularNormalization = ( shininess + 2.0 ) / 8.0;\\n\\n\t\tvec3 schlickSky = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( lVector, hemiHalfVectorSky ), 0.0 ), 5.0 );\\n\t\tvec3 schlickGround = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( lVectorGround, hemiHalfVectorGround ), 0.0 ), 5.0 );\\n\t\ttotalSpecularLight += hemiColor * specularNormalization * ( schlickSky * hemiSpecularWeightSky * max( dotProduct, 0.0 ) + schlickGround * hemiSpecularWeightGround * max( dotProductGround, 0.0 ) );\\n\\n\t}\\n\\n#endif\\n\\n#ifdef METAL\\n\\n\toutgoingLight += diffuseColor.rgb * ( totalDiffuseLight + ambientLightColor ) * specular + totalSpecularLight + emissive;\\n\\n#else\\n\\n\toutgoingLight += diffuseColor.rgb * ( totalDiffuseLight + ambientLightColor ) + totalSpecularLight + emissive;\\n\\n#endif\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/fog_pars_fragment.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'fog_pars_fragment'] = \"#ifdef USE_FOG\\n\\n\tuniform vec3 fogColor;\\n\\n\t#ifdef FOG_EXP2\\n\\n\t\tuniform float fogDensity;\\n\\n\t#else\\n\\n\t\tuniform float fogNear;\\n\t\tuniform float fogFar;\\n\t#endif\\n\\n#endif\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/morphnormal_vertex.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'morphnormal_vertex'] = \"#ifdef USE_MORPHNORMALS\\n\\n\tvec3 morphedNormal = vec3( 0.0 );\\n\\n\tmorphedNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\\n\tmorphedNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\\n\tmorphedNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\\n\tmorphedNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\\n\\n\tmorphedNormal += normal;\\n\\n#endif\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/envmap_pars_fragment.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'envmap_pars_fragment'] = \"#ifdef USE_ENVMAP\\n\\n\tuniform float reflectivity;\\n\t#ifdef ENVMAP_TYPE_CUBE\\n\t\tuniform samplerCube envMap;\\n\t#else\\n\t\tuniform sampler2D envMap;\\n\t#endif\\n\tuniform float flipEnvMap;\\n\\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\\n\\n\t\tuniform float refractionRatio;\\n\\n\t#else\\n\\n\t\tvarying vec3 vReflect;\\n\\n\t#endif\\n\\n#endif\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/logdepthbuf_fragment.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'logdepthbuf_fragment'] = \"#if defined(USE_LOGDEPTHBUF) && defined(USE_LOGDEPTHBUF_EXT)\\n\\n\tgl_FragDepthEXT = log2(vFragDepth) * logDepthBufFC * 0.5;\\n\\n#endif\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/normalmap_pars_fragment.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'normalmap_pars_fragment'] = \"#ifdef USE_NORMALMAP\\n\\n\tuniform sampler2D normalMap;\\n\tuniform vec2 normalScale;\\n\\n\t// Per-Pixel Tangent Space Normal Mapping\\n\t// http://hacksoflife.blogspot.ch/2009/11/per-pixel-tangent-space-normal-mapping.html\\n\\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\\n\\n\t\tvec3 q0 = dFdx( eye_pos.xyz );\\n\t\tvec3 q1 = dFdy( eye_pos.xyz );\\n\t\tvec2 st0 = dFdx( vUv.st );\\n\t\tvec2 st1 = dFdy( vUv.st );\\n\\n\t\tvec3 S = normalize( q0 * st1.t - q1 * st0.t );\\n\t\tvec3 T = normalize( -q0 * st1.s + q1 * st0.s );\\n\t\tvec3 N = normalize( surf_norm );\\n\\n\t\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\\n\t\tmapN.xy = normalScale * mapN.xy;\\n\t\tmat3 tsn = mat3( S, T, N );\\n\t\treturn normalize( tsn * mapN );\\n\\n\t}\\n\\n#endif\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/lights_phong_pars_vertex.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'lights_phong_pars_vertex'] = \"#if MAX_SPOT_LIGHTS > 0 || defined( USE_BUMPMAP ) || defined( USE_ENVMAP )\\n\\n\tvarying vec3 vWorldPosition;\\n\\n#endif\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/lightmap_pars_fragment.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'lightmap_pars_fragment'] = \"#ifdef USE_LIGHTMAP\\n\\n\tvarying vec2 vUv2;\\n\tuniform sampler2D lightMap;\\n\\n#endif\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/shadowmap_vertex.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'shadowmap_vertex'] = \"#ifdef USE_SHADOWMAP\\n\\n\tfor( int i = 0; i < MAX_SHADOWS; i ++ ) {\\n\\n\t\tvShadowCoord[ i ] = shadowMatrix[ i ] * worldPosition;\\n\\n\t}\\n\\n#endif\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/lights_phong_vertex.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'lights_phong_vertex'] = \"#if MAX_SPOT_LIGHTS > 0 || defined( USE_BUMPMAP ) || defined( USE_ENVMAP )\\n\\n\tvWorldPosition = worldPosition.xyz;\\n\\n#endif\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/map_fragment.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'map_fragment'] = \"#ifdef USE_MAP\\n\\n\tvec4 texelColor = texture2D( map, vUv );\\n\\n\ttexelColor.xyz = inputToLinear( texelColor.xyz );\\n\\n\tdiffuseColor *= texelColor;\\n\\n#endif\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/lightmap_vertex.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'lightmap_vertex'] = \"#ifdef USE_LIGHTMAP\\n\\n\tvUv2 = uv2;\\n\\n#endif\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/map_particle_fragment.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'map_particle_fragment'] = \"#ifdef USE_MAP\\n\\n\tdiffuseColor *= texture2D( map, vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y ) * offsetRepeat.zw + offsetRepeat.xy );\\n\\n#endif\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/color_pars_fragment.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'color_pars_fragment'] = \"#ifdef USE_COLOR\\n\\n\tvarying vec3 vColor;\\n\\n#endif\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/color_vertex.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'color_vertex'] = \"#ifdef USE_COLOR\\n\\n\tvColor.xyz = inputToLinear( color.xyz );\\n\\n#endif\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/skinning_vertex.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'skinning_vertex'] = \"#ifdef USE_SKINNING\\n\\n\t#ifdef USE_MORPHTARGETS\\n\\n\tvec4 skinVertex = bindMatrix * vec4( morphed, 1.0 );\\n\\n\t#else\\n\\n\tvec4 skinVertex = bindMatrix * vec4( position, 1.0 );\\n\\n\t#endif\\n\\n\tvec4 skinned = vec4( 0.0 );\\n\tskinned += boneMatX * skinVertex * skinWeight.x;\\n\tskinned += boneMatY * skinVertex * skinWeight.y;\\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\\n\tskinned += boneMatW * skinVertex * skinWeight.w;\\n\tskinned  = bindMatrixInverse * skinned;\\n\\n#endif\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/envmap_pars_vertex.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'envmap_pars_vertex'] = \"#if defined( USE_ENVMAP ) && ! defined( USE_BUMPMAP ) && ! defined( USE_NORMALMAP ) && ! defined( PHONG )\\n\\n\tvarying vec3 vReflect;\\n\\n\tuniform float refractionRatio;\\n\\n#endif\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/linear_to_gamma_fragment.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'linear_to_gamma_fragment'] = \"\\n\toutgoingLight = linearToOutput( outgoingLight );\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/color_pars_vertex.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'color_pars_vertex'] = \"#ifdef USE_COLOR\\n\\n\tvarying vec3 vColor;\\n\\n#endif\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/lights_lambert_pars_vertex.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'lights_lambert_pars_vertex'] = \"uniform vec3 ambientLightColor;\\n\\n#if MAX_DIR_LIGHTS > 0\\n\\n\tuniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];\\n\tuniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];\\n\\n#endif\\n\\n#if MAX_HEMI_LIGHTS > 0\\n\\n\tuniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];\\n\tuniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];\\n\tuniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];\\n\\n#endif\\n\\n#if MAX_POINT_LIGHTS > 0\\n\\n\tuniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];\\n\tuniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\\n\tuniform float pointLightDistance[ MAX_POINT_LIGHTS ];\\n\tuniform float pointLightDecay[ MAX_POINT_LIGHTS ];\\n\\n#endif\\n\\n#if MAX_SPOT_LIGHTS > 0\\n\\n\tuniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];\\n\tuniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];\\n\tuniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];\\n\tuniform float spotLightDistance[ MAX_SPOT_LIGHTS ];\\n\tuniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];\\n\tuniform float spotLightExponent[ MAX_SPOT_LIGHTS ];\\n\tuniform float spotLightDecay[ MAX_SPOT_LIGHTS ];\\n\\n#endif\\n\\n#ifdef WRAP_AROUND\\n\\n\tuniform vec3 wrapRGB;\\n\\n#endif\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/map_pars_vertex.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'map_pars_vertex'] = \"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP )\\n\\n\tvarying vec2 vUv;\\n\tuniform vec4 offsetRepeat;\\n\\n#endif\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/envmap_fragment.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'envmap_fragment'] = \"#ifdef USE_ENVMAP\\n\\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\\n\\n\t\tvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\\n\\n\t\t// Transforming Normal Vectors with the Inverse Transformation\\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\\n\\n\t\t#ifdef ENVMAP_MODE_REFLECTION\\n\\n\t\t\tvec3 reflectVec = reflect( cameraToVertex, worldNormal );\\n\\n\t\t#else\\n\\n\t\t\tvec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\\n\\n\t\t#endif\\n\\n\t#else\\n\\n\t\tvec3 reflectVec = vReflect;\\n\\n\t#endif\\n\\n\t#ifdef DOUBLE_SIDED\\n\t\tfloat flipNormal = ( -1.0 + 2.0 * float( gl_FrontFacing ) );\\n\t#else\\n\t\tfloat flipNormal = 1.0;\\n\t#endif\\n\\n\t#ifdef ENVMAP_TYPE_CUBE\\n\t\tvec4 envColor = textureCube( envMap, flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\\n\\n\t#elif defined( ENVMAP_TYPE_EQUIREC )\\n\t\tvec2 sampleUV;\\n\t\tsampleUV.y = saturate( flipNormal * reflectVec.y * 0.5 + 0.5 );\\n\t\tsampleUV.x = atan( flipNormal * reflectVec.z, flipNormal * reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\\n\t\tvec4 envColor = texture2D( envMap, sampleUV );\\n\\n\t#elif defined( ENVMAP_TYPE_SPHERE )\\n\t\tvec3 reflectView = flipNormal * normalize((viewMatrix * vec4( reflectVec, 0.0 )).xyz + vec3(0.0,0.0,1.0));\\n\t\tvec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\\n\t#endif\\n\\n\tenvColor.xyz = inputToLinear( envColor.xyz );\\n\\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\\n\\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\\n\\n\t#elif defined( ENVMAP_BLENDING_MIX )\\n\\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\\n\\n\t#elif defined( ENVMAP_BLENDING_ADD )\\n\\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\\n\\n\t#endif\\n\\n#endif\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/specularmap_pars_fragment.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'specularmap_pars_fragment'] = \"#ifdef USE_SPECULARMAP\\n\\n\tuniform sampler2D specularMap;\\n\\n#endif\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/logdepthbuf_vertex.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'logdepthbuf_vertex'] = \"#ifdef USE_LOGDEPTHBUF\\n\\n\tgl_Position.z = log2(max( EPSILON, gl_Position.w + 1.0 )) * logDepthBufFC;\\n\\n\t#ifdef USE_LOGDEPTHBUF_EXT\\n\\n\t\tvFragDepth = 1.0 + gl_Position.w;\\n\\n#else\\n\\n\t\tgl_Position.z = (gl_Position.z - 1.0) * gl_Position.w;\\n\\n\t#endif\\n\\n#endif\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/morphtarget_pars_vertex.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'morphtarget_pars_vertex'] = \"#ifdef USE_MORPHTARGETS\\n\\n\t#ifndef USE_MORPHNORMALS\\n\\n\tuniform float morphTargetInfluences[ 8 ];\\n\\n\t#else\\n\\n\tuniform float morphTargetInfluences[ 4 ];\\n\\n\t#endif\\n\\n#endif\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/specularmap_fragment.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'specularmap_fragment'] = \"float specularStrength;\\n\\n#ifdef USE_SPECULARMAP\\n\\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\\n\tspecularStrength = texelSpecular.r;\\n\\n#else\\n\\n\tspecularStrength = 1.0;\\n\\n#endif\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/fog_fragment.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'fog_fragment'] = \"#ifdef USE_FOG\\n\\n\t#ifdef USE_LOGDEPTHBUF_EXT\\n\\n\t\tfloat depth = gl_FragDepthEXT / gl_FragCoord.w;\\n\\n\t#else\\n\\n\t\tfloat depth = gl_FragCoord.z / gl_FragCoord.w;\\n\\n\t#endif\\n\\n\t#ifdef FOG_EXP2\\n\\n\t\tfloat fogFactor = exp2( - square( fogDensity ) * square( depth ) * LOG2 );\\n\t\tfogFactor = whiteCompliment( fogFactor );\\n\\n\t#else\\n\\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, depth );\\n\\n\t#endif\\n\t\\n\toutgoingLight = mix( outgoingLight, fogColor, fogFactor );\\n\\n#endif\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/bumpmap_pars_fragment.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'bumpmap_pars_fragment'] = \"#ifdef USE_BUMPMAP\\n\\n\tuniform sampler2D bumpMap;\\n\tuniform float bumpScale;\\n\\n\t// Derivative maps - bump mapping unparametrized surfaces by Morten Mikkelsen\\n\t// http://mmikkelsen3d.blogspot.sk/2011/07/derivative-maps.html\\n\\n\t// Evaluate the derivative of the height w.r.t. screen-space using forward differencing (listing 2)\\n\\n\tvec2 dHdxy_fwd() {\\n\\n\t\tvec2 dSTdx = dFdx( vUv );\\n\t\tvec2 dSTdy = dFdy( vUv );\\n\\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\\n\\n\t\treturn vec2( dBx, dBy );\\n\\n\t}\\n\\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\\n\\n\t\tvec3 vSigmaX = dFdx( surf_pos );\\n\t\tvec3 vSigmaY = dFdy( surf_pos );\\n\t\tvec3 vN = surf_norm;\t\t// normalized\\n\\n\t\tvec3 R1 = cross( vSigmaY, vN );\\n\t\tvec3 R2 = cross( vN, vSigmaX );\\n\\n\t\tfloat fDet = dot( vSigmaX, R1 );\\n\\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\\n\\n\t}\\n\\n#endif\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/defaultnormal_vertex.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'defaultnormal_vertex'] = \"#ifdef USE_SKINNING\\n\\n\tvec3 objectNormal = skinnedNormal.xyz;\\n\\n#elif defined( USE_MORPHNORMALS )\\n\\n\tvec3 objectNormal = morphedNormal;\\n\\n#else\\n\\n\tvec3 objectNormal = normal;\\n\\n#endif\\n\\n#ifdef FLIP_SIDED\\n\\n\tobjectNormal = -objectNormal;\\n\\n#endif\\n\\nvec3 transformedNormal = normalMatrix * objectNormal;\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/lights_phong_pars_fragment.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'lights_phong_pars_fragment'] = \"uniform vec3 ambientLightColor;\\n\\n#if MAX_DIR_LIGHTS > 0\\n\\n\tuniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];\\n\tuniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];\\n\\n#endif\\n\\n#if MAX_HEMI_LIGHTS > 0\\n\\n\tuniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];\\n\tuniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];\\n\tuniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];\\n\\n#endif\\n\\n#if MAX_POINT_LIGHTS > 0\\n\\n\tuniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];\\n\\n\tuniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\\n\tuniform float pointLightDistance[ MAX_POINT_LIGHTS ];\\n\tuniform float pointLightDecay[ MAX_POINT_LIGHTS ];\\n\\n#endif\\n\\n#if MAX_SPOT_LIGHTS > 0\\n\\n\tuniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];\\n\tuniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];\\n\tuniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];\\n\tuniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];\\n\tuniform float spotLightExponent[ MAX_SPOT_LIGHTS ];\\n\tuniform float spotLightDistance[ MAX_SPOT_LIGHTS ];\\n\tuniform float spotLightDecay[ MAX_SPOT_LIGHTS ];\\n\\n#endif\\n\\n#if MAX_SPOT_LIGHTS > 0 || defined( USE_BUMPMAP ) || defined( USE_ENVMAP )\\n\\n\tvarying vec3 vWorldPosition;\\n\\n#endif\\n\\n#ifdef WRAP_AROUND\\n\\n\tuniform vec3 wrapRGB;\\n\\n#endif\\n\\nvarying vec3 vViewPosition;\\n\\n#ifndef FLAT_SHADED\\n\\n\tvarying vec3 vNormal;\\n\\n#endif\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/skinbase_vertex.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'skinbase_vertex'] = \"#ifdef USE_SKINNING\\n\\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\\n\\n#endif\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/map_vertex.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'map_vertex'] = \"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP )\\n\\n\tvUv = uv * offsetRepeat.zw + offsetRepeat.xy;\\n\\n#endif\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/lightmap_fragment.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'lightmap_fragment'] = \"#ifdef USE_LIGHTMAP\\n\\n\toutgoingLight *= diffuseColor.xyz * texture2D( lightMap, vUv2 ).xyz;\\n\\n#endif\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/shadowmap_pars_vertex.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'shadowmap_pars_vertex'] = \"#ifdef USE_SHADOWMAP\\n\\n\tvarying vec4 vShadowCoord[ MAX_SHADOWS ];\\n\tuniform mat4 shadowMatrix[ MAX_SHADOWS ];\\n\\n#endif\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/color_fragment.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'color_fragment'] = \"#ifdef USE_COLOR\\n\\n\tdiffuseColor.rgb *= vColor;\\n\\n#endif\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/morphtarget_vertex.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'morphtarget_vertex'] = \"#ifdef USE_MORPHTARGETS\\n\\n\tvec3 morphed = vec3( 0.0 );\\n\tmorphed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\\n\tmorphed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\\n\tmorphed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\\n\tmorphed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\\n\\n\t#ifndef USE_MORPHNORMALS\\n\\n\tmorphed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\\n\tmorphed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\\n\tmorphed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\\n\tmorphed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\\n\\n\t#endif\\n\\n\tmorphed += position;\\n\\n#endif\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/envmap_vertex.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'envmap_vertex'] = \"#if defined( USE_ENVMAP ) && ! defined( USE_BUMPMAP ) && ! defined( USE_NORMALMAP ) && ! defined( PHONG )\\n\\n\tvec3 worldNormal = transformDirection( objectNormal, modelMatrix );\\n\\n\tvec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\\n\\n\t#ifdef ENVMAP_MODE_REFLECTION\\n\\n\t\tvReflect = reflect( cameraToVertex, worldNormal );\\n\\n\t#else\\n\\n\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\\n\\n\t#endif\\n\\n#endif\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/shadowmap_fragment.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'shadowmap_fragment'] = \"#ifdef USE_SHADOWMAP\\n\\n\t#ifdef SHADOWMAP_DEBUG\\n\\n\t\tvec3 frustumColors[3];\\n\t\tfrustumColors[0] = vec3( 1.0, 0.5, 0.0 );\\n\t\tfrustumColors[1] = vec3( 0.0, 1.0, 0.8 );\\n\t\tfrustumColors[2] = vec3( 0.0, 0.5, 1.0 );\\n\\n\t#endif\\n\\n\t#ifdef SHADOWMAP_CASCADE\\n\\n\t\tint inFrustumCount = 0;\\n\\n\t#endif\\n\\n\tfloat fDepth;\\n\tvec3 shadowColor = vec3( 1.0 );\\n\\n\tfor( int i = 0; i < MAX_SHADOWS; i ++ ) {\\n\\n\t\tvec3 shadowCoord = vShadowCoord[ i ].xyz / vShadowCoord[ i ].w;\\n\\n\t\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\\n\t\t\t\t// if ( all( something, something ) ) using this instead\\n\\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\\n\t\tbool inFrustum = all( inFrustumVec );\\n\\n\t\t\t\t// don't shadow pixels outside of light frustum\\n\t\t\t\t// use just first frustum (for cascades)\\n\t\t\t\t// don't shadow pixels behind far plane of light frustum\\n\\n\t\t#ifdef SHADOWMAP_CASCADE\\n\\n\t\t\tinFrustumCount += int( inFrustum );\\n\t\t\tbvec3 frustumTestVec = bvec3( inFrustum, inFrustumCount == 1, shadowCoord.z <= 1.0 );\\n\\n\t\t#else\\n\\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\\n\\n\t\t#endif\\n\\n\t\tbool frustumTest = all( frustumTestVec );\\n\\n\t\tif ( frustumTest ) {\\n\\n\t\t\tshadowCoord.z += shadowBias[ i ];\\n\\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\\n\\n\t\t\t\t\t\t// Percentage-close filtering\\n\t\t\t\t\t\t// (9 pixel kernel)\\n\t\t\t\t\t\t// http://fabiensanglard.net/shadowmappingPCF/\\n\\n\t\t\t\tfloat shadow = 0.0;\\n\\n\t\t/*\\n\t\t\t\t\t\t// nested loops breaks shader compiler / validator on some ATI cards when using OpenGL\\n\t\t\t\t\t\t// must enroll loop manually\\n\\n\t\t\t\tfor ( float y = -1.25; y <= 1.25; y += 1.25 )\\n\t\t\t\t\tfor ( float x = -1.25; x <= 1.25; x += 1.25 ) {\\n\\n\t\t\t\t\t\tvec4 rgbaDepth = texture2D( shadowMap[ i ], vec2( x * xPixelOffset, y * yPixelOffset ) + shadowCoord.xy );\\n\\n\t\t\t\t\t\t\t\t// doesn't seem to produce any noticeable visual difference compared to simple texture2D lookup\\n\t\t\t\t\t\t\t\t//vec4 rgbaDepth = texture2DProj( shadowMap[ i ], vec4( vShadowCoord[ i ].w * ( vec2( x * xPixelOffset, y * yPixelOffset ) + shadowCoord.xy ), 0.05, vShadowCoord[ i ].w ) );\\n\\n\t\t\t\t\t\tfloat fDepth = unpackDepth( rgbaDepth );\\n\\n\t\t\t\t\t\tif ( fDepth < shadowCoord.z )\\n\t\t\t\t\t\t\tshadow += 1.0;\\n\\n\t\t\t\t}\\n\\n\t\t\t\tshadow /= 9.0;\\n\\n\t\t*/\\n\\n\t\t\t\tconst float shadowDelta = 1.0 / 9.0;\\n\\n\t\t\t\tfloat xPixelOffset = 1.0 / shadowMapSize[ i ].x;\\n\t\t\t\tfloat yPixelOffset = 1.0 / shadowMapSize[ i ].y;\\n\\n\t\t\t\tfloat dx0 = -1.25 * xPixelOffset;\\n\t\t\t\tfloat dy0 = -1.25 * yPixelOffset;\\n\t\t\t\tfloat dx1 = 1.25 * xPixelOffset;\\n\t\t\t\tfloat dy1 = 1.25 * yPixelOffset;\\n\\n\t\t\t\tfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy0 ) ) );\\n\t\t\t\tif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\\n\\n\t\t\t\tfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy0 ) ) );\\n\t\t\t\tif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\\n\\n\t\t\t\tfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy0 ) ) );\\n\t\t\t\tif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\\n\\n\t\t\t\tfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, 0.0 ) ) );\\n\t\t\t\tif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\\n\\n\t\t\t\tfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy ) );\\n\t\t\t\tif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\\n\\n\t\t\t\tfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, 0.0 ) ) );\\n\t\t\t\tif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\\n\\n\t\t\t\tfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy1 ) ) );\\n\t\t\t\tif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\\n\\n\t\t\t\tfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy1 ) ) );\\n\t\t\t\tif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\\n\\n\t\t\t\tfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy1 ) ) );\\n\t\t\t\tif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\\n\\n\t\t\t\tshadowColor = shadowColor * vec3( ( 1.0 - shadowDarkness[ i ] * shadow ) );\\n\\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\\n\\n\t\t\t\t\t\t// Percentage-close filtering\\n\t\t\t\t\t\t// (9 pixel kernel)\\n\t\t\t\t\t\t// http://fabiensanglard.net/shadowmappingPCF/\\n\\n\t\t\t\tfloat shadow = 0.0;\\n\\n\t\t\t\tfloat xPixelOffset = 1.0 / shadowMapSize[ i ].x;\\n\t\t\t\tfloat yPixelOffset = 1.0 / shadowMapSize[ i ].y;\\n\\n\t\t\t\tfloat dx0 = -1.0 * xPixelOffset;\\n\t\t\t\tfloat dy0 = -1.0 * yPixelOffset;\\n\t\t\t\tfloat dx1 = 1.0 * xPixelOffset;\\n\t\t\t\tfloat dy1 = 1.0 * yPixelOffset;\\n\\n\t\t\t\tmat3 shadowKernel;\\n\t\t\t\tmat3 depthKernel;\\n\\n\t\t\t\tdepthKernel[0][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy0 ) ) );\\n\t\t\t\tdepthKernel[0][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, 0.0 ) ) );\\n\t\t\t\tdepthKernel[0][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy1 ) ) );\\n\t\t\t\tdepthKernel[1][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy0 ) ) );\\n\t\t\t\tdepthKernel[1][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy ) );\\n\t\t\t\tdepthKernel[1][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy1 ) ) );\\n\t\t\t\tdepthKernel[2][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy0 ) ) );\\n\t\t\t\tdepthKernel[2][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, 0.0 ) ) );\\n\t\t\t\tdepthKernel[2][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy1 ) ) );\\n\\n\t\t\t\tvec3 shadowZ = vec3( shadowCoord.z );\\n\t\t\t\tshadowKernel[0] = vec3(lessThan(depthKernel[0], shadowZ ));\\n\t\t\t\tshadowKernel[0] *= vec3(0.25);\\n\\n\t\t\t\tshadowKernel[1] = vec3(lessThan(depthKernel[1], shadowZ ));\\n\t\t\t\tshadowKernel[1] *= vec3(0.25);\\n\\n\t\t\t\tshadowKernel[2] = vec3(lessThan(depthKernel[2], shadowZ ));\\n\t\t\t\tshadowKernel[2] *= vec3(0.25);\\n\\n\t\t\t\tvec2 fractionalCoord = 1.0 - fract( shadowCoord.xy * shadowMapSize[i].xy );\\n\\n\t\t\t\tshadowKernel[0] = mix( shadowKernel[1], shadowKernel[0], fractionalCoord.x );\\n\t\t\t\tshadowKernel[1] = mix( shadowKernel[2], shadowKernel[1], fractionalCoord.x );\\n\\n\t\t\t\tvec4 shadowValues;\\n\t\t\t\tshadowValues.x = mix( shadowKernel[0][1], shadowKernel[0][0], fractionalCoord.y );\\n\t\t\t\tshadowValues.y = mix( shadowKernel[0][2], shadowKernel[0][1], fractionalCoord.y );\\n\t\t\t\tshadowValues.z = mix( shadowKernel[1][1], shadowKernel[1][0], fractionalCoord.y );\\n\t\t\t\tshadowValues.w = mix( shadowKernel[1][2], shadowKernel[1][1], fractionalCoord.y );\\n\\n\t\t\t\tshadow = dot( shadowValues, vec4( 1.0 ) );\\n\\n\t\t\t\tshadowColor = shadowColor * vec3( ( 1.0 - shadowDarkness[ i ] * shadow ) );\\n\\n\t\t\t#else\\n\\n\t\t\t\tvec4 rgbaDepth = texture2D( shadowMap[ i ], shadowCoord.xy );\\n\t\t\t\tfloat fDepth = unpackDepth( rgbaDepth );\\n\\n\t\t\t\tif ( fDepth < shadowCoord.z )\\n\\n\t\t// spot with multiple shadows is darker\\n\\n\t\t\t\t\tshadowColor = shadowColor * vec3( 1.0 - shadowDarkness[ i ] );\\n\\n\t\t// spot with multiple shadows has the same color as single shadow spot\\n\\n\t\t// \t\t\t\t\tshadowColor = min( shadowColor, vec3( shadowDarkness[ i ] ) );\\n\\n\t\t\t#endif\\n\\n\t\t}\\n\\n\\n\t\t#ifdef SHADOWMAP_DEBUG\\n\\n\t\t\t#ifdef SHADOWMAP_CASCADE\\n\\n\t\t\t\tif ( inFrustum && inFrustumCount == 1 ) outgoingLight *= frustumColors[ i ];\\n\\n\t\t\t#else\\n\\n\t\t\t\tif ( inFrustum ) outgoingLight *= frustumColors[ i ];\\n\\n\t\t\t#endif\\n\\n\t\t#endif\\n\\n\t}\\n\\n\t// NOTE: I am unsure if this is correct in linear space.  -bhouston, Dec 29, 2014\\n\tshadowColor = inputToLinear( shadowColor );\\n\\n\toutgoingLight = outgoingLight * shadowColor;\\n\\n#endif\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/worldpos_vertex.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'worldpos_vertex'] = \"#if defined( USE_ENVMAP ) || defined( PHONG ) || defined( LAMBERT ) || defined ( USE_SHADOWMAP )\\n\\n\t#ifdef USE_SKINNING\\n\\n\t\tvec4 worldPosition = modelMatrix * skinned;\\n\\n\t#elif defined( USE_MORPHTARGETS )\\n\\n\t\tvec4 worldPosition = modelMatrix * vec4( morphed, 1.0 );\\n\\n\t#else\\n\\n\t\tvec4 worldPosition = modelMatrix * vec4( position, 1.0 );\\n\\n\t#endif\\n\\n#endif\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/shadowmap_pars_fragment.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'shadowmap_pars_fragment'] = \"#ifdef USE_SHADOWMAP\\n\\n\tuniform sampler2D shadowMap[ MAX_SHADOWS ];\\n\tuniform vec2 shadowMapSize[ MAX_SHADOWS ];\\n\\n\tuniform float shadowDarkness[ MAX_SHADOWS ];\\n\tuniform float shadowBias[ MAX_SHADOWS ];\\n\\n\tvarying vec4 vShadowCoord[ MAX_SHADOWS ];\\n\\n\tfloat unpackDepth( const in vec4 rgba_depth ) {\\n\\n\t\tconst vec4 bit_shift = vec4( 1.0 / ( 256.0 * 256.0 * 256.0 ), 1.0 / ( 256.0 * 256.0 ), 1.0 / 256.0, 1.0 );\\n\t\tfloat depth = dot( rgba_depth, bit_shift );\\n\t\treturn depth;\\n\\n\t}\\n\\n#endif\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/skinning_pars_vertex.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'skinning_pars_vertex'] = \"#ifdef USE_SKINNING\\n\\n\tuniform mat4 bindMatrix;\\n\tuniform mat4 bindMatrixInverse;\\n\\n\t#ifdef BONE_TEXTURE\\n\\n\t\tuniform sampler2D boneTexture;\\n\t\tuniform int boneTextureWidth;\\n\t\tuniform int boneTextureHeight;\\n\\n\t\tmat4 getBoneMatrix( const in float i ) {\\n\\n\t\t\tfloat j = i * 4.0;\\n\t\t\tfloat x = mod( j, float( boneTextureWidth ) );\\n\t\t\tfloat y = floor( j / float( boneTextureWidth ) );\\n\\n\t\t\tfloat dx = 1.0 / float( boneTextureWidth );\\n\t\t\tfloat dy = 1.0 / float( boneTextureHeight );\\n\\n\t\t\ty = dy * ( y + 0.5 );\\n\\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\\n\\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\\n\\n\t\t\treturn bone;\\n\\n\t\t}\\n\\n\t#else\\n\\n\t\tuniform mat4 boneGlobalMatrices[ MAX_BONES ];\\n\\n\t\tmat4 getBoneMatrix( const in float i ) {\\n\\n\t\t\tmat4 bone = boneGlobalMatrices[ int(i) ];\\n\t\t\treturn bone;\\n\\n\t\t}\\n\\n\t#endif\\n\\n#endif\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/logdepthbuf_pars_fragment.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'logdepthbuf_pars_fragment'] = \"#ifdef USE_LOGDEPTHBUF\\n\\n\tuniform float logDepthBufFC;\\n\\n\t#ifdef USE_LOGDEPTHBUF_EXT\\n\\n\t\t#extension GL_EXT_frag_depth : enable\\n\t\tvarying float vFragDepth;\\n\\n\t#endif\\n\\n#endif\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/alphamap_fragment.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'alphamap_fragment'] = \"#ifdef USE_ALPHAMAP\\n\\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\\n\\n#endif\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/alphamap_pars_fragment.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'alphamap_pars_fragment'] = \"#ifdef USE_ALPHAMAP\\n\\n\tuniform sampler2D alphaMap;\\n\\n#endif\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/UniformsUtils.js\r\n\t\r\n\t/**\r\n\t * Uniform Utilities\r\n\t */\r\n\t\r\n\tTHREE.UniformsUtils = {\r\n\t\r\n\t\tmerge: function ( uniforms ) {\r\n\t\r\n\t\t\tvar merged = {};\r\n\t\r\n\t\t\tfor ( var u = 0; u < uniforms.length; u ++ ) {\r\n\t\r\n\t\t\t\tvar tmp = this.clone( uniforms[ u ] );\r\n\t\r\n\t\t\t\tfor ( var p in tmp ) {\r\n\t\r\n\t\t\t\t\tmerged[ p ] = tmp[ p ];\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn merged;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tclone: function ( uniforms_src ) {\r\n\t\r\n\t\t\tvar uniforms_dst = {};\r\n\t\r\n\t\t\tfor ( var u in uniforms_src ) {\r\n\t\r\n\t\t\t\tuniforms_dst[ u ] = {};\r\n\t\r\n\t\t\t\tfor ( var p in uniforms_src[ u ] ) {\r\n\t\r\n\t\t\t\t\tvar parameter_src = uniforms_src[ u ][ p ];\r\n\t\r\n\t\t\t\t\tif ( parameter_src instanceof THREE.Color ||\r\n\t\t\t\t\t\t parameter_src instanceof THREE.Vector2 ||\r\n\t\t\t\t\t\t parameter_src instanceof THREE.Vector3 ||\r\n\t\t\t\t\t\t parameter_src instanceof THREE.Vector4 ||\r\n\t\t\t\t\t\t parameter_src instanceof THREE.Matrix4 ||\r\n\t\t\t\t\t\t parameter_src instanceof THREE.Texture ) {\r\n\t\r\n\t\t\t\t\t\tuniforms_dst[ u ][ p ] = parameter_src.clone();\r\n\t\r\n\t\t\t\t\t} else if ( parameter_src instanceof Array ) {\r\n\t\r\n\t\t\t\t\t\tuniforms_dst[ u ][ p ] = parameter_src.slice();\r\n\t\r\n\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\tuniforms_dst[ u ][ p ] = parameter_src;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn uniforms_dst;\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/renderers/shaders/UniformsLib.js\r\n\t\r\n\t/**\r\n\t * Uniforms library for shared webgl shaders\r\n\t */\r\n\t\r\n\tTHREE.UniformsLib = {\r\n\t\r\n\t\tcommon: {\r\n\t\r\n\t\t\t\"diffuse\" : { type: \"c\", value: new THREE.Color( 0xeeeeee ) },\r\n\t\t\t\"opacity\" : { type: \"f\", value: 1.0 },\r\n\t\r\n\t\t\t\"map\" : { type: \"t\", value: null },\r\n\t\t\t\"offsetRepeat\" : { type: \"v4\", value: new THREE.Vector4( 0, 0, 1, 1 ) },\r\n\t\r\n\t\t\t\"lightMap\" : { type: \"t\", value: null },\r\n\t\t\t\"specularMap\" : { type: \"t\", value: null },\r\n\t\t\t\"alphaMap\" : { type: \"t\", value: null },\r\n\t\r\n\t\t\t\"envMap\" : { type: \"t\", value: null },\r\n\t\t\t\"flipEnvMap\" : { type: \"f\", value: - 1 },\r\n\t\t\t\"reflectivity\" : { type: \"f\", value: 1.0 },\r\n\t\t\t\"refractionRatio\" : { type: \"f\", value: 0.98 },\r\n\t\r\n\t\t\t\"morphTargetInfluences\" : { type: \"f\", value: 0 }\r\n\t\r\n\t\t},\r\n\t\r\n\t\tbump: {\r\n\t\r\n\t\t\t\"bumpMap\" : { type: \"t\", value: null },\r\n\t\t\t\"bumpScale\" : { type: \"f\", value: 1 }\r\n\t\r\n\t\t},\r\n\t\r\n\t\tnormalmap: {\r\n\t\r\n\t\t\t\"normalMap\" : { type: \"t\", value: null },\r\n\t\t\t\"normalScale\" : { type: \"v2\", value: new THREE.Vector2( 1, 1 ) }\r\n\t\t},\r\n\t\r\n\t\tfog : {\r\n\t\r\n\t\t\t\"fogDensity\" : { type: \"f\", value: 0.00025 },\r\n\t\t\t\"fogNear\" : { type: \"f\", value: 1 },\r\n\t\t\t\"fogFar\" : { type: \"f\", value: 2000 },\r\n\t\t\t\"fogColor\" : { type: \"c\", value: new THREE.Color( 0xffffff ) }\r\n\t\r\n\t\t},\r\n\t\r\n\t\tlights: {\r\n\t\r\n\t\t\t\"ambientLightColor\" : { type: \"fv\", value: [] },\r\n\t\r\n\t\t\t\"directionalLightDirection\" : { type: \"fv\", value: [] },\r\n\t\t\t\"directionalLightColor\" : { type: \"fv\", value: [] },\r\n\t\r\n\t\t\t\"hemisphereLightDirection\" : { type: \"fv\", value: [] },\r\n\t\t\t\"hemisphereLightSkyColor\" : { type: \"fv\", value: [] },\r\n\t\t\t\"hemisphereLightGroundColor\" : { type: \"fv\", value: [] },\r\n\t\r\n\t\t\t\"pointLightColor\" : { type: \"fv\", value: [] },\r\n\t\t\t\"pointLightPosition\" : { type: \"fv\", value: [] },\r\n\t\t\t\"pointLightDistance\" : { type: \"fv1\", value: [] },\r\n\t\t\t\"pointLightDecay\" : { type: \"fv1\", value: [] },\r\n\t\r\n\t\t\t\"spotLightColor\" : { type: \"fv\", value: [] },\r\n\t\t\t\"spotLightPosition\" : { type: \"fv\", value: [] },\r\n\t\t\t\"spotLightDirection\" : { type: \"fv\", value: [] },\r\n\t\t\t\"spotLightDistance\" : { type: \"fv1\", value: [] },\r\n\t\t\t\"spotLightAngleCos\" : { type: \"fv1\", value: [] },\r\n\t\t\t\"spotLightExponent\" : { type: \"fv1\", value: [] },\r\n\t\t\t\"spotLightDecay\" : { type: \"fv1\", value: [] }\r\n\t\r\n\t\t},\r\n\t\r\n\t\tparticle: {\r\n\t\r\n\t\t\t\"psColor\" : { type: \"c\", value: new THREE.Color( 0xeeeeee ) },\r\n\t\t\t\"opacity\" : { type: \"f\", value: 1.0 },\r\n\t\t\t\"size\" : { type: \"f\", value: 1.0 },\r\n\t\t\t\"scale\" : { type: \"f\", value: 1.0 },\r\n\t\t\t\"map\" : { type: \"t\", value: null },\r\n\t\t\t\"offsetRepeat\" : { type: \"v4\", value: new THREE.Vector4( 0, 0, 1, 1 ) },\r\n\t\r\n\t\t\t\"fogDensity\" : { type: \"f\", value: 0.00025 },\r\n\t\t\t\"fogNear\" : { type: \"f\", value: 1 },\r\n\t\t\t\"fogFar\" : { type: \"f\", value: 2000 },\r\n\t\t\t\"fogColor\" : { type: \"c\", value: new THREE.Color( 0xffffff ) }\r\n\t\r\n\t\t},\r\n\t\r\n\t\tshadowmap: {\r\n\t\r\n\t\t\t\"shadowMap\": { type: \"tv\", value: [] },\r\n\t\t\t\"shadowMapSize\": { type: \"v2v\", value: [] },\r\n\t\r\n\t\t\t\"shadowBias\" : { type: \"fv1\", value: [] },\r\n\t\t\t\"shadowDarkness\": { type: \"fv1\", value: [] },\r\n\t\r\n\t\t\t\"shadowMatrix\" : { type: \"m4v\", value: [] }\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/renderers/shaders/ShaderLib.js\r\n\t\r\n\t/**\r\n\t * Webgl Shader Library for three.js\r\n\t *\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t * @author mikael emtinger / http://gomo.se/\r\n\t */\r\n\t\r\n\t\r\n\tTHREE.ShaderLib = {\r\n\t\r\n\t\t'basic': {\r\n\t\r\n\t\t\tuniforms: THREE.UniformsUtils.merge( [\r\n\t\r\n\t\t\t\tTHREE.UniformsLib[ \"common\" ],\r\n\t\t\t\tTHREE.UniformsLib[ \"fog\" ],\r\n\t\t\t\tTHREE.UniformsLib[ \"shadowmap\" ]\r\n\t\r\n\t\t\t] ),\r\n\t\r\n\t\t\tvertexShader: [\r\n\t\r\n\t\t\t\tTHREE.ShaderChunk[ \"common\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"map_pars_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"lightmap_pars_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"envmap_pars_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"color_pars_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"morphtarget_pars_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"skinning_pars_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"shadowmap_pars_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"logdepthbuf_pars_vertex\" ],\r\n\t\r\n\t\t\t\t\"void main() {\",\r\n\t\r\n\t\t\t\t\tTHREE.ShaderChunk[ \"map_vertex\" ],\r\n\t\t\t\t\tTHREE.ShaderChunk[ \"lightmap_vertex\" ],\r\n\t\t\t\t\tTHREE.ShaderChunk[ \"color_vertex\" ],\r\n\t\t\t\t\tTHREE.ShaderChunk[ \"skinbase_vertex\" ],\r\n\t\r\n\t\t\t\t\"\t#ifdef USE_ENVMAP\",\r\n\t\r\n\t\t\t\t\tTHREE.ShaderChunk[ \"morphnormal_vertex\" ],\r\n\t\t\t\t\tTHREE.ShaderChunk[ \"skinnormal_vertex\" ],\r\n\t\t\t\t\tTHREE.ShaderChunk[ \"defaultnormal_vertex\" ],\r\n\t\r\n\t\t\t\t\"\t#endif\",\r\n\t\r\n\t\t\t\t\tTHREE.ShaderChunk[ \"morphtarget_vertex\" ],\r\n\t\t\t\t\tTHREE.ShaderChunk[ \"skinning_vertex\" ],\r\n\t\t\t\t\tTHREE.ShaderChunk[ \"default_vertex\" ],\r\n\t\t\t\t\tTHREE.ShaderChunk[ \"logdepthbuf_vertex\" ],\r\n\t\r\n\t\t\t\t\tTHREE.ShaderChunk[ \"worldpos_vertex\" ],\r\n\t\t\t\t\tTHREE.ShaderChunk[ \"envmap_vertex\" ],\r\n\t\t\t\t\tTHREE.ShaderChunk[ \"shadowmap_vertex\" ],\r\n\t\r\n\t\t\t\t\"}\"\r\n\t\r\n\t\t\t].join(\"\\n\"),\r\n\t\r\n\t\t\tfragmentShader: [\r\n\t\r\n\t\t\t\t\"uniform vec3 diffuse;\",\r\n\t\t\t\t\"uniform float opacity;\",\r\n\t\r\n\t\t\t\tTHREE.ShaderChunk[ \"common\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"color_pars_fragment\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"map_pars_fragment\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"alphamap_pars_fragment\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"lightmap_pars_fragment\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"envmap_pars_fragment\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"fog_pars_fragment\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"shadowmap_pars_fragment\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"specularmap_pars_fragment\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"logdepthbuf_pars_fragment\" ],\r\n\t\r\n\t\t\t\t\"void main() {\",\r\n\t\r\n\t\t\t\t\"\tvec3 outgoingLight = vec3( 0.0 );\",\t// outgoing light does not have an alpha, the surface does\r\n\t\t\t\t\"\tvec4 diffuseColor = vec4( diffuse, opacity );\",\r\n\t\r\n\t\t\t\t\tTHREE.ShaderChunk[ \"logdepthbuf_fragment\" ],\r\n\t\t\t\t\tTHREE.ShaderChunk[ \"map_fragment\" ],\r\n\t\t\t\t\tTHREE.ShaderChunk[ \"color_fragment\" ],\r\n\t\t\t\t\tTHREE.ShaderChunk[ \"alphamap_fragment\" ],\r\n\t\t\t\t\tTHREE.ShaderChunk[ \"alphatest_fragment\" ],\r\n\t\t\t\t\tTHREE.ShaderChunk[ \"specularmap_fragment\" ],\r\n\t\r\n\t\t\t\t\"\toutgoingLight = diffuseColor.rgb;\", // simple shader\r\n\t\r\n\t\t\t\t\tTHREE.ShaderChunk[ \"lightmap_fragment\" ],\t\t// TODO: Light map on an otherwise unlit surface doesn't make sense.\r\n\t\t\t\t\tTHREE.ShaderChunk[ \"envmap_fragment\" ],\r\n\t\t\t\t\tTHREE.ShaderChunk[ \"shadowmap_fragment\" ],\t\t// TODO: Shadows on an otherwise unlit surface doesn't make sense.\r\n\t\r\n\t\t\t\t\tTHREE.ShaderChunk[ \"linear_to_gamma_fragment\" ],\r\n\t\r\n\t\t\t\t\tTHREE.ShaderChunk[ \"fog_fragment\" ],\r\n\t\r\n\t\t\t\t\"\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\",\t// TODO, this should be pre-multiplied to allow for bright highlights on very transparent objects\r\n\t\r\n\t\t\t\t\"}\"\r\n\t\r\n\t\t\t].join(\"\\n\")\r\n\t\r\n\t\t},\r\n\t\r\n\t\t'lambert': {\r\n\t\r\n\t\t\tuniforms: THREE.UniformsUtils.merge( [\r\n\t\r\n\t\t\t\tTHREE.UniformsLib[ \"common\" ],\r\n\t\t\t\tTHREE.UniformsLib[ \"fog\" ],\r\n\t\t\t\tTHREE.UniformsLib[ \"lights\" ],\r\n\t\t\t\tTHREE.UniformsLib[ \"shadowmap\" ],\r\n\t\r\n\t\t\t\t{\r\n\t\t\t\t\t\"emissive\" : { type: \"c\", value: new THREE.Color( 0x000000 ) },\r\n\t\t\t\t\t\"wrapRGB\"  : { type: \"v3\", value: new THREE.Vector3( 1, 1, 1 ) }\r\n\t\t\t\t}\r\n\t\r\n\t\t\t] ),\r\n\t\r\n\t\t\tvertexShader: [\r\n\t\r\n\t\t\t\t\"#define LAMBERT\",\r\n\t\r\n\t\t\t\t\"varying vec3 vLightFront;\",\r\n\t\r\n\t\t\t\t\"#ifdef DOUBLE_SIDED\",\r\n\t\r\n\t\t\t\t\"\tvarying vec3 vLightBack;\",\r\n\t\r\n\t\t\t\t\"#endif\",\r\n\t\r\n\t\t\t\tTHREE.ShaderChunk[ \"common\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"map_pars_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"lightmap_pars_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"envmap_pars_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"lights_lambert_pars_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"color_pars_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"morphtarget_pars_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"skinning_pars_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"shadowmap_pars_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"logdepthbuf_pars_vertex\" ],\r\n\t\r\n\t\t\t\t\"void main() {\",\r\n\t\r\n\t\t\t\t\tTHREE.ShaderChunk[ \"map_vertex\" ],\r\n\t\t\t\t\tTHREE.ShaderChunk[ \"lightmap_vertex\" ],\r\n\t\t\t\t\tTHREE.ShaderChunk[ \"color_vertex\" ],\r\n\t\r\n\t\t\t\t\tTHREE.ShaderChunk[ \"morphnormal_vertex\" ],\r\n\t\t\t\t\tTHREE.ShaderChunk[ \"skinbase_vertex\" ],\r\n\t\t\t\t\tTHREE.ShaderChunk[ \"skinnormal_vertex\" ],\r\n\t\t\t\t\tTHREE.ShaderChunk[ \"defaultnormal_vertex\" ],\r\n\t\r\n\t\t\t\t\tTHREE.ShaderChunk[ \"morphtarget_vertex\" ],\r\n\t\t\t\t\tTHREE.ShaderChunk[ \"skinning_vertex\" ],\r\n\t\t\t\t\tTHREE.ShaderChunk[ \"default_vertex\" ],\r\n\t\t\t\t\tTHREE.ShaderChunk[ \"logdepthbuf_vertex\" ],\r\n\t\r\n\t\t\t\t\tTHREE.ShaderChunk[ \"worldpos_vertex\" ],\r\n\t\t\t\t\tTHREE.ShaderChunk[ \"envmap_vertex\" ],\r\n\t\t\t\t\tTHREE.ShaderChunk[ \"lights_lambert_vertex\" ],\r\n\t\t\t\t\tTHREE.ShaderChunk[ \"shadowmap_vertex\" ],\r\n\t\r\n\t\t\t\t\"}\"\r\n\t\r\n\t\t\t].join(\"\\n\"),\r\n\t\r\n\t\t\tfragmentShader: [\r\n\t\r\n\t\t\t\t\"uniform vec3 diffuse;\",\r\n\t\t\t\t\"uniform vec3 emissive;\",\r\n\t\t\t\t\"uniform float opacity;\",\r\n\t\r\n\t\t\t\t\"varying vec3 vLightFront;\",\r\n\t\r\n\t\t\t\t\"#ifdef DOUBLE_SIDED\",\r\n\t\r\n\t\t\t\t\"\tvarying vec3 vLightBack;\",\r\n\t\r\n\t\t\t\t\"#endif\",\r\n\t\r\n\t\t\t\tTHREE.ShaderChunk[ \"common\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"color_pars_fragment\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"map_pars_fragment\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"alphamap_pars_fragment\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"lightmap_pars_fragment\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"envmap_pars_fragment\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"fog_pars_fragment\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"shadowmap_pars_fragment\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"specularmap_pars_fragment\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"logdepthbuf_pars_fragment\" ],\r\n\t\r\n\t\t\t\t\"void main() {\",\r\n\t\r\n\t\t\t\t\"\tvec3 outgoingLight = vec3( 0.0 );\",\t// outgoing light does not have an alpha, the surface does\r\n\t\t\t\t\"\tvec4 diffuseColor = vec4( diffuse, opacity );\",\r\n\t\r\n\t\t\t\t\tTHREE.ShaderChunk[ \"logdepthbuf_fragment\" ],\r\n\t\t\t\t\tTHREE.ShaderChunk[ \"map_fragment\" ],\r\n\t\t\t\t\tTHREE.ShaderChunk[ \"color_fragment\" ],\r\n\t\t\t\t\tTHREE.ShaderChunk[ \"alphamap_fragment\" ],\r\n\t\t\t\t\tTHREE.ShaderChunk[ \"alphatest_fragment\" ],\r\n\t\t\t\t\tTHREE.ShaderChunk[ \"specularmap_fragment\" ],\r\n\t\r\n\t\t\t\t\"\t#ifdef DOUBLE_SIDED\",\r\n\t\r\n\t\t\t\t\t\t//\"float isFront = float( gl_FrontFacing );\",\r\n\t\t\t\t\t\t//\"gl_FragColor.xyz *= isFront * vLightFront + ( 1.0 - isFront ) * vLightBack;\",\r\n\t\r\n\t\t\t\t\"\t\tif ( gl_FrontFacing )\",\r\n\t\t\t\t\"\t\t\toutgoingLight += diffuseColor.rgb * vLightFront + emissive;\",\r\n\t\t\t\t\"\t\telse\",\r\n\t\t\t\t\"\t\t\toutgoingLight += diffuseColor.rgb * vLightBack + emissive;\",\r\n\t\r\n\t\t\t\t\"\t#else\",\r\n\t\r\n\t\t\t\t\"\t\toutgoingLight += diffuseColor.rgb * vLightFront + emissive;\",\r\n\t\r\n\t\t\t\t\"\t#endif\",\r\n\t\r\n\t\t\t\t\tTHREE.ShaderChunk[ \"lightmap_fragment\" ],\r\n\t\t\t\t\tTHREE.ShaderChunk[ \"envmap_fragment\" ],\r\n\t\t\t\t\tTHREE.ShaderChunk[ \"shadowmap_fragment\" ],\r\n\t\r\n\t\t\t\t\tTHREE.ShaderChunk[ \"linear_to_gamma_fragment\" ],\r\n\t\r\n\t\t\t\t\tTHREE.ShaderChunk[ \"fog_fragment\" ],\r\n\t\r\n\t\t\t\t\"\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\",\t// TODO, this should be pre-multiplied to allow for bright highlights on very transparent objects\r\n\t\r\n\t\t\t\t\"}\"\r\n\t\r\n\t\t\t].join(\"\\n\")\r\n\t\r\n\t\t},\r\n\t\r\n\t\t'phong': {\r\n\t\r\n\t\t\tuniforms: THREE.UniformsUtils.merge( [\r\n\t\r\n\t\t\t\tTHREE.UniformsLib[ \"common\" ],\r\n\t\t\t\tTHREE.UniformsLib[ \"bump\" ],\r\n\t\t\t\tTHREE.UniformsLib[ \"normalmap\" ],\r\n\t\t\t\tTHREE.UniformsLib[ \"fog\" ],\r\n\t\t\t\tTHREE.UniformsLib[ \"lights\" ],\r\n\t\t\t\tTHREE.UniformsLib[ \"shadowmap\" ],\r\n\t\r\n\t\t\t\t{\r\n\t\t\t\t\t\"emissive\" : { type: \"c\", value: new THREE.Color( 0x000000 ) },\r\n\t\t\t\t\t\"specular\" : { type: \"c\", value: new THREE.Color( 0x111111 ) },\r\n\t\t\t\t\t\"shininess\": { type: \"f\", value: 30 },\r\n\t\t\t\t\t\"wrapRGB\"  : { type: \"v3\", value: new THREE.Vector3( 1, 1, 1 ) }\r\n\t\t\t\t}\r\n\t\r\n\t\t\t] ),\r\n\t\r\n\t\t\tvertexShader: [\r\n\t\r\n\t\t\t\t\"#define PHONG\",\r\n\t\r\n\t\t\t\t\"varying vec3 vViewPosition;\",\r\n\t\r\n\t\t\t\t\"#ifndef FLAT_SHADED\",\r\n\t\r\n\t\t\t\t\"\tvarying vec3 vNormal;\",\r\n\t\r\n\t\t\t\t\"#endif\",\r\n\t\r\n\t\t\t\tTHREE.ShaderChunk[ \"common\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"map_pars_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"lightmap_pars_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"envmap_pars_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"lights_phong_pars_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"color_pars_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"morphtarget_pars_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"skinning_pars_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"shadowmap_pars_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"logdepthbuf_pars_vertex\" ],\r\n\t\r\n\t\t\t\t\"void main() {\",\r\n\t\r\n\t\t\t\t\tTHREE.ShaderChunk[ \"map_vertex\" ],\r\n\t\t\t\t\tTHREE.ShaderChunk[ \"lightmap_vertex\" ],\r\n\t\t\t\t\tTHREE.ShaderChunk[ \"color_vertex\" ],\r\n\t\r\n\t\t\t\t\tTHREE.ShaderChunk[ \"morphnormal_vertex\" ],\r\n\t\t\t\t\tTHREE.ShaderChunk[ \"skinbase_vertex\" ],\r\n\t\t\t\t\tTHREE.ShaderChunk[ \"skinnormal_vertex\" ],\r\n\t\t\t\t\tTHREE.ShaderChunk[ \"defaultnormal_vertex\" ],\r\n\t\r\n\t\t\t\t\"#ifndef FLAT_SHADED\", // Normal computed with derivatives when FLAT_SHADED\r\n\t\r\n\t\t\t\t\"\tvNormal = normalize( transformedNormal );\",\r\n\t\r\n\t\t\t\t\"#endif\",\r\n\t\r\n\t\t\t\t\tTHREE.ShaderChunk[ \"morphtarget_vertex\" ],\r\n\t\t\t\t\tTHREE.ShaderChunk[ \"skinning_vertex\" ],\r\n\t\t\t\t\tTHREE.ShaderChunk[ \"default_vertex\" ],\r\n\t\t\t\t\tTHREE.ShaderChunk[ \"logdepthbuf_vertex\" ],\r\n\t\r\n\t\t\t\t\"\tvViewPosition = -mvPosition.xyz;\",\r\n\t\r\n\t\t\t\t\tTHREE.ShaderChunk[ \"worldpos_vertex\" ],\r\n\t\t\t\t\tTHREE.ShaderChunk[ \"envmap_vertex\" ],\r\n\t\t\t\t\tTHREE.ShaderChunk[ \"lights_phong_vertex\" ],\r\n\t\t\t\t\tTHREE.ShaderChunk[ \"shadowmap_vertex\" ],\r\n\t\r\n\t\t\t\t\"}\"\r\n\t\r\n\t\t\t].join(\"\\n\"),\r\n\t\r\n\t\t\tfragmentShader: [\r\n\t\r\n\t\t\t\t\"#define PHONG\",\r\n\t\r\n\t\t\t\t\"uniform vec3 diffuse;\",\r\n\t\t\t\t\"uniform vec3 emissive;\",\r\n\t\t\t\t\"uniform vec3 specular;\",\r\n\t\t\t\t\"uniform float shininess;\",\r\n\t\t\t\t\"uniform float opacity;\",\r\n\t\r\n\t\t\t\tTHREE.ShaderChunk[ \"common\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"color_pars_fragment\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"map_pars_fragment\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"alphamap_pars_fragment\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"lightmap_pars_fragment\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"envmap_pars_fragment\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"fog_pars_fragment\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"lights_phong_pars_fragment\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"shadowmap_pars_fragment\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"bumpmap_pars_fragment\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"normalmap_pars_fragment\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"specularmap_pars_fragment\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"logdepthbuf_pars_fragment\" ],\r\n\t\r\n\t\t\t\t\"void main() {\",\r\n\t\r\n\t\t\t\t\"\tvec3 outgoingLight = vec3( 0.0 );\",\t// outgoing light does not have an alpha, the surface does\r\n\t\t\t\t\"\tvec4 diffuseColor = vec4( diffuse, opacity );\",\r\n\t\r\n\t\t\t\t\tTHREE.ShaderChunk[ \"logdepthbuf_fragment\" ],\r\n\t\t\t\t\tTHREE.ShaderChunk[ \"map_fragment\" ],\r\n\t\t\t\t\tTHREE.ShaderChunk[ \"color_fragment\" ],\r\n\t\t\t\t\tTHREE.ShaderChunk[ \"alphamap_fragment\" ],\r\n\t\t\t\t\tTHREE.ShaderChunk[ \"alphatest_fragment\" ],\r\n\t\t\t\t\tTHREE.ShaderChunk[ \"specularmap_fragment\" ],\r\n\t\r\n\t\t\t\t\tTHREE.ShaderChunk[ \"lights_phong_fragment\" ],\r\n\t\r\n\t\t\t\t\tTHREE.ShaderChunk[ \"lightmap_fragment\" ],\r\n\t\t\t\t\tTHREE.ShaderChunk[ \"envmap_fragment\" ],\r\n\t\t\t\t\tTHREE.ShaderChunk[ \"shadowmap_fragment\" ],\r\n\t\r\n\t\t\t\t\tTHREE.ShaderChunk[ \"linear_to_gamma_fragment\" ],\r\n\t\r\n\t\t\t\t\tTHREE.ShaderChunk[ \"fog_fragment\" ],\r\n\t\r\n\t\t\t\t\"\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\",\t// TODO, this should be pre-multiplied to allow for bright highlights on very transparent objects\r\n\t\r\n\t\t\t\t\"}\"\r\n\t\r\n\t\t\t].join(\"\\n\")\r\n\t\r\n\t\t},\r\n\t\r\n\t\t'particle_basic': {\r\n\t\r\n\t\t\tuniforms: THREE.UniformsUtils.merge( [\r\n\t\r\n\t\t\t\tTHREE.UniformsLib[ \"particle\" ],\r\n\t\t\t\tTHREE.UniformsLib[ \"shadowmap\" ]\r\n\t\r\n\t\t\t] ),\r\n\t\r\n\t\t\tvertexShader: [\r\n\t\r\n\t\t\t\t\"uniform float size;\",\r\n\t\t\t\t\"uniform float scale;\",\r\n\t\r\n\t\t\t\tTHREE.ShaderChunk[ \"common\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"color_pars_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"shadowmap_pars_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"logdepthbuf_pars_vertex\" ],\r\n\t\r\n\t\t\t\t\"void main() {\",\r\n\t\r\n\t\t\t\t\tTHREE.ShaderChunk[ \"color_vertex\" ],\r\n\t\r\n\t\t\t\t\"\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\",\r\n\t\r\n\t\t\t\t\"\t#ifdef USE_SIZEATTENUATION\",\r\n\t\t\t\t\"\t\tgl_PointSize = size * ( scale / length( mvPosition.xyz ) );\",\r\n\t\t\t\t\"\t#else\",\r\n\t\t\t\t\"\t\tgl_PointSize = size;\",\r\n\t\t\t\t\"\t#endif\",\r\n\t\r\n\t\t\t\t\"\tgl_Position = projectionMatrix * mvPosition;\",\r\n\t\r\n\t\t\t\t\tTHREE.ShaderChunk[ \"logdepthbuf_vertex\" ],\r\n\t\t\t\t\tTHREE.ShaderChunk[ \"worldpos_vertex\" ],\r\n\t\t\t\t\tTHREE.ShaderChunk[ \"shadowmap_vertex\" ],\r\n\t\r\n\t\t\t\t\"}\"\r\n\t\r\n\t\t\t].join(\"\\n\"),\r\n\t\r\n\t\t\tfragmentShader: [\r\n\t\r\n\t\t\t\t\"uniform vec3 psColor;\",\r\n\t\t\t\t\"uniform float opacity;\",\r\n\t\r\n\t\t\t\tTHREE.ShaderChunk[ \"common\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"color_pars_fragment\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"map_particle_pars_fragment\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"fog_pars_fragment\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"shadowmap_pars_fragment\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"logdepthbuf_pars_fragment\" ],\r\n\t\r\n\t\t\t\t\"void main() {\",\r\n\t\r\n\t\t\t\t\"\tvec3 outgoingLight = vec3( 0.0 );\",\t// outgoing light does not have an alpha, the surface does\r\n\t\t\t\t\"\tvec4 diffuseColor = vec4( psColor, opacity );\",\r\n\t\r\n\t\t\t\t\tTHREE.ShaderChunk[ \"logdepthbuf_fragment\" ],\r\n\t\t\t\t\tTHREE.ShaderChunk[ \"map_particle_fragment\" ],\r\n\t\t\t\t\tTHREE.ShaderChunk[ \"color_fragment\" ],\r\n\t\t\t\t\tTHREE.ShaderChunk[ \"alphatest_fragment\" ],\r\n\t\r\n\t\t\t\t\"\toutgoingLight = diffuseColor.rgb;\", // simple shader\r\n\t\r\n\t\t\t\t\tTHREE.ShaderChunk[ \"shadowmap_fragment\" ],\r\n\t\t\t\t\tTHREE.ShaderChunk[ \"fog_fragment\" ],\r\n\t\r\n\t\t\t\t\"\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\",\t// TODO, this should be pre-multiplied to allow for bright highlights on very transparent objects\r\n\t\r\n\t\t\t\t\"}\"\r\n\t\r\n\t\t\t].join(\"\\n\")\r\n\t\r\n\t\t},\r\n\t\r\n\t\t'dashed': {\r\n\t\r\n\t\t\tuniforms: THREE.UniformsUtils.merge( [\r\n\t\r\n\t\t\t\tTHREE.UniformsLib[ \"common\" ],\r\n\t\t\t\tTHREE.UniformsLib[ \"fog\" ],\r\n\t\r\n\t\t\t\t{\r\n\t\t\t\t\t\"scale\"    : { type: \"f\", value: 1 },\r\n\t\t\t\t\t\"dashSize\" : { type: \"f\", value: 1 },\r\n\t\t\t\t\t\"totalSize\": { type: \"f\", value: 2 }\r\n\t\t\t\t}\r\n\t\r\n\t\t\t] ),\r\n\t\r\n\t\t\tvertexShader: [\r\n\t\r\n\t\t\t\t\"uniform float scale;\",\r\n\t\t\t\t\"attribute float lineDistance;\",\r\n\t\r\n\t\t\t\t\"varying float vLineDistance;\",\r\n\t\r\n\t\t\t\tTHREE.ShaderChunk[ \"common\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"color_pars_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"logdepthbuf_pars_vertex\" ],\r\n\t\r\n\t\t\t\t\"void main() {\",\r\n\t\r\n\t\t\t\t\tTHREE.ShaderChunk[ \"color_vertex\" ],\r\n\t\r\n\t\t\t\t\"\tvLineDistance = scale * lineDistance;\",\r\n\t\r\n\t\t\t\t\"\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\",\r\n\t\t\t\t\"\tgl_Position = projectionMatrix * mvPosition;\",\r\n\t\r\n\t\t\t\t\tTHREE.ShaderChunk[ \"logdepthbuf_vertex\" ],\r\n\t\r\n\t\t\t\t\"}\"\r\n\t\r\n\t\t\t].join(\"\\n\"),\r\n\t\r\n\t\t\tfragmentShader: [\r\n\t\r\n\t\t\t\t\"uniform vec3 diffuse;\",\r\n\t\t\t\t\"uniform float opacity;\",\r\n\t\r\n\t\t\t\t\"uniform float dashSize;\",\r\n\t\t\t\t\"uniform float totalSize;\",\r\n\t\r\n\t\t\t\t\"varying float vLineDistance;\",\r\n\t\r\n\t\t\t\tTHREE.ShaderChunk[ \"common\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"color_pars_fragment\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"fog_pars_fragment\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"logdepthbuf_pars_fragment\" ],\r\n\t\r\n\t\t\t\t\"void main() {\",\r\n\t\r\n\t\t\t\t\"\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\",\r\n\t\r\n\t\t\t\t\"\t\tdiscard;\",\r\n\t\r\n\t\t\t\t\"\t}\",\r\n\t\r\n\t\t\t\t\"\tvec3 outgoingLight = vec3( 0.0 );\",\t// outgoing light does not have an alpha, the surface does\r\n\t\t\t\t\"\tvec4 diffuseColor = vec4( diffuse, opacity );\",\r\n\t\r\n\t\t\t\t\tTHREE.ShaderChunk[ \"logdepthbuf_fragment\" ],\r\n\t\t\t\t\tTHREE.ShaderChunk[ \"color_fragment\" ],\r\n\t\r\n\t\t\t\t\"\toutgoingLight = diffuseColor.rgb;\", // simple shader\r\n\t\r\n\t\t\t\t\tTHREE.ShaderChunk[ \"fog_fragment\" ],\r\n\t\r\n\t\t\t\t\"\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\",\t// TODO, this should be pre-multiplied to allow for bright highlights on very transparent objects\r\n\t\r\n\t\t\t\t\"}\"\r\n\t\r\n\t\t\t].join(\"\\n\")\r\n\t\r\n\t\t},\r\n\t\r\n\t\t'depth': {\r\n\t\r\n\t\t\tuniforms: {\r\n\t\r\n\t\t\t\t\"mNear\": { type: \"f\", value: 1.0 },\r\n\t\t\t\t\"mFar\" : { type: \"f\", value: 2000.0 },\r\n\t\t\t\t\"opacity\" : { type: \"f\", value: 1.0 }\r\n\t\r\n\t\t\t},\r\n\t\r\n\t\t\tvertexShader: [\r\n\t\r\n\t\t\t\tTHREE.ShaderChunk[ \"common\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"morphtarget_pars_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"logdepthbuf_pars_vertex\" ],\r\n\t\r\n\t\t\t\t\"void main() {\",\r\n\t\r\n\t\t\t\t\tTHREE.ShaderChunk[ \"morphtarget_vertex\" ],\r\n\t\t\t\t\tTHREE.ShaderChunk[ \"default_vertex\" ],\r\n\t\t\t\t\tTHREE.ShaderChunk[ \"logdepthbuf_vertex\" ],\r\n\t\r\n\t\t\t\t\"}\"\r\n\t\r\n\t\t\t].join(\"\\n\"),\r\n\t\r\n\t\t\tfragmentShader: [\r\n\t\r\n\t\t\t\t\"uniform float mNear;\",\r\n\t\t\t\t\"uniform float mFar;\",\r\n\t\t\t\t\"uniform float opacity;\",\r\n\t\r\n\t\t\t\tTHREE.ShaderChunk[ \"common\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"logdepthbuf_pars_fragment\" ],\r\n\t\r\n\t\t\t\t\"void main() {\",\r\n\t\r\n\t\t\t\t\tTHREE.ShaderChunk[ \"logdepthbuf_fragment\" ],\r\n\t\r\n\t\t\t\t\"\t#ifdef USE_LOGDEPTHBUF_EXT\",\r\n\t\r\n\t\t\t\t\"\t\tfloat depth = gl_FragDepthEXT / gl_FragCoord.w;\",\r\n\t\r\n\t\t\t\t\"\t#else\",\r\n\t\r\n\t\t\t\t\"\t\tfloat depth = gl_FragCoord.z / gl_FragCoord.w;\",\r\n\t\r\n\t\t\t\t\"\t#endif\",\r\n\t\r\n\t\t\t\t\"\tfloat color = 1.0 - smoothstep( mNear, mFar, depth );\",\r\n\t\t\t\t\"\tgl_FragColor = vec4( vec3( color ), opacity );\",   // TODO, this should be pre-multiplied to allow for bright highlights on very transparent objects\r\n\t\r\n\t\t\t\t\"}\"\r\n\t\r\n\t\t\t].join(\"\\n\")\r\n\t\r\n\t\t},\r\n\t\r\n\t\t'normal': {\r\n\t\r\n\t\t\tuniforms: {\r\n\t\r\n\t\t\t\t\"opacity\" : { type: \"f\", value: 1.0 }\r\n\t\r\n\t\t\t},\r\n\t\r\n\t\t\tvertexShader: [\r\n\t\r\n\t\t\t\t\"varying vec3 vNormal;\",\r\n\t\r\n\t\t\t\tTHREE.ShaderChunk[ \"common\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"morphtarget_pars_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"logdepthbuf_pars_vertex\" ],\r\n\t\r\n\t\t\t\t\"void main() {\",\r\n\t\r\n\t\t\t\t\"\tvNormal = normalize( normalMatrix * normal );\",\r\n\t\r\n\t\t\t\t\tTHREE.ShaderChunk[ \"morphtarget_vertex\" ],\r\n\t\t\t\t\tTHREE.ShaderChunk[ \"default_vertex\" ],\r\n\t\t\t\t\tTHREE.ShaderChunk[ \"logdepthbuf_vertex\" ],\r\n\t\r\n\t\t\t\t\"}\"\r\n\t\r\n\t\t\t].join(\"\\n\"),\r\n\t\r\n\t\t\tfragmentShader: [\r\n\t\r\n\t\t\t\t\"uniform float opacity;\",\r\n\t\t\t\t\"varying vec3 vNormal;\",\r\n\t\r\n\t\t\t\tTHREE.ShaderChunk[ \"common\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"logdepthbuf_pars_fragment\" ],\r\n\t\r\n\t\t\t\t\"void main() {\",\r\n\t\r\n\t\t\t\t\"\tgl_FragColor = vec4( 0.5 * normalize( vNormal ) + 0.5, opacity );\",\r\n\t\r\n\t\t\t\t\tTHREE.ShaderChunk[ \"logdepthbuf_fragment\" ],\r\n\t\r\n\t\t\t\t\"}\"\r\n\t\r\n\t\t\t].join(\"\\n\")\r\n\t\r\n\t\t},\r\n\t\r\n\t\t/* -------------------------------------------------------------------------\r\n\t\t//\tCube map shader\r\n\t\t ------------------------------------------------------------------------- */\r\n\t\r\n\t\t'cube': {\r\n\t\r\n\t\t\tuniforms: { \"tCube\": { type: \"t\", value: null },\r\n\t\t\t\t\t\t\"tFlip\": { type: \"f\", value: - 1 } },\r\n\t\r\n\t\t\tvertexShader: [\r\n\t\r\n\t\t\t\t\"varying vec3 vWorldPosition;\",\r\n\t\r\n\t\t\t\tTHREE.ShaderChunk[ \"common\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"logdepthbuf_pars_vertex\" ],\r\n\t\r\n\t\t\t\t\"void main() {\",\r\n\t\r\n\t\t\t\t\"\tvWorldPosition = transformDirection( position, modelMatrix );\",\r\n\t\r\n\t\t\t\t\"\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\r\n\t\r\n\t\t\t\t\tTHREE.ShaderChunk[ \"logdepthbuf_vertex\" ],\r\n\t\r\n\t\t\t\t\"}\"\r\n\t\r\n\t\t\t].join(\"\\n\"),\r\n\t\r\n\t\t\tfragmentShader: [\r\n\t\r\n\t\t\t\t\"uniform samplerCube tCube;\",\r\n\t\t\t\t\"uniform float tFlip;\",\r\n\t\r\n\t\t\t\t\"varying vec3 vWorldPosition;\",\r\n\t\r\n\t\t\t\tTHREE.ShaderChunk[ \"common\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"logdepthbuf_pars_fragment\" ],\r\n\t\r\n\t\t\t\t\"void main() {\",\r\n\t\r\n\t\t\t\t\"\tgl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );\",\r\n\t\r\n\t\t\t\t\tTHREE.ShaderChunk[ \"logdepthbuf_fragment\" ],\r\n\t\r\n\t\t\t\t\"}\"\r\n\t\r\n\t\t\t].join(\"\\n\")\r\n\t\r\n\t\t},\r\n\t\r\n\t\t/* -------------------------------------------------------------------------\r\n\t\t//\tCube map shader\r\n\t\t ------------------------------------------------------------------------- */\r\n\t\r\n\t\t'equirect': {\r\n\t\r\n\t\t\tuniforms: { \"tEquirect\": { type: \"t\", value: null },\r\n\t\t\t\t\t\t\"tFlip\": { type: \"f\", value: - 1 } },\r\n\t\r\n\t\t\tvertexShader: [\r\n\t\r\n\t\t\t\t\"varying vec3 vWorldPosition;\",\r\n\t\r\n\t\t\t\tTHREE.ShaderChunk[ \"common\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"logdepthbuf_pars_vertex\" ],\r\n\t\r\n\t\t\t\t\"void main() {\",\r\n\t\r\n\t\t\t\t\"\tvWorldPosition = transformDirection( position, modelMatrix );\",\r\n\t\r\n\t\t\t\t\"\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\r\n\t\r\n\t\t\t\t\tTHREE.ShaderChunk[ \"logdepthbuf_vertex\" ],\r\n\t\r\n\t\t\t\t\"}\"\r\n\t\r\n\t\t\t].join(\"\\n\"),\r\n\t\r\n\t\t\tfragmentShader: [\r\n\t\r\n\t\t\t\t\"uniform sampler2D tEquirect;\",\r\n\t\t\t\t\"uniform float tFlip;\",\r\n\t\r\n\t\t\t\t\"varying vec3 vWorldPosition;\",\r\n\t\r\n\t\t\t\tTHREE.ShaderChunk[ \"common\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"logdepthbuf_pars_fragment\" ],\r\n\t\r\n\t\t\t\t\"void main() {\",\r\n\t\r\n\t\t\t\t\t// \"\tgl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );\",\r\n\t\t\t\t\t\"vec3 direction = normalize( vWorldPosition );\",\r\n\t\t\t\t\t\"vec2 sampleUV;\",\r\n\t\t\t\t\t\"sampleUV.y = saturate( tFlip * direction.y * -0.5 + 0.5 );\",\r\n\t\t\t\t\t\"sampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\",\r\n\t\t\t\t\t\"gl_FragColor = texture2D( tEquirect, sampleUV );\",\r\n\t\r\n\t\t\t\t\tTHREE.ShaderChunk[ \"logdepthbuf_fragment\" ],\r\n\t\r\n\t\t\t\t\"}\"\r\n\t\r\n\t\t\t].join(\"\\n\")\r\n\t\r\n\t\t},\r\n\t\r\n\t\t/* Depth encoding into RGBA texture\r\n\t\t *\r\n\t\t * based on SpiderGL shadow map example\r\n\t\t * http://spidergl.org/example.php?id=6\r\n\t\t *\r\n\t\t * originally from\r\n\t\t * http://www.gamedev.net/topic/442138-packing-a-float-into-a-a8r8g8b8-texture-shader/page__whichpage__1%25EF%25BF%25BD\r\n\t\t *\r\n\t\t * see also\r\n\t\t * http://aras-p.info/blog/2009/07/30/encoding-floats-to-rgba-the-final/\r\n\t\t */\r\n\t\r\n\t\t'depthRGBA': {\r\n\t\r\n\t\t\tuniforms: {},\r\n\t\r\n\t\t\tvertexShader: [\r\n\t\r\n\t\t\t\tTHREE.ShaderChunk[ \"common\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"morphtarget_pars_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"skinning_pars_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"logdepthbuf_pars_vertex\" ],\r\n\t\r\n\t\t\t\t\"void main() {\",\r\n\t\r\n\t\t\t\t\tTHREE.ShaderChunk[ \"skinbase_vertex\" ],\r\n\t\t\t\t\tTHREE.ShaderChunk[ \"morphtarget_vertex\" ],\r\n\t\t\t\t\tTHREE.ShaderChunk[ \"skinning_vertex\" ],\r\n\t\t\t\t\tTHREE.ShaderChunk[ \"default_vertex\" ],\r\n\t\t\t\t\tTHREE.ShaderChunk[ \"logdepthbuf_vertex\" ],\r\n\t\r\n\t\t\t\t\"}\"\r\n\t\r\n\t\t\t].join(\"\\n\"),\r\n\t\r\n\t\t\tfragmentShader: [\r\n\t\r\n\t\t\t\tTHREE.ShaderChunk[ \"common\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"logdepthbuf_pars_fragment\" ],\r\n\t\r\n\t\t\t\t\"vec4 pack_depth( const in float depth ) {\",\r\n\t\r\n\t\t\t\t\"\tconst vec4 bit_shift = vec4( 256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0 );\",\r\n\t\t\t\t\"\tconst vec4 bit_mask = vec4( 0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0 );\",\r\n\t\t\t\t\"\tvec4 res = mod( depth * bit_shift * vec4( 255 ), vec4( 256 ) ) / vec4( 255 );\", // \"\tvec4 res = fract( depth * bit_shift );\",\r\n\t\t\t\t\"\tres -= res.xxyz * bit_mask;\",\r\n\t\t\t\t\"\treturn res;\",\r\n\t\r\n\t\t\t\t\"}\",\r\n\t\r\n\t\t\t\t\"void main() {\",\r\n\t\r\n\t\t\t\t\tTHREE.ShaderChunk[ \"logdepthbuf_fragment\" ],\r\n\t\r\n\t\t\t\t\"\t#ifdef USE_LOGDEPTHBUF_EXT\",\r\n\t\r\n\t\t\t\t\"\t\tgl_FragData[ 0 ] = pack_depth( gl_FragDepthEXT );\",\r\n\t\r\n\t\t\t\t\"\t#else\",\r\n\t\r\n\t\t\t\t\"\t\tgl_FragData[ 0 ] = pack_depth( gl_FragCoord.z );\",\r\n\t\r\n\t\t\t\t\"\t#endif\",\r\n\t\r\n\t\t\t\t\t//\"gl_FragData[ 0 ] = pack_depth( gl_FragCoord.z / gl_FragCoord.w );\",\r\n\t\t\t\t\t//\"float z = ( ( gl_FragCoord.z / gl_FragCoord.w ) - 3.0 ) / ( 4000.0 - 3.0 );\",\r\n\t\t\t\t\t//\"gl_FragData[ 0 ] = pack_depth( z );\",\r\n\t\t\t\t\t//\"gl_FragData[ 0 ] = vec4( z, z, z, 1.0 );\",\r\n\t\r\n\t\t\t\t\"}\"\r\n\t\r\n\t\t\t].join(\"\\n\")\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/renderers/WebGLRenderer.js\r\n\t\r\n\t/**\r\n\t * @author supereggbert / http://www.paulbrunt.co.uk/\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t * @author szimek / https://github.com/szimek/\r\n\t */\r\n\t\r\n\tTHREE.WebGLRenderer = function ( parameters ) {\r\n\t\r\n\t\tconsole.log( 'THREE.WebGLRenderer', THREE.REVISION );\r\n\t\r\n\t\tparameters = parameters || {};\r\n\t\r\n\t\tvar _canvas = parameters.canvas !== undefined ? parameters.canvas : document.createElement( 'canvas' ),\r\n\t\t_context = parameters.context !== undefined ? parameters.context : null,\r\n\t\r\n\t\tpixelRatio = 1,\r\n\t\r\n\t\t_precision = parameters.precision !== undefined ? parameters.precision : 'highp',\r\n\t\r\n\t\t_alpha = parameters.alpha !== undefined ? parameters.alpha : false,\r\n\t\t_depth = parameters.depth !== undefined ? parameters.depth : true,\r\n\t\t_stencil = parameters.stencil !== undefined ? parameters.stencil : true,\r\n\t\t_antialias = parameters.antialias !== undefined ? parameters.antialias : false,\r\n\t\t_premultipliedAlpha = parameters.premultipliedAlpha !== undefined ? parameters.premultipliedAlpha : true,\r\n\t\t_preserveDrawingBuffer = parameters.preserveDrawingBuffer !== undefined ? parameters.preserveDrawingBuffer : false,\r\n\t\t_logarithmicDepthBuffer = parameters.logarithmicDepthBuffer !== undefined ? parameters.logarithmicDepthBuffer : false,\r\n\t\r\n\t\t_clearColor = new THREE.Color( 0x000000 ),\r\n\t\t_clearAlpha = 0;\r\n\t\r\n\t\tvar lights = [];\r\n\t\r\n\t\tvar _webglObjects = {};\r\n\t\tvar _webglObjectsImmediate = [];\r\n\t\r\n\t\tvar opaqueObjects = [];\r\n\t\tvar transparentObjects = [];\r\n\t\r\n\t\tvar sprites = [];\r\n\t\tvar lensFlares = [];\r\n\t\r\n\t\t// public properties\r\n\t\r\n\t\tthis.domElement = _canvas;\r\n\t\tthis.context = null;\r\n\t\r\n\t\t// clearing\r\n\t\r\n\t\tthis.autoClear = true;\r\n\t\tthis.autoClearColor = true;\r\n\t\tthis.autoClearDepth = true;\r\n\t\tthis.autoClearStencil = true;\r\n\t\r\n\t\t// scene graph\r\n\t\r\n\t\tthis.sortObjects = true;\r\n\t\r\n\t\t// physically based shading\r\n\t\r\n\t\tthis.gammaFactor = 2.0;\t// for backwards compatibility\r\n\t\tthis.gammaInput = false;\r\n\t\tthis.gammaOutput = false;\r\n\t\r\n\t\t// shadow map\r\n\t\r\n\t\tthis.shadowMapEnabled = false;\r\n\t\tthis.shadowMapType = THREE.PCFShadowMap;\r\n\t\tthis.shadowMapCullFace = THREE.CullFaceFront;\r\n\t\tthis.shadowMapDebug = false;\r\n\t\tthis.shadowMapCascade = false;\r\n\t\r\n\t\t// morphs\r\n\t\r\n\t\tthis.maxMorphTargets = 8;\r\n\t\tthis.maxMorphNormals = 4;\r\n\t\r\n\t\t// flags\r\n\t\r\n\t\tthis.autoScaleCubemaps = true;\r\n\t\r\n\t\t// info\r\n\t\r\n\t\tthis.info = {\r\n\t\r\n\t\t\tmemory: {\r\n\t\r\n\t\t\t\tprograms: 0,\r\n\t\t\t\tgeometries: 0,\r\n\t\t\t\ttextures: 0\r\n\t\r\n\t\t\t},\r\n\t\r\n\t\t\trender: {\r\n\t\r\n\t\t\t\tcalls: 0,\r\n\t\t\t\tvertices: 0,\r\n\t\t\t\tfaces: 0,\r\n\t\t\t\tpoints: 0\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t\t// internal properties\r\n\t\r\n\t\tvar _this = this,\r\n\t\r\n\t\t_programs = [],\r\n\t\r\n\t\t// internal state cache\r\n\t\r\n\t\t_currentProgram = null,\r\n\t\t_currentFramebuffer = null,\r\n\t\t_currentMaterialId = - 1,\r\n\t\t_currentGeometryProgram = '',\r\n\t\t_currentCamera = null,\r\n\t\r\n\t\t_usedTextureUnits = 0,\r\n\t\r\n\t\t_viewportX = 0,\r\n\t\t_viewportY = 0,\r\n\t\t_viewportWidth = _canvas.width,\r\n\t\t_viewportHeight = _canvas.height,\r\n\t\t_currentWidth = 0,\r\n\t\t_currentHeight = 0,\r\n\t\r\n\t\t// frustum\r\n\t\r\n\t\t_frustum = new THREE.Frustum(),\r\n\t\r\n\t\t // camera matrices cache\r\n\t\r\n\t\t_projScreenMatrix = new THREE.Matrix4(),\r\n\t\r\n\t\t_vector3 = new THREE.Vector3(),\r\n\t\r\n\t\t// light arrays cache\r\n\t\r\n\t\t_direction = new THREE.Vector3(),\r\n\t\r\n\t\t_lightsNeedUpdate = true,\r\n\t\r\n\t\t_lights = {\r\n\t\r\n\t\t\tambient: [ 0, 0, 0 ],\r\n\t\t\tdirectional: { length: 0, colors:[], positions: [] },\r\n\t\t\tpoint: { length: 0, colors: [], positions: [], distances: [], decays: [] },\r\n\t\t\tspot: { length: 0, colors: [], positions: [], distances: [], directions: [], anglesCos: [], exponents: [], decays: [] },\r\n\t\t\themi: { length: 0, skyColors: [], groundColors: [], positions: [] }\r\n\t\r\n\t\t};\r\n\t\r\n\t\t// initialize\r\n\t\r\n\t\tvar _gl;\r\n\t\r\n\t\ttry {\r\n\t\r\n\t\t\tvar attributes = {\r\n\t\t\t\talpha: _alpha,\r\n\t\t\t\tdepth: _depth,\r\n\t\t\t\tstencil: _stencil,\r\n\t\t\t\tantialias: _antialias,\r\n\t\t\t\tpremultipliedAlpha: _premultipliedAlpha,\r\n\t\t\t\tpreserveDrawingBuffer: _preserveDrawingBuffer\r\n\t\t\t};\r\n\t\r\n\t\t\t_gl = _context || _canvas.getContext( 'webgl', attributes ) || _canvas.getContext( 'experimental-webgl', attributes );\r\n\t\r\n\t\t\tif ( _gl === null ) {\r\n\t\r\n\t\t\t\tif ( _canvas.getContext( 'webgl') !== null ) {\r\n\t\r\n\t\t\t\t\tthrow 'Error creating WebGL context with your selected attributes.';\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tthrow 'Error creating WebGL context.';\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t_canvas.addEventListener( 'webglcontextlost', function ( event ) {\r\n\t\r\n\t\t\t\tevent.preventDefault();\r\n\t\r\n\t\t\t\tresetGLState();\r\n\t\t\t\tsetDefaultGLState();\r\n\t\r\n\t\t\t\t_webglObjects = {};\r\n\t\r\n\t\t\t}, false);\r\n\t\r\n\t\t} catch ( error ) {\r\n\t\r\n\t\t\tTHREE.error( 'THREE.WebGLRenderer: ' + error );\r\n\t\r\n\t\t}\r\n\t\r\n\t\tvar state = new THREE.WebGLState( _gl, paramThreeToGL );\r\n\t\r\n\t\tif ( _gl.getShaderPrecisionFormat === undefined ) {\r\n\t\r\n\t\t\t_gl.getShaderPrecisionFormat = function () {\r\n\t\r\n\t\t\t\treturn {\r\n\t\t\t\t\t'rangeMin': 1,\r\n\t\t\t\t\t'rangeMax': 1,\r\n\t\t\t\t\t'precision': 1\r\n\t\t\t\t};\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\tvar extensions = new THREE.WebGLExtensions( _gl );\r\n\t\r\n\t\textensions.get( 'OES_texture_float' );\r\n\t\textensions.get( 'OES_texture_float_linear' );\r\n\t\textensions.get( 'OES_texture_half_float' );\r\n\t\textensions.get( 'OES_texture_half_float_linear' );\r\n\t\textensions.get( 'OES_standard_derivatives' );\r\n\t\r\n\t\tif ( _logarithmicDepthBuffer ) {\r\n\t\r\n\t\t\textensions.get( 'EXT_frag_depth' );\r\n\t\r\n\t\t}\r\n\t\r\n\t\t//\r\n\t\r\n\t\tvar glClearColor = function ( r, g, b, a ) {\r\n\t\r\n\t\t\tif ( _premultipliedAlpha === true ) {\r\n\t\r\n\t\t\t\tr *= a; g *= a; b *= a;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t_gl.clearColor( r, g, b, a );\r\n\t\r\n\t\t};\r\n\t\r\n\t\tvar setDefaultGLState = function () {\r\n\t\r\n\t\t\t_gl.clearColor( 0, 0, 0, 1 );\r\n\t\t\t_gl.clearDepth( 1 );\r\n\t\t\t_gl.clearStencil( 0 );\r\n\t\r\n\t\t\t_gl.enable( _gl.DEPTH_TEST );\r\n\t\t\t_gl.depthFunc( _gl.LEQUAL );\r\n\t\r\n\t\t\t_gl.frontFace( _gl.CCW );\r\n\t\t\t_gl.cullFace( _gl.BACK );\r\n\t\t\t_gl.enable( _gl.CULL_FACE );\r\n\t\r\n\t\t\t_gl.enable( _gl.BLEND );\r\n\t\t\t_gl.blendEquation( _gl.FUNC_ADD );\r\n\t\t\t_gl.blendFunc( _gl.SRC_ALPHA, _gl.ONE_MINUS_SRC_ALPHA );\r\n\t\r\n\t\t\t_gl.viewport( _viewportX, _viewportY, _viewportWidth, _viewportHeight );\r\n\t\r\n\t\t\tglClearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );\r\n\t\r\n\t\t};\r\n\t\r\n\t\tvar resetGLState = function () {\r\n\t\r\n\t\t\t_currentProgram = null;\r\n\t\t\t_currentCamera = null;\r\n\t\r\n\t\t\t_currentGeometryProgram = '';\r\n\t\t\t_currentMaterialId = - 1;\r\n\t\r\n\t\t\t_lightsNeedUpdate = true;\r\n\t\r\n\t\t\tstate.reset();\r\n\t\r\n\t\t};\r\n\t\r\n\t\tsetDefaultGLState();\r\n\t\r\n\t\tthis.context = _gl;\r\n\t\tthis.state = state;\r\n\t\r\n\t\t// GPU capabilities\r\n\t\r\n\t\tvar _maxTextures = _gl.getParameter( _gl.MAX_TEXTURE_IMAGE_UNITS );\r\n\t\tvar _maxVertexTextures = _gl.getParameter( _gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS );\r\n\t\tvar _maxTextureSize = _gl.getParameter( _gl.MAX_TEXTURE_SIZE );\r\n\t\tvar _maxCubemapSize = _gl.getParameter( _gl.MAX_CUBE_MAP_TEXTURE_SIZE );\r\n\t\r\n\t\tvar _supportsVertexTextures = _maxVertexTextures > 0;\r\n\t\tvar _supportsBoneTextures = _supportsVertexTextures && extensions.get( 'OES_texture_float' );\r\n\t\r\n\t\t//\r\n\t\r\n\t\tvar _vertexShaderPrecisionHighpFloat = _gl.getShaderPrecisionFormat( _gl.VERTEX_SHADER, _gl.HIGH_FLOAT );\r\n\t\tvar _vertexShaderPrecisionMediumpFloat = _gl.getShaderPrecisionFormat( _gl.VERTEX_SHADER, _gl.MEDIUM_FLOAT );\r\n\t\r\n\t\tvar _fragmentShaderPrecisionHighpFloat = _gl.getShaderPrecisionFormat( _gl.FRAGMENT_SHADER, _gl.HIGH_FLOAT );\r\n\t\tvar _fragmentShaderPrecisionMediumpFloat = _gl.getShaderPrecisionFormat( _gl.FRAGMENT_SHADER, _gl.MEDIUM_FLOAT );\r\n\t\r\n\t\tvar getCompressedTextureFormats = ( function () {\r\n\t\r\n\t\t\tvar array;\r\n\t\r\n\t\t\treturn function () {\r\n\t\r\n\t\t\t\tif ( array !== undefined ) {\r\n\t\r\n\t\t\t\t\treturn array;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tarray = [];\r\n\t\r\n\t\t\t\tif ( extensions.get( 'WEBGL_compressed_texture_pvrtc' ) || extensions.get( 'WEBGL_compressed_texture_s3tc' ) ) {\r\n\t\r\n\t\t\t\t\tvar formats = _gl.getParameter( _gl.COMPRESSED_TEXTURE_FORMATS );\r\n\t\r\n\t\t\t\t\tfor ( var i = 0; i < formats.length; i ++ ) {\r\n\t\r\n\t\t\t\t\t\tarray.push( formats[ i ] );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\treturn array;\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t} )();\r\n\t\r\n\t\t// clamp precision to maximum available\r\n\t\r\n\t\tvar highpAvailable = _vertexShaderPrecisionHighpFloat.precision > 0 && _fragmentShaderPrecisionHighpFloat.precision > 0;\r\n\t\tvar mediumpAvailable = _vertexShaderPrecisionMediumpFloat.precision > 0 && _fragmentShaderPrecisionMediumpFloat.precision > 0;\r\n\t\r\n\t\tif ( _precision === 'highp' && ! highpAvailable ) {\r\n\t\r\n\t\t\tif ( mediumpAvailable ) {\r\n\t\r\n\t\t\t\t_precision = 'mediump';\r\n\t\t\t\tTHREE.warn( 'THREE.WebGLRenderer: highp not supported, using mediump.' );\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\t_precision = 'lowp';\r\n\t\t\t\tTHREE.warn( 'THREE.WebGLRenderer: highp and mediump not supported, using lowp.' );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\tif ( _precision === 'mediump' && ! mediumpAvailable ) {\r\n\t\r\n\t\t\t_precision = 'lowp';\r\n\t\t\tTHREE.warn( 'THREE.WebGLRenderer: mediump not supported, using lowp.' );\r\n\t\r\n\t\t}\r\n\t\r\n\t\t// Plugins\r\n\t\r\n\t\tvar shadowMapPlugin = new THREE.ShadowMapPlugin( this, lights, _webglObjects, _webglObjectsImmediate );\r\n\t\r\n\t\tvar spritePlugin = new THREE.SpritePlugin( this, sprites );\r\n\t\tvar lensFlarePlugin = new THREE.LensFlarePlugin( this, lensFlares );\r\n\t\r\n\t\t// API\r\n\t\r\n\t\tthis.getContext = function () {\r\n\t\r\n\t\t\treturn _gl;\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.forceContextLoss = function () {\r\n\t\r\n\t\t\textensions.get( 'WEBGL_lose_context' ).loseContext();\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.supportsVertexTextures = function () {\r\n\t\r\n\t\t\treturn _supportsVertexTextures;\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.supportsFloatTextures = function () {\r\n\t\r\n\t\t\treturn extensions.get( 'OES_texture_float' );\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.supportsHalfFloatTextures = function () {\r\n\t\r\n\t\t\treturn extensions.get( 'OES_texture_half_float' );\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.supportsStandardDerivatives = function () {\r\n\t\r\n\t\t\treturn extensions.get( 'OES_standard_derivatives' );\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.supportsCompressedTextureS3TC = function () {\r\n\t\r\n\t\t\treturn extensions.get( 'WEBGL_compressed_texture_s3tc' );\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.supportsCompressedTexturePVRTC = function () {\r\n\t\r\n\t\t\treturn extensions.get( 'WEBGL_compressed_texture_pvrtc' );\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.supportsBlendMinMax = function () {\r\n\t\r\n\t\t\treturn extensions.get( 'EXT_blend_minmax' );\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.getMaxAnisotropy = ( function () {\r\n\t\r\n\t\t\tvar value;\r\n\t\r\n\t\t\treturn function () {\r\n\t\r\n\t\t\t\tif ( value !== undefined ) {\r\n\t\r\n\t\t\t\t\treturn value;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tvar extension = extensions.get( 'EXT_texture_filter_anisotropic' );\r\n\t\r\n\t\t\t\tvalue = extension !== null ? _gl.getParameter( extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT ) : 0;\r\n\t\r\n\t\t\t\treturn value;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t} )();\r\n\t\r\n\t\tthis.getPrecision = function () {\r\n\t\r\n\t\t\treturn _precision;\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.getPixelRatio = function () {\r\n\t\r\n\t\t\treturn pixelRatio;\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.setPixelRatio = function ( value ) {\r\n\t\r\n\t\t\tpixelRatio = value;\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.setSize = function ( width, height, updateStyle ) {\r\n\t\r\n\t\t\t_canvas.width = width * pixelRatio;\r\n\t\t\t_canvas.height = height * pixelRatio;\r\n\t\r\n\t\t\tif ( updateStyle !== false ) {\r\n\t\r\n\t\t\t\t_canvas.style.width = width + 'px';\r\n\t\t\t\t_canvas.style.height = height + 'px';\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tthis.setViewport( 0, 0, width, height );\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.setViewport = function ( x, y, width, height ) {\r\n\t\r\n\t\t\t_viewportX = x * pixelRatio;\r\n\t\t\t_viewportY = y * pixelRatio;\r\n\t\r\n\t\t\t_viewportWidth = width * pixelRatio;\r\n\t\t\t_viewportHeight = height * pixelRatio;\r\n\t\r\n\t\t\t_gl.viewport( _viewportX, _viewportY, _viewportWidth, _viewportHeight );\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.setScissor = function ( x, y, width, height ) {\r\n\t\r\n\t\t\t_gl.scissor(\r\n\t\t\t\tx * pixelRatio,\r\n\t\t\t\ty * pixelRatio,\r\n\t\t\t\twidth * pixelRatio,\r\n\t\t\t\theight * pixelRatio\r\n\t\t\t);\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.enableScissorTest = function ( enable ) {\r\n\t\r\n\t\t\tenable ? _gl.enable( _gl.SCISSOR_TEST ) : _gl.disable( _gl.SCISSOR_TEST );\r\n\t\r\n\t\t};\r\n\t\r\n\t\t// Clearing\r\n\t\r\n\t\tthis.getClearColor = function () {\r\n\t\r\n\t\t\treturn _clearColor;\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.setClearColor = function ( color, alpha ) {\r\n\t\r\n\t\t\t_clearColor.set( color );\r\n\t\r\n\t\t\t_clearAlpha = alpha !== undefined ? alpha : 1;\r\n\t\r\n\t\t\tglClearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.getClearAlpha = function () {\r\n\t\r\n\t\t\treturn _clearAlpha;\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.setClearAlpha = function ( alpha ) {\r\n\t\r\n\t\t\t_clearAlpha = alpha;\r\n\t\r\n\t\t\tglClearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.clear = function ( color, depth, stencil ) {\r\n\t\r\n\t\t\tvar bits = 0;\r\n\t\r\n\t\t\tif ( color === undefined || color ) bits |= _gl.COLOR_BUFFER_BIT;\r\n\t\t\tif ( depth === undefined || depth ) bits |= _gl.DEPTH_BUFFER_BIT;\r\n\t\t\tif ( stencil === undefined || stencil ) bits |= _gl.STENCIL_BUFFER_BIT;\r\n\t\r\n\t\t\t_gl.clear( bits );\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.clearColor = function () {\r\n\t\r\n\t\t\t_gl.clear( _gl.COLOR_BUFFER_BIT );\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.clearDepth = function () {\r\n\t\r\n\t\t\t_gl.clear( _gl.DEPTH_BUFFER_BIT );\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.clearStencil = function () {\r\n\t\r\n\t\t\t_gl.clear( _gl.STENCIL_BUFFER_BIT );\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.clearTarget = function ( renderTarget, color, depth, stencil ) {\r\n\t\r\n\t\t\tthis.setRenderTarget( renderTarget );\r\n\t\t\tthis.clear( color, depth, stencil );\r\n\t\r\n\t\t};\r\n\t\r\n\t\t// Reset\r\n\t\r\n\t\tthis.resetGLState = resetGLState;\r\n\t\r\n\t\t// Buffer allocation\r\n\t\r\n\t\tfunction createParticleBuffers ( geometry ) {\r\n\t\r\n\t\t\tgeometry.__webglVertexBuffer = _gl.createBuffer();\r\n\t\t\tgeometry.__webglColorBuffer = _gl.createBuffer();\r\n\t\r\n\t\t\t_this.info.memory.geometries ++;\r\n\t\r\n\t\t};\r\n\t\r\n\t\tfunction createLineBuffers ( geometry ) {\r\n\t\r\n\t\t\tgeometry.__webglVertexBuffer = _gl.createBuffer();\r\n\t\t\tgeometry.__webglColorBuffer = _gl.createBuffer();\r\n\t\t\tgeometry.__webglLineDistanceBuffer = _gl.createBuffer();\r\n\t\r\n\t\t\t_this.info.memory.geometries ++;\r\n\t\r\n\t\t};\r\n\t\r\n\t\tfunction createMeshBuffers ( geometryGroup ) {\r\n\t\r\n\t\t\tgeometryGroup.__webglVertexBuffer = _gl.createBuffer();\r\n\t\t\tgeometryGroup.__webglNormalBuffer = _gl.createBuffer();\r\n\t\t\tgeometryGroup.__webglTangentBuffer = _gl.createBuffer();\r\n\t\t\tgeometryGroup.__webglColorBuffer = _gl.createBuffer();\r\n\t\t\tgeometryGroup.__webglUVBuffer = _gl.createBuffer();\r\n\t\t\tgeometryGroup.__webglUV2Buffer = _gl.createBuffer();\r\n\t\r\n\t\t\tgeometryGroup.__webglSkinIndicesBuffer = _gl.createBuffer();\r\n\t\t\tgeometryGroup.__webglSkinWeightsBuffer = _gl.createBuffer();\r\n\t\r\n\t\t\tgeometryGroup.__webglFaceBuffer = _gl.createBuffer();\r\n\t\t\tgeometryGroup.__webglLineBuffer = _gl.createBuffer();\r\n\t\r\n\t\t\tvar numMorphTargets = geometryGroup.numMorphTargets;\r\n\t\r\n\t\t\tif ( numMorphTargets ) {\r\n\t\r\n\t\t\t\tgeometryGroup.__webglMorphTargetsBuffers = [];\r\n\t\r\n\t\t\t\tfor ( var m = 0, ml = numMorphTargets; m < ml; m ++ ) {\r\n\t\r\n\t\t\t\t\tgeometryGroup.__webglMorphTargetsBuffers.push( _gl.createBuffer() );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar numMorphNormals = geometryGroup.numMorphNormals;\r\n\t\r\n\t\t\tif ( numMorphNormals ) {\r\n\t\r\n\t\t\t\tgeometryGroup.__webglMorphNormalsBuffers = [];\r\n\t\r\n\t\t\t\tfor ( var m = 0, ml = numMorphNormals; m < ml; m ++ ) {\r\n\t\r\n\t\t\t\t\tgeometryGroup.__webglMorphNormalsBuffers.push( _gl.createBuffer() );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t_this.info.memory.geometries ++;\r\n\t\r\n\t\t};\r\n\t\r\n\t\t// Events\r\n\t\r\n\t\tvar onObjectRemoved = function ( event ) {\r\n\t\r\n\t\t\tvar object = event.target;\r\n\t\r\n\t\t\tobject.traverse( function ( child ) {\r\n\t\r\n\t\t\t\tchild.removeEventListener( 'remove', onObjectRemoved );\r\n\t\r\n\t\t\t\tremoveObject( child );\r\n\t\r\n\t\t\t} );\r\n\t\r\n\t\t};\r\n\t\r\n\t\tvar onGeometryDispose = function ( event ) {\r\n\t\r\n\t\t\tvar geometry = event.target;\r\n\t\r\n\t\t\tgeometry.removeEventListener( 'dispose', onGeometryDispose );\r\n\t\r\n\t\t\tdeallocateGeometry( geometry );\r\n\t\r\n\t\t};\r\n\t\r\n\t\tvar onTextureDispose = function ( event ) {\r\n\t\r\n\t\t\tvar texture = event.target;\r\n\t\r\n\t\t\ttexture.removeEventListener( 'dispose', onTextureDispose );\r\n\t\r\n\t\t\tdeallocateTexture( texture );\r\n\t\r\n\t\t\t_this.info.memory.textures --;\r\n\t\r\n\t\r\n\t\t};\r\n\t\r\n\t\tvar onRenderTargetDispose = function ( event ) {\r\n\t\r\n\t\t\tvar renderTarget = event.target;\r\n\t\r\n\t\t\trenderTarget.removeEventListener( 'dispose', onRenderTargetDispose );\r\n\t\r\n\t\t\tdeallocateRenderTarget( renderTarget );\r\n\t\r\n\t\t\t_this.info.memory.textures --;\r\n\t\r\n\t\t};\r\n\t\r\n\t\tvar onMaterialDispose = function ( event ) {\r\n\t\r\n\t\t\tvar material = event.target;\r\n\t\r\n\t\t\tmaterial.removeEventListener( 'dispose', onMaterialDispose );\r\n\t\r\n\t\t\tdeallocateMaterial( material );\r\n\t\r\n\t\t};\r\n\t\r\n\t\t// Buffer deallocation\r\n\t\r\n\t\tvar deleteBuffers = function ( geometry ) {\r\n\t\r\n\t\t\tvar buffers = [\r\n\t\t\t\t'__webglVertexBuffer',\r\n\t\t\t\t'__webglNormalBuffer',\r\n\t\t\t\t'__webglTangentBuffer',\r\n\t\t\t\t'__webglColorBuffer',\r\n\t\t\t\t'__webglUVBuffer',\r\n\t\t\t\t'__webglUV2Buffer',\r\n\t\r\n\t\t\t\t'__webglSkinIndicesBuffer',\r\n\t\t\t\t'__webglSkinWeightsBuffer',\r\n\t\r\n\t\t\t\t'__webglFaceBuffer',\r\n\t\t\t\t'__webglLineBuffer',\r\n\t\r\n\t\t\t\t'__webglLineDistanceBuffer'\r\n\t\t\t];\r\n\t\r\n\t\t\tfor ( var i = 0, l = buffers.length; i < l; i ++ ) {\r\n\t\r\n\t\t\t\tvar name = buffers[ i ];\r\n\t\r\n\t\t\t\tif ( geometry[ name ] !== undefined ) {\r\n\t\r\n\t\t\t\t\t_gl.deleteBuffer( geometry[ name ] );\r\n\t\r\n\t\t\t\t\tdelete geometry[ name ];\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// custom attributes\r\n\t\r\n\t\t\tif ( geometry.__webglCustomAttributesList !== undefined ) {\r\n\t\r\n\t\t\t\tfor ( var name in geometry.__webglCustomAttributesList ) {\r\n\t\r\n\t\t\t\t\t_gl.deleteBuffer( geometry.__webglCustomAttributesList[ name ].buffer );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tdelete geometry.__webglCustomAttributesList;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t_this.info.memory.geometries --;\r\n\t\r\n\t\t};\r\n\t\r\n\t\tvar deallocateGeometry = function ( geometry ) {\r\n\t\r\n\t\t\tdelete geometry.__webglInit;\r\n\t\r\n\t\t\tif ( geometry instanceof THREE.BufferGeometry ) {\r\n\t\r\n\t\t\t\tfor ( var name in geometry.attributes ) {\r\n\t\r\n\t\t\t\t\tvar attribute = geometry.attributes[ name ];\r\n\t\r\n\t\t\t\t\tif ( attribute.buffer !== undefined ) {\r\n\t\r\n\t\t\t\t\t\t_gl.deleteBuffer( attribute.buffer );\r\n\t\r\n\t\t\t\t\t\tdelete attribute.buffer;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\t_this.info.memory.geometries --;\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\tvar geometryGroupsList = geometryGroups[ geometry.id ];\r\n\t\r\n\t\t\t\tif ( geometryGroupsList !== undefined ) {\r\n\t\r\n\t\t\t\t\tfor ( var i = 0, l = geometryGroupsList.length; i < l; i ++ ) {\r\n\t\r\n\t\t\t\t\t\tvar geometryGroup = geometryGroupsList[ i ];\r\n\t\r\n\t\t\t\t\t\tif ( geometryGroup.numMorphTargets !== undefined ) {\r\n\t\r\n\t\t\t\t\t\t\tfor ( var m = 0, ml = geometryGroup.numMorphTargets; m < ml; m ++ ) {\r\n\t\r\n\t\t\t\t\t\t\t\t_gl.deleteBuffer( geometryGroup.__webglMorphTargetsBuffers[ m ] );\r\n\t\r\n\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t\tdelete geometryGroup.__webglMorphTargetsBuffers;\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\tif ( geometryGroup.numMorphNormals !== undefined ) {\r\n\t\r\n\t\t\t\t\t\t\tfor ( var m = 0, ml = geometryGroup.numMorphNormals; m < ml; m ++ ) {\r\n\t\r\n\t\t\t\t\t\t\t\t_gl.deleteBuffer( geometryGroup.__webglMorphNormalsBuffers[ m ] );\r\n\t\r\n\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t\tdelete geometryGroup.__webglMorphNormalsBuffers;\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\tdeleteBuffers( geometryGroup );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tdelete geometryGroups[ geometry.id ];\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tdeleteBuffers( geometry );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// TOFIX: Workaround for deleted geometry being currently bound\r\n\t\r\n\t\t\t_currentGeometryProgram = '';\r\n\t\r\n\t\t};\r\n\t\r\n\t\tvar deallocateTexture = function ( texture ) {\r\n\t\r\n\t\t\tif ( texture.image && texture.image.__webglTextureCube ) {\r\n\t\r\n\t\t\t\t// cube texture\r\n\t\r\n\t\t\t\t_gl.deleteTexture( texture.image.__webglTextureCube );\r\n\t\r\n\t\t\t\tdelete texture.image.__webglTextureCube;\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\t// 2D texture\r\n\t\r\n\t\t\t\tif ( texture.__webglInit === undefined ) return;\r\n\t\r\n\t\t\t\t_gl.deleteTexture( texture.__webglTexture );\r\n\t\r\n\t\t\t\tdelete texture.__webglTexture;\r\n\t\t\t\tdelete texture.__webglInit;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t\tvar deallocateRenderTarget = function ( renderTarget ) {\r\n\t\r\n\t\t\tif ( ! renderTarget || renderTarget.__webglTexture === undefined ) return;\r\n\t\r\n\t\t\t_gl.deleteTexture( renderTarget.__webglTexture );\r\n\t\r\n\t\t\tdelete renderTarget.__webglTexture;\r\n\t\r\n\t\t\tif ( renderTarget instanceof THREE.WebGLRenderTargetCube ) {\r\n\t\r\n\t\t\t\tfor ( var i = 0; i < 6; i ++ ) {\r\n\t\r\n\t\t\t\t\t_gl.deleteFramebuffer( renderTarget.__webglFramebuffer[ i ] );\r\n\t\t\t\t\t_gl.deleteRenderbuffer( renderTarget.__webglRenderbuffer[ i ] );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\t_gl.deleteFramebuffer( renderTarget.__webglFramebuffer );\r\n\t\t\t\t_gl.deleteRenderbuffer( renderTarget.__webglRenderbuffer );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tdelete renderTarget.__webglFramebuffer;\r\n\t\t\tdelete renderTarget.__webglRenderbuffer;\r\n\t\r\n\t\t};\r\n\t\r\n\t\tvar deallocateMaterial = function ( material ) {\r\n\t\r\n\t\t\tvar program = material.program.program;\r\n\t\r\n\t\t\tif ( program === undefined ) return;\r\n\t\r\n\t\t\tmaterial.program = undefined;\r\n\t\r\n\t\t\t// only deallocate GL program if this was the last use of shared program\r\n\t\t\t// assumed there is only single copy of any program in the _programs list\r\n\t\t\t// (that's how it's constructed)\r\n\t\r\n\t\t\tvar i, il, programInfo;\r\n\t\t\tvar deleteProgram = false;\r\n\t\r\n\t\t\tfor ( i = 0, il = _programs.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\tprogramInfo = _programs[ i ];\r\n\t\r\n\t\t\t\tif ( programInfo.program === program ) {\r\n\t\r\n\t\t\t\t\tprogramInfo.usedTimes --;\r\n\t\r\n\t\t\t\t\tif ( programInfo.usedTimes === 0 ) {\r\n\t\r\n\t\t\t\t\t\tdeleteProgram = true;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( deleteProgram === true ) {\r\n\t\r\n\t\t\t\t// avoid using array.splice, this is costlier than creating new array from scratch\r\n\t\r\n\t\t\t\tvar newPrograms = [];\r\n\t\r\n\t\t\t\tfor ( i = 0, il = _programs.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\t\tprogramInfo = _programs[ i ];\r\n\t\r\n\t\t\t\t\tif ( programInfo.program !== program ) {\r\n\t\r\n\t\t\t\t\t\tnewPrograms.push( programInfo );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\t_programs = newPrograms;\r\n\t\r\n\t\t\t\t_gl.deleteProgram( program );\r\n\t\r\n\t\t\t\t_this.info.memory.programs --;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t\t// Buffer initialization\r\n\t\r\n\t\tfunction initCustomAttributes ( object ) {\r\n\t\r\n\t\t\tvar geometry = object.geometry;\r\n\t\t\tvar material = object.material;\r\n\t\r\n\t\t\tvar nvertices = geometry.vertices.length;\r\n\t\r\n\t\t\tif ( material.attributes ) {\r\n\t\r\n\t\t\t\tif ( geometry.__webglCustomAttributesList === undefined ) {\r\n\t\r\n\t\t\t\t\tgeometry.__webglCustomAttributesList = [];\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tfor ( var name in material.attributes ) {\r\n\t\r\n\t\t\t\t\tvar attribute = material.attributes[ name ];\r\n\t\r\n\t\t\t\t\tif ( ! attribute.__webglInitialized || attribute.createUniqueBuffers ) {\r\n\t\r\n\t\t\t\t\t\tattribute.__webglInitialized = true;\r\n\t\r\n\t\t\t\t\t\tvar size = 1;   // \"f\" and \"i\"\r\n\t\r\n\t\t\t\t\t\tif ( attribute.type === 'v2' ) size = 2;\r\n\t\t\t\t\t\telse if ( attribute.type === 'v3' ) size = 3;\r\n\t\t\t\t\t\telse if ( attribute.type === 'v4' ) size = 4;\r\n\t\t\t\t\t\telse if ( attribute.type === 'c'  ) size = 3;\r\n\t\r\n\t\t\t\t\t\tattribute.size = size;\r\n\t\r\n\t\t\t\t\t\tattribute.array = new Float32Array( nvertices * size );\r\n\t\r\n\t\t\t\t\t\tattribute.buffer = _gl.createBuffer();\r\n\t\t\t\t\t\tattribute.buffer.belongsToAttribute = name;\r\n\t\r\n\t\t\t\t\t\tattribute.needsUpdate = true;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tgeometry.__webglCustomAttributesList.push( attribute );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t\tfunction initParticleBuffers ( geometry, object ) {\r\n\t\r\n\t\t\tvar nvertices = geometry.vertices.length;\r\n\t\r\n\t\t\tgeometry.__vertexArray = new Float32Array( nvertices * 3 );\r\n\t\t\tgeometry.__colorArray = new Float32Array( nvertices * 3 );\r\n\t\r\n\t\t\tgeometry.__webglParticleCount = nvertices;\r\n\t\r\n\t\t\tinitCustomAttributes( object );\r\n\t\r\n\t\t};\r\n\t\r\n\t\tfunction initLineBuffers ( geometry, object ) {\r\n\t\r\n\t\t\tvar nvertices = geometry.vertices.length;\r\n\t\r\n\t\t\tgeometry.__vertexArray = new Float32Array( nvertices * 3 );\r\n\t\t\tgeometry.__colorArray = new Float32Array( nvertices * 3 );\r\n\t\t\tgeometry.__lineDistanceArray = new Float32Array( nvertices * 1 );\r\n\t\r\n\t\t\tgeometry.__webglLineCount = nvertices;\r\n\t\r\n\t\t\tinitCustomAttributes( object );\r\n\t\r\n\t\t};\r\n\t\r\n\t\tfunction initMeshBuffers ( geometryGroup, object ) {\r\n\t\r\n\t\t\tvar geometry = object.geometry,\r\n\t\t\t\tfaces3 = geometryGroup.faces3,\r\n\t\r\n\t\t\t\tnvertices = faces3.length * 3,\r\n\t\t\t\tntris     = faces3.length * 1,\r\n\t\t\t\tnlines    = faces3.length * 3,\r\n\t\r\n\t\t\t\tmaterial = getBufferMaterial( object, geometryGroup );\r\n\t\r\n\t\t\tgeometryGroup.__vertexArray = new Float32Array( nvertices * 3 );\r\n\t\t\tgeometryGroup.__normalArray = new Float32Array( nvertices * 3 );\r\n\t\t\tgeometryGroup.__colorArray = new Float32Array( nvertices * 3 );\r\n\t\t\tgeometryGroup.__uvArray = new Float32Array( nvertices * 2 );\r\n\t\r\n\t\t\tif ( geometry.faceVertexUvs.length > 1 ) {\r\n\t\r\n\t\t\t\tgeometryGroup.__uv2Array = new Float32Array( nvertices * 2 );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( geometry.hasTangents ) {\r\n\t\r\n\t\t\t\tgeometryGroup.__tangentArray = new Float32Array( nvertices * 4 );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( object.geometry.skinWeights.length && object.geometry.skinIndices.length ) {\r\n\t\r\n\t\t\t\tgeometryGroup.__skinIndexArray = new Float32Array( nvertices * 4 );\r\n\t\t\t\tgeometryGroup.__skinWeightArray = new Float32Array( nvertices * 4 );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar UintArray = extensions.get( 'OES_element_index_uint' ) !== null && ntris > 21845 ? Uint32Array : Uint16Array; // 65535 / 3\r\n\t\r\n\t\t\tgeometryGroup.__typeArray = UintArray;\r\n\t\t\tgeometryGroup.__faceArray = new UintArray( ntris * 3 );\r\n\t\t\tgeometryGroup.__lineArray = new UintArray( nlines * 2 );\r\n\t\r\n\t\t\tvar numMorphTargets = geometryGroup.numMorphTargets;\r\n\t\r\n\t\t\tif ( numMorphTargets ) {\r\n\t\r\n\t\t\t\tgeometryGroup.__morphTargetsArrays = [];\r\n\t\r\n\t\t\t\tfor ( var m = 0, ml = numMorphTargets; m < ml; m ++ ) {\r\n\t\r\n\t\t\t\t\tgeometryGroup.__morphTargetsArrays.push( new Float32Array( nvertices * 3 ) );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar numMorphNormals = geometryGroup.numMorphNormals;\r\n\t\r\n\t\t\tif ( numMorphNormals ) {\r\n\t\r\n\t\t\t\tgeometryGroup.__morphNormalsArrays = [];\r\n\t\r\n\t\t\t\tfor ( var m = 0, ml = numMorphNormals; m < ml; m ++ ) {\r\n\t\r\n\t\t\t\t\tgeometryGroup.__morphNormalsArrays.push( new Float32Array( nvertices * 3 ) );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tgeometryGroup.__webglFaceCount = ntris * 3;\r\n\t\t\tgeometryGroup.__webglLineCount = nlines * 2;\r\n\t\r\n\t\r\n\t\t\t// custom attributes\r\n\t\r\n\t\t\tif ( material.attributes ) {\r\n\t\r\n\t\t\t\tif ( geometryGroup.__webglCustomAttributesList === undefined ) {\r\n\t\r\n\t\t\t\t\tgeometryGroup.__webglCustomAttributesList = [];\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tfor ( var name in material.attributes ) {\r\n\t\r\n\t\t\t\t\t// Do a shallow copy of the attribute object so different geometryGroup chunks use different\r\n\t\t\t\t\t// attribute buffers which are correctly indexed in the setMeshBuffers function\r\n\t\r\n\t\t\t\t\tvar originalAttribute = material.attributes[ name ];\r\n\t\r\n\t\t\t\t\tvar attribute = {};\r\n\t\r\n\t\t\t\t\tfor ( var property in originalAttribute ) {\r\n\t\r\n\t\t\t\t\t\tattribute[ property ] = originalAttribute[ property ];\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tif ( ! attribute.__webglInitialized || attribute.createUniqueBuffers ) {\r\n\t\r\n\t\t\t\t\t\tattribute.__webglInitialized = true;\r\n\t\r\n\t\t\t\t\t\tvar size = 1;   // \"f\" and \"i\"\r\n\t\r\n\t\t\t\t\t\tif ( attribute.type === 'v2' ) size = 2;\r\n\t\t\t\t\t\telse if ( attribute.type === 'v3' ) size = 3;\r\n\t\t\t\t\t\telse if ( attribute.type === 'v4' ) size = 4;\r\n\t\t\t\t\t\telse if ( attribute.type === 'c'  ) size = 3;\r\n\t\r\n\t\t\t\t\t\tattribute.size = size;\r\n\t\r\n\t\t\t\t\t\tattribute.array = new Float32Array( nvertices * size );\r\n\t\r\n\t\t\t\t\t\tattribute.buffer = _gl.createBuffer();\r\n\t\t\t\t\t\tattribute.buffer.belongsToAttribute = name;\r\n\t\r\n\t\t\t\t\t\toriginalAttribute.needsUpdate = true;\r\n\t\t\t\t\t\tattribute.__original = originalAttribute;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tgeometryGroup.__webglCustomAttributesList.push( attribute );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tgeometryGroup.__inittedArrays = true;\r\n\t\r\n\t\t};\r\n\t\r\n\t\tfunction getBufferMaterial( object, geometryGroup ) {\r\n\t\r\n\t\t\treturn object.material instanceof THREE.MeshFaceMaterial\r\n\t\t\t\t ? object.material.materials[ geometryGroup.materialIndex ]\r\n\t\t\t\t : object.material;\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction materialNeedsFaceNormals ( material ) {\r\n\t\r\n\t\t\treturn material instanceof THREE.MeshPhongMaterial === false && material.shading === THREE.FlatShading;\r\n\t\r\n\t\t}\r\n\t\r\n\t\t// Buffer setting\r\n\t\r\n\t\tfunction setParticleBuffers ( geometry, hint, object ) {\r\n\t\r\n\t\t\tvar v, c, vertex, offset, color,\r\n\t\r\n\t\t\tvertices = geometry.vertices,\r\n\t\t\tvl = vertices.length,\r\n\t\r\n\t\t\tcolors = geometry.colors,\r\n\t\t\tcl = colors.length,\r\n\t\r\n\t\t\tvertexArray = geometry.__vertexArray,\r\n\t\t\tcolorArray = geometry.__colorArray,\r\n\t\r\n\t\t\tdirtyVertices = geometry.verticesNeedUpdate,\r\n\t\t\tdirtyColors = geometry.colorsNeedUpdate,\r\n\t\r\n\t\t\tcustomAttributes = geometry.__webglCustomAttributesList,\r\n\t\t\ti, il,\r\n\t\t\tca, cal, value,\r\n\t\t\tcustomAttribute;\r\n\t\r\n\t\t\tif ( dirtyVertices ) {\r\n\t\r\n\t\t\t\tfor ( v = 0; v < vl; v ++ ) {\r\n\t\r\n\t\t\t\t\tvertex = vertices[ v ];\r\n\t\r\n\t\t\t\t\toffset = v * 3;\r\n\t\r\n\t\t\t\t\tvertexArray[ offset ]     = vertex.x;\r\n\t\t\t\t\tvertexArray[ offset + 1 ] = vertex.y;\r\n\t\t\t\t\tvertexArray[ offset + 2 ] = vertex.z;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometry.__webglVertexBuffer );\r\n\t\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, vertexArray, hint );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( dirtyColors ) {\r\n\t\r\n\t\t\t\tfor ( c = 0; c < cl; c ++ ) {\r\n\t\r\n\t\t\t\t\tcolor = colors[ c ];\r\n\t\r\n\t\t\t\t\toffset = c * 3;\r\n\t\r\n\t\t\t\t\tcolorArray[ offset ]     = color.r;\r\n\t\t\t\t\tcolorArray[ offset + 1 ] = color.g;\r\n\t\t\t\t\tcolorArray[ offset + 2 ] = color.b;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometry.__webglColorBuffer );\r\n\t\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, colorArray, hint );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( customAttributes ) {\r\n\t\r\n\t\t\t\tfor ( i = 0, il = customAttributes.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\t\tcustomAttribute = customAttributes[ i ];\r\n\t\r\n\t\t\t\t\tif ( customAttribute.needsUpdate && ( customAttribute.boundTo === undefined ||  customAttribute.boundTo === 'vertices' ) ) {\r\n\t\r\n\t\t\t\t\t\tcal = customAttribute.value.length;\r\n\t\r\n\t\t\t\t\t\toffset = 0;\r\n\t\r\n\t\t\t\t\t\tif ( customAttribute.size === 1 ) {\r\n\t\r\n\t\t\t\t\t\t\tfor ( ca = 0; ca < cal; ca ++ ) {\r\n\t\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ ca ] = customAttribute.value[ ca ];\r\n\t\r\n\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t} else if ( customAttribute.size === 2 ) {\r\n\t\r\n\t\t\t\t\t\t\tfor ( ca = 0; ca < cal; ca ++ ) {\r\n\t\r\n\t\t\t\t\t\t\t\tvalue = customAttribute.value[ ca ];\r\n\t\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset ]   = value.x;\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset + 1 ] = value.y;\r\n\t\r\n\t\t\t\t\t\t\t\toffset += 2;\r\n\t\r\n\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t} else if ( customAttribute.size === 3 ) {\r\n\t\r\n\t\t\t\t\t\t\tif ( customAttribute.type === 'c' ) {\r\n\t\r\n\t\t\t\t\t\t\t\tfor ( ca = 0; ca < cal; ca ++ ) {\r\n\t\r\n\t\t\t\t\t\t\t\t\tvalue = customAttribute.value[ ca ];\r\n\t\r\n\t\t\t\t\t\t\t\t\tcustomAttribute.array[ offset ]   = value.r;\r\n\t\t\t\t\t\t\t\t\tcustomAttribute.array[ offset + 1 ] = value.g;\r\n\t\t\t\t\t\t\t\t\tcustomAttribute.array[ offset + 2 ] = value.b;\r\n\t\r\n\t\t\t\t\t\t\t\t\toffset += 3;\r\n\t\r\n\t\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\t\t\tfor ( ca = 0; ca < cal; ca ++ ) {\r\n\t\r\n\t\t\t\t\t\t\t\t\tvalue = customAttribute.value[ ca ];\r\n\t\r\n\t\t\t\t\t\t\t\t\tcustomAttribute.array[ offset ]   = value.x;\r\n\t\t\t\t\t\t\t\t\tcustomAttribute.array[ offset + 1 ] = value.y;\r\n\t\t\t\t\t\t\t\t\tcustomAttribute.array[ offset + 2 ] = value.z;\r\n\t\r\n\t\t\t\t\t\t\t\t\toffset += 3;\r\n\t\r\n\t\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t} else if ( customAttribute.size === 4 ) {\r\n\t\r\n\t\t\t\t\t\t\tfor ( ca = 0; ca < cal; ca ++ ) {\r\n\t\r\n\t\t\t\t\t\t\t\tvalue = customAttribute.value[ ca ];\r\n\t\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset ]      = value.x;\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset + 1  ] = value.y;\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset + 2  ] = value.z;\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset + 3  ] = value.w;\r\n\t\r\n\t\t\t\t\t\t\t\toffset += 4;\r\n\t\r\n\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, customAttribute.buffer );\r\n\t\t\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, customAttribute.array, hint );\r\n\t\r\n\t\t\t\t\tcustomAttribute.needsUpdate = false;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction setLineBuffers ( geometry, hint ) {\r\n\t\r\n\t\t\tvar v, c, d, vertex, offset, color,\r\n\t\r\n\t\t\tvertices = geometry.vertices,\r\n\t\t\tcolors = geometry.colors,\r\n\t\t\tlineDistances = geometry.lineDistances,\r\n\t\r\n\t\t\tvl = vertices.length,\r\n\t\t\tcl = colors.length,\r\n\t\t\tdl = lineDistances.length,\r\n\t\r\n\t\t\tvertexArray = geometry.__vertexArray,\r\n\t\t\tcolorArray = geometry.__colorArray,\r\n\t\t\tlineDistanceArray = geometry.__lineDistanceArray,\r\n\t\r\n\t\t\tdirtyVertices = geometry.verticesNeedUpdate,\r\n\t\t\tdirtyColors = geometry.colorsNeedUpdate,\r\n\t\t\tdirtyLineDistances = geometry.lineDistancesNeedUpdate,\r\n\t\r\n\t\t\tcustomAttributes = geometry.__webglCustomAttributesList,\r\n\t\r\n\t\t\ti, il,\r\n\t\t\tca, cal, value,\r\n\t\t\tcustomAttribute;\r\n\t\r\n\t\t\tif ( dirtyVertices ) {\r\n\t\r\n\t\t\t\tfor ( v = 0; v < vl; v ++ ) {\r\n\t\r\n\t\t\t\t\tvertex = vertices[ v ];\r\n\t\r\n\t\t\t\t\toffset = v * 3;\r\n\t\r\n\t\t\t\t\tvertexArray[ offset ]     = vertex.x;\r\n\t\t\t\t\tvertexArray[ offset + 1 ] = vertex.y;\r\n\t\t\t\t\tvertexArray[ offset + 2 ] = vertex.z;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometry.__webglVertexBuffer );\r\n\t\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, vertexArray, hint );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( dirtyColors ) {\r\n\t\r\n\t\t\t\tfor ( c = 0; c < cl; c ++ ) {\r\n\t\r\n\t\t\t\t\tcolor = colors[ c ];\r\n\t\r\n\t\t\t\t\toffset = c * 3;\r\n\t\r\n\t\t\t\t\tcolorArray[ offset ]     = color.r;\r\n\t\t\t\t\tcolorArray[ offset + 1 ] = color.g;\r\n\t\t\t\t\tcolorArray[ offset + 2 ] = color.b;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometry.__webglColorBuffer );\r\n\t\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, colorArray, hint );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( dirtyLineDistances ) {\r\n\t\r\n\t\t\t\tfor ( d = 0; d < dl; d ++ ) {\r\n\t\r\n\t\t\t\t\tlineDistanceArray[ d ] = lineDistances[ d ];\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometry.__webglLineDistanceBuffer );\r\n\t\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, lineDistanceArray, hint );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( customAttributes ) {\r\n\t\r\n\t\t\t\tfor ( i = 0, il = customAttributes.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\t\tcustomAttribute = customAttributes[ i ];\r\n\t\r\n\t\t\t\t\tif ( customAttribute.needsUpdate && ( customAttribute.boundTo === undefined || customAttribute.boundTo === 'vertices' ) ) {\r\n\t\r\n\t\t\t\t\t\toffset = 0;\r\n\t\r\n\t\t\t\t\t\tcal = customAttribute.value.length;\r\n\t\r\n\t\t\t\t\t\tif ( customAttribute.size === 1 ) {\r\n\t\r\n\t\t\t\t\t\t\tfor ( ca = 0; ca < cal; ca ++ ) {\r\n\t\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ ca ] = customAttribute.value[ ca ];\r\n\t\r\n\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t} else if ( customAttribute.size === 2 ) {\r\n\t\r\n\t\t\t\t\t\t\tfor ( ca = 0; ca < cal; ca ++ ) {\r\n\t\r\n\t\t\t\t\t\t\t\tvalue = customAttribute.value[ ca ];\r\n\t\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset ]   = value.x;\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset + 1 ] = value.y;\r\n\t\r\n\t\t\t\t\t\t\t\toffset += 2;\r\n\t\r\n\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t} else if ( customAttribute.size === 3 ) {\r\n\t\r\n\t\t\t\t\t\t\tif ( customAttribute.type === 'c' ) {\r\n\t\r\n\t\t\t\t\t\t\t\tfor ( ca = 0; ca < cal; ca ++ ) {\r\n\t\r\n\t\t\t\t\t\t\t\t\tvalue = customAttribute.value[ ca ];\r\n\t\r\n\t\t\t\t\t\t\t\t\tcustomAttribute.array[ offset ]   = value.r;\r\n\t\t\t\t\t\t\t\t\tcustomAttribute.array[ offset + 1 ] = value.g;\r\n\t\t\t\t\t\t\t\t\tcustomAttribute.array[ offset + 2 ] = value.b;\r\n\t\r\n\t\t\t\t\t\t\t\t\toffset += 3;\r\n\t\r\n\t\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\t\t\tfor ( ca = 0; ca < cal; ca ++ ) {\r\n\t\r\n\t\t\t\t\t\t\t\t\tvalue = customAttribute.value[ ca ];\r\n\t\r\n\t\t\t\t\t\t\t\t\tcustomAttribute.array[ offset ]   = value.x;\r\n\t\t\t\t\t\t\t\t\tcustomAttribute.array[ offset + 1 ] = value.y;\r\n\t\t\t\t\t\t\t\t\tcustomAttribute.array[ offset + 2 ] = value.z;\r\n\t\r\n\t\t\t\t\t\t\t\t\toffset += 3;\r\n\t\r\n\t\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t} else if ( customAttribute.size === 4 ) {\r\n\t\r\n\t\t\t\t\t\t\tfor ( ca = 0; ca < cal; ca ++ ) {\r\n\t\r\n\t\t\t\t\t\t\t\tvalue = customAttribute.value[ ca ];\r\n\t\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset ]    = value.x;\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset + 1  ] = value.y;\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset + 2  ] = value.z;\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset + 3  ] = value.w;\r\n\t\r\n\t\t\t\t\t\t\t\toffset += 4;\r\n\t\r\n\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, customAttribute.buffer );\r\n\t\t\t\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, customAttribute.array, hint );\r\n\t\r\n\t\t\t\t\t\tcustomAttribute.needsUpdate = false;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction setMeshBuffers( geometryGroup, object, hint, dispose, material ) {\r\n\t\r\n\t\t\tif ( ! geometryGroup.__inittedArrays ) {\r\n\t\r\n\t\t\t\treturn;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar needsFaceNormals = materialNeedsFaceNormals( material );\r\n\t\r\n\t\t\tvar f, fl, fi, face,\r\n\t\t\tvertexNormals, faceNormal,\r\n\t\t\tvertexColors, faceColor,\r\n\t\t\tvertexTangents,\r\n\t\t\tuv, uv2, v1, v2, v3, t1, t2, t3, n1, n2, n3,\r\n\t\t\tc1, c2, c3,\r\n\t\t\tsw1, sw2, sw3,\r\n\t\t\tsi1, si2, si3,\r\n\t\t\ti, il,\r\n\t\t\tvn, uvi, uv2i,\r\n\t\t\tvk, vkl, vka,\r\n\t\t\tnka, chf, faceVertexNormals,\r\n\t\r\n\t\t\tvertexIndex = 0,\r\n\t\r\n\t\t\toffset = 0,\r\n\t\t\toffset_uv = 0,\r\n\t\t\toffset_uv2 = 0,\r\n\t\t\toffset_face = 0,\r\n\t\t\toffset_normal = 0,\r\n\t\t\toffset_tangent = 0,\r\n\t\t\toffset_line = 0,\r\n\t\t\toffset_color = 0,\r\n\t\t\toffset_skin = 0,\r\n\t\t\toffset_morphTarget = 0,\r\n\t\t\toffset_custom = 0,\r\n\t\r\n\t\t\tvalue,\r\n\t\r\n\t\t\tvertexArray = geometryGroup.__vertexArray,\r\n\t\t\tuvArray = geometryGroup.__uvArray,\r\n\t\t\tuv2Array = geometryGroup.__uv2Array,\r\n\t\t\tnormalArray = geometryGroup.__normalArray,\r\n\t\t\ttangentArray = geometryGroup.__tangentArray,\r\n\t\t\tcolorArray = geometryGroup.__colorArray,\r\n\t\r\n\t\t\tskinIndexArray = geometryGroup.__skinIndexArray,\r\n\t\t\tskinWeightArray = geometryGroup.__skinWeightArray,\r\n\t\r\n\t\t\tmorphTargetsArrays = geometryGroup.__morphTargetsArrays,\r\n\t\t\tmorphNormalsArrays = geometryGroup.__morphNormalsArrays,\r\n\t\r\n\t\t\tcustomAttributes = geometryGroup.__webglCustomAttributesList,\r\n\t\t\tcustomAttribute,\r\n\t\r\n\t\t\tfaceArray = geometryGroup.__faceArray,\r\n\t\t\tlineArray = geometryGroup.__lineArray,\r\n\t\r\n\t\t\tgeometry = object.geometry, // this is shared for all chunks\r\n\t\r\n\t\t\tdirtyVertices = geometry.verticesNeedUpdate,\r\n\t\t\tdirtyElements = geometry.elementsNeedUpdate,\r\n\t\t\tdirtyUvs = geometry.uvsNeedUpdate,\r\n\t\t\tdirtyNormals = geometry.normalsNeedUpdate,\r\n\t\t\tdirtyTangents = geometry.tangentsNeedUpdate,\r\n\t\t\tdirtyColors = geometry.colorsNeedUpdate,\r\n\t\t\tdirtyMorphTargets = geometry.morphTargetsNeedUpdate,\r\n\t\r\n\t\t\tvertices = geometry.vertices,\r\n\t\t\tchunk_faces3 = geometryGroup.faces3,\r\n\t\t\tobj_faces = geometry.faces,\r\n\t\r\n\t\t\tobj_uvs  = geometry.faceVertexUvs[ 0 ],\r\n\t\t\tobj_uvs2 = geometry.faceVertexUvs[ 1 ],\r\n\t\r\n\t\t\tobj_skinIndices = geometry.skinIndices,\r\n\t\t\tobj_skinWeights = geometry.skinWeights,\r\n\t\r\n\t\t\tmorphTargets = geometry.morphTargets,\r\n\t\t\tmorphNormals = geometry.morphNormals;\r\n\t\r\n\t\t\tif ( dirtyVertices ) {\r\n\t\r\n\t\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\r\n\t\r\n\t\t\t\t\tface = obj_faces[ chunk_faces3[ f ] ];\r\n\t\r\n\t\t\t\t\tv1 = vertices[ face.a ];\r\n\t\t\t\t\tv2 = vertices[ face.b ];\r\n\t\t\t\t\tv3 = vertices[ face.c ];\r\n\t\r\n\t\t\t\t\tvertexArray[ offset ]     = v1.x;\r\n\t\t\t\t\tvertexArray[ offset + 1 ] = v1.y;\r\n\t\t\t\t\tvertexArray[ offset + 2 ] = v1.z;\r\n\t\r\n\t\t\t\t\tvertexArray[ offset + 3 ] = v2.x;\r\n\t\t\t\t\tvertexArray[ offset + 4 ] = v2.y;\r\n\t\t\t\t\tvertexArray[ offset + 5 ] = v2.z;\r\n\t\r\n\t\t\t\t\tvertexArray[ offset + 6 ] = v3.x;\r\n\t\t\t\t\tvertexArray[ offset + 7 ] = v3.y;\r\n\t\t\t\t\tvertexArray[ offset + 8 ] = v3.z;\r\n\t\r\n\t\t\t\t\toffset += 9;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglVertexBuffer );\r\n\t\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, vertexArray, hint );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( dirtyMorphTargets ) {\r\n\t\r\n\t\t\t\tfor ( vk = 0, vkl = morphTargets.length; vk < vkl; vk ++ ) {\r\n\t\r\n\t\t\t\t\toffset_morphTarget = 0;\r\n\t\r\n\t\t\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\r\n\t\r\n\t\t\t\t\t\tchf = chunk_faces3[ f ];\r\n\t\t\t\t\t\tface = obj_faces[ chf ];\r\n\t\r\n\t\t\t\t\t\t// morph positions\r\n\t\r\n\t\t\t\t\t\tv1 = morphTargets[ vk ].vertices[ face.a ];\r\n\t\t\t\t\t\tv2 = morphTargets[ vk ].vertices[ face.b ];\r\n\t\t\t\t\t\tv3 = morphTargets[ vk ].vertices[ face.c ];\r\n\t\r\n\t\t\t\t\t\tvka = morphTargetsArrays[ vk ];\r\n\t\r\n\t\t\t\t\t\tvka[ offset_morphTarget ]     = v1.x;\r\n\t\t\t\t\t\tvka[ offset_morphTarget + 1 ] = v1.y;\r\n\t\t\t\t\t\tvka[ offset_morphTarget + 2 ] = v1.z;\r\n\t\r\n\t\t\t\t\t\tvka[ offset_morphTarget + 3 ] = v2.x;\r\n\t\t\t\t\t\tvka[ offset_morphTarget + 4 ] = v2.y;\r\n\t\t\t\t\t\tvka[ offset_morphTarget + 5 ] = v2.z;\r\n\t\r\n\t\t\t\t\t\tvka[ offset_morphTarget + 6 ] = v3.x;\r\n\t\t\t\t\t\tvka[ offset_morphTarget + 7 ] = v3.y;\r\n\t\t\t\t\t\tvka[ offset_morphTarget + 8 ] = v3.z;\r\n\t\r\n\t\t\t\t\t\t// morph normals\r\n\t\r\n\t\t\t\t\t\tif ( material.morphNormals ) {\r\n\t\r\n\t\t\t\t\t\t\tif ( needsFaceNormals ) {\r\n\t\r\n\t\t\t\t\t\t\t\tn1 = morphNormals[ vk ].faceNormals[ chf ];\r\n\t\t\t\t\t\t\t\tn2 = n1;\r\n\t\t\t\t\t\t\t\tn3 = n1;\r\n\t\r\n\t\t\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\t\t\tfaceVertexNormals = morphNormals[ vk ].vertexNormals[ chf ];\r\n\t\r\n\t\t\t\t\t\t\t\tn1 = faceVertexNormals.a;\r\n\t\t\t\t\t\t\t\tn2 = faceVertexNormals.b;\r\n\t\t\t\t\t\t\t\tn3 = faceVertexNormals.c;\r\n\t\r\n\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t\tnka = morphNormalsArrays[ vk ];\r\n\t\r\n\t\t\t\t\t\t\tnka[ offset_morphTarget ]     = n1.x;\r\n\t\t\t\t\t\t\tnka[ offset_morphTarget + 1 ] = n1.y;\r\n\t\t\t\t\t\t\tnka[ offset_morphTarget + 2 ] = n1.z;\r\n\t\r\n\t\t\t\t\t\t\tnka[ offset_morphTarget + 3 ] = n2.x;\r\n\t\t\t\t\t\t\tnka[ offset_morphTarget + 4 ] = n2.y;\r\n\t\t\t\t\t\t\tnka[ offset_morphTarget + 5 ] = n2.z;\r\n\t\r\n\t\t\t\t\t\t\tnka[ offset_morphTarget + 6 ] = n3.x;\r\n\t\t\t\t\t\t\tnka[ offset_morphTarget + 7 ] = n3.y;\r\n\t\t\t\t\t\t\tnka[ offset_morphTarget + 8 ] = n3.z;\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t//\r\n\t\r\n\t\t\t\t\t\toffset_morphTarget += 9;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglMorphTargetsBuffers[ vk ] );\r\n\t\t\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, morphTargetsArrays[ vk ], hint );\r\n\t\r\n\t\t\t\t\tif ( material.morphNormals ) {\r\n\t\r\n\t\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglMorphNormalsBuffers[ vk ] );\r\n\t\t\t\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, morphNormalsArrays[ vk ], hint );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( obj_skinWeights.length ) {\r\n\t\r\n\t\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\r\n\t\r\n\t\t\t\t\tface = obj_faces[ chunk_faces3[ f ] ];\r\n\t\r\n\t\t\t\t\t// weights\r\n\t\r\n\t\t\t\t\tsw1 = obj_skinWeights[ face.a ];\r\n\t\t\t\t\tsw2 = obj_skinWeights[ face.b ];\r\n\t\t\t\t\tsw3 = obj_skinWeights[ face.c ];\r\n\t\r\n\t\t\t\t\tskinWeightArray[ offset_skin ]     = sw1.x;\r\n\t\t\t\t\tskinWeightArray[ offset_skin + 1 ] = sw1.y;\r\n\t\t\t\t\tskinWeightArray[ offset_skin + 2 ] = sw1.z;\r\n\t\t\t\t\tskinWeightArray[ offset_skin + 3 ] = sw1.w;\r\n\t\r\n\t\t\t\t\tskinWeightArray[ offset_skin + 4 ] = sw2.x;\r\n\t\t\t\t\tskinWeightArray[ offset_skin + 5 ] = sw2.y;\r\n\t\t\t\t\tskinWeightArray[ offset_skin + 6 ] = sw2.z;\r\n\t\t\t\t\tskinWeightArray[ offset_skin + 7 ] = sw2.w;\r\n\t\r\n\t\t\t\t\tskinWeightArray[ offset_skin + 8 ]  = sw3.x;\r\n\t\t\t\t\tskinWeightArray[ offset_skin + 9 ]  = sw3.y;\r\n\t\t\t\t\tskinWeightArray[ offset_skin + 10 ] = sw3.z;\r\n\t\t\t\t\tskinWeightArray[ offset_skin + 11 ] = sw3.w;\r\n\t\r\n\t\t\t\t\t// indices\r\n\t\r\n\t\t\t\t\tsi1 = obj_skinIndices[ face.a ];\r\n\t\t\t\t\tsi2 = obj_skinIndices[ face.b ];\r\n\t\t\t\t\tsi3 = obj_skinIndices[ face.c ];\r\n\t\r\n\t\t\t\t\tskinIndexArray[ offset_skin ]     = si1.x;\r\n\t\t\t\t\tskinIndexArray[ offset_skin + 1 ] = si1.y;\r\n\t\t\t\t\tskinIndexArray[ offset_skin + 2 ] = si1.z;\r\n\t\t\t\t\tskinIndexArray[ offset_skin + 3 ] = si1.w;\r\n\t\r\n\t\t\t\t\tskinIndexArray[ offset_skin + 4 ] = si2.x;\r\n\t\t\t\t\tskinIndexArray[ offset_skin + 5 ] = si2.y;\r\n\t\t\t\t\tskinIndexArray[ offset_skin + 6 ] = si2.z;\r\n\t\t\t\t\tskinIndexArray[ offset_skin + 7 ] = si2.w;\r\n\t\r\n\t\t\t\t\tskinIndexArray[ offset_skin + 8 ]  = si3.x;\r\n\t\t\t\t\tskinIndexArray[ offset_skin + 9 ]  = si3.y;\r\n\t\t\t\t\tskinIndexArray[ offset_skin + 10 ] = si3.z;\r\n\t\t\t\t\tskinIndexArray[ offset_skin + 11 ] = si3.w;\r\n\t\r\n\t\t\t\t\toffset_skin += 12;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( offset_skin > 0 ) {\r\n\t\r\n\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglSkinIndicesBuffer );\r\n\t\t\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, skinIndexArray, hint );\r\n\t\r\n\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglSkinWeightsBuffer );\r\n\t\t\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, skinWeightArray, hint );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( dirtyColors ) {\r\n\t\r\n\t\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\r\n\t\r\n\t\t\t\t\tface = obj_faces[ chunk_faces3[ f ] ];\r\n\t\r\n\t\t\t\t\tvertexColors = face.vertexColors;\r\n\t\t\t\t\tfaceColor = face.color;\r\n\t\r\n\t\t\t\t\tif ( vertexColors.length === 3 && material.vertexColors === THREE.VertexColors ) {\r\n\t\r\n\t\t\t\t\t\tc1 = vertexColors[ 0 ];\r\n\t\t\t\t\t\tc2 = vertexColors[ 1 ];\r\n\t\t\t\t\t\tc3 = vertexColors[ 2 ];\r\n\t\r\n\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\tc1 = faceColor;\r\n\t\t\t\t\t\tc2 = faceColor;\r\n\t\t\t\t\t\tc3 = faceColor;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tcolorArray[ offset_color ]     = c1.r;\r\n\t\t\t\t\tcolorArray[ offset_color + 1 ] = c1.g;\r\n\t\t\t\t\tcolorArray[ offset_color + 2 ] = c1.b;\r\n\t\r\n\t\t\t\t\tcolorArray[ offset_color + 3 ] = c2.r;\r\n\t\t\t\t\tcolorArray[ offset_color + 4 ] = c2.g;\r\n\t\t\t\t\tcolorArray[ offset_color + 5 ] = c2.b;\r\n\t\r\n\t\t\t\t\tcolorArray[ offset_color + 6 ] = c3.r;\r\n\t\t\t\t\tcolorArray[ offset_color + 7 ] = c3.g;\r\n\t\t\t\t\tcolorArray[ offset_color + 8 ] = c3.b;\r\n\t\r\n\t\t\t\t\toffset_color += 9;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( offset_color > 0 ) {\r\n\t\r\n\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglColorBuffer );\r\n\t\t\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, colorArray, hint );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( dirtyTangents && geometry.hasTangents ) {\r\n\t\r\n\t\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\r\n\t\r\n\t\t\t\t\tface = obj_faces[ chunk_faces3[ f ] ];\r\n\t\r\n\t\t\t\t\tvertexTangents = face.vertexTangents;\r\n\t\r\n\t\t\t\t\tt1 = vertexTangents[ 0 ];\r\n\t\t\t\t\tt2 = vertexTangents[ 1 ];\r\n\t\t\t\t\tt3 = vertexTangents[ 2 ];\r\n\t\r\n\t\t\t\t\ttangentArray[ offset_tangent ]     = t1.x;\r\n\t\t\t\t\ttangentArray[ offset_tangent + 1 ] = t1.y;\r\n\t\t\t\t\ttangentArray[ offset_tangent + 2 ] = t1.z;\r\n\t\t\t\t\ttangentArray[ offset_tangent + 3 ] = t1.w;\r\n\t\r\n\t\t\t\t\ttangentArray[ offset_tangent + 4 ] = t2.x;\r\n\t\t\t\t\ttangentArray[ offset_tangent + 5 ] = t2.y;\r\n\t\t\t\t\ttangentArray[ offset_tangent + 6 ] = t2.z;\r\n\t\t\t\t\ttangentArray[ offset_tangent + 7 ] = t2.w;\r\n\t\r\n\t\t\t\t\ttangentArray[ offset_tangent + 8 ]  = t3.x;\r\n\t\t\t\t\ttangentArray[ offset_tangent + 9 ]  = t3.y;\r\n\t\t\t\t\ttangentArray[ offset_tangent + 10 ] = t3.z;\r\n\t\t\t\t\ttangentArray[ offset_tangent + 11 ] = t3.w;\r\n\t\r\n\t\t\t\t\toffset_tangent += 12;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglTangentBuffer );\r\n\t\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, tangentArray, hint );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( dirtyNormals ) {\r\n\t\r\n\t\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\r\n\t\r\n\t\t\t\t\tface = obj_faces[ chunk_faces3[ f ] ];\r\n\t\r\n\t\t\t\t\tvertexNormals = face.vertexNormals;\r\n\t\t\t\t\tfaceNormal = face.normal;\r\n\t\r\n\t\t\t\t\tif ( vertexNormals.length === 3 && needsFaceNormals === false ) {\r\n\t\r\n\t\t\t\t\t\tfor ( i = 0; i < 3; i ++ ) {\r\n\t\r\n\t\t\t\t\t\t\tvn = vertexNormals[ i ];\r\n\t\r\n\t\t\t\t\t\t\tnormalArray[ offset_normal ]     = vn.x;\r\n\t\t\t\t\t\t\tnormalArray[ offset_normal + 1 ] = vn.y;\r\n\t\t\t\t\t\t\tnormalArray[ offset_normal + 2 ] = vn.z;\r\n\t\r\n\t\t\t\t\t\t\toffset_normal += 3;\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\tfor ( i = 0; i < 3; i ++ ) {\r\n\t\r\n\t\t\t\t\t\t\tnormalArray[ offset_normal ]     = faceNormal.x;\r\n\t\t\t\t\t\t\tnormalArray[ offset_normal + 1 ] = faceNormal.y;\r\n\t\t\t\t\t\t\tnormalArray[ offset_normal + 2 ] = faceNormal.z;\r\n\t\r\n\t\t\t\t\t\t\toffset_normal += 3;\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglNormalBuffer );\r\n\t\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, normalArray, hint );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( dirtyUvs && obj_uvs ) {\r\n\t\r\n\t\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\r\n\t\r\n\t\t\t\t\tfi = chunk_faces3[ f ];\r\n\t\r\n\t\t\t\t\tuv = obj_uvs[ fi ];\r\n\t\r\n\t\t\t\t\tif ( uv === undefined ) continue;\r\n\t\r\n\t\t\t\t\tfor ( i = 0; i < 3; i ++ ) {\r\n\t\r\n\t\t\t\t\t\tuvi = uv[ i ];\r\n\t\r\n\t\t\t\t\t\tuvArray[ offset_uv ]     = uvi.x;\r\n\t\t\t\t\t\tuvArray[ offset_uv + 1 ] = uvi.y;\r\n\t\r\n\t\t\t\t\t\toffset_uv += 2;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( offset_uv > 0 ) {\r\n\t\r\n\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglUVBuffer );\r\n\t\t\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, uvArray, hint );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( dirtyUvs && obj_uvs2 ) {\r\n\t\r\n\t\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\r\n\t\r\n\t\t\t\t\tfi = chunk_faces3[ f ];\r\n\t\r\n\t\t\t\t\tuv2 = obj_uvs2[ fi ];\r\n\t\r\n\t\t\t\t\tif ( uv2 === undefined ) continue;\r\n\t\r\n\t\t\t\t\tfor ( i = 0; i < 3; i ++ ) {\r\n\t\r\n\t\t\t\t\t\tuv2i = uv2[ i ];\r\n\t\r\n\t\t\t\t\t\tuv2Array[ offset_uv2 ]     = uv2i.x;\r\n\t\t\t\t\t\tuv2Array[ offset_uv2 + 1 ] = uv2i.y;\r\n\t\r\n\t\t\t\t\t\toffset_uv2 += 2;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( offset_uv2 > 0 ) {\r\n\t\r\n\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglUV2Buffer );\r\n\t\t\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, uv2Array, hint );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( dirtyElements ) {\r\n\t\r\n\t\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\r\n\t\r\n\t\t\t\t\tfaceArray[ offset_face ]   = vertexIndex;\r\n\t\t\t\t\tfaceArray[ offset_face + 1 ] = vertexIndex + 1;\r\n\t\t\t\t\tfaceArray[ offset_face + 2 ] = vertexIndex + 2;\r\n\t\r\n\t\t\t\t\toffset_face += 3;\r\n\t\r\n\t\t\t\t\tlineArray[ offset_line ]     = vertexIndex;\r\n\t\t\t\t\tlineArray[ offset_line + 1 ] = vertexIndex + 1;\r\n\t\r\n\t\t\t\t\tlineArray[ offset_line + 2 ] = vertexIndex;\r\n\t\t\t\t\tlineArray[ offset_line + 3 ] = vertexIndex + 2;\r\n\t\r\n\t\t\t\t\tlineArray[ offset_line + 4 ] = vertexIndex + 1;\r\n\t\t\t\t\tlineArray[ offset_line + 5 ] = vertexIndex + 2;\r\n\t\r\n\t\t\t\t\toffset_line += 6;\r\n\t\r\n\t\t\t\t\tvertexIndex += 3;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\t_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, geometryGroup.__webglFaceBuffer );\r\n\t\t\t\t_gl.bufferData( _gl.ELEMENT_ARRAY_BUFFER, faceArray, hint );\r\n\t\r\n\t\t\t\t_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, geometryGroup.__webglLineBuffer );\r\n\t\t\t\t_gl.bufferData( _gl.ELEMENT_ARRAY_BUFFER, lineArray, hint );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( customAttributes ) {\r\n\t\r\n\t\t\t\tfor ( i = 0, il = customAttributes.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\t\tcustomAttribute = customAttributes[ i ];\r\n\t\r\n\t\t\t\t\tif ( ! customAttribute.__original.needsUpdate ) continue;\r\n\t\r\n\t\t\t\t\toffset_custom = 0;\r\n\t\r\n\t\t\t\t\tif ( customAttribute.size === 1 ) {\r\n\t\r\n\t\t\t\t\t\tif ( customAttribute.boundTo === undefined || customAttribute.boundTo === 'vertices' ) {\r\n\t\r\n\t\t\t\t\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\r\n\t\r\n\t\t\t\t\t\t\t\tface = obj_faces[ chunk_faces3[ f ] ];\r\n\t\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom ]     = customAttribute.value[ face.a ];\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 1 ] = customAttribute.value[ face.b ];\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 2 ] = customAttribute.value[ face.c ];\r\n\t\r\n\t\t\t\t\t\t\t\toffset_custom += 3;\r\n\t\r\n\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t} else if ( customAttribute.boundTo === 'faces' ) {\r\n\t\r\n\t\t\t\t\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\r\n\t\r\n\t\t\t\t\t\t\t\tvalue = customAttribute.value[ chunk_faces3[ f ] ];\r\n\t\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom ]     = value;\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 1 ] = value;\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 2 ] = value;\r\n\t\r\n\t\t\t\t\t\t\t\toffset_custom += 3;\r\n\t\r\n\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t} else if ( customAttribute.size === 2 ) {\r\n\t\r\n\t\t\t\t\t\tif ( customAttribute.boundTo === undefined || customAttribute.boundTo === 'vertices' ) {\r\n\t\r\n\t\t\t\t\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\r\n\t\r\n\t\t\t\t\t\t\t\tface = obj_faces[ chunk_faces3[ f ] ];\r\n\t\r\n\t\t\t\t\t\t\t\tv1 = customAttribute.value[ face.a ];\r\n\t\t\t\t\t\t\t\tv2 = customAttribute.value[ face.b ];\r\n\t\t\t\t\t\t\t\tv3 = customAttribute.value[ face.c ];\r\n\t\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom ]     = v1.x;\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 1 ] = v1.y;\r\n\t\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 2 ] = v2.x;\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 3 ] = v2.y;\r\n\t\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 4 ] = v3.x;\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 5 ] = v3.y;\r\n\t\r\n\t\t\t\t\t\t\t\toffset_custom += 6;\r\n\t\r\n\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t} else if ( customAttribute.boundTo === 'faces' ) {\r\n\t\r\n\t\t\t\t\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\r\n\t\r\n\t\t\t\t\t\t\t\tvalue = customAttribute.value[ chunk_faces3[ f ] ];\r\n\t\r\n\t\t\t\t\t\t\t\tv1 = value;\r\n\t\t\t\t\t\t\t\tv2 = value;\r\n\t\t\t\t\t\t\t\tv3 = value;\r\n\t\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom ]     = v1.x;\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 1 ] = v1.y;\r\n\t\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 2 ] = v2.x;\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 3 ] = v2.y;\r\n\t\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 4 ] = v3.x;\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 5 ] = v3.y;\r\n\t\r\n\t\t\t\t\t\t\t\toffset_custom += 6;\r\n\t\r\n\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t} else if ( customAttribute.size === 3 ) {\r\n\t\r\n\t\t\t\t\t\tvar pp;\r\n\t\r\n\t\t\t\t\t\tif ( customAttribute.type === 'c' ) {\r\n\t\r\n\t\t\t\t\t\t\tpp = [ 'r', 'g', 'b' ];\r\n\t\r\n\t\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\t\tpp = [ 'x', 'y', 'z' ];\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\tif ( customAttribute.boundTo === undefined || customAttribute.boundTo === 'vertices' ) {\r\n\t\r\n\t\t\t\t\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\r\n\t\r\n\t\t\t\t\t\t\t\tface = obj_faces[ chunk_faces3[ f ] ];\r\n\t\r\n\t\t\t\t\t\t\t\tv1 = customAttribute.value[ face.a ];\r\n\t\t\t\t\t\t\t\tv2 = customAttribute.value[ face.b ];\r\n\t\t\t\t\t\t\t\tv3 = customAttribute.value[ face.c ];\r\n\t\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom ]     = v1[ pp[ 0 ] ];\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 1 ] = v1[ pp[ 1 ] ];\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 2 ] = v1[ pp[ 2 ] ];\r\n\t\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 3 ] = v2[ pp[ 0 ] ];\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 4 ] = v2[ pp[ 1 ] ];\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 5 ] = v2[ pp[ 2 ] ];\r\n\t\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 6 ] = v3[ pp[ 0 ] ];\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 7 ] = v3[ pp[ 1 ] ];\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 8 ] = v3[ pp[ 2 ] ];\r\n\t\r\n\t\t\t\t\t\t\t\toffset_custom += 9;\r\n\t\r\n\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t} else if ( customAttribute.boundTo === 'faces' ) {\r\n\t\r\n\t\t\t\t\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\r\n\t\r\n\t\t\t\t\t\t\t\tvalue = customAttribute.value[ chunk_faces3[ f ] ];\r\n\t\r\n\t\t\t\t\t\t\t\tv1 = value;\r\n\t\t\t\t\t\t\t\tv2 = value;\r\n\t\t\t\t\t\t\t\tv3 = value;\r\n\t\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom ]     = v1[ pp[ 0 ] ];\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 1 ] = v1[ pp[ 1 ] ];\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 2 ] = v1[ pp[ 2 ] ];\r\n\t\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 3 ] = v2[ pp[ 0 ] ];\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 4 ] = v2[ pp[ 1 ] ];\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 5 ] = v2[ pp[ 2 ] ];\r\n\t\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 6 ] = v3[ pp[ 0 ] ];\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 7 ] = v3[ pp[ 1 ] ];\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 8 ] = v3[ pp[ 2 ] ];\r\n\t\r\n\t\t\t\t\t\t\t\toffset_custom += 9;\r\n\t\r\n\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t} else if ( customAttribute.boundTo === 'faceVertices' ) {\r\n\t\r\n\t\t\t\t\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\r\n\t\r\n\t\t\t\t\t\t\t\tvalue = customAttribute.value[ chunk_faces3[ f ] ];\r\n\t\r\n\t\t\t\t\t\t\t\tv1 = value[ 0 ];\r\n\t\t\t\t\t\t\t\tv2 = value[ 1 ];\r\n\t\t\t\t\t\t\t\tv3 = value[ 2 ];\r\n\t\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom ]     = v1[ pp[ 0 ] ];\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 1 ] = v1[ pp[ 1 ] ];\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 2 ] = v1[ pp[ 2 ] ];\r\n\t\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 3 ] = v2[ pp[ 0 ] ];\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 4 ] = v2[ pp[ 1 ] ];\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 5 ] = v2[ pp[ 2 ] ];\r\n\t\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 6 ] = v3[ pp[ 0 ] ];\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 7 ] = v3[ pp[ 1 ] ];\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 8 ] = v3[ pp[ 2 ] ];\r\n\t\r\n\t\t\t\t\t\t\t\toffset_custom += 9;\r\n\t\r\n\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t} else if ( customAttribute.size === 4 ) {\r\n\t\r\n\t\t\t\t\t\tif ( customAttribute.boundTo === undefined || customAttribute.boundTo === 'vertices' ) {\r\n\t\r\n\t\t\t\t\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\r\n\t\r\n\t\t\t\t\t\t\t\tface = obj_faces[ chunk_faces3[ f ] ];\r\n\t\r\n\t\t\t\t\t\t\t\tv1 = customAttribute.value[ face.a ];\r\n\t\t\t\t\t\t\t\tv2 = customAttribute.value[ face.b ];\r\n\t\t\t\t\t\t\t\tv3 = customAttribute.value[ face.c ];\r\n\t\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom  ]   = v1.x;\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 1  ] = v1.y;\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 2  ] = v1.z;\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 3  ] = v1.w;\r\n\t\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 4  ] = v2.x;\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 5  ] = v2.y;\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 6  ] = v2.z;\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 7  ] = v2.w;\r\n\t\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 8  ] = v3.x;\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 9  ] = v3.y;\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 10 ] = v3.z;\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 11 ] = v3.w;\r\n\t\r\n\t\t\t\t\t\t\t\toffset_custom += 12;\r\n\t\r\n\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t} else if ( customAttribute.boundTo === 'faces' ) {\r\n\t\r\n\t\t\t\t\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\r\n\t\r\n\t\t\t\t\t\t\t\tvalue = customAttribute.value[ chunk_faces3[ f ] ];\r\n\t\r\n\t\t\t\t\t\t\t\tv1 = value;\r\n\t\t\t\t\t\t\t\tv2 = value;\r\n\t\t\t\t\t\t\t\tv3 = value;\r\n\t\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom  ]   = v1.x;\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 1  ] = v1.y;\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 2  ] = v1.z;\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 3  ] = v1.w;\r\n\t\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 4  ] = v2.x;\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 5  ] = v2.y;\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 6  ] = v2.z;\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 7  ] = v2.w;\r\n\t\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 8  ] = v3.x;\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 9  ] = v3.y;\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 10 ] = v3.z;\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 11 ] = v3.w;\r\n\t\r\n\t\t\t\t\t\t\t\toffset_custom += 12;\r\n\t\r\n\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t} else if ( customAttribute.boundTo === 'faceVertices' ) {\r\n\t\r\n\t\t\t\t\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\r\n\t\r\n\t\t\t\t\t\t\t\tvalue = customAttribute.value[ chunk_faces3[ f ] ];\r\n\t\r\n\t\t\t\t\t\t\t\tv1 = value[ 0 ];\r\n\t\t\t\t\t\t\t\tv2 = value[ 1 ];\r\n\t\t\t\t\t\t\t\tv3 = value[ 2 ];\r\n\t\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom  ]   = v1.x;\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 1  ] = v1.y;\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 2  ] = v1.z;\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 3  ] = v1.w;\r\n\t\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 4  ] = v2.x;\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 5  ] = v2.y;\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 6  ] = v2.z;\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 7  ] = v2.w;\r\n\t\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 8  ] = v3.x;\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 9  ] = v3.y;\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 10 ] = v3.z;\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 11 ] = v3.w;\r\n\t\r\n\t\t\t\t\t\t\t\toffset_custom += 12;\r\n\t\r\n\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, customAttribute.buffer );\r\n\t\t\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, customAttribute.array, hint );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( dispose ) {\r\n\t\r\n\t\t\t\tdelete geometryGroup.__inittedArrays;\r\n\t\t\t\tdelete geometryGroup.__colorArray;\r\n\t\t\t\tdelete geometryGroup.__normalArray;\r\n\t\t\t\tdelete geometryGroup.__tangentArray;\r\n\t\t\t\tdelete geometryGroup.__uvArray;\r\n\t\t\t\tdelete geometryGroup.__uv2Array;\r\n\t\t\t\tdelete geometryGroup.__faceArray;\r\n\t\t\t\tdelete geometryGroup.__vertexArray;\r\n\t\t\t\tdelete geometryGroup.__lineArray;\r\n\t\t\t\tdelete geometryGroup.__skinIndexArray;\r\n\t\t\t\tdelete geometryGroup.__skinWeightArray;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t\t// Buffer rendering\r\n\t\r\n\t\tthis.renderBufferImmediate = function ( object, program, material ) {\r\n\t\r\n\t\t\tstate.initAttributes();\r\n\t\r\n\t\t\tif ( object.hasPositions && ! object.__webglVertexBuffer ) object.__webglVertexBuffer = _gl.createBuffer();\r\n\t\t\tif ( object.hasNormals && ! object.__webglNormalBuffer ) object.__webglNormalBuffer = _gl.createBuffer();\r\n\t\t\tif ( object.hasUvs && ! object.__webglUvBuffer ) object.__webglUvBuffer = _gl.createBuffer();\r\n\t\t\tif ( object.hasColors && ! object.__webglColorBuffer ) object.__webglColorBuffer = _gl.createBuffer();\r\n\t\r\n\t\t\tif ( object.hasPositions ) {\r\n\t\r\n\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, object.__webglVertexBuffer );\r\n\t\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, object.positionArray, _gl.DYNAMIC_DRAW );\r\n\t\r\n\t\t\t\tstate.enableAttribute( program.attributes.position );\r\n\t\r\n\t\t\t\t_gl.vertexAttribPointer( program.attributes.position, 3, _gl.FLOAT, false, 0, 0 );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( object.hasNormals ) {\r\n\t\r\n\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, object.__webglNormalBuffer );\r\n\t\r\n\t\t\t\tif ( material instanceof THREE.MeshPhongMaterial === false &&\r\n\t\t\t\t\t   material.shading === THREE.FlatShading ) {\r\n\t\r\n\t\t\t\t\tvar nx, ny, nz,\r\n\t\t\t\t\t\tnax, nbx, ncx, nay, nby, ncy, naz, nbz, ncz,\r\n\t\t\t\t\t\tnormalArray,\r\n\t\t\t\t\t\ti, il = object.count * 3;\r\n\t\r\n\t\t\t\t\tfor ( i = 0; i < il; i += 9 ) {\r\n\t\r\n\t\t\t\t\t\tnormalArray = object.normalArray;\r\n\t\r\n\t\t\t\t\t\tnax  = normalArray[ i ];\r\n\t\t\t\t\t\tnay  = normalArray[ i + 1 ];\r\n\t\t\t\t\t\tnaz  = normalArray[ i + 2 ];\r\n\t\r\n\t\t\t\t\t\tnbx  = normalArray[ i + 3 ];\r\n\t\t\t\t\t\tnby  = normalArray[ i + 4 ];\r\n\t\t\t\t\t\tnbz  = normalArray[ i + 5 ];\r\n\t\r\n\t\t\t\t\t\tncx  = normalArray[ i + 6 ];\r\n\t\t\t\t\t\tncy  = normalArray[ i + 7 ];\r\n\t\t\t\t\t\tncz  = normalArray[ i + 8 ];\r\n\t\r\n\t\t\t\t\t\tnx = ( nax + nbx + ncx ) / 3;\r\n\t\t\t\t\t\tny = ( nay + nby + ncy ) / 3;\r\n\t\t\t\t\t\tnz = ( naz + nbz + ncz ) / 3;\r\n\t\r\n\t\t\t\t\t\tnormalArray[ i ]   = nx;\r\n\t\t\t\t\t\tnormalArray[ i + 1 ] = ny;\r\n\t\t\t\t\t\tnormalArray[ i + 2 ] = nz;\r\n\t\r\n\t\t\t\t\t\tnormalArray[ i + 3 ] = nx;\r\n\t\t\t\t\t\tnormalArray[ i + 4 ] = ny;\r\n\t\t\t\t\t\tnormalArray[ i + 5 ] = nz;\r\n\t\r\n\t\t\t\t\t\tnormalArray[ i + 6 ] = nx;\r\n\t\t\t\t\t\tnormalArray[ i + 7 ] = ny;\r\n\t\t\t\t\t\tnormalArray[ i + 8 ] = nz;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, object.normalArray, _gl.DYNAMIC_DRAW );\r\n\t\r\n\t\t\t\tstate.enableAttribute( program.attributes.normal );\r\n\t\r\n\t\t\t\t_gl.vertexAttribPointer( program.attributes.normal, 3, _gl.FLOAT, false, 0, 0 );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( object.hasUvs && material.map ) {\r\n\t\r\n\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, object.__webglUvBuffer );\r\n\t\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, object.uvArray, _gl.DYNAMIC_DRAW );\r\n\t\r\n\t\t\t\tstate.enableAttribute( program.attributes.uv );\r\n\t\r\n\t\t\t\t_gl.vertexAttribPointer( program.attributes.uv, 2, _gl.FLOAT, false, 0, 0 );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( object.hasColors && material.vertexColors !== THREE.NoColors ) {\r\n\t\r\n\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, object.__webglColorBuffer );\r\n\t\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, object.colorArray, _gl.DYNAMIC_DRAW );\r\n\t\r\n\t\t\t\tstate.enableAttribute( program.attributes.color );\r\n\t\r\n\t\t\t\t_gl.vertexAttribPointer( program.attributes.color, 3, _gl.FLOAT, false, 0, 0 );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tstate.disableUnusedAttributes();\r\n\t\r\n\t\t\t_gl.drawArrays( _gl.TRIANGLES, 0, object.count );\r\n\t\r\n\t\t\tobject.count = 0;\r\n\t\r\n\t\t};\r\n\t\r\n\t\tfunction setupVertexAttributes( material, program, geometry, startIndex ) {\r\n\t\r\n\t\t\tvar geometryAttributes = geometry.attributes;\r\n\t\r\n\t\t\tvar programAttributes = program.attributes;\r\n\t\t\tvar programAttributesKeys = program.attributesKeys;\r\n\t\r\n\t\t\tfor ( var i = 0, l = programAttributesKeys.length; i < l; i ++ ) {\r\n\t\r\n\t\t\t\tvar key = programAttributesKeys[ i ];\r\n\t\t\t\tvar programAttribute = programAttributes[ key ];\r\n\t\r\n\t\t\t\tif ( programAttribute >= 0 ) {\r\n\t\r\n\t\t\t\t\tvar geometryAttribute = geometryAttributes[ key ];\r\n\t\r\n\t\t\t\t\tif ( geometryAttribute !== undefined ) {\r\n\t\r\n\t\t\t\t\t\tvar size = geometryAttribute.itemSize;\r\n\t\r\n\t\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryAttribute.buffer );\r\n\t\r\n\t\t\t\t\t\tstate.enableAttribute( programAttribute );\r\n\t\r\n\t\t\t\t\t\t_gl.vertexAttribPointer( programAttribute, size, _gl.FLOAT, false, 0, startIndex * size * 4 ); // 4 bytes per Float32\r\n\t\r\n\t\t\t\t\t} else if ( material.defaultAttributeValues !== undefined ) {\r\n\t\r\n\t\t\t\t\t\tif ( material.defaultAttributeValues[ key ].length === 2 ) {\r\n\t\r\n\t\t\t\t\t\t\t_gl.vertexAttrib2fv( programAttribute, material.defaultAttributeValues[ key ] );\r\n\t\r\n\t\t\t\t\t\t} else if ( material.defaultAttributeValues[ key ].length === 3 ) {\r\n\t\r\n\t\t\t\t\t\t\t_gl.vertexAttrib3fv( programAttribute, material.defaultAttributeValues[ key ] );\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tstate.disableUnusedAttributes();\r\n\t\r\n\t\t}\r\n\t\r\n\t\tthis.renderBufferDirect = function ( camera, lights, fog, material, geometry, object ) {\r\n\t\r\n\t\t\tif ( material.visible === false ) return;\r\n\t\r\n\t\t\tupdateObject( object );\r\n\t\r\n\t\t\tvar program = setProgram( camera, lights, fog, material, object );\r\n\t\r\n\t\t\tvar updateBuffers = false,\r\n\t\t\t\twireframeBit = material.wireframe ? 1 : 0,\r\n\t\t\t\tgeometryProgram = 'direct_' + geometry.id + '_' + program.id + '_' + wireframeBit;\r\n\t\r\n\t\t\tif ( geometryProgram !== _currentGeometryProgram ) {\r\n\t\r\n\t\t\t\t_currentGeometryProgram = geometryProgram;\r\n\t\t\t\tupdateBuffers = true;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( updateBuffers ) {\r\n\t\r\n\t\t\t\tstate.initAttributes();\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// render mesh\r\n\t\r\n\t\t\tif ( object instanceof THREE.Mesh ) {\r\n\t\r\n\t\t\t\tvar mode = material.wireframe === true ? _gl.LINES : _gl.TRIANGLES;\r\n\t\r\n\t\t\t\tvar index = geometry.attributes.index;\r\n\t\r\n\t\t\t\tif ( index ) {\r\n\t\r\n\t\t\t\t\t// indexed triangles\r\n\t\r\n\t\t\t\t\tvar type, size;\r\n\t\r\n\t\t\t\t\tif ( index.array instanceof Uint32Array && extensions.get( 'OES_element_index_uint' ) ) {\r\n\t\r\n\t\t\t\t\t\ttype = _gl.UNSIGNED_INT;\r\n\t\t\t\t\t\tsize = 4;\r\n\t\r\n\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\ttype = _gl.UNSIGNED_SHORT;\r\n\t\t\t\t\t\tsize = 2;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tvar offsets = geometry.offsets;\r\n\t\r\n\t\t\t\t\tif ( offsets.length === 0 ) {\r\n\t\r\n\t\t\t\t\t\tif ( updateBuffers ) {\r\n\t\r\n\t\t\t\t\t\t\tsetupVertexAttributes( material, program, geometry, 0 );\r\n\t\t\t\t\t\t\t_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, index.buffer );\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t_gl.drawElements( mode, index.array.length, type, 0 );\r\n\t\r\n\t\t\t\t\t\t_this.info.render.calls ++;\r\n\t\t\t\t\t\t_this.info.render.vertices += index.array.length; // not really true, here vertices can be shared\r\n\t\t\t\t\t\t_this.info.render.faces += index.array.length / 3;\r\n\t\r\n\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\t// if there is more than 1 chunk\r\n\t\t\t\t\t\t// must set attribute pointers to use new offsets for each chunk\r\n\t\t\t\t\t\t// even if geometry and materials didn't change\r\n\t\r\n\t\t\t\t\t\tupdateBuffers = true;\r\n\t\r\n\t\t\t\t\t\tfor ( var i = 0, il = offsets.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\t\t\t\tvar startIndex = offsets[ i ].index;\r\n\t\r\n\t\t\t\t\t\t\tif ( updateBuffers ) {\r\n\t\r\n\t\t\t\t\t\t\t\tsetupVertexAttributes( material, program, geometry, startIndex );\r\n\t\t\t\t\t\t\t\t_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, index.buffer );\r\n\t\r\n\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t\t// render indexed triangles\r\n\t\r\n\t\t\t\t\t\t\t_gl.drawElements( mode, offsets[ i ].count, type, offsets[ i ].start * size );\r\n\t\r\n\t\t\t\t\t\t\t_this.info.render.calls ++;\r\n\t\t\t\t\t\t\t_this.info.render.vertices += offsets[ i ].count; // not really true, here vertices can be shared\r\n\t\t\t\t\t\t\t_this.info.render.faces += offsets[ i ].count / 3;\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t// non-indexed triangles\r\n\t\r\n\t\t\t\t\tif ( updateBuffers ) {\r\n\t\r\n\t\t\t\t\t\tsetupVertexAttributes( material, program, geometry, 0 );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tvar position = geometry.attributes[ 'position' ];\r\n\t\r\n\t\t\t\t\t// render non-indexed triangles\r\n\t\r\n\t\t\t\t\t_gl.drawArrays( mode, 0, position.array.length / position.itemSize );\r\n\t\r\n\t\t\t\t\t_this.info.render.calls ++;\r\n\t\t\t\t\t_this.info.render.vertices += position.array.length / position.itemSize;\r\n\t\t\t\t\t_this.info.render.faces += position.array.length / ( 3 * position.itemSize );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t} else if ( object instanceof THREE.PointCloud ) {\r\n\t\r\n\t\t\t\t// render particles\r\n\t\r\n\t\t\t\tvar mode = _gl.POINTS;\r\n\t\r\n\t\t\t\tvar index = geometry.attributes.index;\r\n\t\r\n\t\t\t\tif ( index ) {\r\n\t\r\n\t\t\t\t\t// indexed points\r\n\t\r\n\t\t\t\t\tvar type, size;\r\n\t\r\n\t\t\t\t\tif ( index.array instanceof Uint32Array && extensions.get( 'OES_element_index_uint' ) ) {\r\n\t\r\n\t\t\t\t\t\ttype = _gl.UNSIGNED_INT;\r\n\t\t\t\t\t\tsize = 4;\r\n\t\r\n\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\ttype = _gl.UNSIGNED_SHORT;\r\n\t\t\t\t\t\tsize = 2;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tvar offsets = geometry.offsets;\r\n\t\r\n\t\t\t\t\tif ( offsets.length === 0 ) {\r\n\t\r\n\t\t\t\t\t\tif ( updateBuffers ) {\r\n\t\r\n\t\t\t\t\t\t\tsetupVertexAttributes( material, program, geometry, 0 );\r\n\t\t\t\t\t\t\t_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, index.buffer );\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t_gl.drawElements( mode, index.array.length, type, 0);\r\n\t\r\n\t\t\t\t\t\t_this.info.render.calls ++;\r\n\t\t\t\t\t\t_this.info.render.points += index.array.length;\r\n\t\r\n\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\t// if there is more than 1 chunk\r\n\t\t\t\t\t\t// must set attribute pointers to use new offsets for each chunk\r\n\t\t\t\t\t\t// even if geometry and materials didn't change\r\n\t\r\n\t\t\t\t\t\tif ( offsets.length > 1 ) updateBuffers = true;\r\n\t\r\n\t\t\t\t\t\tfor ( var i = 0, il = offsets.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\t\t\t\tvar startIndex = offsets[ i ].index;\r\n\t\r\n\t\t\t\t\t\t\tif ( updateBuffers ) {\r\n\t\r\n\t\t\t\t\t\t\t\tsetupVertexAttributes( material, program, geometry, startIndex );\r\n\t\t\t\t\t\t\t\t_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, index.buffer );\r\n\t\r\n\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t\t// render indexed points\r\n\t\r\n\t\t\t\t\t\t\t_gl.drawElements( mode, offsets[ i ].count, type, offsets[ i ].start * size );\r\n\t\r\n\t\t\t\t\t\t\t_this.info.render.calls ++;\r\n\t\t\t\t\t\t\t_this.info.render.points += offsets[ i ].count;\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t// non-indexed points\r\n\t\r\n\t\t\t\t\tif ( updateBuffers ) {\r\n\t\r\n\t\t\t\t\t\tsetupVertexAttributes( material, program, geometry, 0 );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tvar position = geometry.attributes.position;\r\n\t\t\t\t\tvar offsets = geometry.offsets;\r\n\t\r\n\t\t\t\t\tif ( offsets.length === 0 ) {\r\n\t\r\n\t\t\t\t\t\t_gl.drawArrays( mode, 0, position.array.length / 3 );\r\n\t\r\n\t\t\t\t\t\t_this.info.render.calls ++;\r\n\t\t\t\t\t\t_this.info.render.points += position.array.length / 3;\r\n\t\r\n\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\tfor ( var i = 0, il = offsets.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\t\t\t\t_gl.drawArrays( mode, offsets[ i ].index, offsets[ i ].count );\r\n\t\r\n\t\t\t\t\t\t\t_this.info.render.calls ++;\r\n\t\t\t\t\t\t\t_this.info.render.points += offsets[ i ].count;\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t} else if ( object instanceof THREE.Line ) {\r\n\t\r\n\t\t\t\tvar mode = ( object.mode === THREE.LineStrip ) ? _gl.LINE_STRIP : _gl.LINES;\r\n\t\r\n\t\t\t\tstate.setLineWidth( material.linewidth * pixelRatio );\r\n\t\r\n\t\t\t\tvar index = geometry.attributes.index;\r\n\t\r\n\t\t\t\tif ( index ) {\r\n\t\r\n\t\t\t\t\t// indexed lines\r\n\t\r\n\t\t\t\t\tvar type, size;\r\n\t\r\n\t\t\t\t\tif ( index.array instanceof Uint32Array ) {\r\n\t\r\n\t\t\t\t\t\ttype = _gl.UNSIGNED_INT;\r\n\t\t\t\t\t\tsize = 4;\r\n\t\r\n\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\ttype = _gl.UNSIGNED_SHORT;\r\n\t\t\t\t\t\tsize = 2;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tvar offsets = geometry.offsets;\r\n\t\r\n\t\t\t\t\tif ( offsets.length === 0 ) {\r\n\t\r\n\t\t\t\t\t\tif ( updateBuffers ) {\r\n\t\r\n\t\t\t\t\t\t\tsetupVertexAttributes( material, program, geometry, 0 );\r\n\t\t\t\t\t\t\t_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, index.buffer );\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t_gl.drawElements( mode, index.array.length, type, 0 ); // 2 bytes per Uint16Array\r\n\t\r\n\t\t\t\t\t\t_this.info.render.calls ++;\r\n\t\t\t\t\t\t_this.info.render.vertices += index.array.length; // not really true, here vertices can be shared\r\n\t\r\n\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\t// if there is more than 1 chunk\r\n\t\t\t\t\t\t// must set attribute pointers to use new offsets for each chunk\r\n\t\t\t\t\t\t// even if geometry and materials didn't change\r\n\t\r\n\t\t\t\t\t\tif ( offsets.length > 1 ) updateBuffers = true;\r\n\t\r\n\t\t\t\t\t\tfor ( var i = 0, il = offsets.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\t\t\t\tvar startIndex = offsets[ i ].index;\r\n\t\r\n\t\t\t\t\t\t\tif ( updateBuffers ) {\r\n\t\r\n\t\t\t\t\t\t\t\tsetupVertexAttributes( material, program, geometry, startIndex );\r\n\t\t\t\t\t\t\t\t_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, index.buffer );\r\n\t\r\n\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t\t// render indexed lines\r\n\t\r\n\t\t\t\t\t\t\t_gl.drawElements( mode, offsets[ i ].count, type, offsets[ i ].start * size ); // 2 bytes per Uint16Array\r\n\t\r\n\t\t\t\t\t\t\t_this.info.render.calls ++;\r\n\t\t\t\t\t\t\t_this.info.render.vertices += offsets[ i ].count; // not really true, here vertices can be shared\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t// non-indexed lines\r\n\t\r\n\t\t\t\t\tif ( updateBuffers ) {\r\n\t\r\n\t\t\t\t\t\tsetupVertexAttributes( material, program, geometry, 0 );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tvar position = geometry.attributes.position;\r\n\t\t\t\t\tvar offsets = geometry.offsets;\r\n\t\r\n\t\t\t\t\tif ( offsets.length === 0 ) {\r\n\t\r\n\t\t\t\t\t\t_gl.drawArrays( mode, 0, position.array.length / 3 );\r\n\t\r\n\t\t\t\t\t\t_this.info.render.calls ++;\r\n\t\t\t\t\t\t_this.info.render.vertices += position.array.length / 3;\r\n\t\r\n\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\tfor ( var i = 0, il = offsets.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\t\t\t\t_gl.drawArrays( mode, offsets[ i ].index, offsets[ i ].count );\r\n\t\r\n\t\t\t\t\t\t\t_this.info.render.calls ++;\r\n\t\t\t\t\t\t\t_this.info.render.vertices += offsets[ i ].count;\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.renderBuffer = function ( camera, lights, fog, material, geometryGroup, object ) {\r\n\t\r\n\t\t\tif ( material.visible === false ) return;\r\n\t\r\n\t\t\tupdateObject( object );\r\n\t\r\n\t\t\tvar program = setProgram( camera, lights, fog, material, object );\r\n\t\r\n\t\t\tvar attributes = program.attributes;\r\n\t\r\n\t\t\tvar updateBuffers = false,\r\n\t\t\t\twireframeBit = material.wireframe ? 1 : 0,\r\n\t\t\t\tgeometryProgram = geometryGroup.id + '_' + program.id + '_' + wireframeBit;\r\n\t\r\n\t\t\tif ( geometryProgram !== _currentGeometryProgram ) {\r\n\t\r\n\t\t\t\t_currentGeometryProgram = geometryProgram;\r\n\t\t\t\tupdateBuffers = true;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( updateBuffers ) {\r\n\t\r\n\t\t\t\tstate.initAttributes();\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// vertices\r\n\t\r\n\t\t\tif ( ! material.morphTargets && attributes.position >= 0 ) {\r\n\t\r\n\t\t\t\tif ( updateBuffers ) {\r\n\t\r\n\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglVertexBuffer );\r\n\t\r\n\t\t\t\t\tstate.enableAttribute( attributes.position );\r\n\t\r\n\t\t\t\t\t_gl.vertexAttribPointer( attributes.position, 3, _gl.FLOAT, false, 0, 0 );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\tif ( object.morphTargetBase ) {\r\n\t\r\n\t\t\t\t\tsetupMorphTargets( material, geometryGroup, object );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\r\n\t\t\tif ( updateBuffers ) {\r\n\t\r\n\t\t\t\t// custom attributes\r\n\t\r\n\t\t\t\t// Use the per-geometryGroup custom attribute arrays which are setup in initMeshBuffers\r\n\t\r\n\t\t\t\tif ( geometryGroup.__webglCustomAttributesList ) {\r\n\t\r\n\t\t\t\t\tfor ( var i = 0, il = geometryGroup.__webglCustomAttributesList.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\t\t\tvar attribute = geometryGroup.__webglCustomAttributesList[ i ];\r\n\t\r\n\t\t\t\t\t\tif ( attributes[ attribute.buffer.belongsToAttribute ] >= 0 ) {\r\n\t\r\n\t\t\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, attribute.buffer );\r\n\t\r\n\t\t\t\t\t\t\tstate.enableAttribute( attributes[ attribute.buffer.belongsToAttribute ] );\r\n\t\r\n\t\t\t\t\t\t\t_gl.vertexAttribPointer( attributes[ attribute.buffer.belongsToAttribute ], attribute.size, _gl.FLOAT, false, 0, 0 );\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\r\n\t\t\t\t// colors\r\n\t\r\n\t\t\t\tif ( attributes.color >= 0 ) {\r\n\t\r\n\t\t\t\t\tif ( object.geometry.colors.length > 0 || object.geometry.faces.length > 0 ) {\r\n\t\r\n\t\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglColorBuffer );\r\n\t\r\n\t\t\t\t\t\tstate.enableAttribute( attributes.color );\r\n\t\r\n\t\t\t\t\t\t_gl.vertexAttribPointer( attributes.color, 3, _gl.FLOAT, false, 0, 0 );\r\n\t\r\n\t\t\t\t\t} else if ( material.defaultAttributeValues !== undefined ) {\r\n\t\r\n\t\r\n\t\t\t\t\t\t_gl.vertexAttrib3fv( attributes.color, material.defaultAttributeValues.color );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\t// normals\r\n\t\r\n\t\t\t\tif ( attributes.normal >= 0 ) {\r\n\t\r\n\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglNormalBuffer );\r\n\t\r\n\t\t\t\t\tstate.enableAttribute( attributes.normal );\r\n\t\r\n\t\t\t\t\t_gl.vertexAttribPointer( attributes.normal, 3, _gl.FLOAT, false, 0, 0 );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\t// tangents\r\n\t\r\n\t\t\t\tif ( attributes.tangent >= 0 ) {\r\n\t\r\n\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglTangentBuffer );\r\n\t\r\n\t\t\t\t\tstate.enableAttribute( attributes.tangent );\r\n\t\r\n\t\t\t\t\t_gl.vertexAttribPointer( attributes.tangent, 4, _gl.FLOAT, false, 0, 0 );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\t// uvs\r\n\t\r\n\t\t\t\tif ( attributes.uv >= 0 ) {\r\n\t\r\n\t\t\t\t\tif ( object.geometry.faceVertexUvs[ 0 ] ) {\r\n\t\r\n\t\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglUVBuffer );\r\n\t\r\n\t\t\t\t\t\tstate.enableAttribute( attributes.uv );\r\n\t\r\n\t\t\t\t\t\t_gl.vertexAttribPointer( attributes.uv, 2, _gl.FLOAT, false, 0, 0 );\r\n\t\r\n\t\t\t\t\t} else if ( material.defaultAttributeValues !== undefined ) {\r\n\t\r\n\t\r\n\t\t\t\t\t\t_gl.vertexAttrib2fv( attributes.uv, material.defaultAttributeValues.uv );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( attributes.uv2 >= 0 ) {\r\n\t\r\n\t\t\t\t\tif ( object.geometry.faceVertexUvs[ 1 ] ) {\r\n\t\r\n\t\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglUV2Buffer );\r\n\t\r\n\t\t\t\t\t\tstate.enableAttribute( attributes.uv2 );\r\n\t\r\n\t\t\t\t\t\t_gl.vertexAttribPointer( attributes.uv2, 2, _gl.FLOAT, false, 0, 0 );\r\n\t\r\n\t\t\t\t\t} else if ( material.defaultAttributeValues !== undefined ) {\r\n\t\r\n\t\r\n\t\t\t\t\t\t_gl.vertexAttrib2fv( attributes.uv2, material.defaultAttributeValues.uv2 );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( material.skinning &&\r\n\t\t\t\t\t attributes.skinIndex >= 0 && attributes.skinWeight >= 0 ) {\r\n\t\r\n\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglSkinIndicesBuffer );\r\n\t\r\n\t\t\t\t\tstate.enableAttribute( attributes.skinIndex );\r\n\t\r\n\t\t\t\t\t_gl.vertexAttribPointer( attributes.skinIndex, 4, _gl.FLOAT, false, 0, 0 );\r\n\t\r\n\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglSkinWeightsBuffer );\r\n\t\r\n\t\t\t\t\tstate.enableAttribute( attributes.skinWeight );\r\n\t\r\n\t\t\t\t\t_gl.vertexAttribPointer( attributes.skinWeight, 4, _gl.FLOAT, false, 0, 0 );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\t// line distances\r\n\t\r\n\t\t\t\tif ( attributes.lineDistance >= 0 ) {\r\n\t\r\n\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglLineDistanceBuffer );\r\n\t\r\n\t\t\t\t\tstate.enableAttribute( attributes.lineDistance );\r\n\t\r\n\t\t\t\t\t_gl.vertexAttribPointer( attributes.lineDistance, 1, _gl.FLOAT, false, 0, 0 );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tstate.disableUnusedAttributes();\r\n\t\r\n\t\t\t// render mesh\r\n\t\r\n\t\t\tif ( object instanceof THREE.Mesh ) {\r\n\t\r\n\t\t\t\tvar type = geometryGroup.__typeArray === Uint32Array ? _gl.UNSIGNED_INT : _gl.UNSIGNED_SHORT;\r\n\t\r\n\t\t\t\t// wireframe\r\n\t\r\n\t\t\t\tif ( material.wireframe ) {\r\n\t\r\n\t\t\t\t\tstate.setLineWidth( material.wireframeLinewidth * pixelRatio );\r\n\t\r\n\t\t\t\t\tif ( updateBuffers ) _gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, geometryGroup.__webglLineBuffer );\r\n\t\t\t\t\t_gl.drawElements( _gl.LINES, geometryGroup.__webglLineCount, type, 0 );\r\n\t\r\n\t\t\t\t// triangles\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tif ( updateBuffers ) _gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, geometryGroup.__webglFaceBuffer );\r\n\t\t\t\t\t_gl.drawElements( _gl.TRIANGLES, geometryGroup.__webglFaceCount, type, 0 );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\t_this.info.render.calls ++;\r\n\t\t\t\t_this.info.render.vertices += geometryGroup.__webglFaceCount;\r\n\t\t\t\t_this.info.render.faces += geometryGroup.__webglFaceCount / 3;\r\n\t\r\n\t\t\t// render lines\r\n\t\r\n\t\t\t} else if ( object instanceof THREE.Line ) {\r\n\t\r\n\t\t\t\tvar mode = ( object.mode === THREE.LineStrip ) ? _gl.LINE_STRIP : _gl.LINES;\r\n\t\r\n\t\t\t\tstate.setLineWidth( material.linewidth * pixelRatio );\r\n\t\r\n\t\t\t\t_gl.drawArrays( mode, 0, geometryGroup.__webglLineCount );\r\n\t\r\n\t\t\t\t_this.info.render.calls ++;\r\n\t\r\n\t\t\t// render particles\r\n\t\r\n\t\t\t} else if ( object instanceof THREE.PointCloud ) {\r\n\t\r\n\t\t\t\t_gl.drawArrays( _gl.POINTS, 0, geometryGroup.__webglParticleCount );\r\n\t\r\n\t\t\t\t_this.info.render.calls ++;\r\n\t\t\t\t_this.info.render.points += geometryGroup.__webglParticleCount;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t\tfunction setupMorphTargets ( material, geometryGroup, object ) {\r\n\t\r\n\t\t\t// set base\r\n\t\r\n\t\t\tvar attributes = material.program.attributes;\r\n\t\r\n\t\t\tif ( object.morphTargetBase !== - 1 && attributes.position >= 0 ) {\r\n\t\r\n\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglMorphTargetsBuffers[ object.morphTargetBase ] );\r\n\t\r\n\t\t\t\tstate.enableAttribute( attributes.position );\r\n\t\r\n\t\t\t\t_gl.vertexAttribPointer( attributes.position, 3, _gl.FLOAT, false, 0, 0 );\r\n\t\r\n\t\t\t} else if ( attributes.position >= 0 ) {\r\n\t\r\n\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglVertexBuffer );\r\n\t\r\n\t\t\t\tstate.enableAttribute( attributes.position );\r\n\t\r\n\t\t\t\t_gl.vertexAttribPointer( attributes.position, 3, _gl.FLOAT, false, 0, 0 );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( object.morphTargetForcedOrder.length ) {\r\n\t\r\n\t\t\t\t// set forced order\r\n\t\r\n\t\t\t\tvar m = 0;\r\n\t\t\t\tvar order = object.morphTargetForcedOrder;\r\n\t\t\t\tvar influences = object.morphTargetInfluences;\r\n\t\r\n\t\t\t\tvar attribute;\r\n\t\r\n\t\t\t\twhile ( m < material.numSupportedMorphTargets && m < order.length ) {\r\n\t\r\n\t\t\t\t\tattribute = attributes[ 'morphTarget' + m ];\r\n\t\r\n\t\t\t\t\tif ( attribute >= 0 ) {\r\n\t\r\n\t\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglMorphTargetsBuffers[ order[ m ] ] );\r\n\t\r\n\t\t\t\t\t\tstate.enableAttribute( attribute );\r\n\t\r\n\t\t\t\t\t\t_gl.vertexAttribPointer( attribute, 3, _gl.FLOAT, false, 0, 0 );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tattribute = attributes[ 'morphNormal' + m ];\r\n\t\r\n\t\t\t\t\tif ( attribute >= 0 && material.morphNormals ) {\r\n\t\r\n\t\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglMorphNormalsBuffers[ order[ m ] ] );\r\n\t\r\n\t\t\t\t\t\tstate.enableAttribute( attribute );\r\n\t\r\n\t\t\t\t\t\t_gl.vertexAttribPointer( attribute, 3, _gl.FLOAT, false, 0, 0 );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tobject.__webglMorphTargetInfluences[ m ] = influences[ order[ m ] ];\r\n\t\r\n\t\t\t\t\tm ++;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\t// find the most influencing\r\n\t\r\n\t\t\t\tvar activeInfluenceIndices = [];\r\n\t\t\t\tvar influences = object.morphTargetInfluences;\r\n\t\t\t\tvar morphTargets = object.geometry.morphTargets;\r\n\t\r\n\t\t\t\tif ( influences.length > morphTargets.length ) {\r\n\t\r\n\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: Influences array is bigger than morphTargets array.' );\r\n\t\t\t\t\tinfluences.length = morphTargets.length;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tfor ( var i = 0, il = influences.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\t\tvar influence = influences[ i ];\r\n\t\r\n\t\t\t\t\tactiveInfluenceIndices.push( [ influence, i ] );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( activeInfluenceIndices.length > material.numSupportedMorphTargets ) {\r\n\t\r\n\t\t\t\t\tactiveInfluenceIndices.sort( numericalSort );\r\n\t\t\t\t\tactiveInfluenceIndices.length = material.numSupportedMorphTargets;\r\n\t\r\n\t\t\t\t} else if ( activeInfluenceIndices.length > material.numSupportedMorphNormals ) {\r\n\t\r\n\t\t\t\t\tactiveInfluenceIndices.sort( numericalSort );\r\n\t\r\n\t\t\t\t} else if ( activeInfluenceIndices.length === 0 ) {\r\n\t\r\n\t\t\t\t\tactiveInfluenceIndices.push( [ 0, 0 ] );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tvar attribute;\r\n\t\r\n\t\t\t\tfor ( var m = 0, ml = material.numSupportedMorphTargets; m < ml; m ++ ) {\r\n\t\r\n\t\t\t\t\tif ( activeInfluenceIndices[ m ] ) {\r\n\t\r\n\t\t\t\t\t\tvar influenceIndex = activeInfluenceIndices[ m ][ 1 ];\r\n\t\r\n\t\t\t\t\t\tattribute = attributes[ 'morphTarget' + m ];\r\n\t\r\n\t\t\t\t\t\tif ( attribute >= 0 ) {\r\n\t\r\n\t\t\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglMorphTargetsBuffers[ influenceIndex ] );\r\n\t\r\n\t\t\t\t\t\t\tstate.enableAttribute( attribute );\r\n\t\r\n\t\t\t\t\t\t\t_gl.vertexAttribPointer( attribute, 3, _gl.FLOAT, false, 0, 0 );\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\tattribute = attributes[ 'morphNormal' + m ];\r\n\t\r\n\t\t\t\t\t\tif ( attribute >= 0 && material.morphNormals ) {\r\n\t\r\n\t\t\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglMorphNormalsBuffers[ influenceIndex ] );\r\n\t\r\n\t\t\t\t\t\t\tstate.enableAttribute( attribute );\r\n\t\r\n\t\t\t\t\t\t\t_gl.vertexAttribPointer( attribute, 3, _gl.FLOAT, false, 0, 0 );\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\tobject.__webglMorphTargetInfluences[ m ] = influences[ influenceIndex ];\r\n\t\r\n\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\t/*\r\n\t\t\t\t\t\t_gl.vertexAttribPointer( attributes[ \"morphTarget\" + m ], 3, _gl.FLOAT, false, 0, 0 );\r\n\t\r\n\t\t\t\t\t\tif ( material.morphNormals ) {\r\n\t\r\n\t\t\t\t\t\t\t_gl.vertexAttribPointer( attributes[ \"morphNormal\" + m ], 3, _gl.FLOAT, false, 0, 0 );\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t*/\r\n\t\r\n\t\t\t\t\t\tobject.__webglMorphTargetInfluences[ m ] = 0;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// load updated influences uniform\r\n\t\r\n\t\t\tif ( material.program.uniforms.morphTargetInfluences !== null ) {\r\n\t\r\n\t\t\t\t_gl.uniform1fv( material.program.uniforms.morphTargetInfluences, object.__webglMorphTargetInfluences );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\t// Sorting\r\n\t\r\n\t\tfunction painterSortStable ( a, b ) {\r\n\t\r\n\t\t\tif ( a.object.renderOrder !== b.object.renderOrder ) {\r\n\t\r\n\t\t\t\treturn a.object.renderOrder - b.object.renderOrder;\r\n\t\r\n\t\t\t} else if ( a.material.id !== b.material.id ) {\r\n\t\r\n\t\t\t\treturn a.material.id - b.material.id;\r\n\t\r\n\t\t\t} else if ( a.z !== b.z ) {\r\n\t\r\n\t\t\t\treturn a.z - b.z;\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\treturn a.id - b.id;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction reversePainterSortStable ( a, b ) {\r\n\t\r\n\t\t\tif ( a.object.renderOrder !== b.object.renderOrder ) {\r\n\t\r\n\t\t\t\treturn a.object.renderOrder - b.object.renderOrder;\r\n\t\r\n\t\t\t} if ( a.z !== b.z ) {\r\n\t\r\n\t\t\t\treturn b.z - a.z;\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\treturn a.id - b.id;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction numericalSort ( a, b ) {\r\n\t\r\n\t\t\treturn b[ 0 ] - a[ 0 ];\r\n\t\r\n\t\t}\r\n\t\r\n\t\t// Rendering\r\n\t\r\n\t\tthis.render = function ( scene, camera, renderTarget, forceClear ) {\r\n\t\r\n\t\t\tif ( camera instanceof THREE.Camera === false ) {\r\n\t\r\n\t\t\t\tTHREE.error( 'THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.' );\r\n\t\t\t\treturn;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar fog = scene.fog;\r\n\t\r\n\t\t\t// reset caching for this frame\r\n\t\r\n\t\t\t_currentGeometryProgram = '';\r\n\t\t\t_currentMaterialId = - 1;\r\n\t\t\t_currentCamera = null;\r\n\t\t\t_lightsNeedUpdate = true;\r\n\t\r\n\t\t\t// update scene graph\r\n\t\r\n\t\t\tif ( scene.autoUpdate === true ) scene.updateMatrixWorld();\r\n\t\r\n\t\t\t// update camera matrices and frustum\r\n\t\r\n\t\t\tif ( camera.parent === undefined ) camera.updateMatrixWorld();\r\n\t\r\n\t\t\t// update Skeleton objects\r\n\t\r\n\t\t\tscene.traverse( function ( object ) {\r\n\t\r\n\t\t\t\tif ( object instanceof THREE.SkinnedMesh ) {\r\n\t\r\n\t\t\t\t\tobject.skeleton.update();\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t} );\r\n\t\r\n\t\t\tcamera.matrixWorldInverse.getInverse( camera.matrixWorld );\r\n\t\r\n\t\t\t_projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );\r\n\t\t\t_frustum.setFromMatrix( _projScreenMatrix );\r\n\t\r\n\t\t\tlights.length = 0;\r\n\t\t\topaqueObjects.length = 0;\r\n\t\t\ttransparentObjects.length = 0;\r\n\t\r\n\t\t\tsprites.length = 0;\r\n\t\t\tlensFlares.length = 0;\r\n\t\r\n\t\t\tprojectObject( scene );\r\n\t\r\n\t\t\tif ( _this.sortObjects === true ) {\r\n\t\r\n\t\t\t\topaqueObjects.sort( painterSortStable );\r\n\t\t\t\ttransparentObjects.sort( reversePainterSortStable );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// custom render plugins (pre pass)\r\n\t\r\n\t\t\tshadowMapPlugin.render( scene, camera );\r\n\t\r\n\t\t\t//\r\n\t\r\n\t\t\t_this.info.render.calls = 0;\r\n\t\t\t_this.info.render.vertices = 0;\r\n\t\t\t_this.info.render.faces = 0;\r\n\t\t\t_this.info.render.points = 0;\r\n\t\r\n\t\t\tthis.setRenderTarget( renderTarget );\r\n\t\r\n\t\t\tif ( this.autoClear || forceClear ) {\r\n\t\r\n\t\t\t\tthis.clear( this.autoClearColor, this.autoClearDepth, this.autoClearStencil );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// set matrices for immediate objects\r\n\t\r\n\t\t\tfor ( var i = 0, il = _webglObjectsImmediate.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\tvar webglObject = _webglObjectsImmediate[ i ];\r\n\t\t\t\tvar object = webglObject.object;\r\n\t\r\n\t\t\t\tif ( object.visible ) {\r\n\t\r\n\t\t\t\t\tsetupMatrices( object, camera );\r\n\t\r\n\t\t\t\t\tunrollImmediateBufferMaterial( webglObject );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( scene.overrideMaterial ) {\r\n\t\r\n\t\t\t\tvar overrideMaterial = scene.overrideMaterial;\r\n\t\r\n\t\t\t\tsetMaterial( overrideMaterial );\r\n\t\r\n\t\t\t\trenderObjects( opaqueObjects, camera, lights, fog, overrideMaterial );\r\n\t\t\t\trenderObjects( transparentObjects, camera, lights, fog, overrideMaterial );\r\n\t\t\t\trenderObjectsImmediate( _webglObjectsImmediate, '', camera, lights, fog, overrideMaterial );\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\t// opaque pass (front-to-back order)\r\n\t\r\n\t\t\t\tstate.setBlending( THREE.NoBlending );\r\n\t\r\n\t\t\t\trenderObjects( opaqueObjects, camera, lights, fog, null );\r\n\t\t\t\trenderObjectsImmediate( _webglObjectsImmediate, 'opaque', camera, lights, fog, null );\r\n\t\r\n\t\t\t\t// transparent pass (back-to-front order)\r\n\t\r\n\t\t\t\trenderObjects( transparentObjects, camera, lights, fog, null );\r\n\t\t\t\trenderObjectsImmediate( _webglObjectsImmediate, 'transparent', camera, lights, fog, null );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// custom render plugins (post pass)\r\n\t\r\n\t\t\tspritePlugin.render( scene, camera );\r\n\t\t\tlensFlarePlugin.render( scene, camera, _currentWidth, _currentHeight );\r\n\t\r\n\t\t\t// Generate mipmap if we're using any kind of mipmap filtering\r\n\t\r\n\t\t\tif ( renderTarget && renderTarget.generateMipmaps && renderTarget.minFilter !== THREE.NearestFilter && renderTarget.minFilter !== THREE.LinearFilter ) {\r\n\t\r\n\t\t\t\tupdateRenderTargetMipmap( renderTarget );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// Ensure depth buffer writing is enabled so it can be cleared on next render\r\n\t\r\n\t\t\tstate.setDepthTest( true );\r\n\t\t\tstate.setDepthWrite( true );\r\n\t\t\tstate.setColorWrite( true );\r\n\t\r\n\t\t\t// _gl.finish();\r\n\t\r\n\t\t};\r\n\t\r\n\t\tfunction projectObject( object ) {\r\n\t\r\n\t\t\tif ( object.visible === false ) return;\r\n\t\r\n\t\t\tif ( object instanceof THREE.Scene || object instanceof THREE.Group ) {\r\n\t\r\n\t\t\t\t// skip\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\tinitObject( object );\r\n\t\r\n\t\t\t\tif ( object instanceof THREE.Light ) {\r\n\t\r\n\t\t\t\t\tlights.push( object );\r\n\t\r\n\t\t\t\t} else if ( object instanceof THREE.Sprite ) {\r\n\t\r\n\t\t\t\t\tsprites.push( object );\r\n\t\r\n\t\t\t\t} else if ( object instanceof THREE.LensFlare ) {\r\n\t\r\n\t\t\t\t\tlensFlares.push( object );\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tvar webglObjects = _webglObjects[ object.id ];\r\n\t\r\n\t\t\t\t\tif ( webglObjects && ( object.frustumCulled === false || _frustum.intersectsObject( object ) === true ) ) {\r\n\t\r\n\t\t\t\t\t\tfor ( var i = 0, l = webglObjects.length; i < l; i ++ ) {\r\n\t\r\n\t\t\t\t\t\t\tvar webglObject = webglObjects[ i ];\r\n\t\r\n\t\t\t\t\t\t\tunrollBufferMaterial( webglObject );\r\n\t\r\n\t\t\t\t\t\t\twebglObject.render = true;\r\n\t\r\n\t\t\t\t\t\t\tif ( _this.sortObjects === true ) {\r\n\t\r\n\t\t\t\t\t\t\t\t_vector3.setFromMatrixPosition( object.matrixWorld );\r\n\t\t\t\t\t\t\t\t_vector3.applyProjection( _projScreenMatrix );\r\n\t\r\n\t\t\t\t\t\t\t\twebglObject.z = _vector3.z;\r\n\t\r\n\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tfor ( var i = 0, l = object.children.length; i < l; i ++ ) {\r\n\t\r\n\t\t\t\tprojectObject( object.children[ i ] );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction renderObjects( renderList, camera, lights, fog, overrideMaterial ) {\r\n\t\r\n\t\t\tvar material;\r\n\t\r\n\t\t\tfor ( var i = 0, l = renderList.length; i < l; i ++ ) {\r\n\t\r\n\t\t\t\tvar webglObject = renderList[ i ];\r\n\t\r\n\t\t\t\tvar object = webglObject.object;\r\n\t\t\t\tvar buffer = webglObject.buffer;\r\n\t\r\n\t\t\t\tsetupMatrices( object, camera );\r\n\t\r\n\t\t\t\tif ( overrideMaterial ) {\r\n\t\r\n\t\t\t\t\tmaterial = overrideMaterial;\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tmaterial = webglObject.material;\r\n\t\r\n\t\t\t\t\tif ( ! material ) continue;\r\n\t\r\n\t\t\t\t\tsetMaterial( material );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\t_this.setMaterialFaces( material );\r\n\t\r\n\t\t\t\tif ( buffer instanceof THREE.BufferGeometry ) {\r\n\t\r\n\t\t\t\t\t_this.renderBufferDirect( camera, lights, fog, material, buffer, object );\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t_this.renderBuffer( camera, lights, fog, material, buffer, object );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction renderObjectsImmediate ( renderList, materialType, camera, lights, fog, overrideMaterial ) {\r\n\t\r\n\t\t\tvar material;\r\n\t\r\n\t\t\tfor ( var i = 0, l = renderList.length; i < l; i ++ ) {\r\n\t\r\n\t\t\t\tvar webglObject = renderList[ i ];\r\n\t\t\t\tvar object = webglObject.object;\r\n\t\r\n\t\t\t\tif ( object.visible ) {\r\n\t\r\n\t\t\t\t\tif ( overrideMaterial ) {\r\n\t\r\n\t\t\t\t\t\tmaterial = overrideMaterial;\r\n\t\r\n\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\tmaterial = webglObject[ materialType ];\r\n\t\r\n\t\t\t\t\t\tif ( ! material ) continue;\r\n\t\r\n\t\t\t\t\t\tsetMaterial( material );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t_this.renderImmediateObject( camera, lights, fog, material, object );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\tthis.renderImmediateObject = function ( camera, lights, fog, material, object ) {\r\n\t\r\n\t\t\tvar program = setProgram( camera, lights, fog, material, object );\r\n\t\r\n\t\t\t_currentGeometryProgram = '';\r\n\t\r\n\t\t\t_this.setMaterialFaces( material );\r\n\t\r\n\t\t\tif ( object.immediateRenderCallback ) {\r\n\t\r\n\t\t\t\tobject.immediateRenderCallback( program, _gl, _frustum );\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\tobject.render( function ( object ) { _this.renderBufferImmediate( object, program, material ); } );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t\tfunction unrollImmediateBufferMaterial ( globject ) {\r\n\t\r\n\t\t\tvar object = globject.object,\r\n\t\t\t\tmaterial = object.material;\r\n\t\r\n\t\t\tif ( material.transparent ) {\r\n\t\r\n\t\t\t\tglobject.transparent = material;\r\n\t\t\t\tglobject.opaque = null;\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\tglobject.opaque = material;\r\n\t\t\t\tglobject.transparent = null;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction unrollBufferMaterial ( globject ) {\r\n\t\r\n\t\t\tvar object = globject.object;\r\n\t\t\tvar buffer = globject.buffer;\r\n\t\r\n\t\t\tvar geometry = object.geometry;\r\n\t\t\tvar material = object.material;\r\n\t\r\n\t\t\tif ( material instanceof THREE.MeshFaceMaterial ) {\r\n\t\r\n\t\t\t\tvar materialIndex = geometry instanceof THREE.BufferGeometry ? 0 : buffer.materialIndex;\r\n\t\r\n\t\t\t\tmaterial = material.materials[ materialIndex ];\r\n\t\r\n\t\t\t\tglobject.material = material;\r\n\t\r\n\t\t\t\tif ( material.transparent ) {\r\n\t\r\n\t\t\t\t\ttransparentObjects.push( globject );\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\topaqueObjects.push( globject );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t} else if ( material ) {\r\n\t\r\n\t\t\t\tglobject.material = material;\r\n\t\r\n\t\t\t\tif ( material.transparent ) {\r\n\t\r\n\t\t\t\t\ttransparentObjects.push( globject );\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\topaqueObjects.push( globject );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction initObject( object ) {\r\n\t\r\n\t\t\tif ( object.__webglInit === undefined ) {\r\n\t\r\n\t\t\t\tobject.__webglInit = true;\r\n\t\t\t\tobject._modelViewMatrix = new THREE.Matrix4();\r\n\t\t\t\tobject._normalMatrix = new THREE.Matrix3();\r\n\t\r\n\t\t\t\tobject.addEventListener( 'removed', onObjectRemoved );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar geometry = object.geometry;\r\n\t\r\n\t\t\tif ( geometry === undefined ) {\r\n\t\r\n\t\t\t\t// ImmediateRenderObject\r\n\t\r\n\t\t\t} else if ( geometry.__webglInit === undefined ) {\r\n\t\r\n\t\t\t\tgeometry.__webglInit = true;\r\n\t\t\t\tgeometry.addEventListener( 'dispose', onGeometryDispose );\r\n\t\r\n\t\t\t\tif ( geometry instanceof THREE.BufferGeometry ) {\r\n\t\r\n\t\t\t\t\t_this.info.memory.geometries ++;\r\n\t\r\n\t\t\t\t} else if ( object instanceof THREE.Mesh ) {\r\n\t\r\n\t\t\t\t\tinitGeometryGroups( object, geometry );\r\n\t\r\n\t\t\t\t} else if ( object instanceof THREE.Line ) {\r\n\t\r\n\t\t\t\t\tif ( geometry.__webglVertexBuffer === undefined ) {\r\n\t\r\n\t\t\t\t\t\tcreateLineBuffers( geometry );\r\n\t\t\t\t\t\tinitLineBuffers( geometry, object );\r\n\t\r\n\t\t\t\t\t\tgeometry.verticesNeedUpdate = true;\r\n\t\t\t\t\t\tgeometry.colorsNeedUpdate = true;\r\n\t\t\t\t\t\tgeometry.lineDistancesNeedUpdate = true;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t} else if ( object instanceof THREE.PointCloud ) {\r\n\t\r\n\t\t\t\t\tif ( geometry.__webglVertexBuffer === undefined ) {\r\n\t\r\n\t\t\t\t\t\tcreateParticleBuffers( geometry );\r\n\t\t\t\t\t\tinitParticleBuffers( geometry, object );\r\n\t\r\n\t\t\t\t\t\tgeometry.verticesNeedUpdate = true;\r\n\t\t\t\t\t\tgeometry.colorsNeedUpdate = true;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( object.__webglActive === undefined) {\r\n\t\r\n\t\t\t\tobject.__webglActive = true;\r\n\t\r\n\t\t\t\tif ( object instanceof THREE.Mesh ) {\r\n\t\r\n\t\t\t\t\tif ( geometry instanceof THREE.BufferGeometry ) {\r\n\t\r\n\t\t\t\t\t\taddBuffer( _webglObjects, geometry, object );\r\n\t\r\n\t\t\t\t\t} else if ( geometry instanceof THREE.Geometry ) {\r\n\t\r\n\t\t\t\t\t\tvar geometryGroupsList = geometryGroups[ geometry.id ];\r\n\t\r\n\t\t\t\t\t\tfor ( var i = 0,l = geometryGroupsList.length; i < l; i ++ ) {\r\n\t\r\n\t\t\t\t\t\t\taddBuffer( _webglObjects, geometryGroupsList[ i ], object );\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t} else if ( object instanceof THREE.Line || object instanceof THREE.PointCloud ) {\r\n\t\r\n\t\t\t\t\taddBuffer( _webglObjects, geometry, object );\r\n\t\r\n\t\t\t\t} else if ( object instanceof THREE.ImmediateRenderObject || object.immediateRenderCallback ) {\r\n\t\r\n\t\t\t\t\taddBufferImmediate( _webglObjectsImmediate, object );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\t// Geometry splitting\r\n\t\r\n\t\tvar geometryGroups = {};\r\n\t\tvar geometryGroupCounter = 0;\r\n\t\r\n\t\tfunction makeGroups( geometry, usesFaceMaterial ) {\r\n\t\r\n\t\t\tvar maxVerticesInGroup = extensions.get( 'OES_element_index_uint' ) ? 4294967296 : 65535;\r\n\t\r\n\t\t\tvar groupHash, hash_map = {};\r\n\t\r\n\t\t\tvar numMorphTargets = geometry.morphTargets.length;\r\n\t\t\tvar numMorphNormals = geometry.morphNormals.length;\r\n\t\r\n\t\t\tvar group;\r\n\t\t\tvar groups = {};\r\n\t\t\tvar groupsList = [];\r\n\t\r\n\t\t\tfor ( var f = 0, fl = geometry.faces.length; f < fl; f ++ ) {\r\n\t\r\n\t\t\t\tvar face = geometry.faces[ f ];\r\n\t\t\t\tvar materialIndex = usesFaceMaterial ? face.materialIndex : 0;\r\n\t\r\n\t\t\t\tif ( ! ( materialIndex in hash_map ) ) {\r\n\t\r\n\t\t\t\t\thash_map[ materialIndex ] = { hash: materialIndex, counter: 0 };\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tgroupHash = hash_map[ materialIndex ].hash + '_' + hash_map[ materialIndex ].counter;\r\n\t\r\n\t\t\t\tif ( ! ( groupHash in groups ) ) {\r\n\t\r\n\t\t\t\t\tgroup = {\r\n\t\t\t\t\t\tid: geometryGroupCounter ++,\r\n\t\t\t\t\t\tfaces3: [],\r\n\t\t\t\t\t\tmaterialIndex: materialIndex,\r\n\t\t\t\t\t\tvertices: 0,\r\n\t\t\t\t\t\tnumMorphTargets: numMorphTargets,\r\n\t\t\t\t\t\tnumMorphNormals: numMorphNormals\r\n\t\t\t\t\t};\r\n\t\r\n\t\t\t\t\tgroups[ groupHash ] = group;\r\n\t\t\t\t\tgroupsList.push( group );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( groups[ groupHash ].vertices + 3 > maxVerticesInGroup ) {\r\n\t\r\n\t\t\t\t\thash_map[ materialIndex ].counter += 1;\r\n\t\t\t\t\tgroupHash = hash_map[ materialIndex ].hash + '_' + hash_map[ materialIndex ].counter;\r\n\t\r\n\t\t\t\t\tif ( ! ( groupHash in groups ) ) {\r\n\t\r\n\t\t\t\t\t\tgroup = {\r\n\t\t\t\t\t\t\tid: geometryGroupCounter ++,\r\n\t\t\t\t\t\t\tfaces3: [],\r\n\t\t\t\t\t\t\tmaterialIndex: materialIndex,\r\n\t\t\t\t\t\t\tvertices: 0,\r\n\t\t\t\t\t\t\tnumMorphTargets: numMorphTargets,\r\n\t\t\t\t\t\t\tnumMorphNormals: numMorphNormals\r\n\t\t\t\t\t\t};\r\n\t\r\n\t\t\t\t\t\tgroups[ groupHash ] = group;\r\n\t\t\t\t\t\tgroupsList.push( group );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tgroups[ groupHash ].faces3.push( f );\r\n\t\t\t\tgroups[ groupHash ].vertices += 3;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn groupsList;\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction initGeometryGroups( object, geometry ) {\r\n\t\r\n\t\t\tvar material = object.material, addBuffers = false;\r\n\t\r\n\t\t\tif ( geometryGroups[ geometry.id ] === undefined || geometry.groupsNeedUpdate === true ) {\r\n\t\r\n\t\t\t\tdelete _webglObjects[ object.id ];\r\n\t\r\n\t\t\t\tgeometryGroups[ geometry.id ] = makeGroups( geometry, material instanceof THREE.MeshFaceMaterial );\r\n\t\r\n\t\t\t\tgeometry.groupsNeedUpdate = false;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar geometryGroupsList = geometryGroups[ geometry.id ];\r\n\t\r\n\t\t\t// create separate VBOs per geometry chunk\r\n\t\r\n\t\t\tfor ( var i = 0, il = geometryGroupsList.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\tvar geometryGroup = geometryGroupsList[ i ];\r\n\t\r\n\t\t\t\t// initialise VBO on the first access\r\n\t\r\n\t\t\t\tif ( geometryGroup.__webglVertexBuffer === undefined ) {\r\n\t\r\n\t\t\t\t\tcreateMeshBuffers( geometryGroup );\r\n\t\t\t\t\tinitMeshBuffers( geometryGroup, object );\r\n\t\r\n\t\t\t\t\tgeometry.verticesNeedUpdate = true;\r\n\t\t\t\t\tgeometry.morphTargetsNeedUpdate = true;\r\n\t\t\t\t\tgeometry.elementsNeedUpdate = true;\r\n\t\t\t\t\tgeometry.uvsNeedUpdate = true;\r\n\t\t\t\t\tgeometry.normalsNeedUpdate = true;\r\n\t\t\t\t\tgeometry.tangentsNeedUpdate = true;\r\n\t\t\t\t\tgeometry.colorsNeedUpdate = true;\r\n\t\r\n\t\t\t\t\taddBuffers = true;\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\taddBuffers = false;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( addBuffers || object.__webglActive === undefined ) {\r\n\t\r\n\t\t\t\t\taddBuffer( _webglObjects, geometryGroup, object );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tobject.__webglActive = true;\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction addBuffer( objlist, buffer, object ) {\r\n\t\r\n\t\t\tvar id = object.id;\r\n\t\t\tobjlist[id] = objlist[id] || [];\r\n\t\t\tobjlist[id].push(\r\n\t\t\t\t{\r\n\t\t\t\t\tid: id,\r\n\t\t\t\t\tbuffer: buffer,\r\n\t\t\t\t\tobject: object,\r\n\t\t\t\t\tmaterial: null,\r\n\t\t\t\t\tz: 0\r\n\t\t\t\t}\r\n\t\t\t);\r\n\t\r\n\t\t};\r\n\t\r\n\t\tfunction addBufferImmediate( objlist, object ) {\r\n\t\r\n\t\t\tobjlist.push(\r\n\t\t\t\t{\r\n\t\t\t\t\tid: null,\r\n\t\t\t\t\tobject: object,\r\n\t\t\t\t\topaque: null,\r\n\t\t\t\t\ttransparent: null,\r\n\t\t\t\t\tz: 0\r\n\t\t\t\t}\r\n\t\t\t);\r\n\t\r\n\t\t};\r\n\t\r\n\t\t// Objects updates\r\n\t\r\n\t\tfunction updateObject( object ) {\r\n\t\r\n\t\t\tvar geometry = object.geometry;\r\n\t\r\n\t\t\tif ( geometry instanceof THREE.BufferGeometry ) {\r\n\t\r\n\t\t\t\tvar attributes = geometry.attributes;\r\n\t\t\t\tvar attributesKeys = geometry.attributesKeys;\r\n\t\r\n\t\t\t\tfor ( var i = 0, l = attributesKeys.length; i < l; i ++ ) {\r\n\t\r\n\t\t\t\t\tvar key = attributesKeys[ i ];\r\n\t\t\t\t\tvar attribute = attributes[ key ];\r\n\t\t\t\t\tvar bufferType = ( key === 'index' ) ? _gl.ELEMENT_ARRAY_BUFFER : _gl.ARRAY_BUFFER;\r\n\t\r\n\t\t\t\t\tif ( attribute.buffer === undefined ) {\r\n\t\r\n\t\t\t\t\t\tattribute.buffer = _gl.createBuffer();\r\n\t\t\t\t\t\t_gl.bindBuffer( bufferType, attribute.buffer );\r\n\t\t\t\t\t\t_gl.bufferData( bufferType, attribute.array, ( attribute instanceof THREE.DynamicBufferAttribute ) ? _gl.DYNAMIC_DRAW : _gl.STATIC_DRAW );\r\n\t\r\n\t\t\t\t\t\tattribute.needsUpdate = false;\r\n\t\r\n\t\t\t\t\t} else if ( attribute.needsUpdate === true ) {\r\n\t\r\n\t\t\t\t\t\t_gl.bindBuffer( bufferType, attribute.buffer );\r\n\t\r\n\t\t\t\t\t\tif ( attribute.updateRange === undefined || attribute.updateRange.count === -1 ) { // Not using update ranges\r\n\t\r\n\t\t\t\t\t\t\t_gl.bufferSubData( bufferType, 0, attribute.array );\r\n\t\r\n\t\t\t\t\t\t} else if ( attribute.updateRange.count === 0 ) {\r\n\t\r\n\t\t\t\t\t\t\tconsole.error( 'THREE.WebGLRenderer.updateObject: using updateRange for THREE.DynamicBufferAttribute and marked as needsUpdate but count is 0, ensure you are using set methods or updating manually.' );\r\n\t\r\n\t\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\t\t_gl.bufferSubData( bufferType, attribute.updateRange.offset * attribute.array.BYTES_PER_ELEMENT,\r\n\t\t\t\t\t\t\t\t\t\t\t   attribute.array.subarray( attribute.updateRange.offset, attribute.updateRange.offset + attribute.updateRange.count ) );\r\n\t\r\n\t\t\t\t\t\t\tattribute.updateRange.count = 0; // reset range\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\tattribute.needsUpdate = false;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t} else if ( object instanceof THREE.Mesh ) {\r\n\t\r\n\t\t\t\t// check all geometry groups\r\n\t\r\n\t\t\t\tif ( geometry.groupsNeedUpdate === true ) {\r\n\t\r\n\t\t\t\t\tinitGeometryGroups( object, geometry );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tvar geometryGroupsList = geometryGroups[ geometry.id ];\r\n\t\r\n\t\t\t\tfor ( var i = 0, il = geometryGroupsList.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\t\tvar geometryGroup = geometryGroupsList[ i ];\r\n\t\t\t\t\tvar material = getBufferMaterial( object, geometryGroup );\r\n\t\r\n\t\t\t\t\tvar customAttributesDirty = material.attributes && areCustomAttributesDirty( material );\r\n\t\r\n\t\t\t\t\tif ( geometry.verticesNeedUpdate || geometry.morphTargetsNeedUpdate || geometry.elementsNeedUpdate ||\r\n\t\t\t\t\t\t geometry.uvsNeedUpdate || geometry.normalsNeedUpdate ||\r\n\t\t\t\t\t\t geometry.colorsNeedUpdate || geometry.tangentsNeedUpdate || customAttributesDirty ) {\r\n\t\r\n\t\t\t\t\t\tsetMeshBuffers( geometryGroup, object, _gl.DYNAMIC_DRAW, ! geometry.dynamic, material );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tgeometry.verticesNeedUpdate = false;\r\n\t\t\t\tgeometry.morphTargetsNeedUpdate = false;\r\n\t\t\t\tgeometry.elementsNeedUpdate = false;\r\n\t\t\t\tgeometry.uvsNeedUpdate = false;\r\n\t\t\t\tgeometry.normalsNeedUpdate = false;\r\n\t\t\t\tgeometry.colorsNeedUpdate = false;\r\n\t\t\t\tgeometry.tangentsNeedUpdate = false;\r\n\t\r\n\t\t\t\tmaterial.attributes && clearCustomAttributes( material );\r\n\t\r\n\t\t\t} else if ( object instanceof THREE.Line ) {\r\n\t\r\n\t\t\t\tvar material = getBufferMaterial( object, geometry );\r\n\t\t\t\tvar customAttributesDirty = material.attributes && areCustomAttributesDirty( material );\r\n\t\r\n\t\t\t\tif ( geometry.verticesNeedUpdate || geometry.colorsNeedUpdate || geometry.lineDistancesNeedUpdate || customAttributesDirty ) {\r\n\t\r\n\t\t\t\t\tsetLineBuffers( geometry, _gl.DYNAMIC_DRAW );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tgeometry.verticesNeedUpdate = false;\r\n\t\t\t\tgeometry.colorsNeedUpdate = false;\r\n\t\t\t\tgeometry.lineDistancesNeedUpdate = false;\r\n\t\r\n\t\t\t\tmaterial.attributes && clearCustomAttributes( material );\r\n\t\r\n\t\t\t} else if ( object instanceof THREE.PointCloud ) {\r\n\t\r\n\t\t\t\tvar material = getBufferMaterial( object, geometry );\r\n\t\t\t\tvar customAttributesDirty = material.attributes && areCustomAttributesDirty( material );\r\n\t\r\n\t\t\t\tif ( geometry.verticesNeedUpdate || geometry.colorsNeedUpdate || customAttributesDirty ) {\r\n\t\r\n\t\t\t\t\tsetParticleBuffers( geometry, _gl.DYNAMIC_DRAW, object );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tgeometry.verticesNeedUpdate = false;\r\n\t\t\t\tgeometry.colorsNeedUpdate = false;\r\n\t\r\n\t\t\t\tmaterial.attributes && clearCustomAttributes( material );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\t// Objects updates - custom attributes check\r\n\t\r\n\t\tfunction areCustomAttributesDirty( material ) {\r\n\t\r\n\t\t\tfor ( var name in material.attributes ) {\r\n\t\r\n\t\t\t\tif ( material.attributes[ name ].needsUpdate ) return true;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn false;\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction clearCustomAttributes( material ) {\r\n\t\r\n\t\t\tfor ( var name in material.attributes ) {\r\n\t\r\n\t\t\t\tmaterial.attributes[ name ].needsUpdate = false;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\t// Objects removal\r\n\t\r\n\t\tfunction removeObject( object ) {\r\n\t\r\n\t\t\tif ( object instanceof THREE.Mesh  ||\r\n\t\t\t\t object instanceof THREE.PointCloud ||\r\n\t\t\t\t object instanceof THREE.Line ) {\r\n\t\r\n\t\t\t\tdelete _webglObjects[ object.id ];\r\n\t\r\n\t\t\t} else if ( object instanceof THREE.ImmediateRenderObject || object.immediateRenderCallback ) {\r\n\t\r\n\t\t\t\tremoveInstances( _webglObjectsImmediate, object );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tdelete object.__webglInit;\r\n\t\t\tdelete object._modelViewMatrix;\r\n\t\t\tdelete object._normalMatrix;\r\n\t\r\n\t\t\tdelete object.__webglActive;\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction removeInstances( objlist, object ) {\r\n\t\r\n\t\t\tfor ( var o = objlist.length - 1; o >= 0; o -- ) {\r\n\t\r\n\t\t\t\tif ( objlist[ o ].object === object ) {\r\n\t\r\n\t\t\t\t\tobjlist.splice( o, 1 );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\t// Materials\r\n\t\r\n\t\tvar shaderIDs = {\r\n\t\t\tMeshDepthMaterial: 'depth',\r\n\t\t\tMeshNormalMaterial: 'normal',\r\n\t\t\tMeshBasicMaterial: 'basic',\r\n\t\t\tMeshLambertMaterial: 'lambert',\r\n\t\t\tMeshPhongMaterial: 'phong',\r\n\t\t\tLineBasicMaterial: 'basic',\r\n\t\t\tLineDashedMaterial: 'dashed',\r\n\t\t\tPointCloudMaterial: 'particle_basic'\r\n\t\t};\r\n\t\r\n\t\tfunction initMaterial( material, lights, fog, object ) {\r\n\t\r\n\t\t\tmaterial.addEventListener( 'dispose', onMaterialDispose );\r\n\t\r\n\t\t\tvar shaderID = shaderIDs[ material.type ];\r\n\t\r\n\t\t\tif ( shaderID ) {\r\n\t\r\n\t\t\t\tvar shader = THREE.ShaderLib[ shaderID ];\r\n\t\r\n\t\t\t\tmaterial.__webglShader = {\r\n\t\t\t\t\tuniforms: THREE.UniformsUtils.clone( shader.uniforms ),\r\n\t\t\t\t\tvertexShader: shader.vertexShader,\r\n\t\t\t\t\tfragmentShader: shader.fragmentShader\r\n\t\t\t\t}\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\tmaterial.__webglShader = {\r\n\t\t\t\t\tuniforms: material.uniforms,\r\n\t\t\t\t\tvertexShader: material.vertexShader,\r\n\t\t\t\t\tfragmentShader: material.fragmentShader\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// heuristics to create shader parameters according to lights in the scene\r\n\t\t\t// (not to blow over maxLights budget)\r\n\t\r\n\t\t\tvar maxLightCount = allocateLights( lights );\r\n\t\t\tvar maxShadows = allocateShadows( lights );\r\n\t\t\tvar maxBones = allocateBones( object );\r\n\t\r\n\t\t\tvar parameters = {\r\n\t\r\n\t\t\t\tprecision: _precision,\r\n\t\t\t\tsupportsVertexTextures: _supportsVertexTextures,\r\n\t\r\n\t\t\t\tmap: !! material.map,\r\n\t\t\t\tenvMap: !! material.envMap,\r\n\t\t\t\tenvMapMode: material.envMap && material.envMap.mapping,\r\n\t\t\t\tlightMap: !! material.lightMap,\r\n\t\t\t\tbumpMap: !! material.bumpMap,\r\n\t\t\t\tnormalMap: !! material.normalMap,\r\n\t\t\t\tspecularMap: !! material.specularMap,\r\n\t\t\t\talphaMap: !! material.alphaMap,\r\n\t\r\n\t\t\t\tcombine: material.combine,\r\n\t\r\n\t\t\t\tvertexColors: material.vertexColors,\r\n\t\r\n\t\t\t\tfog: fog,\r\n\t\t\t\tuseFog: material.fog,\r\n\t\t\t\tfogExp: fog instanceof THREE.FogExp2,\r\n\t\r\n\t\t\t\tflatShading: material.shading === THREE.FlatShading,\r\n\t\r\n\t\t\t\tsizeAttenuation: material.sizeAttenuation,\r\n\t\t\t\tlogarithmicDepthBuffer: _logarithmicDepthBuffer,\r\n\t\r\n\t\t\t\tskinning: material.skinning,\r\n\t\t\t\tmaxBones: maxBones,\r\n\t\t\t\tuseVertexTexture: _supportsBoneTextures && object && object.skeleton && object.skeleton.useVertexTexture,\r\n\t\r\n\t\t\t\tmorphTargets: material.morphTargets,\r\n\t\t\t\tmorphNormals: material.morphNormals,\r\n\t\t\t\tmaxMorphTargets: _this.maxMorphTargets,\r\n\t\t\t\tmaxMorphNormals: _this.maxMorphNormals,\r\n\t\r\n\t\t\t\tmaxDirLights: maxLightCount.directional,\r\n\t\t\t\tmaxPointLights: maxLightCount.point,\r\n\t\t\t\tmaxSpotLights: maxLightCount.spot,\r\n\t\t\t\tmaxHemiLights: maxLightCount.hemi,\r\n\t\r\n\t\t\t\tmaxShadows: maxShadows,\r\n\t\t\t\tshadowMapEnabled: _this.shadowMapEnabled && object.receiveShadow && maxShadows > 0,\r\n\t\t\t\tshadowMapType: _this.shadowMapType,\r\n\t\t\t\tshadowMapDebug: _this.shadowMapDebug,\r\n\t\t\t\tshadowMapCascade: _this.shadowMapCascade,\r\n\t\r\n\t\t\t\talphaTest: material.alphaTest,\r\n\t\t\t\tmetal: material.metal,\r\n\t\t\t\twrapAround: material.wrapAround,\r\n\t\t\t\tdoubleSided: material.side === THREE.DoubleSide,\r\n\t\t\t\tflipSided: material.side === THREE.BackSide\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t\t// Generate code\r\n\t\r\n\t\t\tvar chunks = [];\r\n\t\r\n\t\t\tif ( shaderID ) {\r\n\t\r\n\t\t\t\tchunks.push( shaderID );\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\tchunks.push( material.fragmentShader );\r\n\t\t\t\tchunks.push( material.vertexShader );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( material.defines !== undefined ) {\r\n\t\r\n\t\t\t\tfor ( var name in material.defines ) {\r\n\t\r\n\t\t\t\t\tchunks.push( name );\r\n\t\t\t\t\tchunks.push( material.defines[ name ] );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tfor ( var name in parameters ) {\r\n\t\r\n\t\t\t\tchunks.push( name );\r\n\t\t\t\tchunks.push( parameters[ name ] );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar code = chunks.join();\r\n\t\r\n\t\t\tvar program;\r\n\t\r\n\t\t\t// Check if code has been already compiled\r\n\t\r\n\t\t\tfor ( var p = 0, pl = _programs.length; p < pl; p ++ ) {\r\n\t\r\n\t\t\t\tvar programInfo = _programs[ p ];\r\n\t\r\n\t\t\t\tif ( programInfo.code === code ) {\r\n\t\r\n\t\t\t\t\tprogram = programInfo;\r\n\t\t\t\t\tprogram.usedTimes ++;\r\n\t\r\n\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( program === undefined ) {\r\n\t\r\n\t\t\t\tprogram = new THREE.WebGLProgram( _this, code, material, parameters );\r\n\t\t\t\t_programs.push( program );\r\n\t\r\n\t\t\t\t_this.info.memory.programs = _programs.length;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tmaterial.program = program;\r\n\t\r\n\t\t\tvar attributes = program.attributes;\r\n\t\r\n\t\t\tif ( material.morphTargets ) {\r\n\t\r\n\t\t\t\tmaterial.numSupportedMorphTargets = 0;\r\n\t\r\n\t\t\t\tvar id, base = 'morphTarget';\r\n\t\r\n\t\t\t\tfor ( var i = 0; i < _this.maxMorphTargets; i ++ ) {\r\n\t\r\n\t\t\t\t\tid = base + i;\r\n\t\r\n\t\t\t\t\tif ( attributes[ id ] >= 0 ) {\r\n\t\r\n\t\t\t\t\t\tmaterial.numSupportedMorphTargets ++;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( material.morphNormals ) {\r\n\t\r\n\t\t\t\tmaterial.numSupportedMorphNormals = 0;\r\n\t\r\n\t\t\t\tvar id, base = 'morphNormal';\r\n\t\r\n\t\t\t\tfor ( i = 0; i < _this.maxMorphNormals; i ++ ) {\r\n\t\r\n\t\t\t\t\tid = base + i;\r\n\t\r\n\t\t\t\t\tif ( attributes[ id ] >= 0 ) {\r\n\t\r\n\t\t\t\t\t\tmaterial.numSupportedMorphNormals ++;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tmaterial.uniformsList = [];\r\n\t\r\n\t\t\tfor ( var u in material.__webglShader.uniforms ) {\r\n\t\r\n\t\t\t\tvar location = material.program.uniforms[ u ];\r\n\t\r\n\t\t\t\tif ( location ) {\r\n\t\t\t\t\tmaterial.uniformsList.push( [ material.__webglShader.uniforms[ u ], location ] );\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction setMaterial( material ) {\r\n\t\r\n\t\t\tif ( material.transparent === true ) {\r\n\t\r\n\t\t\t\tstate.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha );\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\tstate.setBlending( THREE.NoBlending );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tstate.setDepthTest( material.depthTest );\r\n\t\t\tstate.setDepthWrite( material.depthWrite );\r\n\t\t\tstate.setColorWrite( material.colorWrite );\r\n\t\t\tstate.setPolygonOffset( material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits );\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction setProgram( camera, lights, fog, material, object ) {\r\n\t\r\n\t\t\t_usedTextureUnits = 0;\r\n\t\r\n\t\t\tif ( material.needsUpdate ) {\r\n\t\r\n\t\t\t\tif ( material.program ) deallocateMaterial( material );\r\n\t\r\n\t\t\t\tinitMaterial( material, lights, fog, object );\r\n\t\t\t\tmaterial.needsUpdate = false;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( material.morphTargets ) {\r\n\t\r\n\t\t\t\tif ( ! object.__webglMorphTargetInfluences ) {\r\n\t\r\n\t\t\t\t\tobject.__webglMorphTargetInfluences = new Float32Array( _this.maxMorphTargets );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar refreshProgram = false;\r\n\t\t\tvar refreshMaterial = false;\r\n\t\t\tvar refreshLights = false;\r\n\t\r\n\t\t\tvar program = material.program,\r\n\t\t\t\tp_uniforms = program.uniforms,\r\n\t\t\t\tm_uniforms = material.__webglShader.uniforms;\r\n\t\r\n\t\t\tif ( program.id !== _currentProgram ) {\r\n\t\r\n\t\t\t\t_gl.useProgram( program.program );\r\n\t\t\t\t_currentProgram = program.id;\r\n\t\r\n\t\t\t\trefreshProgram = true;\r\n\t\t\t\trefreshMaterial = true;\r\n\t\t\t\trefreshLights = true;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( material.id !== _currentMaterialId ) {\r\n\t\r\n\t\t\t\tif ( _currentMaterialId === -1 ) refreshLights = true;\r\n\t\t\t\t_currentMaterialId = material.id;\r\n\t\r\n\t\t\t\trefreshMaterial = true;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( refreshProgram || camera !== _currentCamera ) {\r\n\t\r\n\t\t\t\t_gl.uniformMatrix4fv( p_uniforms.projectionMatrix, false, camera.projectionMatrix.elements );\r\n\t\r\n\t\t\t\tif ( _logarithmicDepthBuffer ) {\r\n\t\r\n\t\t\t\t\t_gl.uniform1f( p_uniforms.logDepthBufFC, 2.0 / ( Math.log( camera.far + 1.0 ) / Math.LN2 ) );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\r\n\t\t\t\tif ( camera !== _currentCamera ) _currentCamera = camera;\r\n\t\r\n\t\t\t\t// load material specific uniforms\r\n\t\t\t\t// (shader material also gets them for the sake of genericity)\r\n\t\r\n\t\t\t\tif ( material instanceof THREE.ShaderMaterial ||\r\n\t\t\t\t\t material instanceof THREE.MeshPhongMaterial ||\r\n\t\t\t\t\t material.envMap ) {\r\n\t\r\n\t\t\t\t\tif ( p_uniforms.cameraPosition !== null ) {\r\n\t\r\n\t\t\t\t\t\t_vector3.setFromMatrixPosition( camera.matrixWorld );\r\n\t\t\t\t\t\t_gl.uniform3f( p_uniforms.cameraPosition, _vector3.x, _vector3.y, _vector3.z );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( material instanceof THREE.MeshPhongMaterial ||\r\n\t\t\t\t\t material instanceof THREE.MeshLambertMaterial ||\r\n\t\t\t\t\t material instanceof THREE.MeshBasicMaterial ||\r\n\t\t\t\t\t material instanceof THREE.ShaderMaterial ||\r\n\t\t\t\t\t material.skinning ) {\r\n\t\r\n\t\t\t\t\tif ( p_uniforms.viewMatrix !== null ) {\r\n\t\r\n\t\t\t\t\t\t_gl.uniformMatrix4fv( p_uniforms.viewMatrix, false, camera.matrixWorldInverse.elements );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// skinning uniforms must be set even if material didn't change\r\n\t\t\t// auto-setting of texture unit for bone texture must go before other textures\r\n\t\t\t// not sure why, but otherwise weird things happen\r\n\t\r\n\t\t\tif ( material.skinning ) {\r\n\t\r\n\t\t\t\tif ( object.bindMatrix && p_uniforms.bindMatrix !== null ) {\r\n\t\r\n\t\t\t\t\t_gl.uniformMatrix4fv( p_uniforms.bindMatrix, false, object.bindMatrix.elements );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( object.bindMatrixInverse && p_uniforms.bindMatrixInverse !== null ) {\r\n\t\r\n\t\t\t\t\t_gl.uniformMatrix4fv( p_uniforms.bindMatrixInverse, false, object.bindMatrixInverse.elements );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( _supportsBoneTextures && object.skeleton && object.skeleton.useVertexTexture ) {\r\n\t\r\n\t\t\t\t\tif ( p_uniforms.boneTexture !== null ) {\r\n\t\r\n\t\t\t\t\t\tvar textureUnit = getTextureUnit();\r\n\t\r\n\t\t\t\t\t\t_gl.uniform1i( p_uniforms.boneTexture, textureUnit );\r\n\t\t\t\t\t\t_this.setTexture( object.skeleton.boneTexture, textureUnit );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tif ( p_uniforms.boneTextureWidth !== null ) {\r\n\t\r\n\t\t\t\t\t\t_gl.uniform1i( p_uniforms.boneTextureWidth, object.skeleton.boneTextureWidth );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tif ( p_uniforms.boneTextureHeight !== null ) {\r\n\t\r\n\t\t\t\t\t\t_gl.uniform1i( p_uniforms.boneTextureHeight, object.skeleton.boneTextureHeight );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t} else if ( object.skeleton && object.skeleton.boneMatrices ) {\r\n\t\r\n\t\t\t\t\tif ( p_uniforms.boneGlobalMatrices !== null ) {\r\n\t\r\n\t\t\t\t\t\t_gl.uniformMatrix4fv( p_uniforms.boneGlobalMatrices, false, object.skeleton.boneMatrices );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( refreshMaterial ) {\r\n\t\r\n\t\t\t\t// refresh uniforms common to several materials\r\n\t\r\n\t\t\t\tif ( fog && material.fog ) {\r\n\t\r\n\t\t\t\t\trefreshUniformsFog( m_uniforms, fog );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( material instanceof THREE.MeshPhongMaterial ||\r\n\t\t\t\t\t material instanceof THREE.MeshLambertMaterial ||\r\n\t\t\t\t\t material.lights ) {\r\n\t\r\n\t\t\t\t\tif ( _lightsNeedUpdate ) {\r\n\t\r\n\t\t\t\t\t\trefreshLights = true;\r\n\t\t\t\t\t\tsetupLights( lights );\r\n\t\t\t\t\t\t_lightsNeedUpdate = false;\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tif ( refreshLights ) {\r\n\t\t\t\t\t\trefreshUniformsLights( m_uniforms, _lights );\r\n\t\t\t\t\t\tmarkUniformsLightsNeedsUpdate( m_uniforms, true );\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tmarkUniformsLightsNeedsUpdate( m_uniforms, false );\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( material instanceof THREE.MeshBasicMaterial ||\r\n\t\t\t\t\t material instanceof THREE.MeshLambertMaterial ||\r\n\t\t\t\t\t material instanceof THREE.MeshPhongMaterial ) {\r\n\t\r\n\t\t\t\t\trefreshUniformsCommon( m_uniforms, material );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\t// refresh single material specific uniforms\r\n\t\r\n\t\t\t\tif ( material instanceof THREE.LineBasicMaterial ) {\r\n\t\r\n\t\t\t\t\trefreshUniformsLine( m_uniforms, material );\r\n\t\r\n\t\t\t\t} else if ( material instanceof THREE.LineDashedMaterial ) {\r\n\t\r\n\t\t\t\t\trefreshUniformsLine( m_uniforms, material );\r\n\t\t\t\t\trefreshUniformsDash( m_uniforms, material );\r\n\t\r\n\t\t\t\t} else if ( material instanceof THREE.PointCloudMaterial ) {\r\n\t\r\n\t\t\t\t\trefreshUniformsParticle( m_uniforms, material );\r\n\t\r\n\t\t\t\t} else if ( material instanceof THREE.MeshPhongMaterial ) {\r\n\t\r\n\t\t\t\t\trefreshUniformsPhong( m_uniforms, material );\r\n\t\r\n\t\t\t\t} else if ( material instanceof THREE.MeshLambertMaterial ) {\r\n\t\r\n\t\t\t\t\trefreshUniformsLambert( m_uniforms, material );\r\n\t\r\n\t\t\t\t} else if ( material instanceof THREE.MeshDepthMaterial ) {\r\n\t\r\n\t\t\t\t\tm_uniforms.mNear.value = camera.near;\r\n\t\t\t\t\tm_uniforms.mFar.value = camera.far;\r\n\t\t\t\t\tm_uniforms.opacity.value = material.opacity;\r\n\t\r\n\t\t\t\t} else if ( material instanceof THREE.MeshNormalMaterial ) {\r\n\t\r\n\t\t\t\t\tm_uniforms.opacity.value = material.opacity;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( object.receiveShadow && ! material._shadowPass ) {\r\n\t\r\n\t\t\t\t\trefreshUniformsShadow( m_uniforms, lights );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\t// load common uniforms\r\n\t\r\n\t\t\t\tloadUniformsGeneric( material.uniformsList );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tloadUniformsMatrices( p_uniforms, object );\r\n\t\r\n\t\t\tif ( p_uniforms.modelMatrix !== null ) {\r\n\t\r\n\t\t\t\t_gl.uniformMatrix4fv( p_uniforms.modelMatrix, false, object.matrixWorld.elements );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn program;\r\n\t\r\n\t\t}\r\n\t\r\n\t\t// Uniforms (refresh uniforms objects)\r\n\t\r\n\t\tfunction refreshUniformsCommon ( uniforms, material ) {\r\n\t\r\n\t\t\tuniforms.opacity.value = material.opacity;\r\n\t\r\n\t\t\tuniforms.diffuse.value = material.color;\r\n\t\r\n\t\t\tuniforms.map.value = material.map;\r\n\t\t\tuniforms.lightMap.value = material.lightMap;\r\n\t\t\tuniforms.specularMap.value = material.specularMap;\r\n\t\t\tuniforms.alphaMap.value = material.alphaMap;\r\n\t\r\n\t\t\tif ( material.bumpMap ) {\r\n\t\r\n\t\t\t\tuniforms.bumpMap.value = material.bumpMap;\r\n\t\t\t\tuniforms.bumpScale.value = material.bumpScale;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( material.normalMap ) {\r\n\t\r\n\t\t\t\tuniforms.normalMap.value = material.normalMap;\r\n\t\t\t\tuniforms.normalScale.value.copy( material.normalScale );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// uv repeat and offset setting priorities\r\n\t\t\t//  1. color map\r\n\t\t\t//  2. specular map\r\n\t\t\t//  3. normal map\r\n\t\t\t//  4. bump map\r\n\t\t\t//  5. alpha map\r\n\t\r\n\t\t\tvar uvScaleMap;\r\n\t\r\n\t\t\tif ( material.map ) {\r\n\t\r\n\t\t\t\tuvScaleMap = material.map;\r\n\t\r\n\t\t\t} else if ( material.specularMap ) {\r\n\t\r\n\t\t\t\tuvScaleMap = material.specularMap;\r\n\t\r\n\t\t\t} else if ( material.normalMap ) {\r\n\t\r\n\t\t\t\tuvScaleMap = material.normalMap;\r\n\t\r\n\t\t\t} else if ( material.bumpMap ) {\r\n\t\r\n\t\t\t\tuvScaleMap = material.bumpMap;\r\n\t\r\n\t\t\t} else if ( material.alphaMap ) {\r\n\t\r\n\t\t\t\tuvScaleMap = material.alphaMap;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( uvScaleMap !== undefined ) {\r\n\t\r\n\t\t\t\tvar offset = uvScaleMap.offset;\r\n\t\t\t\tvar repeat = uvScaleMap.repeat;\r\n\t\r\n\t\t\t\tuniforms.offsetRepeat.value.set( offset.x, offset.y, repeat.x, repeat.y );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tuniforms.envMap.value = material.envMap;\r\n\t\t\tuniforms.flipEnvMap.value = ( material.envMap instanceof THREE.WebGLRenderTargetCube ) ? 1 : - 1;\r\n\t\r\n\t\t\tuniforms.reflectivity.value = material.reflectivity;\r\n\t\t\tuniforms.refractionRatio.value = material.refractionRatio;\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction refreshUniformsLine ( uniforms, material ) {\r\n\t\r\n\t\t\tuniforms.diffuse.value = material.color;\r\n\t\t\tuniforms.opacity.value = material.opacity;\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction refreshUniformsDash ( uniforms, material ) {\r\n\t\r\n\t\t\tuniforms.dashSize.value = material.dashSize;\r\n\t\t\tuniforms.totalSize.value = material.dashSize + material.gapSize;\r\n\t\t\tuniforms.scale.value = material.scale;\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction refreshUniformsParticle ( uniforms, material ) {\r\n\t\r\n\t\t\tuniforms.psColor.value = material.color;\r\n\t\t\tuniforms.opacity.value = material.opacity;\r\n\t\t\tuniforms.size.value = material.size;\r\n\t\t\tuniforms.scale.value = _canvas.height / 2.0; // TODO: Cache this.\r\n\t\r\n\t\t\tuniforms.map.value = material.map;\r\n\t\r\n\t\t\tif ( material.map !== null ) {\r\n\t\r\n\t\t\t\tvar offset = material.map.offset;\r\n\t\t\t\tvar repeat = material.map.repeat;\r\n\t\r\n\t\t\t\tuniforms.offsetRepeat.value.set( offset.x, offset.y, repeat.x, repeat.y );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction refreshUniformsFog ( uniforms, fog ) {\r\n\t\r\n\t\t\tuniforms.fogColor.value = fog.color;\r\n\t\r\n\t\t\tif ( fog instanceof THREE.Fog ) {\r\n\t\r\n\t\t\t\tuniforms.fogNear.value = fog.near;\r\n\t\t\t\tuniforms.fogFar.value = fog.far;\r\n\t\r\n\t\t\t} else if ( fog instanceof THREE.FogExp2 ) {\r\n\t\r\n\t\t\t\tuniforms.fogDensity.value = fog.density;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction refreshUniformsPhong ( uniforms, material ) {\r\n\t\r\n\t\t\tuniforms.shininess.value = material.shininess;\r\n\t\r\n\t\t\tuniforms.emissive.value = material.emissive;\r\n\t\t\tuniforms.specular.value = material.specular;\r\n\t\r\n\t\t\tif ( material.wrapAround ) {\r\n\t\r\n\t\t\t\tuniforms.wrapRGB.value.copy( material.wrapRGB );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction refreshUniformsLambert ( uniforms, material ) {\r\n\t\r\n\t\t\tuniforms.emissive.value = material.emissive;\r\n\t\r\n\t\t\tif ( material.wrapAround ) {\r\n\t\r\n\t\t\t\tuniforms.wrapRGB.value.copy( material.wrapRGB );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction refreshUniformsLights ( uniforms, lights ) {\r\n\t\r\n\t\t\tuniforms.ambientLightColor.value = lights.ambient;\r\n\t\r\n\t\t\tuniforms.directionalLightColor.value = lights.directional.colors;\r\n\t\t\tuniforms.directionalLightDirection.value = lights.directional.positions;\r\n\t\r\n\t\t\tuniforms.pointLightColor.value = lights.point.colors;\r\n\t\t\tuniforms.pointLightPosition.value = lights.point.positions;\r\n\t\t\tuniforms.pointLightDistance.value = lights.point.distances;\r\n\t\t\tuniforms.pointLightDecay.value = lights.point.decays;\r\n\t\r\n\t\t\tuniforms.spotLightColor.value = lights.spot.colors;\r\n\t\t\tuniforms.spotLightPosition.value = lights.spot.positions;\r\n\t\t\tuniforms.spotLightDistance.value = lights.spot.distances;\r\n\t\t\tuniforms.spotLightDirection.value = lights.spot.directions;\r\n\t\t\tuniforms.spotLightAngleCos.value = lights.spot.anglesCos;\r\n\t\t\tuniforms.spotLightExponent.value = lights.spot.exponents;\r\n\t\t\tuniforms.spotLightDecay.value = lights.spot.decays;\r\n\t\r\n\t\t\tuniforms.hemisphereLightSkyColor.value = lights.hemi.skyColors;\r\n\t\t\tuniforms.hemisphereLightGroundColor.value = lights.hemi.groundColors;\r\n\t\t\tuniforms.hemisphereLightDirection.value = lights.hemi.positions;\r\n\t\r\n\t\t}\r\n\t\r\n\t\t// If uniforms are marked as clean, they don't need to be loaded to the GPU.\r\n\t\r\n\t\tfunction markUniformsLightsNeedsUpdate ( uniforms, value ) {\r\n\t\r\n\t\t\tuniforms.ambientLightColor.needsUpdate = value;\r\n\t\r\n\t\t\tuniforms.directionalLightColor.needsUpdate = value;\r\n\t\t\tuniforms.directionalLightDirection.needsUpdate = value;\r\n\t\r\n\t\t\tuniforms.pointLightColor.needsUpdate = value;\r\n\t\t\tuniforms.pointLightPosition.needsUpdate = value;\r\n\t\t\tuniforms.pointLightDistance.needsUpdate = value;\r\n\t\t\tuniforms.pointLightDecay.needsUpdate = value;\r\n\t\r\n\t\t\tuniforms.spotLightColor.needsUpdate = value;\r\n\t\t\tuniforms.spotLightPosition.needsUpdate = value;\r\n\t\t\tuniforms.spotLightDistance.needsUpdate = value;\r\n\t\t\tuniforms.spotLightDirection.needsUpdate = value;\r\n\t\t\tuniforms.spotLightAngleCos.needsUpdate = value;\r\n\t\t\tuniforms.spotLightExponent.needsUpdate = value;\r\n\t\t\tuniforms.spotLightDecay.needsUpdate = value;\r\n\t\r\n\t\t\tuniforms.hemisphereLightSkyColor.needsUpdate = value;\r\n\t\t\tuniforms.hemisphereLightGroundColor.needsUpdate = value;\r\n\t\t\tuniforms.hemisphereLightDirection.needsUpdate = value;\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction refreshUniformsShadow ( uniforms, lights ) {\r\n\t\r\n\t\t\tif ( uniforms.shadowMatrix ) {\r\n\t\r\n\t\t\t\tvar j = 0;\r\n\t\r\n\t\t\t\tfor ( var i = 0, il = lights.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\t\tvar light = lights[ i ];\r\n\t\r\n\t\t\t\t\tif ( ! light.castShadow ) continue;\r\n\t\r\n\t\t\t\t\tif ( light instanceof THREE.SpotLight || ( light instanceof THREE.DirectionalLight && ! light.shadowCascade ) ) {\r\n\t\r\n\t\t\t\t\t\tuniforms.shadowMap.value[ j ] = light.shadowMap;\r\n\t\t\t\t\t\tuniforms.shadowMapSize.value[ j ] = light.shadowMapSize;\r\n\t\r\n\t\t\t\t\t\tuniforms.shadowMatrix.value[ j ] = light.shadowMatrix;\r\n\t\r\n\t\t\t\t\t\tuniforms.shadowDarkness.value[ j ] = light.shadowDarkness;\r\n\t\t\t\t\t\tuniforms.shadowBias.value[ j ] = light.shadowBias;\r\n\t\r\n\t\t\t\t\t\tj ++;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\t// Uniforms (load to GPU)\r\n\t\r\n\t\tfunction loadUniformsMatrices ( uniforms, object ) {\r\n\t\r\n\t\t\t_gl.uniformMatrix4fv( uniforms.modelViewMatrix, false, object._modelViewMatrix.elements );\r\n\t\r\n\t\t\tif ( uniforms.normalMatrix ) {\r\n\t\r\n\t\t\t\t_gl.uniformMatrix3fv( uniforms.normalMatrix, false, object._normalMatrix.elements );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction getTextureUnit() {\r\n\t\r\n\t\t\tvar textureUnit = _usedTextureUnits;\r\n\t\r\n\t\t\tif ( textureUnit >= _maxTextures ) {\r\n\t\r\n\t\t\t\tTHREE.warn( 'WebGLRenderer: trying to use ' + textureUnit + ' texture units while this GPU supports only ' + _maxTextures );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t_usedTextureUnits += 1;\r\n\t\r\n\t\t\treturn textureUnit;\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction loadUniformsGeneric ( uniforms ) {\r\n\t\r\n\t\t\tvar texture, textureUnit, offset;\r\n\t\r\n\t\t\tfor ( var j = 0, jl = uniforms.length; j < jl; j ++ ) {\r\n\t\r\n\t\t\t\tvar uniform = uniforms[ j ][ 0 ];\r\n\t\r\n\t\t\t\t// needsUpdate property is not added to all uniforms.\r\n\t\t\t\tif ( uniform.needsUpdate === false ) continue;\r\n\t\r\n\t\t\t\tvar type = uniform.type;\r\n\t\t\t\tvar value = uniform.value;\r\n\t\t\t\tvar location = uniforms[ j ][ 1 ];\r\n\t\r\n\t\t\t\tswitch ( type ) {\r\n\t\r\n\t\t\t\t\tcase '1i':\r\n\t\t\t\t\t\t_gl.uniform1i( location, value );\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\tcase '1f':\r\n\t\t\t\t\t\t_gl.uniform1f( location, value );\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\tcase '2f':\r\n\t\t\t\t\t\t_gl.uniform2f( location, value[ 0 ], value[ 1 ] );\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\tcase '3f':\r\n\t\t\t\t\t\t_gl.uniform3f( location, value[ 0 ], value[ 1 ], value[ 2 ] );\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\tcase '4f':\r\n\t\t\t\t\t\t_gl.uniform4f( location, value[ 0 ], value[ 1 ], value[ 2 ], value[ 3 ] );\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\tcase '1iv':\r\n\t\t\t\t\t\t_gl.uniform1iv( location, value );\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\tcase '3iv':\r\n\t\t\t\t\t\t_gl.uniform3iv( location, value );\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\tcase '1fv':\r\n\t\t\t\t\t\t_gl.uniform1fv( location, value );\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\tcase '2fv':\r\n\t\t\t\t\t\t_gl.uniform2fv( location, value );\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\tcase '3fv':\r\n\t\t\t\t\t\t_gl.uniform3fv( location, value );\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\tcase '4fv':\r\n\t\t\t\t\t\t_gl.uniform4fv( location, value );\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\tcase 'Matrix3fv':\r\n\t\t\t\t\t\t_gl.uniformMatrix3fv( location, false, value );\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\tcase 'Matrix4fv':\r\n\t\t\t\t\t\t_gl.uniformMatrix4fv( location, false, value );\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\t//\r\n\t\r\n\t\t\t\t\tcase 'i':\r\n\t\r\n\t\t\t\t\t\t// single integer\r\n\t\t\t\t\t\t_gl.uniform1i( location, value );\r\n\t\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\tcase 'f':\r\n\t\r\n\t\t\t\t\t\t// single float\r\n\t\t\t\t\t\t_gl.uniform1f( location, value );\r\n\t\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\tcase 'v2':\r\n\t\r\n\t\t\t\t\t\t// single THREE.Vector2\r\n\t\t\t\t\t\t_gl.uniform2f( location, value.x, value.y );\r\n\t\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\tcase 'v3':\r\n\t\r\n\t\t\t\t\t\t// single THREE.Vector3\r\n\t\t\t\t\t\t_gl.uniform3f( location, value.x, value.y, value.z );\r\n\t\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\tcase 'v4':\r\n\t\r\n\t\t\t\t\t\t// single THREE.Vector4\r\n\t\t\t\t\t\t_gl.uniform4f( location, value.x, value.y, value.z, value.w );\r\n\t\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\tcase 'c':\r\n\t\r\n\t\t\t\t\t\t// single THREE.Color\r\n\t\t\t\t\t\t_gl.uniform3f( location, value.r, value.g, value.b );\r\n\t\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\tcase 'iv1':\r\n\t\r\n\t\t\t\t\t\t// flat array of integers (JS or typed array)\r\n\t\t\t\t\t\t_gl.uniform1iv( location, value );\r\n\t\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\tcase 'iv':\r\n\t\r\n\t\t\t\t\t\t// flat array of integers with 3 x N size (JS or typed array)\r\n\t\t\t\t\t\t_gl.uniform3iv( location, value );\r\n\t\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\tcase 'fv1':\r\n\t\r\n\t\t\t\t\t\t// flat array of floats (JS or typed array)\r\n\t\t\t\t\t\t_gl.uniform1fv( location, value );\r\n\t\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\tcase 'fv':\r\n\t\r\n\t\t\t\t\t\t// flat array of floats with 3 x N size (JS or typed array)\r\n\t\t\t\t\t\t_gl.uniform3fv( location, value );\r\n\t\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\tcase 'v2v':\r\n\t\r\n\t\t\t\t\t\t// array of THREE.Vector2\r\n\t\r\n\t\t\t\t\t\tif ( uniform._array === undefined ) {\r\n\t\r\n\t\t\t\t\t\t\tuniform._array = new Float32Array( 2 * value.length );\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\tfor ( var i = 0, il = value.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\t\t\t\toffset = i * 2;\r\n\t\r\n\t\t\t\t\t\t\tuniform._array[ offset ]   = value[ i ].x;\r\n\t\t\t\t\t\t\tuniform._array[ offset + 1 ] = value[ i ].y;\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t_gl.uniform2fv( location, uniform._array );\r\n\t\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\tcase 'v3v':\r\n\t\r\n\t\t\t\t\t\t// array of THREE.Vector3\r\n\t\r\n\t\t\t\t\t\tif ( uniform._array === undefined ) {\r\n\t\r\n\t\t\t\t\t\t\tuniform._array = new Float32Array( 3 * value.length );\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\tfor ( var i = 0, il = value.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\t\t\t\toffset = i * 3;\r\n\t\r\n\t\t\t\t\t\t\tuniform._array[ offset ]   = value[ i ].x;\r\n\t\t\t\t\t\t\tuniform._array[ offset + 1 ] = value[ i ].y;\r\n\t\t\t\t\t\t\tuniform._array[ offset + 2 ] = value[ i ].z;\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t_gl.uniform3fv( location, uniform._array );\r\n\t\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\tcase 'v4v':\r\n\t\r\n\t\t\t\t\t\t// array of THREE.Vector4\r\n\t\r\n\t\t\t\t\t\tif ( uniform._array === undefined ) {\r\n\t\r\n\t\t\t\t\t\t\tuniform._array = new Float32Array( 4 * value.length );\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\tfor ( var i = 0, il = value.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\t\t\t\toffset = i * 4;\r\n\t\r\n\t\t\t\t\t\t\tuniform._array[ offset ]   = value[ i ].x;\r\n\t\t\t\t\t\t\tuniform._array[ offset + 1 ] = value[ i ].y;\r\n\t\t\t\t\t\t\tuniform._array[ offset + 2 ] = value[ i ].z;\r\n\t\t\t\t\t\t\tuniform._array[ offset + 3 ] = value[ i ].w;\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t_gl.uniform4fv( location, uniform._array );\r\n\t\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\tcase 'm3':\r\n\t\r\n\t\t\t\t\t\t// single THREE.Matrix3\r\n\t\t\t\t\t\t_gl.uniformMatrix3fv( location, false, value.elements );\r\n\t\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\tcase 'm3v':\r\n\t\r\n\t\t\t\t\t\t// array of THREE.Matrix3\r\n\t\r\n\t\t\t\t\t\tif ( uniform._array === undefined ) {\r\n\t\r\n\t\t\t\t\t\t\tuniform._array = new Float32Array( 9 * value.length );\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\tfor ( var i = 0, il = value.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\t\t\t\tvalue[ i ].flattenToArrayOffset( uniform._array, i * 9 );\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t_gl.uniformMatrix3fv( location, false, uniform._array );\r\n\t\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\tcase 'm4':\r\n\t\r\n\t\t\t\t\t\t// single THREE.Matrix4\r\n\t\t\t\t\t\t_gl.uniformMatrix4fv( location, false, value.elements );\r\n\t\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\tcase 'm4v':\r\n\t\r\n\t\t\t\t\t\t// array of THREE.Matrix4\r\n\t\r\n\t\t\t\t\t\tif ( uniform._array === undefined ) {\r\n\t\r\n\t\t\t\t\t\t\tuniform._array = new Float32Array( 16 * value.length );\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\tfor ( var i = 0, il = value.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\t\t\t\tvalue[ i ].flattenToArrayOffset( uniform._array, i * 16 );\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t_gl.uniformMatrix4fv( location, false, uniform._array );\r\n\t\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\tcase 't':\r\n\t\r\n\t\t\t\t\t\t// single THREE.Texture (2d or cube)\r\n\t\r\n\t\t\t\t\t\ttexture = value;\r\n\t\t\t\t\t\ttextureUnit = getTextureUnit();\r\n\t\r\n\t\t\t\t\t\t_gl.uniform1i( location, textureUnit );\r\n\t\r\n\t\t\t\t\t\tif ( ! texture ) continue;\r\n\t\r\n\t\t\t\t\t\tif ( texture instanceof THREE.CubeTexture ||\r\n\t\t\t\t\t\t   ( texture.image instanceof Array && texture.image.length === 6 ) ) { // CompressedTexture can have Array in image :/\r\n\t\r\n\t\t\t\t\t\t\tsetCubeTexture( texture, textureUnit );\r\n\t\r\n\t\t\t\t\t\t} else if ( texture instanceof THREE.WebGLRenderTargetCube ) {\r\n\t\r\n\t\t\t\t\t\t\tsetCubeTextureDynamic( texture, textureUnit );\r\n\t\r\n\t\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\t\t_this.setTexture( texture, textureUnit );\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\tcase 'tv':\r\n\t\r\n\t\t\t\t\t\t// array of THREE.Texture (2d)\r\n\t\r\n\t\t\t\t\t\tif ( uniform._array === undefined ) {\r\n\t\r\n\t\t\t\t\t\t\tuniform._array = [];\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\tfor ( var i = 0, il = uniform.value.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\t\t\t\tuniform._array[ i ] = getTextureUnit();\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t_gl.uniform1iv( location, uniform._array );\r\n\t\r\n\t\t\t\t\t\tfor ( var i = 0, il = uniform.value.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\t\t\t\ttexture = uniform.value[ i ];\r\n\t\t\t\t\t\t\ttextureUnit = uniform._array[ i ];\r\n\t\r\n\t\t\t\t\t\t\tif ( ! texture ) continue;\r\n\t\r\n\t\t\t\t\t\t\t_this.setTexture( texture, textureUnit );\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\tdefault:\r\n\t\r\n\t\t\t\t\t\tTHREE.warn( 'THREE.WebGLRenderer: Unknown uniform type: ' + type );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction setupMatrices ( object, camera ) {\r\n\t\r\n\t\t\tobject._modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );\r\n\t\t\tobject._normalMatrix.getNormalMatrix( object._modelViewMatrix );\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction setColorLinear( array, offset, color, intensity ) {\r\n\t\r\n\t\t\tarray[ offset ]     = color.r * intensity;\r\n\t\t\tarray[ offset + 1 ] = color.g * intensity;\r\n\t\t\tarray[ offset + 2 ] = color.b * intensity;\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction setupLights ( lights ) {\r\n\t\r\n\t\t\tvar l, ll, light,\r\n\t\t\tr = 0, g = 0, b = 0,\r\n\t\t\tcolor, skyColor, groundColor,\r\n\t\t\tintensity,\r\n\t\t\tdistance,\r\n\t\r\n\t\t\tzlights = _lights,\r\n\t\r\n\t\t\tdirColors = zlights.directional.colors,\r\n\t\t\tdirPositions = zlights.directional.positions,\r\n\t\r\n\t\t\tpointColors = zlights.point.colors,\r\n\t\t\tpointPositions = zlights.point.positions,\r\n\t\t\tpointDistances = zlights.point.distances,\r\n\t\t\tpointDecays = zlights.point.decays,\r\n\t\r\n\t\t\tspotColors = zlights.spot.colors,\r\n\t\t\tspotPositions = zlights.spot.positions,\r\n\t\t\tspotDistances = zlights.spot.distances,\r\n\t\t\tspotDirections = zlights.spot.directions,\r\n\t\t\tspotAnglesCos = zlights.spot.anglesCos,\r\n\t\t\tspotExponents = zlights.spot.exponents,\r\n\t\t\tspotDecays = zlights.spot.decays,\r\n\t\r\n\t\t\themiSkyColors = zlights.hemi.skyColors,\r\n\t\t\themiGroundColors = zlights.hemi.groundColors,\r\n\t\t\themiPositions = zlights.hemi.positions,\r\n\t\r\n\t\t\tdirLength = 0,\r\n\t\t\tpointLength = 0,\r\n\t\t\tspotLength = 0,\r\n\t\t\themiLength = 0,\r\n\t\r\n\t\t\tdirCount = 0,\r\n\t\t\tpointCount = 0,\r\n\t\t\tspotCount = 0,\r\n\t\t\themiCount = 0,\r\n\t\r\n\t\t\tdirOffset = 0,\r\n\t\t\tpointOffset = 0,\r\n\t\t\tspotOffset = 0,\r\n\t\t\themiOffset = 0;\r\n\t\r\n\t\t\tfor ( l = 0, ll = lights.length; l < ll; l ++ ) {\r\n\t\r\n\t\t\t\tlight = lights[ l ];\r\n\t\r\n\t\t\t\tif ( light.onlyShadow ) continue;\r\n\t\r\n\t\t\t\tcolor = light.color;\r\n\t\t\t\tintensity = light.intensity;\r\n\t\t\t\tdistance = light.distance;\r\n\t\r\n\t\t\t\tif ( light instanceof THREE.AmbientLight ) {\r\n\t\r\n\t\t\t\t\tif ( ! light.visible ) continue;\r\n\t\r\n\t\t\t\t\tr += color.r;\r\n\t\t\t\t\tg += color.g;\r\n\t\t\t\t\tb += color.b;\r\n\t\r\n\t\t\t\t} else if ( light instanceof THREE.DirectionalLight ) {\r\n\t\r\n\t\t\t\t\tdirCount += 1;\r\n\t\r\n\t\t\t\t\tif ( ! light.visible ) continue;\r\n\t\r\n\t\t\t\t\t_direction.setFromMatrixPosition( light.matrixWorld );\r\n\t\t\t\t\t_vector3.setFromMatrixPosition( light.target.matrixWorld );\r\n\t\t\t\t\t_direction.sub( _vector3 );\r\n\t\t\t\t\t_direction.normalize();\r\n\t\r\n\t\t\t\t\tdirOffset = dirLength * 3;\r\n\t\r\n\t\t\t\t\tdirPositions[ dirOffset ]     = _direction.x;\r\n\t\t\t\t\tdirPositions[ dirOffset + 1 ] = _direction.y;\r\n\t\t\t\t\tdirPositions[ dirOffset + 2 ] = _direction.z;\r\n\t\r\n\t\t\t\t\tsetColorLinear( dirColors, dirOffset, color, intensity );\r\n\t\r\n\t\t\t\t\tdirLength += 1;\r\n\t\r\n\t\t\t\t} else if ( light instanceof THREE.PointLight ) {\r\n\t\r\n\t\t\t\t\tpointCount += 1;\r\n\t\r\n\t\t\t\t\tif ( ! light.visible ) continue;\r\n\t\r\n\t\t\t\t\tpointOffset = pointLength * 3;\r\n\t\r\n\t\t\t\t\tsetColorLinear( pointColors, pointOffset, color, intensity );\r\n\t\r\n\t\t\t\t\t_vector3.setFromMatrixPosition( light.matrixWorld );\r\n\t\r\n\t\t\t\t\tpointPositions[ pointOffset ]     = _vector3.x;\r\n\t\t\t\t\tpointPositions[ pointOffset + 1 ] = _vector3.y;\r\n\t\t\t\t\tpointPositions[ pointOffset + 2 ] = _vector3.z;\r\n\t\r\n\t\t\t\t\t// distance is 0 if decay is 0, because there is no attenuation at all.\r\n\t\t\t\t\tpointDistances[ pointLength ] = distance;\r\n\t\t\t\t\tpointDecays[ pointLength ] = ( light.distance === 0 ) ? 0.0 : light.decay;\r\n\t\r\n\t\t\t\t\tpointLength += 1;\r\n\t\r\n\t\t\t\t} else if ( light instanceof THREE.SpotLight ) {\r\n\t\r\n\t\t\t\t\tspotCount += 1;\r\n\t\r\n\t\t\t\t\tif ( ! light.visible ) continue;\r\n\t\r\n\t\t\t\t\tspotOffset = spotLength * 3;\r\n\t\r\n\t\t\t\t\tsetColorLinear( spotColors, spotOffset, color, intensity );\r\n\t\r\n\t\t\t\t\t_direction.setFromMatrixPosition( light.matrixWorld );\r\n\t\r\n\t\t\t\t\tspotPositions[ spotOffset ]     = _direction.x;\r\n\t\t\t\t\tspotPositions[ spotOffset + 1 ] = _direction.y;\r\n\t\t\t\t\tspotPositions[ spotOffset + 2 ] = _direction.z;\r\n\t\r\n\t\t\t\t\tspotDistances[ spotLength ] = distance;\r\n\t\r\n\t\t\t\t\t_vector3.setFromMatrixPosition( light.target.matrixWorld );\r\n\t\t\t\t\t_direction.sub( _vector3 );\r\n\t\t\t\t\t_direction.normalize();\r\n\t\r\n\t\t\t\t\tspotDirections[ spotOffset ]     = _direction.x;\r\n\t\t\t\t\tspotDirections[ spotOffset + 1 ] = _direction.y;\r\n\t\t\t\t\tspotDirections[ spotOffset + 2 ] = _direction.z;\r\n\t\r\n\t\t\t\t\tspotAnglesCos[ spotLength ] = Math.cos( light.angle );\r\n\t\t\t\t\tspotExponents[ spotLength ] = light.exponent;\r\n\t\t\t\t\tspotDecays[ spotLength ] = ( light.distance === 0 ) ? 0.0 : light.decay;\r\n\t\r\n\t\t\t\t\tspotLength += 1;\r\n\t\r\n\t\t\t\t} else if ( light instanceof THREE.HemisphereLight ) {\r\n\t\r\n\t\t\t\t\themiCount += 1;\r\n\t\r\n\t\t\t\t\tif ( ! light.visible ) continue;\r\n\t\r\n\t\t\t\t\t_direction.setFromMatrixPosition( light.matrixWorld );\r\n\t\t\t\t\t_direction.normalize();\r\n\t\r\n\t\t\t\t\themiOffset = hemiLength * 3;\r\n\t\r\n\t\t\t\t\themiPositions[ hemiOffset ]     = _direction.x;\r\n\t\t\t\t\themiPositions[ hemiOffset + 1 ] = _direction.y;\r\n\t\t\t\t\themiPositions[ hemiOffset + 2 ] = _direction.z;\r\n\t\r\n\t\t\t\t\tskyColor = light.color;\r\n\t\t\t\t\tgroundColor = light.groundColor;\r\n\t\r\n\t\t\t\t\tsetColorLinear( hemiSkyColors, hemiOffset, skyColor, intensity );\r\n\t\t\t\t\tsetColorLinear( hemiGroundColors, hemiOffset, groundColor, intensity );\r\n\t\r\n\t\t\t\t\themiLength += 1;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// null eventual remains from removed lights\r\n\t\t\t// (this is to avoid if in shader)\r\n\t\r\n\t\t\tfor ( l = dirLength * 3, ll = Math.max( dirColors.length, dirCount * 3 ); l < ll; l ++ ) dirColors[ l ] = 0.0;\r\n\t\t\tfor ( l = pointLength * 3, ll = Math.max( pointColors.length, pointCount * 3 ); l < ll; l ++ ) pointColors[ l ] = 0.0;\r\n\t\t\tfor ( l = spotLength * 3, ll = Math.max( spotColors.length, spotCount * 3 ); l < ll; l ++ ) spotColors[ l ] = 0.0;\r\n\t\t\tfor ( l = hemiLength * 3, ll = Math.max( hemiSkyColors.length, hemiCount * 3 ); l < ll; l ++ ) hemiSkyColors[ l ] = 0.0;\r\n\t\t\tfor ( l = hemiLength * 3, ll = Math.max( hemiGroundColors.length, hemiCount * 3 ); l < ll; l ++ ) hemiGroundColors[ l ] = 0.0;\r\n\t\r\n\t\t\tzlights.directional.length = dirLength;\r\n\t\t\tzlights.point.length = pointLength;\r\n\t\t\tzlights.spot.length = spotLength;\r\n\t\t\tzlights.hemi.length = hemiLength;\r\n\t\r\n\t\t\tzlights.ambient[ 0 ] = r;\r\n\t\t\tzlights.ambient[ 1 ] = g;\r\n\t\t\tzlights.ambient[ 2 ] = b;\r\n\t\r\n\t\t}\r\n\t\r\n\t\t// GL state setting\r\n\t\r\n\t\tthis.setFaceCulling = function ( cullFace, frontFaceDirection ) {\r\n\t\r\n\t\t\tif ( cullFace === THREE.CullFaceNone ) {\r\n\t\r\n\t\t\t\t_gl.disable( _gl.CULL_FACE );\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\tif ( frontFaceDirection === THREE.FrontFaceDirectionCW ) {\r\n\t\r\n\t\t\t\t\t_gl.frontFace( _gl.CW );\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t_gl.frontFace( _gl.CCW );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( cullFace === THREE.CullFaceBack ) {\r\n\t\r\n\t\t\t\t\t_gl.cullFace( _gl.BACK );\r\n\t\r\n\t\t\t\t} else if ( cullFace === THREE.CullFaceFront ) {\r\n\t\r\n\t\t\t\t\t_gl.cullFace( _gl.FRONT );\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t_gl.cullFace( _gl.FRONT_AND_BACK );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\t_gl.enable( _gl.CULL_FACE );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.setMaterialFaces = function ( material ) {\r\n\t\r\n\t\t\tstate.setDoubleSided( material.side === THREE.DoubleSide );\r\n\t\t\tstate.setFlipSided( material.side === THREE.BackSide );\r\n\t\r\n\t\t};\r\n\t\r\n\t\t// Textures\r\n\t\r\n\t\tfunction setTextureParameters ( textureType, texture, isImagePowerOfTwo ) {\r\n\t\r\n\t\t\tvar extension;\r\n\t\r\n\t\t\tif ( isImagePowerOfTwo ) {\r\n\t\r\n\t\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, paramThreeToGL( texture.wrapS ) );\r\n\t\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, paramThreeToGL( texture.wrapT ) );\r\n\t\r\n\t\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, paramThreeToGL( texture.magFilter ) );\r\n\t\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, paramThreeToGL( texture.minFilter ) );\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, _gl.CLAMP_TO_EDGE );\r\n\t\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, _gl.CLAMP_TO_EDGE );\r\n\t\r\n\t\t\t\tif ( texture.wrapS !== THREE.ClampToEdgeWrapping || texture.wrapT !== THREE.ClampToEdgeWrapping ) {\r\n\t\r\n\t\t\t\t\tTHREE.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping. ( ' + texture.sourceFile + ' )' );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, filterFallback( texture.magFilter ) );\r\n\t\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, filterFallback( texture.minFilter ) );\r\n\t\r\n\t\t\t\tif ( texture.minFilter !== THREE.NearestFilter && texture.minFilter !== THREE.LinearFilter ) {\r\n\t\r\n\t\t\t\t\tTHREE.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter. ( ' + texture.sourceFile + ' )' );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\textension = extensions.get( 'EXT_texture_filter_anisotropic' );\r\n\t\r\n\t\t\tif ( extension && texture.type !== THREE.FloatType && texture.type !== THREE.HalfFloatType ) {\r\n\t\r\n\t\t\t\tif ( texture.anisotropy > 1 || texture.__currentAnisotropy ) {\r\n\t\r\n\t\t\t\t\t_gl.texParameterf( textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min( texture.anisotropy, _this.getMaxAnisotropy() ) );\r\n\t\t\t\t\ttexture.__currentAnisotropy = texture.anisotropy;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\tthis.uploadTexture = function ( texture ) {\r\n\t\r\n\t\t\tif ( texture.__webglInit === undefined ) {\r\n\t\r\n\t\t\t\ttexture.__webglInit = true;\r\n\t\r\n\t\t\t\ttexture.addEventListener( 'dispose', onTextureDispose );\r\n\t\r\n\t\t\t\ttexture.__webglTexture = _gl.createTexture();\r\n\t\r\n\t\t\t\t_this.info.memory.textures ++;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t_gl.bindTexture( _gl.TEXTURE_2D, texture.__webglTexture );\r\n\t\r\n\t\t\t_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );\r\n\t\t\t_gl.pixelStorei( _gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha );\r\n\t\t\t_gl.pixelStorei( _gl.UNPACK_ALIGNMENT, texture.unpackAlignment );\r\n\t\r\n\t\t\ttexture.image = clampToMaxSize( texture.image, _maxTextureSize );\r\n\t\r\n\t\t\tvar image = texture.image,\r\n\t\t\tisImagePowerOfTwo = THREE.Math.isPowerOfTwo( image.width ) && THREE.Math.isPowerOfTwo( image.height ),\r\n\t\t\tglFormat = paramThreeToGL( texture.format ),\r\n\t\t\tglType = paramThreeToGL( texture.type );\r\n\t\r\n\t\t\tsetTextureParameters( _gl.TEXTURE_2D, texture, isImagePowerOfTwo );\r\n\t\r\n\t\t\tvar mipmap, mipmaps = texture.mipmaps;\r\n\t\r\n\t\t\tif ( texture instanceof THREE.DataTexture ) {\r\n\t\r\n\t\t\t\t// use manually created mipmaps if available\r\n\t\t\t\t// if there are no manual mipmaps\r\n\t\t\t\t// set 0 level mipmap and then use GL to generate other mipmap levels\r\n\t\r\n\t\t\t\tif ( mipmaps.length > 0 && isImagePowerOfTwo ) {\r\n\t\r\n\t\t\t\t\tfor ( var i = 0, il = mipmaps.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\t\t\tmipmap = mipmaps[ i ];\r\n\t\t\t\t\t\t_gl.texImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\ttexture.generateMipmaps = false;\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t_gl.texImage2D( _gl.TEXTURE_2D, 0, glFormat, image.width, image.height, 0, glFormat, glType, image.data );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t} else if ( texture instanceof THREE.CompressedTexture ) {\r\n\t\r\n\t\t\t\tfor ( var i = 0, il = mipmaps.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\t\tmipmap = mipmaps[ i ];\r\n\t\r\n\t\t\t\t\tif ( texture.format !== THREE.RGBAFormat && texture.format !== THREE.RGBFormat ) {\r\n\t\r\n\t\t\t\t\t\tif ( getCompressedTextureFormats().indexOf( glFormat ) > -1 ) {\r\n\t\r\n\t\t\t\t\t\t\t_gl.compressedTexImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, mipmap.data );\r\n\t\r\n\t\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\t\tTHREE.warn( \"THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()\" );\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\t_gl.texImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t} else { // regular Texture (image, video, canvas)\r\n\t\r\n\t\t\t\t// use manually created mipmaps if available\r\n\t\t\t\t// if there are no manual mipmaps\r\n\t\t\t\t// set 0 level mipmap and then use GL to generate other mipmap levels\r\n\t\r\n\t\t\t\tif ( mipmaps.length > 0 && isImagePowerOfTwo ) {\r\n\t\r\n\t\t\t\t\tfor ( var i = 0, il = mipmaps.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\t\t\tmipmap = mipmaps[ i ];\r\n\t\t\t\t\t\t_gl.texImage2D( _gl.TEXTURE_2D, i, glFormat, glFormat, glType, mipmap );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\ttexture.generateMipmaps = false;\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t_gl.texImage2D( _gl.TEXTURE_2D, 0, glFormat, glFormat, glType, texture.image );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( texture.generateMipmaps && isImagePowerOfTwo ) _gl.generateMipmap( _gl.TEXTURE_2D );\r\n\t\r\n\t\t\ttexture.needsUpdate = false;\r\n\t\r\n\t\t\tif ( texture.onUpdate ) texture.onUpdate();\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.setTexture = function ( texture, slot ) {\r\n\t\r\n\t\t\t_gl.activeTexture( _gl.TEXTURE0 + slot );\r\n\t\r\n\t\t\tif ( texture.needsUpdate ) {\r\n\t\r\n\t\t\t\t_this.uploadTexture( texture );\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\t_gl.bindTexture( _gl.TEXTURE_2D, texture.__webglTexture );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t\tfunction clampToMaxSize ( image, maxSize ) {\r\n\t\r\n\t\t\tif ( image.width > maxSize || image.height > maxSize ) {\r\n\t\r\n\t\t\t\t// Warning: Scaling through the canvas will only work with images that use\r\n\t\t\t\t// premultiplied alpha.\r\n\t\r\n\t\t\t\tvar scale = maxSize / Math.max( image.width, image.height );\r\n\t\r\n\t\t\t\tvar canvas = document.createElement( 'canvas' );\r\n\t\t\t\tcanvas.width = Math.floor( image.width * scale );\r\n\t\t\t\tcanvas.height = Math.floor( image.height * scale );\r\n\t\r\n\t\t\t\tvar context = canvas.getContext( '2d' );\r\n\t\t\t\tcontext.drawImage( image, 0, 0, image.width, image.height, 0, 0, canvas.width, canvas.height );\r\n\t\r\n\t\t\t\tTHREE.warn( 'THREE.WebGLRenderer: image is too big (' + image.width + 'x' + image.height + '). Resized to ' + canvas.width + 'x' + canvas.height, image );\r\n\t\r\n\t\t\t\treturn canvas;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn image;\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction setCubeTexture ( texture, slot ) {\r\n\t\r\n\t\t\tif ( texture.image.length === 6 ) {\r\n\t\r\n\t\t\t\tif ( texture.needsUpdate ) {\r\n\t\r\n\t\t\t\t\tif ( ! texture.image.__webglTextureCube ) {\r\n\t\r\n\t\t\t\t\t\ttexture.addEventListener( 'dispose', onTextureDispose );\r\n\t\r\n\t\t\t\t\t\ttexture.image.__webglTextureCube = _gl.createTexture();\r\n\t\r\n\t\t\t\t\t\t_this.info.memory.textures ++;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t_gl.activeTexture( _gl.TEXTURE0 + slot );\r\n\t\t\t\t\t_gl.bindTexture( _gl.TEXTURE_CUBE_MAP, texture.image.__webglTextureCube );\r\n\t\r\n\t\t\t\t\t_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );\r\n\t\r\n\t\t\t\t\tvar isCompressed = texture instanceof THREE.CompressedTexture;\r\n\t\t\t\t\tvar isDataTexture = texture.image[ 0 ] instanceof THREE.DataTexture;\r\n\t\r\n\t\t\t\t\tvar cubeImage = [];\r\n\t\r\n\t\t\t\t\tfor ( var i = 0; i < 6; i ++ ) {\r\n\t\r\n\t\t\t\t\t\tif ( _this.autoScaleCubemaps && ! isCompressed && ! isDataTexture ) {\r\n\t\r\n\t\t\t\t\t\t\tcubeImage[ i ] = clampToMaxSize( texture.image[ i ], _maxCubemapSize );\r\n\t\r\n\t\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\t\tcubeImage[ i ] = isDataTexture ? texture.image[ i ].image : texture.image[ i ];\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tvar image = cubeImage[ 0 ],\r\n\t\t\t\t\tisImagePowerOfTwo = THREE.Math.isPowerOfTwo( image.width ) && THREE.Math.isPowerOfTwo( image.height ),\r\n\t\t\t\t\tglFormat = paramThreeToGL( texture.format ),\r\n\t\t\t\t\tglType = paramThreeToGL( texture.type );\r\n\t\r\n\t\t\t\t\tsetTextureParameters( _gl.TEXTURE_CUBE_MAP, texture, isImagePowerOfTwo );\r\n\t\r\n\t\t\t\t\tfor ( var i = 0; i < 6; i ++ ) {\r\n\t\r\n\t\t\t\t\t\tif ( ! isCompressed ) {\r\n\t\r\n\t\t\t\t\t\t\tif ( isDataTexture ) {\r\n\t\r\n\t\t\t\t\t\t\t\t_gl.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, cubeImage[ i ].width, cubeImage[ i ].height, 0, glFormat, glType, cubeImage[ i ].data );\r\n\t\r\n\t\t\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\t\t\t_gl.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, glFormat, glType, cubeImage[ i ] );\r\n\t\r\n\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\t\tvar mipmap, mipmaps = cubeImage[ i ].mipmaps;\r\n\t\r\n\t\t\t\t\t\t\tfor ( var j = 0, jl = mipmaps.length; j < jl; j ++ ) {\r\n\t\r\n\t\t\t\t\t\t\t\tmipmap = mipmaps[ j ];\r\n\t\r\n\t\t\t\t\t\t\t\tif ( texture.format !== THREE.RGBAFormat && texture.format !== THREE.RGBFormat ) {\r\n\t\r\n\t\t\t\t\t\t\t\t\tif ( getCompressedTextureFormats().indexOf( glFormat ) > -1 ) {\r\n\t\r\n\t\t\t\t\t\t\t\t\t\t_gl.compressedTexImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, mipmap.data );\r\n\t\r\n\t\t\t\t\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\t\t\t\t\tTHREE.warn( \"THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setCubeTexture()\" );\r\n\t\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\t\t\t\t_gl.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );\r\n\t\r\n\t\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tif ( texture.generateMipmaps && isImagePowerOfTwo ) {\r\n\t\r\n\t\t\t\t\t\t_gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\ttexture.needsUpdate = false;\r\n\t\r\n\t\t\t\t\tif ( texture.onUpdate ) texture.onUpdate();\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t_gl.activeTexture( _gl.TEXTURE0 + slot );\r\n\t\t\t\t\t_gl.bindTexture( _gl.TEXTURE_CUBE_MAP, texture.image.__webglTextureCube );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction setCubeTextureDynamic ( texture, slot ) {\r\n\t\r\n\t\t\t_gl.activeTexture( _gl.TEXTURE0 + slot );\r\n\t\t\t_gl.bindTexture( _gl.TEXTURE_CUBE_MAP, texture.__webglTexture );\r\n\t\r\n\t\t}\r\n\t\r\n\t\t// Render targets\r\n\t\r\n\t\tfunction setupFrameBuffer ( framebuffer, renderTarget, textureTarget ) {\r\n\t\r\n\t\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );\r\n\t\t\t_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, textureTarget, renderTarget.__webglTexture, 0 );\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction setupRenderBuffer ( renderbuffer, renderTarget  ) {\r\n\t\r\n\t\t\t_gl.bindRenderbuffer( _gl.RENDERBUFFER, renderbuffer );\r\n\t\r\n\t\t\tif ( renderTarget.depthBuffer && ! renderTarget.stencilBuffer ) {\r\n\t\r\n\t\t\t\t_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_COMPONENT16, renderTarget.width, renderTarget.height );\r\n\t\t\t\t_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );\r\n\t\r\n\t\t\t/* For some reason this is not working. Defaulting to RGBA4.\r\n\t\t\t} else if ( ! renderTarget.depthBuffer && renderTarget.stencilBuffer ) {\r\n\t\r\n\t\t\t\t_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.STENCIL_INDEX8, renderTarget.width, renderTarget.height );\r\n\t\t\t\t_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );\r\n\t\t\t*/\r\n\t\t\t} else if ( renderTarget.depthBuffer && renderTarget.stencilBuffer ) {\r\n\t\r\n\t\t\t\t_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_STENCIL, renderTarget.width, renderTarget.height );\r\n\t\t\t\t_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\t_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.RGBA4, renderTarget.width, renderTarget.height );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\tthis.setRenderTarget = function ( renderTarget ) {\r\n\t\r\n\t\t\tvar isCube = ( renderTarget instanceof THREE.WebGLRenderTargetCube );\r\n\t\r\n\t\t\tif ( renderTarget && renderTarget.__webglFramebuffer === undefined ) {\r\n\t\r\n\t\t\t\tif ( renderTarget.depthBuffer === undefined ) renderTarget.depthBuffer = true;\r\n\t\t\t\tif ( renderTarget.stencilBuffer === undefined ) renderTarget.stencilBuffer = true;\r\n\t\r\n\t\t\t\trenderTarget.addEventListener( 'dispose', onRenderTargetDispose );\r\n\t\r\n\t\t\t\trenderTarget.__webglTexture = _gl.createTexture();\r\n\t\r\n\t\t\t\t_this.info.memory.textures ++;\r\n\t\r\n\t\t\t\t// Setup texture, create render and frame buffers\r\n\t\r\n\t\t\t\tvar isTargetPowerOfTwo = THREE.Math.isPowerOfTwo( renderTarget.width ) && THREE.Math.isPowerOfTwo( renderTarget.height ),\r\n\t\t\t\t\tglFormat = paramThreeToGL( renderTarget.format ),\r\n\t\t\t\t\tglType = paramThreeToGL( renderTarget.type );\r\n\t\r\n\t\t\t\tif ( isCube ) {\r\n\t\r\n\t\t\t\t\trenderTarget.__webglFramebuffer = [];\r\n\t\t\t\t\trenderTarget.__webglRenderbuffer = [];\r\n\t\r\n\t\t\t\t\t_gl.bindTexture( _gl.TEXTURE_CUBE_MAP, renderTarget.__webglTexture );\r\n\t\t\t\t\tsetTextureParameters( _gl.TEXTURE_CUBE_MAP, renderTarget, isTargetPowerOfTwo );\r\n\t\r\n\t\t\t\t\tfor ( var i = 0; i < 6; i ++ ) {\r\n\t\r\n\t\t\t\t\t\trenderTarget.__webglFramebuffer[ i ] = _gl.createFramebuffer();\r\n\t\t\t\t\t\trenderTarget.__webglRenderbuffer[ i ] = _gl.createRenderbuffer();\r\n\t\r\n\t\t\t\t\t\t_gl.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null );\r\n\t\r\n\t\t\t\t\t\tsetupFrameBuffer( renderTarget.__webglFramebuffer[ i ], renderTarget, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i );\r\n\t\t\t\t\t\tsetupRenderBuffer( renderTarget.__webglRenderbuffer[ i ], renderTarget );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tif ( isTargetPowerOfTwo ) _gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\trenderTarget.__webglFramebuffer = _gl.createFramebuffer();\r\n\t\r\n\t\t\t\t\tif ( renderTarget.shareDepthFrom ) {\r\n\t\r\n\t\t\t\t\t\trenderTarget.__webglRenderbuffer = renderTarget.shareDepthFrom.__webglRenderbuffer;\r\n\t\r\n\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\trenderTarget.__webglRenderbuffer = _gl.createRenderbuffer();\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t_gl.bindTexture( _gl.TEXTURE_2D, renderTarget.__webglTexture );\r\n\t\t\t\t\tsetTextureParameters( _gl.TEXTURE_2D, renderTarget, isTargetPowerOfTwo );\r\n\t\r\n\t\t\t\t\t_gl.texImage2D( _gl.TEXTURE_2D, 0, glFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null );\r\n\t\r\n\t\t\t\t\tsetupFrameBuffer( renderTarget.__webglFramebuffer, renderTarget, _gl.TEXTURE_2D );\r\n\t\r\n\t\t\t\t\tif ( renderTarget.shareDepthFrom ) {\r\n\t\r\n\t\t\t\t\t\tif ( renderTarget.depthBuffer && ! renderTarget.stencilBuffer ) {\r\n\t\r\n\t\t\t\t\t\t\t_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderTarget.__webglRenderbuffer );\r\n\t\r\n\t\t\t\t\t\t} else if ( renderTarget.depthBuffer && renderTarget.stencilBuffer ) {\r\n\t\r\n\t\t\t\t\t\t\t_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderTarget.__webglRenderbuffer );\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\tsetupRenderBuffer( renderTarget.__webglRenderbuffer, renderTarget );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tif ( isTargetPowerOfTwo ) _gl.generateMipmap( _gl.TEXTURE_2D );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\t// Release everything\r\n\t\r\n\t\t\t\tif ( isCube ) {\r\n\t\r\n\t\t\t\t\t_gl.bindTexture( _gl.TEXTURE_CUBE_MAP, null );\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t_gl.bindTexture( _gl.TEXTURE_2D, null );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\t_gl.bindRenderbuffer( _gl.RENDERBUFFER, null );\r\n\t\t\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, null );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar framebuffer, width, height, vx, vy;\r\n\t\r\n\t\t\tif ( renderTarget ) {\r\n\t\r\n\t\t\t\tif ( isCube ) {\r\n\t\r\n\t\t\t\t\tframebuffer = renderTarget.__webglFramebuffer[ renderTarget.activeCubeFace ];\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tframebuffer = renderTarget.__webglFramebuffer;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\twidth = renderTarget.width;\r\n\t\t\t\theight = renderTarget.height;\r\n\t\r\n\t\t\t\tvx = 0;\r\n\t\t\t\tvy = 0;\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\tframebuffer = null;\r\n\t\r\n\t\t\t\twidth = _viewportWidth;\r\n\t\t\t\theight = _viewportHeight;\r\n\t\r\n\t\t\t\tvx = _viewportX;\r\n\t\t\t\tvy = _viewportY;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( framebuffer !== _currentFramebuffer ) {\r\n\t\r\n\t\t\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );\r\n\t\t\t\t_gl.viewport( vx, vy, width, height );\r\n\t\r\n\t\t\t\t_currentFramebuffer = framebuffer;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t_currentWidth = width;\r\n\t\t\t_currentHeight = height;\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.readRenderTargetPixels = function( renderTarget, x, y, width, height, buffer ) {\r\n\t\r\n\t\t\tif ( ! ( renderTarget instanceof THREE.WebGLRenderTarget ) ) {\r\n\t\r\n\t\t\t\tconsole.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.' );\r\n\t\t\t\treturn;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( renderTarget.__webglFramebuffer ) {\r\n\t\r\n\t\t\t\tif ( renderTarget.format !== THREE.RGBAFormat ) {\r\n\t\r\n\t\t\t\t\tconsole.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA format. readPixels can read only RGBA format.' );\r\n\t\t\t\t\treturn;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tvar restore = false;\r\n\t\r\n\t\t\t\tif ( renderTarget.__webglFramebuffer !== _currentFramebuffer ) {\r\n\t\r\n\t\t\t\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, renderTarget.__webglFramebuffer );\r\n\t\r\n\t\t\t\t\trestore = true;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( _gl.checkFramebufferStatus( _gl.FRAMEBUFFER ) === _gl.FRAMEBUFFER_COMPLETE ) {\r\n\t\r\n\t\t\t\t\t_gl.readPixels( x, y, width, height, _gl.RGBA, _gl.UNSIGNED_BYTE, buffer );\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tconsole.error( 'THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.' );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( restore ) {\r\n\t\r\n\t\t\t\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, _currentFramebuffer );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t\tfunction updateRenderTargetMipmap ( renderTarget ) {\r\n\t\r\n\t\t\tif ( renderTarget instanceof THREE.WebGLRenderTargetCube ) {\r\n\t\r\n\t\t\t\t_gl.bindTexture( _gl.TEXTURE_CUBE_MAP, renderTarget.__webglTexture );\r\n\t\t\t\t_gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );\r\n\t\t\t\t_gl.bindTexture( _gl.TEXTURE_CUBE_MAP, null );\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\t_gl.bindTexture( _gl.TEXTURE_2D, renderTarget.__webglTexture );\r\n\t\t\t\t_gl.generateMipmap( _gl.TEXTURE_2D );\r\n\t\t\t\t_gl.bindTexture( _gl.TEXTURE_2D, null );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\t// Fallback filters for non-power-of-2 textures\r\n\t\r\n\t\tfunction filterFallback ( f ) {\r\n\t\r\n\t\t\tif ( f === THREE.NearestFilter || f === THREE.NearestMipMapNearestFilter || f === THREE.NearestMipMapLinearFilter ) {\r\n\t\r\n\t\t\t\treturn _gl.NEAREST;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn _gl.LINEAR;\r\n\t\r\n\t\t}\r\n\t\r\n\t\t// Map three.js constants to WebGL constants\r\n\t\r\n\t\tfunction paramThreeToGL ( p ) {\r\n\t\r\n\t\t\tvar extension;\r\n\t\r\n\t\t\tif ( p === THREE.RepeatWrapping ) return _gl.REPEAT;\r\n\t\t\tif ( p === THREE.ClampToEdgeWrapping ) return _gl.CLAMP_TO_EDGE;\r\n\t\t\tif ( p === THREE.MirroredRepeatWrapping ) return _gl.MIRRORED_REPEAT;\r\n\t\r\n\t\t\tif ( p === THREE.NearestFilter ) return _gl.NEAREST;\r\n\t\t\tif ( p === THREE.NearestMipMapNearestFilter ) return _gl.NEAREST_MIPMAP_NEAREST;\r\n\t\t\tif ( p === THREE.NearestMipMapLinearFilter ) return _gl.NEAREST_MIPMAP_LINEAR;\r\n\t\r\n\t\t\tif ( p === THREE.LinearFilter ) return _gl.LINEAR;\r\n\t\t\tif ( p === THREE.LinearMipMapNearestFilter ) return _gl.LINEAR_MIPMAP_NEAREST;\r\n\t\t\tif ( p === THREE.LinearMipMapLinearFilter ) return _gl.LINEAR_MIPMAP_LINEAR;\r\n\t\r\n\t\t\tif ( p === THREE.UnsignedByteType ) return _gl.UNSIGNED_BYTE;\r\n\t\t\tif ( p === THREE.UnsignedShort4444Type ) return _gl.UNSIGNED_SHORT_4_4_4_4;\r\n\t\t\tif ( p === THREE.UnsignedShort5551Type ) return _gl.UNSIGNED_SHORT_5_5_5_1;\r\n\t\t\tif ( p === THREE.UnsignedShort565Type ) return _gl.UNSIGNED_SHORT_5_6_5;\r\n\t\r\n\t\t\tif ( p === THREE.ByteType ) return _gl.BYTE;\r\n\t\t\tif ( p === THREE.ShortType ) return _gl.SHORT;\r\n\t\t\tif ( p === THREE.UnsignedShortType ) return _gl.UNSIGNED_SHORT;\r\n\t\t\tif ( p === THREE.IntType ) return _gl.INT;\r\n\t\t\tif ( p === THREE.UnsignedIntType ) return _gl.UNSIGNED_INT;\r\n\t\t\tif ( p === THREE.FloatType ) return _gl.FLOAT;\r\n\t\r\n\t\t\textension = extensions.get( 'OES_texture_half_float' );\r\n\t\r\n\t\t\tif ( extension !== null ) {\r\n\t\r\n\t\t\t\tif ( p === THREE.HalfFloatType ) return extension.HALF_FLOAT_OES;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( p === THREE.AlphaFormat ) return _gl.ALPHA;\r\n\t\t\tif ( p === THREE.RGBFormat ) return _gl.RGB;\r\n\t\t\tif ( p === THREE.RGBAFormat ) return _gl.RGBA;\r\n\t\t\tif ( p === THREE.LuminanceFormat ) return _gl.LUMINANCE;\r\n\t\t\tif ( p === THREE.LuminanceAlphaFormat ) return _gl.LUMINANCE_ALPHA;\r\n\t\r\n\t\t\tif ( p === THREE.AddEquation ) return _gl.FUNC_ADD;\r\n\t\t\tif ( p === THREE.SubtractEquation ) return _gl.FUNC_SUBTRACT;\r\n\t\t\tif ( p === THREE.ReverseSubtractEquation ) return _gl.FUNC_REVERSE_SUBTRACT;\r\n\t\r\n\t\t\tif ( p === THREE.ZeroFactor ) return _gl.ZERO;\r\n\t\t\tif ( p === THREE.OneFactor ) return _gl.ONE;\r\n\t\t\tif ( p === THREE.SrcColorFactor ) return _gl.SRC_COLOR;\r\n\t\t\tif ( p === THREE.OneMinusSrcColorFactor ) return _gl.ONE_MINUS_SRC_COLOR;\r\n\t\t\tif ( p === THREE.SrcAlphaFactor ) return _gl.SRC_ALPHA;\r\n\t\t\tif ( p === THREE.OneMinusSrcAlphaFactor ) return _gl.ONE_MINUS_SRC_ALPHA;\r\n\t\t\tif ( p === THREE.DstAlphaFactor ) return _gl.DST_ALPHA;\r\n\t\t\tif ( p === THREE.OneMinusDstAlphaFactor ) return _gl.ONE_MINUS_DST_ALPHA;\r\n\t\r\n\t\t\tif ( p === THREE.DstColorFactor ) return _gl.DST_COLOR;\r\n\t\t\tif ( p === THREE.OneMinusDstColorFactor ) return _gl.ONE_MINUS_DST_COLOR;\r\n\t\t\tif ( p === THREE.SrcAlphaSaturateFactor ) return _gl.SRC_ALPHA_SATURATE;\r\n\t\r\n\t\t\textension = extensions.get( 'WEBGL_compressed_texture_s3tc' );\r\n\t\r\n\t\t\tif ( extension !== null ) {\r\n\t\r\n\t\t\t\tif ( p === THREE.RGB_S3TC_DXT1_Format ) return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;\r\n\t\t\t\tif ( p === THREE.RGBA_S3TC_DXT1_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;\r\n\t\t\t\tif ( p === THREE.RGBA_S3TC_DXT3_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;\r\n\t\t\t\tif ( p === THREE.RGBA_S3TC_DXT5_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\textension = extensions.get( 'WEBGL_compressed_texture_pvrtc' );\r\n\t\r\n\t\t\tif ( extension !== null ) {\r\n\t\r\n\t\t\t\tif ( p === THREE.RGB_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;\r\n\t\t\t\tif ( p === THREE.RGB_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;\r\n\t\t\t\tif ( p === THREE.RGBA_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;\r\n\t\t\t\tif ( p === THREE.RGBA_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\textension = extensions.get( 'EXT_blend_minmax' );\r\n\t\r\n\t\t\tif ( extension !== null ) {\r\n\t\r\n\t\t\t\tif ( p === THREE.MinEquation ) return extension.MIN_EXT;\r\n\t\t\t\tif ( p === THREE.MaxEquation ) return extension.MAX_EXT;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn 0;\r\n\t\r\n\t\t}\r\n\t\r\n\t\t// Allocations\r\n\t\r\n\t\tfunction allocateBones ( object ) {\r\n\t\r\n\t\t\tif ( _supportsBoneTextures && object && object.skeleton && object.skeleton.useVertexTexture ) {\r\n\t\r\n\t\t\t\treturn 1024;\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\t// default for when object is not specified\r\n\t\t\t\t// ( for example when prebuilding shader\r\n\t\t\t\t//   to be used with multiple objects )\r\n\t\t\t\t//\r\n\t\t\t\t//  - leave some extra space for other uniforms\r\n\t\t\t\t//  - limit here is ANGLE's 254 max uniform vectors\r\n\t\t\t\t//    (up to 54 should be safe)\r\n\t\r\n\t\t\t\tvar nVertexUniforms = _gl.getParameter( _gl.MAX_VERTEX_UNIFORM_VECTORS );\r\n\t\t\t\tvar nVertexMatrices = Math.floor( ( nVertexUniforms - 20 ) / 4 );\r\n\t\r\n\t\t\t\tvar maxBones = nVertexMatrices;\r\n\t\r\n\t\t\t\tif ( object !== undefined && object instanceof THREE.SkinnedMesh ) {\r\n\t\r\n\t\t\t\t\tmaxBones = Math.min( object.skeleton.bones.length, maxBones );\r\n\t\r\n\t\t\t\t\tif ( maxBones < object.skeleton.bones.length ) {\r\n\t\r\n\t\t\t\t\t\tTHREE.warn( 'WebGLRenderer: too many bones - ' + object.skeleton.bones.length + ', this GPU supports just ' + maxBones + ' (try OpenGL instead of ANGLE)' );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\treturn maxBones;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction allocateLights( lights ) {\r\n\t\r\n\t\t\tvar dirLights = 0;\r\n\t\t\tvar pointLights = 0;\r\n\t\t\tvar spotLights = 0;\r\n\t\t\tvar hemiLights = 0;\r\n\t\r\n\t\t\tfor ( var l = 0, ll = lights.length; l < ll; l ++ ) {\r\n\t\r\n\t\t\t\tvar light = lights[ l ];\r\n\t\r\n\t\t\t\tif ( light.onlyShadow || light.visible === false ) continue;\r\n\t\r\n\t\t\t\tif ( light instanceof THREE.DirectionalLight ) dirLights ++;\r\n\t\t\t\tif ( light instanceof THREE.PointLight ) pointLights ++;\r\n\t\t\t\tif ( light instanceof THREE.SpotLight ) spotLights ++;\r\n\t\t\t\tif ( light instanceof THREE.HemisphereLight ) hemiLights ++;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn { 'directional': dirLights, 'point': pointLights, 'spot': spotLights, 'hemi': hemiLights };\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction allocateShadows( lights ) {\r\n\t\r\n\t\t\tvar maxShadows = 0;\r\n\t\r\n\t\t\tfor ( var l = 0, ll = lights.length; l < ll; l ++ ) {\r\n\t\r\n\t\t\t\tvar light = lights[ l ];\r\n\t\r\n\t\t\t\tif ( ! light.castShadow ) continue;\r\n\t\r\n\t\t\t\tif ( light instanceof THREE.SpotLight ) maxShadows ++;\r\n\t\t\t\tif ( light instanceof THREE.DirectionalLight && ! light.shadowCascade ) maxShadows ++;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn maxShadows;\r\n\t\r\n\t\t}\r\n\t\r\n\t\t// DEPRECATED\r\n\t\r\n\t\tthis.initMaterial = function () {\r\n\t\r\n\t\t\tTHREE.warn( 'THREE.WebGLRenderer: .initMaterial() has been removed.' );\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.addPrePlugin = function () {\r\n\t\r\n\t\t\tTHREE.warn( 'THREE.WebGLRenderer: .addPrePlugin() has been removed.' );\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.addPostPlugin = function () {\r\n\t\r\n\t\t\tTHREE.warn( 'THREE.WebGLRenderer: .addPostPlugin() has been removed.' );\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.updateShadowMap = function () {\r\n\t\r\n\t\t\tTHREE.warn( 'THREE.WebGLRenderer: .updateShadowMap() has been removed.' );\r\n\t\r\n\t\t};\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/renderers/WebGLRenderTarget.js\r\n\t\r\n\t/**\r\n\t * @author szimek / https://github.com/szimek/\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t */\r\n\t\r\n\tTHREE.WebGLRenderTarget = function ( width, height, options ) {\r\n\t\r\n\t\tthis.width = width;\r\n\t\tthis.height = height;\r\n\t\r\n\t\toptions = options || {};\r\n\t\r\n\t\tthis.wrapS = options.wrapS !== undefined ? options.wrapS : THREE.ClampToEdgeWrapping;\r\n\t\tthis.wrapT = options.wrapT !== undefined ? options.wrapT : THREE.ClampToEdgeWrapping;\r\n\t\r\n\t\tthis.magFilter = options.magFilter !== undefined ? options.magFilter : THREE.LinearFilter;\r\n\t\tthis.minFilter = options.minFilter !== undefined ? options.minFilter : THREE.LinearMipMapLinearFilter;\r\n\t\r\n\t\tthis.anisotropy = options.anisotropy !== undefined ? options.anisotropy : 1;\r\n\t\r\n\t\tthis.offset = new THREE.Vector2( 0, 0 );\r\n\t\tthis.repeat = new THREE.Vector2( 1, 1 );\r\n\t\r\n\t\tthis.format = options.format !== undefined ? options.format : THREE.RGBAFormat;\r\n\t\tthis.type = options.type !== undefined ? options.type : THREE.UnsignedByteType;\r\n\t\r\n\t\tthis.depthBuffer = options.depthBuffer !== undefined ? options.depthBuffer : true;\r\n\t\tthis.stencilBuffer = options.stencilBuffer !== undefined ? options.stencilBuffer : true;\r\n\t\r\n\t\tthis.generateMipmaps = true;\r\n\t\r\n\t\tthis.shareDepthFrom = options.shareDepthFrom !== undefined ? options.shareDepthFrom : null;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.WebGLRenderTarget.prototype = {\r\n\t\r\n\t\tconstructor: THREE.WebGLRenderTarget,\r\n\t\r\n\t\tsetSize: function ( width, height ) {\r\n\t\r\n\t\t\tthis.width = width;\r\n\t\t\tthis.height = height;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tclone: function () {\r\n\t\r\n\t\t\tvar tmp = new THREE.WebGLRenderTarget( this.width, this.height );\r\n\t\r\n\t\t\ttmp.wrapS = this.wrapS;\r\n\t\t\ttmp.wrapT = this.wrapT;\r\n\t\r\n\t\t\ttmp.magFilter = this.magFilter;\r\n\t\t\ttmp.minFilter = this.minFilter;\r\n\t\r\n\t\t\ttmp.anisotropy = this.anisotropy;\r\n\t\r\n\t\t\ttmp.offset.copy( this.offset );\r\n\t\t\ttmp.repeat.copy( this.repeat );\r\n\t\r\n\t\t\ttmp.format = this.format;\r\n\t\t\ttmp.type = this.type;\r\n\t\r\n\t\t\ttmp.depthBuffer = this.depthBuffer;\r\n\t\t\ttmp.stencilBuffer = this.stencilBuffer;\r\n\t\r\n\t\t\ttmp.generateMipmaps = this.generateMipmaps;\r\n\t\r\n\t\t\ttmp.shareDepthFrom = this.shareDepthFrom;\r\n\t\r\n\t\t\treturn tmp;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tdispose: function () {\r\n\t\r\n\t\t\tthis.dispatchEvent( { type: 'dispose' } );\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.EventDispatcher.prototype.apply( THREE.WebGLRenderTarget.prototype );\r\n\t\r\n\t// File:src/renderers/WebGLRenderTargetCube.js\r\n\t\r\n\t/**\r\n\t * @author alteredq / http://alteredqualia.com\r\n\t */\r\n\t\r\n\tTHREE.WebGLRenderTargetCube = function ( width, height, options ) {\r\n\t\r\n\t\tTHREE.WebGLRenderTarget.call( this, width, height, options );\r\n\t\r\n\t\tthis.activeCubeFace = 0; // PX 0, NX 1, PY 2, NY 3, PZ 4, NZ 5\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.WebGLRenderTargetCube.prototype = Object.create( THREE.WebGLRenderTarget.prototype );\r\n\tTHREE.WebGLRenderTargetCube.prototype.constructor = THREE.WebGLRenderTargetCube;\r\n\t\r\n\t// File:src/renderers/webgl/WebGLExtensions.js\r\n\t\r\n\t/**\r\n\t* @author mrdoob / http://mrdoob.com/\r\n\t*/\r\n\t\r\n\tTHREE.WebGLExtensions = function ( gl ) {\r\n\t\r\n\t\tvar extensions = {};\r\n\t\r\n\t\tthis.get = function ( name ) {\r\n\t\r\n\t\t\tif ( extensions[ name ] !== undefined ) {\r\n\t\r\n\t\t\t\treturn extensions[ name ];\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar extension;\r\n\t\r\n\t\t\tswitch ( name ) {\r\n\t\r\n\t\t\t\tcase 'EXT_texture_filter_anisotropic':\r\n\t\t\t\t\textension = gl.getExtension( 'EXT_texture_filter_anisotropic' ) || gl.getExtension( 'MOZ_EXT_texture_filter_anisotropic' ) || gl.getExtension( 'WEBKIT_EXT_texture_filter_anisotropic' );\r\n\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\tcase 'WEBGL_compressed_texture_s3tc':\r\n\t\t\t\t\textension = gl.getExtension( 'WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'MOZ_WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_s3tc' );\r\n\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\tcase 'WEBGL_compressed_texture_pvrtc':\r\n\t\t\t\t\textension = gl.getExtension( 'WEBGL_compressed_texture_pvrtc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_pvrtc' );\r\n\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\tdefault:\r\n\t\t\t\t\textension = gl.getExtension( name );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( extension === null ) {\r\n\t\r\n\t\t\t\tTHREE.warn( 'THREE.WebGLRenderer: ' + name + ' extension not supported.' );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\textensions[ name ] = extension;\r\n\t\r\n\t\t\treturn extension;\r\n\t\r\n\t\t};\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/renderers/webgl/WebGLProgram.js\r\n\t\r\n\tTHREE.WebGLProgram = ( function () {\r\n\t\r\n\t\tvar programIdCount = 0;\r\n\t\r\n\t\tvar generateDefines = function ( defines ) {\r\n\t\r\n\t\t\tvar value, chunk, chunks = [];\r\n\t\r\n\t\t\tfor ( var d in defines ) {\r\n\t\r\n\t\t\t\tvalue = defines[ d ];\r\n\t\t\t\tif ( value === false ) continue;\r\n\t\r\n\t\t\t\tchunk = '#define ' + d + ' ' + value;\r\n\t\t\t\tchunks.push( chunk );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn chunks.join( '\\n' );\r\n\t\r\n\t\t};\r\n\t\r\n\t\tvar cacheUniformLocations = function ( gl, program, identifiers ) {\r\n\t\r\n\t\t\tvar uniforms = {};\r\n\t\r\n\t\t\tfor ( var i = 0, l = identifiers.length; i < l; i ++ ) {\r\n\t\r\n\t\t\t\tvar id = identifiers[ i ];\r\n\t\t\t\tuniforms[ id ] = gl.getUniformLocation( program, id );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn uniforms;\r\n\t\r\n\t\t};\r\n\t\r\n\t\tvar cacheAttributeLocations = function ( gl, program, identifiers ) {\r\n\t\r\n\t\t\tvar attributes = {};\r\n\t\r\n\t\t\tfor ( var i = 0, l = identifiers.length; i < l; i ++ ) {\r\n\t\r\n\t\t\t\tvar id = identifiers[ i ];\r\n\t\t\t\tattributes[ id ] = gl.getAttribLocation( program, id );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn attributes;\r\n\t\r\n\t\t};\r\n\t\r\n\t\treturn function ( renderer, code, material, parameters ) {\r\n\t\r\n\t\t\tvar _this = renderer;\r\n\t\t\tvar _gl = _this.context;\r\n\t\r\n\t\t\tvar defines = material.defines;\r\n\t\t\tvar uniforms = material.__webglShader.uniforms;\r\n\t\t\tvar attributes = material.attributes;\r\n\t\r\n\t\t\tvar vertexShader = material.__webglShader.vertexShader;\r\n\t\t\tvar fragmentShader = material.__webglShader.fragmentShader;\r\n\t\r\n\t\t\tvar index0AttributeName = material.index0AttributeName;\r\n\t\r\n\t\t\tif ( index0AttributeName === undefined && parameters.morphTargets === true ) {\r\n\t\r\n\t\t\t\t// programs with morphTargets displace position out of attribute 0\r\n\t\r\n\t\t\t\tindex0AttributeName = 'position';\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar shadowMapTypeDefine = 'SHADOWMAP_TYPE_BASIC';\r\n\t\r\n\t\t\tif ( parameters.shadowMapType === THREE.PCFShadowMap ) {\r\n\t\r\n\t\t\t\tshadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF';\r\n\t\r\n\t\t\t} else if ( parameters.shadowMapType === THREE.PCFSoftShadowMap ) {\r\n\t\r\n\t\t\t\tshadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF_SOFT';\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar envMapTypeDefine = 'ENVMAP_TYPE_CUBE';\r\n\t\t\tvar envMapModeDefine = 'ENVMAP_MODE_REFLECTION';\r\n\t\t\tvar envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';\r\n\t\r\n\t\t\tif ( parameters.envMap ) {\r\n\t\r\n\t\t\t\tswitch ( material.envMap.mapping ) {\r\n\t\r\n\t\t\t\t\tcase THREE.CubeReflectionMapping:\r\n\t\t\t\t\tcase THREE.CubeRefractionMapping:\r\n\t\t\t\t\t\tenvMapTypeDefine = 'ENVMAP_TYPE_CUBE';\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\tcase THREE.EquirectangularReflectionMapping:\r\n\t\t\t\t\tcase THREE.EquirectangularRefractionMapping:\r\n\t\t\t\t\t\tenvMapTypeDefine = 'ENVMAP_TYPE_EQUIREC';\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\tcase THREE.SphericalReflectionMapping:\r\n\t\t\t\t\t\tenvMapTypeDefine = 'ENVMAP_TYPE_SPHERE';\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tswitch ( material.envMap.mapping ) {\r\n\t\r\n\t\t\t\t\tcase THREE.CubeRefractionMapping:\r\n\t\t\t\t\tcase THREE.EquirectangularRefractionMapping:\r\n\t\t\t\t\t\tenvMapModeDefine = 'ENVMAP_MODE_REFRACTION';\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tswitch ( material.combine ) {\r\n\t\r\n\t\t\t\t\tcase THREE.MultiplyOperation:\r\n\t\t\t\t\t\tenvMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\tcase THREE.MixOperation:\r\n\t\t\t\t\t\tenvMapBlendingDefine = 'ENVMAP_BLENDING_MIX';\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\tcase THREE.AddOperation:\r\n\t\t\t\t\t\tenvMapBlendingDefine = 'ENVMAP_BLENDING_ADD';\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar gammaFactorDefine = ( renderer.gammaFactor > 0 ) ? renderer.gammaFactor : 1.0;\r\n\t\r\n\t\t\t// console.log( 'building new program ' );\r\n\t\r\n\t\t\t//\r\n\t\r\n\t\t\tvar customDefines = generateDefines( defines );\r\n\t\r\n\t\t\t//\r\n\t\r\n\t\t\tvar program = _gl.createProgram();\r\n\t\r\n\t\t\tvar prefix_vertex, prefix_fragment;\r\n\t\r\n\t\t\tif ( material instanceof THREE.RawShaderMaterial ) {\r\n\t\r\n\t\t\t\tprefix_vertex = '';\r\n\t\t\t\tprefix_fragment = '';\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\tprefix_vertex = [\r\n\t\r\n\t\t\t\t\t'precision ' + parameters.precision + ' float;',\r\n\t\t\t\t\t'precision ' + parameters.precision + ' int;',\r\n\t\r\n\t\t\t\t\tcustomDefines,\r\n\t\r\n\t\t\t\t\tparameters.supportsVertexTextures ? '#define VERTEX_TEXTURES' : '',\r\n\t\r\n\t\t\t\t\t_this.gammaInput ? '#define GAMMA_INPUT' : '',\r\n\t\t\t\t\t_this.gammaOutput ? '#define GAMMA_OUTPUT' : '',\r\n\t\t\t\t\t'#define GAMMA_FACTOR ' + gammaFactorDefine,\r\n\t\r\n\t\t\t\t\t'#define MAX_DIR_LIGHTS ' + parameters.maxDirLights,\r\n\t\t\t\t\t'#define MAX_POINT_LIGHTS ' + parameters.maxPointLights,\r\n\t\t\t\t\t'#define MAX_SPOT_LIGHTS ' + parameters.maxSpotLights,\r\n\t\t\t\t\t'#define MAX_HEMI_LIGHTS ' + parameters.maxHemiLights,\r\n\t\r\n\t\t\t\t\t'#define MAX_SHADOWS ' + parameters.maxShadows,\r\n\t\r\n\t\t\t\t\t'#define MAX_BONES ' + parameters.maxBones,\r\n\t\r\n\t\t\t\t\tparameters.map ? '#define USE_MAP' : '',\r\n\t\t\t\t\tparameters.envMap ? '#define USE_ENVMAP' : '',\r\n\t\t\t\t\tparameters.envMap ? '#define ' + envMapModeDefine : '',\r\n\t\t\t\t\tparameters.lightMap ? '#define USE_LIGHTMAP' : '',\r\n\t\t\t\t\tparameters.bumpMap ? '#define USE_BUMPMAP' : '',\r\n\t\t\t\t\tparameters.normalMap ? '#define USE_NORMALMAP' : '',\r\n\t\t\t\t\tparameters.specularMap ? '#define USE_SPECULARMAP' : '',\r\n\t\t\t\t\tparameters.alphaMap ? '#define USE_ALPHAMAP' : '',\r\n\t\t\t\t\tparameters.vertexColors ? '#define USE_COLOR' : '',\r\n\t\r\n\t\t\t\t\tparameters.flatShading ? '#define FLAT_SHADED': '',\r\n\t\r\n\t\t\t\t\tparameters.skinning ? '#define USE_SKINNING' : '',\r\n\t\t\t\t\tparameters.useVertexTexture ? '#define BONE_TEXTURE' : '',\r\n\t\r\n\t\t\t\t\tparameters.morphTargets ? '#define USE_MORPHTARGETS' : '',\r\n\t\t\t\t\tparameters.morphNormals ? '#define USE_MORPHNORMALS' : '',\r\n\t\t\t\t\tparameters.wrapAround ? '#define WRAP_AROUND' : '',\r\n\t\t\t\t\tparameters.doubleSided ? '#define DOUBLE_SIDED' : '',\r\n\t\t\t\t\tparameters.flipSided ? '#define FLIP_SIDED' : '',\r\n\t\r\n\t\t\t\t\tparameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',\r\n\t\t\t\t\tparameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',\r\n\t\t\t\t\tparameters.shadowMapDebug ? '#define SHADOWMAP_DEBUG' : '',\r\n\t\t\t\t\tparameters.shadowMapCascade ? '#define SHADOWMAP_CASCADE' : '',\r\n\t\r\n\t\t\t\t\tparameters.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '',\r\n\t\r\n\t\t\t\t\tparameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',\r\n\t\t\t\t\t//_this._glExtensionFragDepth ? '#define USE_LOGDEPTHBUF_EXT' : '',\r\n\t\r\n\t\r\n\t\t\t\t\t'uniform mat4 modelMatrix;',\r\n\t\t\t\t\t'uniform mat4 modelViewMatrix;',\r\n\t\t\t\t\t'uniform mat4 projectionMatrix;',\r\n\t\t\t\t\t'uniform mat4 viewMatrix;',\r\n\t\t\t\t\t'uniform mat3 normalMatrix;',\r\n\t\t\t\t\t'uniform vec3 cameraPosition;',\r\n\t\r\n\t\t\t\t\t'attribute vec3 position;',\r\n\t\t\t\t\t'attribute vec3 normal;',\r\n\t\t\t\t\t'attribute vec2 uv;',\r\n\t\t\t\t\t'attribute vec2 uv2;',\r\n\t\r\n\t\t\t\t\t'#ifdef USE_COLOR',\r\n\t\r\n\t\t\t\t\t'\tattribute vec3 color;',\r\n\t\r\n\t\t\t\t\t'#endif',\r\n\t\r\n\t\t\t\t\t'#ifdef USE_MORPHTARGETS',\r\n\t\r\n\t\t\t\t\t'\tattribute vec3 morphTarget0;',\r\n\t\t\t\t\t'\tattribute vec3 morphTarget1;',\r\n\t\t\t\t\t'\tattribute vec3 morphTarget2;',\r\n\t\t\t\t\t'\tattribute vec3 morphTarget3;',\r\n\t\r\n\t\t\t\t\t'\t#ifdef USE_MORPHNORMALS',\r\n\t\r\n\t\t\t\t\t'\t\tattribute vec3 morphNormal0;',\r\n\t\t\t\t\t'\t\tattribute vec3 morphNormal1;',\r\n\t\t\t\t\t'\t\tattribute vec3 morphNormal2;',\r\n\t\t\t\t\t'\t\tattribute vec3 morphNormal3;',\r\n\t\r\n\t\t\t\t\t'\t#else',\r\n\t\r\n\t\t\t\t\t'\t\tattribute vec3 morphTarget4;',\r\n\t\t\t\t\t'\t\tattribute vec3 morphTarget5;',\r\n\t\t\t\t\t'\t\tattribute vec3 morphTarget6;',\r\n\t\t\t\t\t'\t\tattribute vec3 morphTarget7;',\r\n\t\r\n\t\t\t\t\t'\t#endif',\r\n\t\r\n\t\t\t\t\t'#endif',\r\n\t\r\n\t\t\t\t\t'#ifdef USE_SKINNING',\r\n\t\r\n\t\t\t\t\t'\tattribute vec4 skinIndex;',\r\n\t\t\t\t\t'\tattribute vec4 skinWeight;',\r\n\t\r\n\t\t\t\t\t'#endif',\r\n\t\r\n\t\t\t\t\t''\r\n\t\r\n\t\t\t\t].join( '\\n' );\r\n\t\r\n\t\t\t\tprefix_fragment = [\r\n\t\r\n\t\t\t\t\t'precision ' + parameters.precision + ' float;',\r\n\t\t\t\t\t'precision ' + parameters.precision + ' int;',\r\n\t\r\n\t\t\t\t\t( parameters.bumpMap || parameters.normalMap || parameters.flatShading ) ? '#extension GL_OES_standard_derivatives : enable' : '',\r\n\t\r\n\t\t\t\t\tcustomDefines,\r\n\t\r\n\t\t\t\t\t'#define MAX_DIR_LIGHTS ' + parameters.maxDirLights,\r\n\t\t\t\t\t'#define MAX_POINT_LIGHTS ' + parameters.maxPointLights,\r\n\t\t\t\t\t'#define MAX_SPOT_LIGHTS ' + parameters.maxSpotLights,\r\n\t\t\t\t\t'#define MAX_HEMI_LIGHTS ' + parameters.maxHemiLights,\r\n\t\r\n\t\t\t\t\t'#define MAX_SHADOWS ' + parameters.maxShadows,\r\n\t\r\n\t\t\t\t\tparameters.alphaTest ? '#define ALPHATEST ' + parameters.alphaTest : '',\r\n\t\r\n\t\t\t\t\t_this.gammaInput ? '#define GAMMA_INPUT' : '',\r\n\t\t\t\t\t_this.gammaOutput ? '#define GAMMA_OUTPUT' : '',\r\n\t\t\t\t\t'#define GAMMA_FACTOR ' + gammaFactorDefine,\r\n\t\r\n\t\t\t\t\t( parameters.useFog && parameters.fog ) ? '#define USE_FOG' : '',\r\n\t\t\t\t\t( parameters.useFog && parameters.fogExp ) ? '#define FOG_EXP2' : '',\r\n\t\r\n\t\t\t\t\tparameters.map ? '#define USE_MAP' : '',\r\n\t\t\t\t\tparameters.envMap ? '#define USE_ENVMAP' : '',\r\n\t\t\t\t\tparameters.envMap ? '#define ' + envMapTypeDefine : '',\r\n\t\t\t\t\tparameters.envMap ? '#define ' + envMapModeDefine : '',\r\n\t\t\t\t\tparameters.envMap ? '#define ' + envMapBlendingDefine : '',\r\n\t\t\t\t\tparameters.lightMap ? '#define USE_LIGHTMAP' : '',\r\n\t\t\t\t\tparameters.bumpMap ? '#define USE_BUMPMAP' : '',\r\n\t\t\t\t\tparameters.normalMap ? '#define USE_NORMALMAP' : '',\r\n\t\t\t\t\tparameters.specularMap ? '#define USE_SPECULARMAP' : '',\r\n\t\t\t\t\tparameters.alphaMap ? '#define USE_ALPHAMAP' : '',\r\n\t\t\t\t\tparameters.vertexColors ? '#define USE_COLOR' : '',\r\n\t\r\n\t\t\t\t\tparameters.flatShading ? '#define FLAT_SHADED': '',\r\n\t\r\n\t\t\t\t\tparameters.metal ? '#define METAL' : '',\r\n\t\t\t\t\tparameters.wrapAround ? '#define WRAP_AROUND' : '',\r\n\t\t\t\t\tparameters.doubleSided ? '#define DOUBLE_SIDED' : '',\r\n\t\t\t\t\tparameters.flipSided ? '#define FLIP_SIDED' : '',\r\n\t\r\n\t\t\t\t\tparameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',\r\n\t\t\t\t\tparameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',\r\n\t\t\t\t\tparameters.shadowMapDebug ? '#define SHADOWMAP_DEBUG' : '',\r\n\t\t\t\t\tparameters.shadowMapCascade ? '#define SHADOWMAP_CASCADE' : '',\r\n\t\r\n\t\t\t\t\tparameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',\r\n\t\t\t\t\t//_this._glExtensionFragDepth ? '#define USE_LOGDEPTHBUF_EXT' : '',\r\n\t\r\n\t\t\t\t\t'uniform mat4 viewMatrix;',\r\n\t\t\t\t\t'uniform vec3 cameraPosition;',\r\n\t\t\t\t\t''\r\n\t\r\n\t\t\t\t].join( '\\n' );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar glVertexShader = new THREE.WebGLShader( _gl, _gl.VERTEX_SHADER, prefix_vertex + vertexShader );\r\n\t\t\tvar glFragmentShader = new THREE.WebGLShader( _gl, _gl.FRAGMENT_SHADER, prefix_fragment + fragmentShader );\r\n\t\r\n\t\t\t_gl.attachShader( program, glVertexShader );\r\n\t\t\t_gl.attachShader( program, glFragmentShader );\r\n\t\r\n\t\t\tif ( index0AttributeName !== undefined ) {\r\n\t\r\n\t\t\t\t// Force a particular attribute to index 0.\r\n\t\t\t\t// because potentially expensive emulation is done by browser if attribute 0 is disabled.\r\n\t\t\t\t// And, color, for example is often automatically bound to index 0 so disabling it\r\n\t\r\n\t\t\t\t_gl.bindAttribLocation( program, 0, index0AttributeName );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t_gl.linkProgram( program );\r\n\t\r\n\t\t\tvar programLogInfo = _gl.getProgramInfoLog( program );\r\n\t\r\n\t\t\tif ( _gl.getProgramParameter( program, _gl.LINK_STATUS ) === false ) {\r\n\t\r\n\t\t\t\tTHREE.error( 'THREE.WebGLProgram: shader error: ' + _gl.getError(), 'gl.VALIDATE_STATUS', _gl.getProgramParameter( program, _gl.VALIDATE_STATUS ), 'gl.getPRogramInfoLog', programLogInfo );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( programLogInfo !== '' ) {\r\n\t\r\n\t\t\t\tTHREE.warn( 'THREE.WebGLProgram: gl.getProgramInfoLog()' + programLogInfo );\r\n\t\t\t\t// THREE.warn( _gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( glVertexShader ) );\r\n\t\t\t\t// THREE.warn( _gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( glFragmentShader ) );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// clean up\r\n\t\r\n\t\t\t_gl.deleteShader( glVertexShader );\r\n\t\t\t_gl.deleteShader( glFragmentShader );\r\n\t\r\n\t\t\t// cache uniform locations\r\n\t\r\n\t\t\tvar identifiers = [\r\n\t\r\n\t\t\t\t'viewMatrix',\r\n\t\t\t\t'modelViewMatrix',\r\n\t\t\t\t'projectionMatrix',\r\n\t\t\t\t'normalMatrix',\r\n\t\t\t\t'modelMatrix',\r\n\t\t\t\t'cameraPosition',\r\n\t\t\t\t'morphTargetInfluences',\r\n\t\t\t\t'bindMatrix',\r\n\t\t\t\t'bindMatrixInverse'\r\n\t\r\n\t\t\t];\r\n\t\r\n\t\t\tif ( parameters.useVertexTexture ) {\r\n\t\r\n\t\t\t\tidentifiers.push( 'boneTexture' );\r\n\t\t\t\tidentifiers.push( 'boneTextureWidth' );\r\n\t\t\t\tidentifiers.push( 'boneTextureHeight' );\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\tidentifiers.push( 'boneGlobalMatrices' );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( parameters.logarithmicDepthBuffer ) {\r\n\t\r\n\t\t\t\tidentifiers.push('logDepthBufFC');\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\r\n\t\t\tfor ( var u in uniforms ) {\r\n\t\r\n\t\t\t\tidentifiers.push( u );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tthis.uniforms = cacheUniformLocations( _gl, program, identifiers );\r\n\t\r\n\t\t\t// cache attributes locations\r\n\t\r\n\t\t\tidentifiers = [\r\n\t\r\n\t\t\t\t'position',\r\n\t\t\t\t'normal',\r\n\t\t\t\t'uv',\r\n\t\t\t\t'uv2',\r\n\t\t\t\t'tangent',\r\n\t\t\t\t'color',\r\n\t\t\t\t'skinIndex',\r\n\t\t\t\t'skinWeight',\r\n\t\t\t\t'lineDistance'\r\n\t\r\n\t\t\t];\r\n\t\r\n\t\t\tfor ( var i = 0; i < parameters.maxMorphTargets; i ++ ) {\r\n\t\r\n\t\t\t\tidentifiers.push( 'morphTarget' + i );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tfor ( var i = 0; i < parameters.maxMorphNormals; i ++ ) {\r\n\t\r\n\t\t\t\tidentifiers.push( 'morphNormal' + i );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tfor ( var a in attributes ) {\r\n\t\r\n\t\t\t\tidentifiers.push( a );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tthis.attributes = cacheAttributeLocations( _gl, program, identifiers );\r\n\t\t\tthis.attributesKeys = Object.keys( this.attributes );\r\n\t\r\n\t\t\t//\r\n\t\r\n\t\t\tthis.id = programIdCount ++;\r\n\t\t\tthis.code = code;\r\n\t\t\tthis.usedTimes = 1;\r\n\t\t\tthis.program = program;\r\n\t\t\tthis.vertexShader = glVertexShader;\r\n\t\t\tthis.fragmentShader = glFragmentShader;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t};\r\n\t\r\n\t} )();\r\n\t\r\n\t// File:src/renderers/webgl/WebGLShader.js\r\n\t\r\n\tTHREE.WebGLShader = ( function () {\r\n\t\r\n\t\tvar addLineNumbers = function ( string ) {\r\n\t\r\n\t\t\tvar lines = string.split( '\\n' );\r\n\t\r\n\t\t\tfor ( var i = 0; i < lines.length; i ++ ) {\r\n\t\r\n\t\t\t\tlines[ i ] = ( i + 1 ) + ': ' + lines[ i ];\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn lines.join( '\\n' );\r\n\t\r\n\t\t};\r\n\t\r\n\t\treturn function ( gl, type, string ) {\r\n\t\r\n\t\t\tvar shader = gl.createShader( type ); \r\n\t\r\n\t\t\tgl.shaderSource( shader, string );\r\n\t\t\tgl.compileShader( shader );\r\n\t\r\n\t\t\tif ( gl.getShaderParameter( shader, gl.COMPILE_STATUS ) === false ) {\r\n\t\r\n\t\t\t\tTHREE.error( 'THREE.WebGLShader: Shader couldn\\'t compile.' );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( gl.getShaderInfoLog( shader ) !== '' ) {\r\n\t\r\n\t\t\t\tTHREE.warn( 'THREE.WebGLShader: gl.getShaderInfoLog()', gl.getShaderInfoLog( shader ), addLineNumbers( string ) );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// --enable-privileged-webgl-extension\r\n\t\t\t// console.log( type, gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( shader ) );\r\n\t\r\n\t\t\treturn shader;\r\n\t\r\n\t\t};\r\n\t\r\n\t} )();\r\n\t\r\n\t// File:src/renderers/webgl/WebGLState.js\r\n\t\r\n\t/**\r\n\t* @author mrdoob / http://mrdoob.com/\r\n\t*/\r\n\t\r\n\tTHREE.WebGLState = function ( gl, paramThreeToGL ) {\r\n\t\r\n\t\tvar newAttributes = new Uint8Array( 16 );\r\n\t\tvar enabledAttributes = new Uint8Array( 16 );\r\n\t\r\n\t\tvar currentBlending = null;\r\n\t\tvar currentBlendEquation = null;\r\n\t\tvar currentBlendSrc = null;\r\n\t\tvar currentBlendDst = null;\r\n\t\tvar currentBlendEquationAlpha = null;\r\n\t\tvar currentBlendSrcAlpha = null;\r\n\t\tvar currentBlendDstAlpha = null;\r\n\t\r\n\t\tvar currentDepthTest = null;\r\n\t\tvar currentDepthWrite = null;\r\n\t\r\n\t\tvar currentColorWrite = null;\r\n\t\r\n\t\tvar currentDoubleSided = null;\r\n\t\tvar currentFlipSided = null;\r\n\t\r\n\t\tvar currentLineWidth = null;\r\n\t\r\n\t\tvar currentPolygonOffset = null;\r\n\t\tvar currentPolygonOffsetFactor = null;\r\n\t\tvar currentPolygonOffsetUnits = null;\r\n\t\r\n\t\tthis.initAttributes = function () {\r\n\t\r\n\t\t\tfor ( var i = 0, l = newAttributes.length; i < l; i ++ ) {\r\n\t\r\n\t\t\t\tnewAttributes[ i ] = 0;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.enableAttribute = function ( attribute ) {\r\n\t\r\n\t\t\tnewAttributes[ attribute ] = 1;\r\n\t\r\n\t\t\tif ( enabledAttributes[ attribute ] === 0 ) {\r\n\t\r\n\t\t\t\tgl.enableVertexAttribArray( attribute );\r\n\t\t\t\tenabledAttributes[ attribute ] = 1;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.disableUnusedAttributes = function () {\r\n\t\r\n\t\t\tfor ( var i = 0, l = enabledAttributes.length; i < l; i ++ ) {\r\n\t\r\n\t\t\t\tif ( enabledAttributes[ i ] !== newAttributes[ i ] ) {\r\n\t\r\n\t\t\t\t\tgl.disableVertexAttribArray( i );\r\n\t\t\t\t\tenabledAttributes[ i ] = 0;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.setBlending = function ( blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha ) {\r\n\t\r\n\t\t\tif ( blending !== currentBlending ) {\r\n\t\r\n\t\t\t\tif ( blending === THREE.NoBlending ) {\r\n\t\r\n\t\t\t\t\tgl.disable( gl.BLEND );\r\n\t\r\n\t\t\t\t} else if ( blending === THREE.AdditiveBlending ) {\r\n\t\r\n\t\t\t\t\tgl.enable( gl.BLEND );\r\n\t\t\t\t\tgl.blendEquation( gl.FUNC_ADD );\r\n\t\t\t\t\tgl.blendFunc( gl.SRC_ALPHA, gl.ONE );\r\n\t\r\n\t\t\t\t} else if ( blending === THREE.SubtractiveBlending ) {\r\n\t\r\n\t\t\t\t\t// TODO: Find blendFuncSeparate() combination\r\n\t\t\t\t\tgl.enable( gl.BLEND );\r\n\t\t\t\t\tgl.blendEquation( gl.FUNC_ADD );\r\n\t\t\t\t\tgl.blendFunc( gl.ZERO, gl.ONE_MINUS_SRC_COLOR );\r\n\t\r\n\t\t\t\t} else if ( blending === THREE.MultiplyBlending ) {\r\n\t\r\n\t\t\t\t\t// TODO: Find blendFuncSeparate() combination\r\n\t\t\t\t\tgl.enable( gl.BLEND );\r\n\t\t\t\t\tgl.blendEquation( gl.FUNC_ADD );\r\n\t\t\t\t\tgl.blendFunc( gl.ZERO, gl.SRC_COLOR );\r\n\t\r\n\t\t\t\t} else if ( blending === THREE.CustomBlending ) {\r\n\t\r\n\t\t\t\t\tgl.enable( gl.BLEND );\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tgl.enable( gl.BLEND );\r\n\t\t\t\t\tgl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );\r\n\t\t\t\t\tgl.blendFuncSeparate( gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tcurrentBlending = blending;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( blending === THREE.CustomBlending ) {\r\n\t\r\n\t\t\t\tblendEquationAlpha = blendEquationAlpha || blendEquation;\r\n\t\t\t\tblendSrcAlpha = blendSrcAlpha || blendSrc;\r\n\t\t\t\tblendDstAlpha = blendDstAlpha || blendDst;\r\n\t\r\n\t\t\t\tif ( blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha ) {\r\n\t\r\n\t\t\t\t\tgl.blendEquationSeparate( paramThreeToGL( blendEquation ), paramThreeToGL( blendEquationAlpha ) );\r\n\t\r\n\t\t\t\t\tcurrentBlendEquation = blendEquation;\r\n\t\t\t\t\tcurrentBlendEquationAlpha = blendEquationAlpha;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha ) {\r\n\t\r\n\t\t\t\t\tgl.blendFuncSeparate( paramThreeToGL( blendSrc ), paramThreeToGL( blendDst ), paramThreeToGL( blendSrcAlpha ), paramThreeToGL( blendDstAlpha ) );\r\n\t\r\n\t\t\t\t\tcurrentBlendSrc = blendSrc;\r\n\t\t\t\t\tcurrentBlendDst = blendDst;\r\n\t\t\t\t\tcurrentBlendSrcAlpha = blendSrcAlpha;\r\n\t\t\t\t\tcurrentBlendDstAlpha = blendDstAlpha;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\tcurrentBlendEquation = null;\r\n\t\t\t\tcurrentBlendSrc = null;\r\n\t\t\t\tcurrentBlendDst = null;\r\n\t\t\t\tcurrentBlendEquationAlpha = null;\r\n\t\t\t\tcurrentBlendSrcAlpha = null;\r\n\t\t\t\tcurrentBlendDstAlpha = null;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.setDepthTest = function ( depthTest ) {\r\n\t\r\n\t\t\tif ( currentDepthTest !== depthTest ) {\r\n\t\r\n\t\t\t\tif ( depthTest ) {\r\n\t\r\n\t\t\t\t\tgl.enable( gl.DEPTH_TEST );\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tgl.disable( gl.DEPTH_TEST );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tcurrentDepthTest = depthTest;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.setDepthWrite = function ( depthWrite ) {\r\n\t\r\n\t\t\tif ( currentDepthWrite !== depthWrite ) {\r\n\t\r\n\t\t\t\tgl.depthMask( depthWrite );\r\n\t\t\t\tcurrentDepthWrite = depthWrite;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.setColorWrite = function ( colorWrite ) {\r\n\t\r\n\t\t\tif ( currentColorWrite !== colorWrite ) {\r\n\t\r\n\t\t\t\tgl.colorMask( colorWrite, colorWrite, colorWrite, colorWrite );\r\n\t\t\t\tcurrentColorWrite = colorWrite;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.setDoubleSided = function ( doubleSided ) {\r\n\t\r\n\t\t\tif ( currentDoubleSided !== doubleSided ) {\r\n\t\r\n\t\t\t\tif ( doubleSided ) {\r\n\t\r\n\t\t\t\t\tgl.disable( gl.CULL_FACE );\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tgl.enable( gl.CULL_FACE );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tcurrentDoubleSided = doubleSided;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.setFlipSided = function ( flipSided ) {\r\n\t\r\n\t\t\tif ( currentFlipSided !== flipSided ) {\r\n\t\r\n\t\t\t\tif ( flipSided ) {\r\n\t\r\n\t\t\t\t\tgl.frontFace( gl.CW );\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tgl.frontFace( gl.CCW );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tcurrentFlipSided = flipSided;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.setLineWidth = function ( width ) {\r\n\t\r\n\t\t\tif ( width !== currentLineWidth ) {\r\n\t\r\n\t\t\t\tgl.lineWidth( width );\r\n\t\r\n\t\t\t\tcurrentLineWidth = width;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.setPolygonOffset = function ( polygonoffset, factor, units ) {\r\n\t\r\n\t\t\tif ( currentPolygonOffset !== polygonoffset ) {\r\n\t\r\n\t\t\t\tif ( polygonoffset ) {\r\n\t\r\n\t\t\t\t\tgl.enable( gl.POLYGON_OFFSET_FILL );\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tgl.disable( gl.POLYGON_OFFSET_FILL );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tcurrentPolygonOffset = polygonoffset;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( polygonoffset && ( currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units ) ) {\r\n\t\r\n\t\t\t\tgl.polygonOffset( factor, units );\r\n\t\r\n\t\t\t\tcurrentPolygonOffsetFactor = factor;\r\n\t\t\t\tcurrentPolygonOffsetUnits = units;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.reset = function () {\r\n\t\r\n\t\t\tfor ( var i = 0; i < enabledAttributes.length; i ++ ) {\r\n\t\r\n\t\t\t\tenabledAttributes[ i ] = 0;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tcurrentBlending = null;\r\n\t\t\tcurrentDepthTest = null;\r\n\t\t\tcurrentDepthWrite = null;\r\n\t\t\tcurrentColorWrite = null;\r\n\t\t\tcurrentDoubleSided = null;\r\n\t\t\tcurrentFlipSided = null;\r\n\t\r\n\t\t};\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/renderers/webgl/plugins/LensFlarePlugin.js\r\n\t\r\n\t/**\r\n\t * @author mikael emtinger / http://gomo.se/\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t */\r\n\t\r\n\tTHREE.LensFlarePlugin = function ( renderer, flares ) {\r\n\t\r\n\t\tvar gl = renderer.context;\r\n\t\r\n\t\tvar vertexBuffer, elementBuffer;\r\n\t\tvar program, attributes, uniforms;\r\n\t\tvar hasVertexTexture;\r\n\t\r\n\t\tvar tempTexture, occlusionTexture;\r\n\t\r\n\t\tvar init = function () {\r\n\t\r\n\t\t\tvar vertices = new Float32Array( [\r\n\t\t\t\t-1, -1,  0, 0,\r\n\t\t\t\t 1, -1,  1, 0,\r\n\t\t\t\t 1,  1,  1, 1,\r\n\t\t\t\t-1,  1,  0, 1\r\n\t\t\t] );\r\n\t\r\n\t\t\tvar faces = new Uint16Array( [\r\n\t\t\t\t0, 1, 2,\r\n\t\t\t\t0, 2, 3\r\n\t\t\t] );\r\n\t\r\n\t\t\t// buffers\r\n\t\r\n\t\t\tvertexBuffer     = gl.createBuffer();\r\n\t\t\telementBuffer    = gl.createBuffer();\r\n\t\r\n\t\t\tgl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );\r\n\t\t\tgl.bufferData( gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW );\r\n\t\r\n\t\t\tgl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );\r\n\t\t\tgl.bufferData( gl.ELEMENT_ARRAY_BUFFER, faces, gl.STATIC_DRAW );\r\n\t\r\n\t\t\t// textures\r\n\t\r\n\t\t\ttempTexture      = gl.createTexture();\r\n\t\t\tocclusionTexture = gl.createTexture();\r\n\t\r\n\t\t\tgl.bindTexture( gl.TEXTURE_2D, tempTexture );\r\n\t\t\tgl.texImage2D( gl.TEXTURE_2D, 0, gl.RGB, 16, 16, 0, gl.RGB, gl.UNSIGNED_BYTE, null );\r\n\t\t\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE );\r\n\t\t\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE );\r\n\t\t\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST );\r\n\t\t\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST );\r\n\t\r\n\t\t\tgl.bindTexture( gl.TEXTURE_2D, occlusionTexture );\r\n\t\t\tgl.texImage2D( gl.TEXTURE_2D, 0, gl.RGBA, 16, 16, 0, gl.RGBA, gl.UNSIGNED_BYTE, null );\r\n\t\t\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE );\r\n\t\t\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE );\r\n\t\t\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST );\r\n\t\t\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST );\r\n\t\r\n\t\t\thasVertexTexture = gl.getParameter( gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS ) > 0;\r\n\t\r\n\t\t\tvar shader;\r\n\t\r\n\t\t\tif ( hasVertexTexture ) {\r\n\t\r\n\t\t\t\tshader = {\r\n\t\r\n\t\t\t\t\tvertexShader: [\r\n\t\r\n\t\t\t\t\t\t\"uniform lowp int renderType;\",\r\n\t\r\n\t\t\t\t\t\t\"uniform vec3 screenPosition;\",\r\n\t\t\t\t\t\t\"uniform vec2 scale;\",\r\n\t\t\t\t\t\t\"uniform float rotation;\",\r\n\t\r\n\t\t\t\t\t\t\"uniform sampler2D occlusionMap;\",\r\n\t\r\n\t\t\t\t\t\t\"attribute vec2 position;\",\r\n\t\t\t\t\t\t\"attribute vec2 uv;\",\r\n\t\r\n\t\t\t\t\t\t\"varying vec2 vUV;\",\r\n\t\t\t\t\t\t\"varying float vVisibility;\",\r\n\t\r\n\t\t\t\t\t\t\"void main() {\",\r\n\t\r\n\t\t\t\t\t\t\t\"vUV = uv;\",\r\n\t\r\n\t\t\t\t\t\t\t\"vec2 pos = position;\",\r\n\t\r\n\t\t\t\t\t\t\t\"if( renderType == 2 ) {\",\r\n\t\r\n\t\t\t\t\t\t\t\t\"vec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );\",\r\n\t\t\t\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );\",\r\n\t\t\t\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );\",\r\n\t\t\t\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );\",\r\n\t\t\t\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );\",\r\n\t\t\t\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );\",\r\n\t\t\t\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );\",\r\n\t\t\t\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );\",\r\n\t\t\t\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );\",\r\n\t\r\n\t\t\t\t\t\t\t\t\"vVisibility =        visibility.r / 9.0;\",\r\n\t\t\t\t\t\t\t\t\"vVisibility *= 1.0 - visibility.g / 9.0;\",\r\n\t\t\t\t\t\t\t\t\"vVisibility *=       visibility.b / 9.0;\",\r\n\t\t\t\t\t\t\t\t\"vVisibility *= 1.0 - visibility.a / 9.0;\",\r\n\t\r\n\t\t\t\t\t\t\t\t\"pos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;\",\r\n\t\t\t\t\t\t\t\t\"pos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;\",\r\n\t\r\n\t\t\t\t\t\t\t\"}\",\r\n\t\r\n\t\t\t\t\t\t\t\"gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );\",\r\n\t\r\n\t\t\t\t\t\t\"}\"\r\n\t\r\n\t\t\t\t\t].join( \"\\n\" ),\r\n\t\r\n\t\t\t\t\tfragmentShader: [\r\n\t\r\n\t\t\t\t\t\t\"uniform lowp int renderType;\",\r\n\t\r\n\t\t\t\t\t\t\"uniform sampler2D map;\",\r\n\t\t\t\t\t\t\"uniform float opacity;\",\r\n\t\t\t\t\t\t\"uniform vec3 color;\",\r\n\t\r\n\t\t\t\t\t\t\"varying vec2 vUV;\",\r\n\t\t\t\t\t\t\"varying float vVisibility;\",\r\n\t\r\n\t\t\t\t\t\t\"void main() {\",\r\n\t\r\n\t\t\t\t\t\t\t// pink square\r\n\t\r\n\t\t\t\t\t\t\t\"if( renderType == 0 ) {\",\r\n\t\r\n\t\t\t\t\t\t\t\t\"gl_FragColor = vec4( 1.0, 0.0, 1.0, 0.0 );\",\r\n\t\r\n\t\t\t\t\t\t\t// restore\r\n\t\r\n\t\t\t\t\t\t\t\"} else if( renderType == 1 ) {\",\r\n\t\r\n\t\t\t\t\t\t\t\t\"gl_FragColor = texture2D( map, vUV );\",\r\n\t\r\n\t\t\t\t\t\t\t// flare\r\n\t\r\n\t\t\t\t\t\t\t\"} else {\",\r\n\t\r\n\t\t\t\t\t\t\t\t\"vec4 texture = texture2D( map, vUV );\",\r\n\t\t\t\t\t\t\t\t\"texture.a *= opacity * vVisibility;\",\r\n\t\t\t\t\t\t\t\t\"gl_FragColor = texture;\",\r\n\t\t\t\t\t\t\t\t\"gl_FragColor.rgb *= color;\",\r\n\t\r\n\t\t\t\t\t\t\t\"}\",\r\n\t\r\n\t\t\t\t\t\t\"}\"\r\n\t\r\n\t\t\t\t\t].join( \"\\n\" )\r\n\t\r\n\t\t\t\t};\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\tshader = {\r\n\t\r\n\t\t\t\t\tvertexShader: [\r\n\t\r\n\t\t\t\t\t\t\"uniform lowp int renderType;\",\r\n\t\r\n\t\t\t\t\t\t\"uniform vec3 screenPosition;\",\r\n\t\t\t\t\t\t\"uniform vec2 scale;\",\r\n\t\t\t\t\t\t\"uniform float rotation;\",\r\n\t\r\n\t\t\t\t\t\t\"attribute vec2 position;\",\r\n\t\t\t\t\t\t\"attribute vec2 uv;\",\r\n\t\r\n\t\t\t\t\t\t\"varying vec2 vUV;\",\r\n\t\r\n\t\t\t\t\t\t\"void main() {\",\r\n\t\r\n\t\t\t\t\t\t\t\"vUV = uv;\",\r\n\t\r\n\t\t\t\t\t\t\t\"vec2 pos = position;\",\r\n\t\r\n\t\t\t\t\t\t\t\"if( renderType == 2 ) {\",\r\n\t\r\n\t\t\t\t\t\t\t\t\"pos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;\",\r\n\t\t\t\t\t\t\t\t\"pos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;\",\r\n\t\r\n\t\t\t\t\t\t\t\"}\",\r\n\t\r\n\t\t\t\t\t\t\t\"gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );\",\r\n\t\r\n\t\t\t\t\t\t\"}\"\r\n\t\r\n\t\t\t\t\t].join( \"\\n\" ),\r\n\t\r\n\t\t\t\t\tfragmentShader: [\r\n\t\r\n\t\t\t\t\t\t\"precision mediump float;\",\r\n\t\r\n\t\t\t\t\t\t\"uniform lowp int renderType;\",\r\n\t\r\n\t\t\t\t\t\t\"uniform sampler2D map;\",\r\n\t\t\t\t\t\t\"uniform sampler2D occlusionMap;\",\r\n\t\t\t\t\t\t\"uniform float opacity;\",\r\n\t\t\t\t\t\t\"uniform vec3 color;\",\r\n\t\r\n\t\t\t\t\t\t\"varying vec2 vUV;\",\r\n\t\r\n\t\t\t\t\t\t\"void main() {\",\r\n\t\r\n\t\t\t\t\t\t\t// pink square\r\n\t\r\n\t\t\t\t\t\t\t\"if( renderType == 0 ) {\",\r\n\t\r\n\t\t\t\t\t\t\t\t\"gl_FragColor = vec4( texture2D( map, vUV ).rgb, 0.0 );\",\r\n\t\r\n\t\t\t\t\t\t\t// restore\r\n\t\r\n\t\t\t\t\t\t\t\"} else if( renderType == 1 ) {\",\r\n\t\r\n\t\t\t\t\t\t\t\t\"gl_FragColor = texture2D( map, vUV );\",\r\n\t\r\n\t\t\t\t\t\t\t// flare\r\n\t\r\n\t\t\t\t\t\t\t\"} else {\",\r\n\t\r\n\t\t\t\t\t\t\t\t\"float visibility = texture2D( occlusionMap, vec2( 0.5, 0.1 ) ).a;\",\r\n\t\t\t\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) ).a;\",\r\n\t\t\t\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) ).a;\",\r\n\t\t\t\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) ).a;\",\r\n\t\t\t\t\t\t\t\t\"visibility = ( 1.0 - visibility / 4.0 );\",\r\n\t\r\n\t\t\t\t\t\t\t\t\"vec4 texture = texture2D( map, vUV );\",\r\n\t\t\t\t\t\t\t\t\"texture.a *= opacity * visibility;\",\r\n\t\t\t\t\t\t\t\t\"gl_FragColor = texture;\",\r\n\t\t\t\t\t\t\t\t\"gl_FragColor.rgb *= color;\",\r\n\t\r\n\t\t\t\t\t\t\t\"}\",\r\n\t\r\n\t\t\t\t\t\t\"}\"\r\n\t\r\n\t\t\t\t\t].join( \"\\n\" )\r\n\t\r\n\t\t\t\t};\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tprogram = createProgram( shader );\r\n\t\r\n\t\t\tattributes = {\r\n\t\t\t\tvertex: gl.getAttribLocation ( program, \"position\" ),\r\n\t\t\t\tuv:     gl.getAttribLocation ( program, \"uv\" )\r\n\t\t\t}\r\n\t\r\n\t\t\tuniforms = {\r\n\t\t\t\trenderType:     gl.getUniformLocation( program, \"renderType\" ),\r\n\t\t\t\tmap:            gl.getUniformLocation( program, \"map\" ),\r\n\t\t\t\tocclusionMap:   gl.getUniformLocation( program, \"occlusionMap\" ),\r\n\t\t\t\topacity:        gl.getUniformLocation( program, \"opacity\" ),\r\n\t\t\t\tcolor:          gl.getUniformLocation( program, \"color\" ),\r\n\t\t\t\tscale:          gl.getUniformLocation( program, \"scale\" ),\r\n\t\t\t\trotation:       gl.getUniformLocation( program, \"rotation\" ),\r\n\t\t\t\tscreenPosition: gl.getUniformLocation( program, \"screenPosition\" )\r\n\t\t\t};\r\n\t\r\n\t\t};\r\n\t\r\n\t\t/*\r\n\t\t * Render lens flares\r\n\t\t * Method: renders 16x16 0xff00ff-colored points scattered over the light source area,\r\n\t\t *         reads these back and calculates occlusion.\r\n\t\t */\r\n\t\r\n\t\tthis.render = function ( scene, camera, viewportWidth, viewportHeight ) {\r\n\t\r\n\t\t\tif ( flares.length === 0 ) return;\r\n\t\r\n\t\t\tvar tempPosition = new THREE.Vector3();\r\n\t\r\n\t\t\tvar invAspect = viewportHeight / viewportWidth,\r\n\t\t\t\thalfViewportWidth = viewportWidth * 0.5,\r\n\t\t\t\thalfViewportHeight = viewportHeight * 0.5;\r\n\t\r\n\t\t\tvar size = 16 / viewportHeight,\r\n\t\t\t\tscale = new THREE.Vector2( size * invAspect, size );\r\n\t\r\n\t\t\tvar screenPosition = new THREE.Vector3( 1, 1, 0 ),\r\n\t\t\t\tscreenPositionPixels = new THREE.Vector2( 1, 1 );\r\n\t\r\n\t\t\tif ( program === undefined ) {\r\n\t\r\n\t\t\t\tinit();\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tgl.useProgram( program );\r\n\t\r\n\t\t\tgl.enableVertexAttribArray( attributes.vertex );\r\n\t\t\tgl.enableVertexAttribArray( attributes.uv );\r\n\t\r\n\t\t\t// loop through all lens flares to update their occlusion and positions\r\n\t\t\t// setup gl and common used attribs/unforms\r\n\t\r\n\t\t\tgl.uniform1i( uniforms.occlusionMap, 0 );\r\n\t\t\tgl.uniform1i( uniforms.map, 1 );\r\n\t\r\n\t\t\tgl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );\r\n\t\t\tgl.vertexAttribPointer( attributes.vertex, 2, gl.FLOAT, false, 2 * 8, 0 );\r\n\t\t\tgl.vertexAttribPointer( attributes.uv, 2, gl.FLOAT, false, 2 * 8, 8 );\r\n\t\r\n\t\t\tgl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );\r\n\t\r\n\t\t\tgl.disable( gl.CULL_FACE );\r\n\t\t\tgl.depthMask( false );\r\n\t\r\n\t\t\tfor ( var i = 0, l = flares.length; i < l; i ++ ) {\r\n\t\r\n\t\t\t\tsize = 16 / viewportHeight;\r\n\t\t\t\tscale.set( size * invAspect, size );\r\n\t\r\n\t\t\t\t// calc object screen position\r\n\t\r\n\t\t\t\tvar flare = flares[ i ];\r\n\t\r\n\t\t\t\ttempPosition.set( flare.matrixWorld.elements[12], flare.matrixWorld.elements[13], flare.matrixWorld.elements[14] );\r\n\t\r\n\t\t\t\ttempPosition.applyMatrix4( camera.matrixWorldInverse );\r\n\t\t\t\ttempPosition.applyProjection( camera.projectionMatrix );\r\n\t\r\n\t\t\t\t// setup arrays for gl programs\r\n\t\r\n\t\t\t\tscreenPosition.copy( tempPosition )\r\n\t\r\n\t\t\t\tscreenPositionPixels.x = screenPosition.x * halfViewportWidth + halfViewportWidth;\r\n\t\t\t\tscreenPositionPixels.y = screenPosition.y * halfViewportHeight + halfViewportHeight;\r\n\t\r\n\t\t\t\t// screen cull\r\n\t\r\n\t\t\t\tif ( hasVertexTexture || (\r\n\t\t\t\t\tscreenPositionPixels.x > 0 &&\r\n\t\t\t\t\tscreenPositionPixels.x < viewportWidth &&\r\n\t\t\t\t\tscreenPositionPixels.y > 0 &&\r\n\t\t\t\t\tscreenPositionPixels.y < viewportHeight ) ) {\r\n\t\r\n\t\t\t\t\t// save current RGB to temp texture\r\n\t\r\n\t\t\t\t\tgl.activeTexture( gl.TEXTURE1 );\r\n\t\t\t\t\tgl.bindTexture( gl.TEXTURE_2D, tempTexture );\r\n\t\t\t\t\tgl.copyTexImage2D( gl.TEXTURE_2D, 0, gl.RGB, screenPositionPixels.x - 8, screenPositionPixels.y - 8, 16, 16, 0 );\r\n\t\r\n\t\r\n\t\t\t\t\t// render pink quad\r\n\t\r\n\t\t\t\t\tgl.uniform1i( uniforms.renderType, 0 );\r\n\t\t\t\t\tgl.uniform2f( uniforms.scale, scale.x, scale.y );\r\n\t\t\t\t\tgl.uniform3f( uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z );\r\n\t\r\n\t\t\t\t\tgl.disable( gl.BLEND );\r\n\t\t\t\t\tgl.enable( gl.DEPTH_TEST );\r\n\t\r\n\t\t\t\t\tgl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );\r\n\t\r\n\t\r\n\t\t\t\t\t// copy result to occlusionMap\r\n\t\r\n\t\t\t\t\tgl.activeTexture( gl.TEXTURE0 );\r\n\t\t\t\t\tgl.bindTexture( gl.TEXTURE_2D, occlusionTexture );\r\n\t\t\t\t\tgl.copyTexImage2D( gl.TEXTURE_2D, 0, gl.RGBA, screenPositionPixels.x - 8, screenPositionPixels.y - 8, 16, 16, 0 );\r\n\t\r\n\t\r\n\t\t\t\t\t// restore graphics\r\n\t\r\n\t\t\t\t\tgl.uniform1i( uniforms.renderType, 1 );\r\n\t\t\t\t\tgl.disable( gl.DEPTH_TEST );\r\n\t\r\n\t\t\t\t\tgl.activeTexture( gl.TEXTURE1 );\r\n\t\t\t\t\tgl.bindTexture( gl.TEXTURE_2D, tempTexture );\r\n\t\t\t\t\tgl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );\r\n\t\r\n\t\r\n\t\t\t\t\t// update object positions\r\n\t\r\n\t\t\t\t\tflare.positionScreen.copy( screenPosition )\r\n\t\r\n\t\t\t\t\tif ( flare.customUpdateCallback ) {\r\n\t\r\n\t\t\t\t\t\tflare.customUpdateCallback( flare );\r\n\t\r\n\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\tflare.updateLensFlares();\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t// render flares\r\n\t\r\n\t\t\t\t\tgl.uniform1i( uniforms.renderType, 2 );\r\n\t\t\t\t\tgl.enable( gl.BLEND );\r\n\t\r\n\t\t\t\t\tfor ( var j = 0, jl = flare.lensFlares.length; j < jl; j ++ ) {\r\n\t\r\n\t\t\t\t\t\tvar sprite = flare.lensFlares[ j ];\r\n\t\r\n\t\t\t\t\t\tif ( sprite.opacity > 0.001 && sprite.scale > 0.001 ) {\r\n\t\r\n\t\t\t\t\t\t\tscreenPosition.x = sprite.x;\r\n\t\t\t\t\t\t\tscreenPosition.y = sprite.y;\r\n\t\t\t\t\t\t\tscreenPosition.z = sprite.z;\r\n\t\r\n\t\t\t\t\t\t\tsize = sprite.size * sprite.scale / viewportHeight;\r\n\t\r\n\t\t\t\t\t\t\tscale.x = size * invAspect;\r\n\t\t\t\t\t\t\tscale.y = size;\r\n\t\r\n\t\t\t\t\t\t\tgl.uniform3f( uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z );\r\n\t\t\t\t\t\t\tgl.uniform2f( uniforms.scale, scale.x, scale.y );\r\n\t\t\t\t\t\t\tgl.uniform1f( uniforms.rotation, sprite.rotation );\r\n\t\r\n\t\t\t\t\t\t\tgl.uniform1f( uniforms.opacity, sprite.opacity );\r\n\t\t\t\t\t\t\tgl.uniform3f( uniforms.color, sprite.color.r, sprite.color.g, sprite.color.b );\r\n\t\r\n\t\t\t\t\t\t\trenderer.state.setBlending( sprite.blending, sprite.blendEquation, sprite.blendSrc, sprite.blendDst );\r\n\t\t\t\t\t\t\trenderer.setTexture( sprite.texture, 1 );\r\n\t\r\n\t\t\t\t\t\t\tgl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// restore gl\r\n\t\r\n\t\t\tgl.enable( gl.CULL_FACE );\r\n\t\t\tgl.enable( gl.DEPTH_TEST );\r\n\t\t\tgl.depthMask( true );\r\n\t\r\n\t\t\trenderer.resetGLState();\r\n\t\r\n\t\t};\r\n\t\r\n\t\tfunction createProgram ( shader ) {\r\n\t\r\n\t\t\tvar program = gl.createProgram();\r\n\t\r\n\t\t\tvar fragmentShader = gl.createShader( gl.FRAGMENT_SHADER );\r\n\t\t\tvar vertexShader = gl.createShader( gl.VERTEX_SHADER );\r\n\t\r\n\t\t\tvar prefix = \"precision \" + renderer.getPrecision() + \" float;\\n\";\r\n\t\r\n\t\t\tgl.shaderSource( fragmentShader, prefix + shader.fragmentShader );\r\n\t\t\tgl.shaderSource( vertexShader, prefix + shader.vertexShader );\r\n\t\r\n\t\t\tgl.compileShader( fragmentShader );\r\n\t\t\tgl.compileShader( vertexShader );\r\n\t\r\n\t\t\tgl.attachShader( program, fragmentShader );\r\n\t\t\tgl.attachShader( program, vertexShader );\r\n\t\r\n\t\t\tgl.linkProgram( program );\r\n\t\r\n\t\t\treturn program;\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/renderers/webgl/plugins/ShadowMapPlugin.js\r\n\t\r\n\t/**\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t */\r\n\t\r\n\tTHREE.ShadowMapPlugin = function ( _renderer, _lights, _webglObjects, _webglObjectsImmediate ) {\r\n\t\r\n\t\tvar _gl = _renderer.context;\r\n\t\r\n\t\tvar _depthMaterial, _depthMaterialMorph, _depthMaterialSkin, _depthMaterialMorphSkin,\r\n\t\r\n\t\t_frustum = new THREE.Frustum(),\r\n\t\t_projScreenMatrix = new THREE.Matrix4(),\r\n\t\r\n\t\t_min = new THREE.Vector3(),\r\n\t\t_max = new THREE.Vector3(),\r\n\t\r\n\t\t_matrixPosition = new THREE.Vector3(),\r\n\t\r\n\t\t_renderList = [];\r\n\t\r\n\t\t// init\r\n\t\r\n\t\tvar depthShader = THREE.ShaderLib[ \"depthRGBA\" ];\r\n\t\tvar depthUniforms = THREE.UniformsUtils.clone( depthShader.uniforms );\r\n\t\r\n\t\t_depthMaterial = new THREE.ShaderMaterial( {\r\n\t\t\tuniforms: depthUniforms,\r\n\t\t\tvertexShader: depthShader.vertexShader,\r\n\t\t\tfragmentShader: depthShader.fragmentShader\r\n\t\t } );\r\n\t\r\n\t\t_depthMaterialMorph = new THREE.ShaderMaterial( {\r\n\t\t\tuniforms: depthUniforms,\r\n\t\t\tvertexShader: depthShader.vertexShader,\r\n\t\t\tfragmentShader: depthShader.fragmentShader,\r\n\t\t\tmorphTargets: true\r\n\t\t} );\r\n\t\r\n\t\t_depthMaterialSkin = new THREE.ShaderMaterial( {\r\n\t\t\tuniforms: depthUniforms,\r\n\t\t\tvertexShader: depthShader.vertexShader,\r\n\t\t\tfragmentShader: depthShader.fragmentShader,\r\n\t\t\tskinning: true\r\n\t\t} );\r\n\t\r\n\t\t_depthMaterialMorphSkin = new THREE.ShaderMaterial( {\r\n\t\t\tuniforms: depthUniforms,\r\n\t\t\tvertexShader: depthShader.vertexShader,\r\n\t\t\tfragmentShader: depthShader.fragmentShader,\r\n\t\t\tmorphTargets: true,\r\n\t\t\tskinning: true\r\n\t\t} );\r\n\t\r\n\t\t_depthMaterial._shadowPass = true;\r\n\t\t_depthMaterialMorph._shadowPass = true;\r\n\t\t_depthMaterialSkin._shadowPass = true;\r\n\t\t_depthMaterialMorphSkin._shadowPass = true;\r\n\t\r\n\t\tthis.render = function ( scene, camera ) {\r\n\t\r\n\t\t\tif ( _renderer.shadowMapEnabled === false ) return;\r\n\t\r\n\t\t\tvar i, il, j, jl, n,\r\n\t\r\n\t\t\tshadowMap, shadowMatrix, shadowCamera,\r\n\t\t\tbuffer, material,\r\n\t\t\twebglObject, object, light,\r\n\t\r\n\t\t\tlights = [],\r\n\t\t\tk = 0,\r\n\t\r\n\t\t\tfog = null;\r\n\t\r\n\t\t\t// set GL state for depth map\r\n\t\r\n\t\t\t_gl.clearColor( 1, 1, 1, 1 );\r\n\t\t\t_gl.disable( _gl.BLEND );\r\n\t\r\n\t\t\t_gl.enable( _gl.CULL_FACE );\r\n\t\t\t_gl.frontFace( _gl.CCW );\r\n\t\r\n\t\t\tif ( _renderer.shadowMapCullFace === THREE.CullFaceFront ) {\r\n\t\r\n\t\t\t\t_gl.cullFace( _gl.FRONT );\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\t_gl.cullFace( _gl.BACK );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t_renderer.state.setDepthTest( true );\r\n\t\r\n\t\t\t// preprocess lights\r\n\t\t\t// \t- skip lights that are not casting shadows\r\n\t\t\t//\t- create virtual lights for cascaded shadow maps\r\n\t\r\n\t\t\tfor ( i = 0, il = _lights.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\tlight = _lights[ i ];\r\n\t\r\n\t\t\t\tif ( ! light.castShadow ) continue;\r\n\t\r\n\t\t\t\tif ( ( light instanceof THREE.DirectionalLight ) && light.shadowCascade ) {\r\n\t\r\n\t\t\t\t\tfor ( n = 0; n < light.shadowCascadeCount; n ++ ) {\r\n\t\r\n\t\t\t\t\t\tvar virtualLight;\r\n\t\r\n\t\t\t\t\t\tif ( ! light.shadowCascadeArray[ n ] ) {\r\n\t\r\n\t\t\t\t\t\t\tvirtualLight = createVirtualLight( light, n );\r\n\t\t\t\t\t\t\tvirtualLight.originalCamera = camera;\r\n\t\r\n\t\t\t\t\t\t\tvar gyro = new THREE.Gyroscope();\r\n\t\t\t\t\t\t\tgyro.position.copy( light.shadowCascadeOffset );\r\n\t\r\n\t\t\t\t\t\t\tgyro.add( virtualLight );\r\n\t\t\t\t\t\t\tgyro.add( virtualLight.target );\r\n\t\r\n\t\t\t\t\t\t\tcamera.add( gyro );\r\n\t\r\n\t\t\t\t\t\t\tlight.shadowCascadeArray[ n ] = virtualLight;\r\n\t\r\n\t\t\t\t\t\t\t//console.log( \"Created virtualLight\", virtualLight );\r\n\t\r\n\t\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\t\tvirtualLight = light.shadowCascadeArray[ n ];\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\tupdateVirtualLight( light, n );\r\n\t\r\n\t\t\t\t\t\tlights[ k ] = virtualLight;\r\n\t\t\t\t\t\tk ++;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tlights[ k ] = light;\r\n\t\t\t\t\tk ++;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// render depth map\r\n\t\r\n\t\t\tfor ( i = 0, il = lights.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\tlight = lights[ i ];\r\n\t\r\n\t\t\t\tif ( ! light.shadowMap ) {\r\n\t\r\n\t\t\t\t\tvar shadowFilter = THREE.LinearFilter;\r\n\t\r\n\t\t\t\t\tif ( _renderer.shadowMapType === THREE.PCFSoftShadowMap ) {\r\n\t\r\n\t\t\t\t\t\tshadowFilter = THREE.NearestFilter;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tvar pars = { minFilter: shadowFilter, magFilter: shadowFilter, format: THREE.RGBAFormat };\r\n\t\r\n\t\t\t\t\tlight.shadowMap = new THREE.WebGLRenderTarget( light.shadowMapWidth, light.shadowMapHeight, pars );\r\n\t\t\t\t\tlight.shadowMapSize = new THREE.Vector2( light.shadowMapWidth, light.shadowMapHeight );\r\n\t\r\n\t\t\t\t\tlight.shadowMatrix = new THREE.Matrix4();\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( ! light.shadowCamera ) {\r\n\t\r\n\t\t\t\t\tif ( light instanceof THREE.SpotLight ) {\r\n\t\r\n\t\t\t\t\t\tlight.shadowCamera = new THREE.PerspectiveCamera( light.shadowCameraFov, light.shadowMapWidth / light.shadowMapHeight, light.shadowCameraNear, light.shadowCameraFar );\r\n\t\r\n\t\t\t\t\t} else if ( light instanceof THREE.DirectionalLight ) {\r\n\t\r\n\t\t\t\t\t\tlight.shadowCamera = new THREE.OrthographicCamera( light.shadowCameraLeft, light.shadowCameraRight, light.shadowCameraTop, light.shadowCameraBottom, light.shadowCameraNear, light.shadowCameraFar );\r\n\t\r\n\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\tTHREE.error( \"THREE.ShadowMapPlugin: Unsupported light type for shadow\", light );\r\n\t\t\t\t\t\tcontinue;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tscene.add( light.shadowCamera );\r\n\t\r\n\t\t\t\t\tif ( scene.autoUpdate === true ) scene.updateMatrixWorld();\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( light.shadowCameraVisible && ! light.cameraHelper ) {\r\n\t\r\n\t\t\t\t\tlight.cameraHelper = new THREE.CameraHelper( light.shadowCamera );\r\n\t\t\t\t\tscene.add( light.cameraHelper );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( light.isVirtual && virtualLight.originalCamera == camera ) {\r\n\t\r\n\t\t\t\t\tupdateShadowCamera( camera, light );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tshadowMap = light.shadowMap;\r\n\t\t\t\tshadowMatrix = light.shadowMatrix;\r\n\t\t\t\tshadowCamera = light.shadowCamera;\r\n\t\r\n\t\t\t\t//\r\n\t\r\n\t\t\t\tshadowCamera.position.setFromMatrixPosition( light.matrixWorld );\r\n\t\t\t\t_matrixPosition.setFromMatrixPosition( light.target.matrixWorld );\r\n\t\t\t\tshadowCamera.lookAt( _matrixPosition );\r\n\t\t\t\tshadowCamera.updateMatrixWorld();\r\n\t\r\n\t\t\t\tshadowCamera.matrixWorldInverse.getInverse( shadowCamera.matrixWorld );\r\n\t\r\n\t\t\t\t//\r\n\t\r\n\t\t\t\tif ( light.cameraHelper ) light.cameraHelper.visible = light.shadowCameraVisible;\r\n\t\t\t\tif ( light.shadowCameraVisible ) light.cameraHelper.update();\r\n\t\r\n\t\t\t\t// compute shadow matrix\r\n\t\r\n\t\t\t\tshadowMatrix.set(\r\n\t\t\t\t\t0.5, 0.0, 0.0, 0.5,\r\n\t\t\t\t\t0.0, 0.5, 0.0, 0.5,\r\n\t\t\t\t\t0.0, 0.0, 0.5, 0.5,\r\n\t\t\t\t\t0.0, 0.0, 0.0, 1.0\r\n\t\t\t\t);\r\n\t\r\n\t\t\t\tshadowMatrix.multiply( shadowCamera.projectionMatrix );\r\n\t\t\t\tshadowMatrix.multiply( shadowCamera.matrixWorldInverse );\r\n\t\r\n\t\t\t\t// update camera matrices and frustum\r\n\t\r\n\t\t\t\t_projScreenMatrix.multiplyMatrices( shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse );\r\n\t\t\t\t_frustum.setFromMatrix( _projScreenMatrix );\r\n\t\r\n\t\t\t\t// render shadow map\r\n\t\r\n\t\t\t\t_renderer.setRenderTarget( shadowMap );\r\n\t\t\t\t_renderer.clear();\r\n\t\r\n\t\t\t\t// set object matrices & frustum culling\r\n\t\r\n\t\t\t\t_renderList.length = 0;\r\n\t\r\n\t\t\t\tprojectObject( scene, scene, shadowCamera );\r\n\t\r\n\t\r\n\t\t\t\t// render regular objects\r\n\t\r\n\t\t\t\tvar objectMaterial, useMorphing, useSkinning;\r\n\t\r\n\t\t\t\tfor ( j = 0, jl = _renderList.length; j < jl; j ++ ) {\r\n\t\r\n\t\t\t\t\twebglObject = _renderList[ j ];\r\n\t\r\n\t\t\t\t\tobject = webglObject.object;\r\n\t\t\t\t\tbuffer = webglObject.buffer;\r\n\t\r\n\t\t\t\t\t// culling is overriden globally for all objects\r\n\t\t\t\t\t// while rendering depth map\r\n\t\r\n\t\t\t\t\t// need to deal with MeshFaceMaterial somehow\r\n\t\t\t\t\t// in that case just use the first of material.materials for now\r\n\t\t\t\t\t// (proper solution would require to break objects by materials\r\n\t\t\t\t\t//  similarly to regular rendering and then set corresponding\r\n\t\t\t\t\t//  depth materials per each chunk instead of just once per object)\r\n\t\r\n\t\t\t\t\tobjectMaterial = getObjectMaterial( object );\r\n\t\r\n\t\t\t\t\tuseMorphing = object.geometry.morphTargets !== undefined && object.geometry.morphTargets.length > 0 && objectMaterial.morphTargets;\r\n\t\t\t\t\tuseSkinning = object instanceof THREE.SkinnedMesh && objectMaterial.skinning;\r\n\t\r\n\t\t\t\t\tif ( object.customDepthMaterial ) {\r\n\t\r\n\t\t\t\t\t\tmaterial = object.customDepthMaterial;\r\n\t\r\n\t\t\t\t\t} else if ( useSkinning ) {\r\n\t\r\n\t\t\t\t\t\tmaterial = useMorphing ? _depthMaterialMorphSkin : _depthMaterialSkin;\r\n\t\r\n\t\t\t\t\t} else if ( useMorphing ) {\r\n\t\r\n\t\t\t\t\t\tmaterial = _depthMaterialMorph;\r\n\t\r\n\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\tmaterial = _depthMaterial;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t_renderer.setMaterialFaces( objectMaterial );\r\n\t\r\n\t\t\t\t\tif ( buffer instanceof THREE.BufferGeometry ) {\r\n\t\r\n\t\t\t\t\t\t_renderer.renderBufferDirect( shadowCamera, _lights, fog, material, buffer, object );\r\n\t\r\n\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\t_renderer.renderBuffer( shadowCamera, _lights, fog, material, buffer, object );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\t// set matrices and render immediate objects\r\n\t\r\n\t\t\t\tfor ( j = 0, jl = _webglObjectsImmediate.length; j < jl; j ++ ) {\r\n\t\r\n\t\t\t\t\twebglObject = _webglObjectsImmediate[ j ];\r\n\t\t\t\t\tobject = webglObject.object;\r\n\t\r\n\t\t\t\t\tif ( object.visible && object.castShadow ) {\r\n\t\r\n\t\t\t\t\t\tobject._modelViewMatrix.multiplyMatrices( shadowCamera.matrixWorldInverse, object.matrixWorld );\r\n\t\r\n\t\t\t\t\t\t_renderer.renderImmediateObject( shadowCamera, _lights, fog, _depthMaterial, object );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// restore GL state\r\n\t\r\n\t\t\tvar clearColor = _renderer.getClearColor(),\r\n\t\t\tclearAlpha = _renderer.getClearAlpha();\r\n\t\r\n\t\t\t_gl.clearColor( clearColor.r, clearColor.g, clearColor.b, clearAlpha );\r\n\t\t\t_gl.enable( _gl.BLEND );\r\n\t\r\n\t\t\tif ( _renderer.shadowMapCullFace === THREE.CullFaceFront ) {\r\n\t\r\n\t\t\t\t_gl.cullFace( _gl.BACK );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t_renderer.resetGLState();\r\n\t\r\n\t\t};\r\n\t\r\n\t\tfunction projectObject( scene, object, shadowCamera ) {\r\n\t\r\n\t\t\tif ( object.visible ) {\r\n\t\r\n\t\t\t\tvar webglObjects = _webglObjects[ object.id ];\r\n\t\r\n\t\t\t\tif ( webglObjects && object.castShadow && (object.frustumCulled === false || _frustum.intersectsObject( object ) === true) ) {\r\n\t\r\n\t\t\t\t\tfor ( var i = 0, l = webglObjects.length; i < l; i ++ ) {\r\n\t\r\n\t\t\t\t\t\tvar webglObject = webglObjects[ i ];\r\n\t\r\n\t\t\t\t\t\tobject._modelViewMatrix.multiplyMatrices( shadowCamera.matrixWorldInverse, object.matrixWorld );\r\n\t\t\t\t\t\t_renderList.push( webglObject );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tfor ( var i = 0, l = object.children.length; i < l; i ++ ) {\r\n\t\r\n\t\t\t\t\tprojectObject( scene, object.children[ i ], shadowCamera );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction createVirtualLight( light, cascade ) {\r\n\t\r\n\t\t\tvar virtualLight = new THREE.DirectionalLight();\r\n\t\r\n\t\t\tvirtualLight.isVirtual = true;\r\n\t\r\n\t\t\tvirtualLight.onlyShadow = true;\r\n\t\t\tvirtualLight.castShadow = true;\r\n\t\r\n\t\t\tvirtualLight.shadowCameraNear = light.shadowCameraNear;\r\n\t\t\tvirtualLight.shadowCameraFar = light.shadowCameraFar;\r\n\t\r\n\t\t\tvirtualLight.shadowCameraLeft = light.shadowCameraLeft;\r\n\t\t\tvirtualLight.shadowCameraRight = light.shadowCameraRight;\r\n\t\t\tvirtualLight.shadowCameraBottom = light.shadowCameraBottom;\r\n\t\t\tvirtualLight.shadowCameraTop = light.shadowCameraTop;\r\n\t\r\n\t\t\tvirtualLight.shadowCameraVisible = light.shadowCameraVisible;\r\n\t\r\n\t\t\tvirtualLight.shadowDarkness = light.shadowDarkness;\r\n\t\r\n\t\t\tvirtualLight.shadowBias = light.shadowCascadeBias[ cascade ];\r\n\t\t\tvirtualLight.shadowMapWidth = light.shadowCascadeWidth[ cascade ];\r\n\t\t\tvirtualLight.shadowMapHeight = light.shadowCascadeHeight[ cascade ];\r\n\t\r\n\t\t\tvirtualLight.pointsWorld = [];\r\n\t\t\tvirtualLight.pointsFrustum = [];\r\n\t\r\n\t\t\tvar pointsWorld = virtualLight.pointsWorld,\r\n\t\t\t\tpointsFrustum = virtualLight.pointsFrustum;\r\n\t\r\n\t\t\tfor ( var i = 0; i < 8; i ++ ) {\r\n\t\r\n\t\t\t\tpointsWorld[ i ] = new THREE.Vector3();\r\n\t\t\t\tpointsFrustum[ i ] = new THREE.Vector3();\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar nearZ = light.shadowCascadeNearZ[ cascade ];\r\n\t\t\tvar farZ = light.shadowCascadeFarZ[ cascade ];\r\n\t\r\n\t\t\tpointsFrustum[ 0 ].set( - 1, - 1, nearZ );\r\n\t\t\tpointsFrustum[ 1 ].set(  1, - 1, nearZ );\r\n\t\t\tpointsFrustum[ 2 ].set( - 1,  1, nearZ );\r\n\t\t\tpointsFrustum[ 3 ].set(  1,  1, nearZ );\r\n\t\r\n\t\t\tpointsFrustum[ 4 ].set( - 1, - 1, farZ );\r\n\t\t\tpointsFrustum[ 5 ].set(  1, - 1, farZ );\r\n\t\t\tpointsFrustum[ 6 ].set( - 1,  1, farZ );\r\n\t\t\tpointsFrustum[ 7 ].set(  1,  1, farZ );\r\n\t\r\n\t\t\treturn virtualLight;\r\n\t\r\n\t\t}\r\n\t\r\n\t\t// Synchronize virtual light with the original light\r\n\t\r\n\t\tfunction updateVirtualLight( light, cascade ) {\r\n\t\r\n\t\t\tvar virtualLight = light.shadowCascadeArray[ cascade ];\r\n\t\r\n\t\t\tvirtualLight.position.copy( light.position );\r\n\t\t\tvirtualLight.target.position.copy( light.target.position );\r\n\t\t\tvirtualLight.lookAt( virtualLight.target );\r\n\t\r\n\t\t\tvirtualLight.shadowCameraVisible = light.shadowCameraVisible;\r\n\t\t\tvirtualLight.shadowDarkness = light.shadowDarkness;\r\n\t\r\n\t\t\tvirtualLight.shadowBias = light.shadowCascadeBias[ cascade ];\r\n\t\r\n\t\t\tvar nearZ = light.shadowCascadeNearZ[ cascade ];\r\n\t\t\tvar farZ = light.shadowCascadeFarZ[ cascade ];\r\n\t\r\n\t\t\tvar pointsFrustum = virtualLight.pointsFrustum;\r\n\t\r\n\t\t\tpointsFrustum[ 0 ].z = nearZ;\r\n\t\t\tpointsFrustum[ 1 ].z = nearZ;\r\n\t\t\tpointsFrustum[ 2 ].z = nearZ;\r\n\t\t\tpointsFrustum[ 3 ].z = nearZ;\r\n\t\r\n\t\t\tpointsFrustum[ 4 ].z = farZ;\r\n\t\t\tpointsFrustum[ 5 ].z = farZ;\r\n\t\t\tpointsFrustum[ 6 ].z = farZ;\r\n\t\t\tpointsFrustum[ 7 ].z = farZ;\r\n\t\r\n\t\t}\r\n\t\r\n\t\t// Fit shadow camera's ortho frustum to camera frustum\r\n\t\r\n\t\tfunction updateShadowCamera( camera, light ) {\r\n\t\r\n\t\t\tvar shadowCamera = light.shadowCamera,\r\n\t\t\t\tpointsFrustum = light.pointsFrustum,\r\n\t\t\t\tpointsWorld = light.pointsWorld;\r\n\t\r\n\t\t\t_min.set( Infinity, Infinity, Infinity );\r\n\t\t\t_max.set( - Infinity, - Infinity, - Infinity );\r\n\t\r\n\t\t\tfor ( var i = 0; i < 8; i ++ ) {\r\n\t\r\n\t\t\t\tvar p = pointsWorld[ i ];\r\n\t\r\n\t\t\t\tp.copy( pointsFrustum[ i ] );\r\n\t\t\t\tp.unproject( camera );\r\n\t\r\n\t\t\t\tp.applyMatrix4( shadowCamera.matrixWorldInverse );\r\n\t\r\n\t\t\t\tif ( p.x < _min.x ) _min.x = p.x;\r\n\t\t\t\tif ( p.x > _max.x ) _max.x = p.x;\r\n\t\r\n\t\t\t\tif ( p.y < _min.y ) _min.y = p.y;\r\n\t\t\t\tif ( p.y > _max.y ) _max.y = p.y;\r\n\t\r\n\t\t\t\tif ( p.z < _min.z ) _min.z = p.z;\r\n\t\t\t\tif ( p.z > _max.z ) _max.z = p.z;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tshadowCamera.left = _min.x;\r\n\t\t\tshadowCamera.right = _max.x;\r\n\t\t\tshadowCamera.top = _max.y;\r\n\t\t\tshadowCamera.bottom = _min.y;\r\n\t\r\n\t\t\t// can't really fit near/far\r\n\t\t\t//shadowCamera.near = _min.z;\r\n\t\t\t//shadowCamera.far = _max.z;\r\n\t\r\n\t\t\tshadowCamera.updateProjectionMatrix();\r\n\t\r\n\t\t}\r\n\t\r\n\t\t// For the moment just ignore objects that have multiple materials with different animation methods\r\n\t\t// Only the first material will be taken into account for deciding which depth material to use for shadow maps\r\n\t\r\n\t\tfunction getObjectMaterial( object ) {\r\n\t\r\n\t\t\treturn object.material instanceof THREE.MeshFaceMaterial\r\n\t\t\t\t? object.material.materials[ 0 ]\r\n\t\t\t\t: object.material;\r\n\t\r\n\t\t};\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/renderers/webgl/plugins/SpritePlugin.js\r\n\t\r\n\t/**\r\n\t * @author mikael emtinger / http://gomo.se/\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t */\r\n\t\r\n\tTHREE.SpritePlugin = function ( renderer, sprites ) {\r\n\t\r\n\t\tvar gl = renderer.context;\r\n\t\r\n\t\tvar vertexBuffer, elementBuffer;\r\n\t\tvar program, attributes, uniforms;\r\n\t\r\n\t\tvar texture;\r\n\t\r\n\t\t// decompose matrixWorld\r\n\t\r\n\t\tvar spritePosition = new THREE.Vector3();\r\n\t\tvar spriteRotation = new THREE.Quaternion();\r\n\t\tvar spriteScale = new THREE.Vector3();\r\n\t\r\n\t\tvar init = function () {\r\n\t\r\n\t\t\tvar vertices = new Float32Array( [\r\n\t\t\t\t- 0.5, - 0.5,  0, 0,\r\n\t\t\t\t  0.5, - 0.5,  1, 0,\r\n\t\t\t\t  0.5,   0.5,  1, 1,\r\n\t\t\t\t- 0.5,   0.5,  0, 1\r\n\t\t\t] );\r\n\t\r\n\t\t\tvar faces = new Uint16Array( [\r\n\t\t\t\t0, 1, 2,\r\n\t\t\t\t0, 2, 3\r\n\t\t\t] );\r\n\t\r\n\t\t\tvertexBuffer  = gl.createBuffer();\r\n\t\t\telementBuffer = gl.createBuffer();\r\n\t\r\n\t\t\tgl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );\r\n\t\t\tgl.bufferData( gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW );\r\n\t\r\n\t\t\tgl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );\r\n\t\t\tgl.bufferData( gl.ELEMENT_ARRAY_BUFFER, faces, gl.STATIC_DRAW );\r\n\t\r\n\t\t\tprogram = createProgram();\r\n\t\r\n\t\t\tattributes = {\r\n\t\t\t\tposition:\t\t\tgl.getAttribLocation ( program, 'position' ),\r\n\t\t\t\tuv:\t\t\t\t\tgl.getAttribLocation ( program, 'uv' )\r\n\t\t\t};\r\n\t\r\n\t\t\tuniforms = {\r\n\t\t\t\tuvOffset:\t\t\tgl.getUniformLocation( program, 'uvOffset' ),\r\n\t\t\t\tuvScale:\t\t\tgl.getUniformLocation( program, 'uvScale' ),\r\n\t\r\n\t\t\t\trotation:\t\t\tgl.getUniformLocation( program, 'rotation' ),\r\n\t\t\t\tscale:\t\t\t\tgl.getUniformLocation( program, 'scale' ),\r\n\t\r\n\t\t\t\tcolor:\t\t\t\tgl.getUniformLocation( program, 'color' ),\r\n\t\t\t\tmap:\t\t\t\tgl.getUniformLocation( program, 'map' ),\r\n\t\t\t\topacity:\t\t\tgl.getUniformLocation( program, 'opacity' ),\r\n\t\r\n\t\t\t\tmodelViewMatrix: \tgl.getUniformLocation( program, 'modelViewMatrix' ),\r\n\t\t\t\tprojectionMatrix:\tgl.getUniformLocation( program, 'projectionMatrix' ),\r\n\t\r\n\t\t\t\tfogType:\t\t\tgl.getUniformLocation( program, 'fogType' ),\r\n\t\t\t\tfogDensity:\t\t\tgl.getUniformLocation( program, 'fogDensity' ),\r\n\t\t\t\tfogNear:\t\t\tgl.getUniformLocation( program, 'fogNear' ),\r\n\t\t\t\tfogFar:\t\t\t\tgl.getUniformLocation( program, 'fogFar' ),\r\n\t\t\t\tfogColor:\t\t\tgl.getUniformLocation( program, 'fogColor' ),\r\n\t\r\n\t\t\t\talphaTest:\t\t\tgl.getUniformLocation( program, 'alphaTest' )\r\n\t\t\t};\r\n\t\r\n\t\t\tvar canvas = document.createElement( 'canvas' );\r\n\t\t\tcanvas.width = 8;\r\n\t\t\tcanvas.height = 8;\r\n\t\r\n\t\t\tvar context = canvas.getContext( '2d' );\r\n\t\t\tcontext.fillStyle = 'white';\r\n\t\t\tcontext.fillRect( 0, 0, 8, 8 );\r\n\t\r\n\t\t\ttexture = new THREE.Texture( canvas );\r\n\t\t\ttexture.needsUpdate = true;\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.render = function ( scene, camera ) {\r\n\t\r\n\t\t\tif ( sprites.length === 0 ) return;\r\n\t\r\n\t\t\t// setup gl\r\n\t\r\n\t\t\tif ( program === undefined ) {\r\n\t\r\n\t\t\t\tinit();\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tgl.useProgram( program );\r\n\t\r\n\t\t\tgl.enableVertexAttribArray( attributes.position );\r\n\t\t\tgl.enableVertexAttribArray( attributes.uv );\r\n\t\r\n\t\t\tgl.disable( gl.CULL_FACE );\r\n\t\t\tgl.enable( gl.BLEND );\r\n\t\r\n\t\t\tgl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );\r\n\t\t\tgl.vertexAttribPointer( attributes.position, 2, gl.FLOAT, false, 2 * 8, 0 );\r\n\t\t\tgl.vertexAttribPointer( attributes.uv, 2, gl.FLOAT, false, 2 * 8, 8 );\r\n\t\r\n\t\t\tgl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );\r\n\t\r\n\t\t\tgl.uniformMatrix4fv( uniforms.projectionMatrix, false, camera.projectionMatrix.elements );\r\n\t\r\n\t\t\tgl.activeTexture( gl.TEXTURE0 );\r\n\t\t\tgl.uniform1i( uniforms.map, 0 );\r\n\t\r\n\t\t\tvar oldFogType = 0;\r\n\t\t\tvar sceneFogType = 0;\r\n\t\t\tvar fog = scene.fog;\r\n\t\r\n\t\t\tif ( fog ) {\r\n\t\r\n\t\t\t\tgl.uniform3f( uniforms.fogColor, fog.color.r, fog.color.g, fog.color.b );\r\n\t\r\n\t\t\t\tif ( fog instanceof THREE.Fog ) {\r\n\t\r\n\t\t\t\t\tgl.uniform1f( uniforms.fogNear, fog.near );\r\n\t\t\t\t\tgl.uniform1f( uniforms.fogFar, fog.far );\r\n\t\r\n\t\t\t\t\tgl.uniform1i( uniforms.fogType, 1 );\r\n\t\t\t\t\toldFogType = 1;\r\n\t\t\t\t\tsceneFogType = 1;\r\n\t\r\n\t\t\t\t} else if ( fog instanceof THREE.FogExp2 ) {\r\n\t\r\n\t\t\t\t\tgl.uniform1f( uniforms.fogDensity, fog.density );\r\n\t\r\n\t\t\t\t\tgl.uniform1i( uniforms.fogType, 2 );\r\n\t\t\t\t\toldFogType = 2;\r\n\t\t\t\t\tsceneFogType = 2;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\tgl.uniform1i( uniforms.fogType, 0 );\r\n\t\t\t\toldFogType = 0;\r\n\t\t\t\tsceneFogType = 0;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\r\n\t\t\t// update positions and sort\r\n\t\r\n\t\t\tfor ( var i = 0, l = sprites.length; i < l; i ++ ) {\r\n\t\r\n\t\t\t\tvar sprite = sprites[ i ];\r\n\t\r\n\t\t\t\tsprite._modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, sprite.matrixWorld );\r\n\t\t\t\tsprite.z = - sprite._modelViewMatrix.elements[ 14 ];\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tsprites.sort( painterSortStable );\r\n\t\r\n\t\t\t// render all sprites\r\n\t\r\n\t\t\tvar scale = [];\r\n\t\r\n\t\t\tfor ( var i = 0, l = sprites.length; i < l; i ++ ) {\r\n\t\r\n\t\t\t\tvar sprite = sprites[ i ];\r\n\t\t\t\tvar material = sprite.material;\r\n\t\r\n\t\t\t\tgl.uniform1f( uniforms.alphaTest, material.alphaTest );\r\n\t\t\t\tgl.uniformMatrix4fv( uniforms.modelViewMatrix, false, sprite._modelViewMatrix.elements );\r\n\t\r\n\t\t\t\tsprite.matrixWorld.decompose( spritePosition, spriteRotation, spriteScale );\r\n\t\r\n\t\t\t\tscale[ 0 ] = spriteScale.x;\r\n\t\t\t\tscale[ 1 ] = spriteScale.y;\r\n\t\r\n\t\t\t\tvar fogType = 0;\r\n\t\r\n\t\t\t\tif ( scene.fog && material.fog ) {\r\n\t\r\n\t\t\t\t\tfogType = sceneFogType;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( oldFogType !== fogType ) {\r\n\t\r\n\t\t\t\t\tgl.uniform1i( uniforms.fogType, fogType );\r\n\t\t\t\t\toldFogType = fogType;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( material.map !== null ) {\r\n\t\r\n\t\t\t\t\tgl.uniform2f( uniforms.uvOffset, material.map.offset.x, material.map.offset.y );\r\n\t\t\t\t\tgl.uniform2f( uniforms.uvScale, material.map.repeat.x, material.map.repeat.y );\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tgl.uniform2f( uniforms.uvOffset, 0, 0 );\r\n\t\t\t\t\tgl.uniform2f( uniforms.uvScale, 1, 1 );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tgl.uniform1f( uniforms.opacity, material.opacity );\r\n\t\t\t\tgl.uniform3f( uniforms.color, material.color.r, material.color.g, material.color.b );\r\n\t\r\n\t\t\t\tgl.uniform1f( uniforms.rotation, material.rotation );\r\n\t\t\t\tgl.uniform2fv( uniforms.scale, scale );\r\n\t\r\n\t\t\t\trenderer.state.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst );\r\n\t\t\t\trenderer.state.setDepthTest( material.depthTest );\r\n\t\t\t\trenderer.state.setDepthWrite( material.depthWrite );\r\n\t\r\n\t\t\t\tif ( material.map && material.map.image && material.map.image.width ) {\r\n\t\r\n\t\t\t\t\trenderer.setTexture( material.map, 0 );\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\trenderer.setTexture( texture, 0 );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tgl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// restore gl\r\n\t\r\n\t\t\tgl.enable( gl.CULL_FACE );\r\n\t\r\n\t\t\trenderer.resetGLState();\r\n\t\r\n\t\t};\r\n\t\r\n\t\tfunction createProgram () {\r\n\t\r\n\t\t\tvar program = gl.createProgram();\r\n\t\r\n\t\t\tvar vertexShader = gl.createShader( gl.VERTEX_SHADER );\r\n\t\t\tvar fragmentShader = gl.createShader( gl.FRAGMENT_SHADER );\r\n\t\r\n\t\t\tgl.shaderSource( vertexShader, [\r\n\t\r\n\t\t\t\t'precision ' + renderer.getPrecision() + ' float;',\r\n\t\r\n\t\t\t\t'uniform mat4 modelViewMatrix;',\r\n\t\t\t\t'uniform mat4 projectionMatrix;',\r\n\t\t\t\t'uniform float rotation;',\r\n\t\t\t\t'uniform vec2 scale;',\r\n\t\t\t\t'uniform vec2 uvOffset;',\r\n\t\t\t\t'uniform vec2 uvScale;',\r\n\t\r\n\t\t\t\t'attribute vec2 position;',\r\n\t\t\t\t'attribute vec2 uv;',\r\n\t\r\n\t\t\t\t'varying vec2 vUV;',\r\n\t\r\n\t\t\t\t'void main() {',\r\n\t\r\n\t\t\t\t\t'vUV = uvOffset + uv * uvScale;',\r\n\t\r\n\t\t\t\t\t'vec2 alignedPosition = position * scale;',\r\n\t\r\n\t\t\t\t\t'vec2 rotatedPosition;',\r\n\t\t\t\t\t'rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;',\r\n\t\t\t\t\t'rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;',\r\n\t\r\n\t\t\t\t\t'vec4 finalPosition;',\r\n\t\r\n\t\t\t\t\t'finalPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );',\r\n\t\t\t\t\t'finalPosition.xy += rotatedPosition;',\r\n\t\t\t\t\t'finalPosition = projectionMatrix * finalPosition;',\r\n\t\r\n\t\t\t\t\t'gl_Position = finalPosition;',\r\n\t\r\n\t\t\t\t'}'\r\n\t\r\n\t\t\t].join( '\\n' ) );\r\n\t\r\n\t\t\tgl.shaderSource( fragmentShader, [\r\n\t\r\n\t\t\t\t'precision ' + renderer.getPrecision() + ' float;',\r\n\t\r\n\t\t\t\t'uniform vec3 color;',\r\n\t\t\t\t'uniform sampler2D map;',\r\n\t\t\t\t'uniform float opacity;',\r\n\t\r\n\t\t\t\t'uniform int fogType;',\r\n\t\t\t\t'uniform vec3 fogColor;',\r\n\t\t\t\t'uniform float fogDensity;',\r\n\t\t\t\t'uniform float fogNear;',\r\n\t\t\t\t'uniform float fogFar;',\r\n\t\t\t\t'uniform float alphaTest;',\r\n\t\r\n\t\t\t\t'varying vec2 vUV;',\r\n\t\r\n\t\t\t\t'void main() {',\r\n\t\r\n\t\t\t\t\t'vec4 texture = texture2D( map, vUV );',\r\n\t\r\n\t\t\t\t\t'if ( texture.a < alphaTest ) discard;',\r\n\t\r\n\t\t\t\t\t'gl_FragColor = vec4( color * texture.xyz, texture.a * opacity );',\r\n\t\r\n\t\t\t\t\t'if ( fogType > 0 ) {',\r\n\t\r\n\t\t\t\t\t\t'float depth = gl_FragCoord.z / gl_FragCoord.w;',\r\n\t\t\t\t\t\t'float fogFactor = 0.0;',\r\n\t\r\n\t\t\t\t\t\t'if ( fogType == 1 ) {',\r\n\t\r\n\t\t\t\t\t\t\t'fogFactor = smoothstep( fogNear, fogFar, depth );',\r\n\t\r\n\t\t\t\t\t\t'} else {',\r\n\t\r\n\t\t\t\t\t\t\t'const float LOG2 = 1.442695;',\r\n\t\t\t\t\t\t\t'float fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );',\r\n\t\t\t\t\t\t\t'fogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );',\r\n\t\r\n\t\t\t\t\t\t'}',\r\n\t\r\n\t\t\t\t\t\t'gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );',\r\n\t\r\n\t\t\t\t\t'}',\r\n\t\r\n\t\t\t\t'}'\r\n\t\r\n\t\t\t].join( '\\n' ) );\r\n\t\r\n\t\t\tgl.compileShader( vertexShader );\r\n\t\t\tgl.compileShader( fragmentShader );\r\n\t\r\n\t\t\tgl.attachShader( program, vertexShader );\r\n\t\t\tgl.attachShader( program, fragmentShader );\r\n\t\r\n\t\t\tgl.linkProgram( program );\r\n\t\r\n\t\t\treturn program;\r\n\t\r\n\t\t};\r\n\t\r\n\t\tfunction painterSortStable ( a, b ) {\r\n\t\r\n\t\t\tif ( a.z !== b.z ) {\r\n\t\r\n\t\t\t\treturn b.z - a.z;\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\treturn b.id - a.id;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/extras/GeometryUtils.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tTHREE.GeometryUtils = {\r\n\t\r\n\t\tmerge: function ( geometry1, geometry2, materialIndexOffset ) {\r\n\t\r\n\t\t\tTHREE.warn( 'THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead.' );\r\n\t\r\n\t\t\tvar matrix;\r\n\t\r\n\t\t\tif ( geometry2 instanceof THREE.Mesh ) {\r\n\t\r\n\t\t\t\tgeometry2.matrixAutoUpdate && geometry2.updateMatrix();\r\n\t\r\n\t\t\t\tmatrix = geometry2.matrix;\r\n\t\t\t\tgeometry2 = geometry2.geometry;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tgeometry1.merge( geometry2, matrix, materialIndexOffset );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcenter: function ( geometry ) {\r\n\t\r\n\t\t\tTHREE.warn( 'THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead.' );\r\n\t\t\treturn geometry.center();\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/extras/ImageUtils.js\r\n\t\r\n\t/**\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t * @author Daosheng Mu / https://github.com/DaoshengMu/\r\n\t */\r\n\t\r\n\tTHREE.ImageUtils = {\r\n\t\r\n\t\tcrossOrigin: undefined,\r\n\t\r\n\t\tloadTexture: function ( url, mapping, onLoad, onError ) {\r\n\t\r\n\t\t\tvar loader = new THREE.ImageLoader();\r\n\t\t\tloader.crossOrigin = this.crossOrigin;\r\n\t\r\n\t\t\tvar texture = new THREE.Texture( undefined, mapping );\r\n\t\r\n\t\t\tloader.load( url, function ( image ) {\r\n\t\r\n\t\t\t\ttexture.image = image;\r\n\t\t\t\ttexture.needsUpdate = true;\r\n\t\r\n\t\t\t\tif ( onLoad ) onLoad( texture );\r\n\t\r\n\t\t\t}, undefined, function ( event ) {\r\n\t\r\n\t\t\t\tif ( onError ) onError( event );\r\n\t\r\n\t\t\t} );\r\n\t\r\n\t\t\ttexture.sourceFile = url;\r\n\t\r\n\t\t\treturn texture;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tloadTextureCube: function ( array, mapping, onLoad, onError ) {\r\n\t\r\n\t\t\tvar images = [];\r\n\t\r\n\t\t\tvar loader = new THREE.ImageLoader();\r\n\t\t\tloader.crossOrigin = this.crossOrigin;\r\n\t\r\n\t\t\tvar texture = new THREE.CubeTexture( images, mapping );\r\n\t\r\n\t\t\t// no flipping needed for cube textures\r\n\t\r\n\t\t\ttexture.flipY = false;\r\n\t\r\n\t\t\tvar loaded = 0;\r\n\t\r\n\t\t\tvar loadTexture = function ( i ) {\r\n\t\r\n\t\t\t\tloader.load( array[ i ], function ( image ) {\r\n\t\r\n\t\t\t\t\ttexture.images[ i ] = image;\r\n\t\r\n\t\t\t\t\tloaded += 1;\r\n\t\r\n\t\t\t\t\tif ( loaded === 6 ) {\r\n\t\r\n\t\t\t\t\t\ttexture.needsUpdate = true;\r\n\t\r\n\t\t\t\t\t\tif ( onLoad ) onLoad( texture );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}, undefined, onError );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tfor ( var i = 0, il = array.length; i < il; ++ i ) {\r\n\t\r\n\t\t\t\tloadTexture( i );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn texture;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tloadCompressedTexture: function () {\r\n\t\r\n\t\t\tTHREE.error( 'THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.' )\r\n\t\r\n\t\t},\r\n\t\r\n\t\tloadCompressedTextureCube: function () {\r\n\t\r\n\t\t\tTHREE.error( 'THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.' )\r\n\t\r\n\t\t},\r\n\t\r\n\t\tgetNormalMap: function ( image, depth ) {\r\n\t\r\n\t\t\t// Adapted from http://www.paulbrunt.co.uk/lab/heightnormal/\r\n\t\r\n\t\t\tvar cross = function ( a, b ) {\r\n\t\r\n\t\t\t\treturn [ a[ 1 ] * b[ 2 ] - a[ 2 ] * b[ 1 ], a[ 2 ] * b[ 0 ] - a[ 0 ] * b[ 2 ], a[ 0 ] * b[ 1 ] - a[ 1 ] * b[ 0 ] ];\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar subtract = function ( a, b ) {\r\n\t\r\n\t\t\t\treturn [ a[ 0 ] - b[ 0 ], a[ 1 ] - b[ 1 ], a[ 2 ] - b[ 2 ] ];\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar normalize = function ( a ) {\r\n\t\r\n\t\t\t\tvar l = Math.sqrt( a[ 0 ] * a[ 0 ] + a[ 1 ] * a[ 1 ] + a[ 2 ] * a[ 2 ] );\r\n\t\t\t\treturn [ a[ 0 ] / l, a[ 1 ] / l, a[ 2 ] / l ];\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tdepth = depth | 1;\r\n\t\r\n\t\t\tvar width = image.width;\r\n\t\t\tvar height = image.height;\r\n\t\r\n\t\t\tvar canvas = document.createElement( 'canvas' );\r\n\t\t\tcanvas.width = width;\r\n\t\t\tcanvas.height = height;\r\n\t\r\n\t\t\tvar context = canvas.getContext( '2d' );\r\n\t\t\tcontext.drawImage( image, 0, 0 );\r\n\t\r\n\t\t\tvar data = context.getImageData( 0, 0, width, height ).data;\r\n\t\t\tvar imageData = context.createImageData( width, height );\r\n\t\t\tvar output = imageData.data;\r\n\t\r\n\t\t\tfor ( var x = 0; x < width; x ++ ) {\r\n\t\r\n\t\t\t\tfor ( var y = 0; y < height; y ++ ) {\r\n\t\r\n\t\t\t\t\tvar ly = y - 1 < 0 ? 0 : y - 1;\r\n\t\t\t\t\tvar uy = y + 1 > height - 1 ? height - 1 : y + 1;\r\n\t\t\t\t\tvar lx = x - 1 < 0 ? 0 : x - 1;\r\n\t\t\t\t\tvar ux = x + 1 > width - 1 ? width - 1 : x + 1;\r\n\t\r\n\t\t\t\t\tvar points = [];\r\n\t\t\t\t\tvar origin = [ 0, 0, data[ ( y * width + x ) * 4 ] / 255 * depth ];\r\n\t\t\t\t\tpoints.push( [ - 1, 0, data[ ( y * width + lx ) * 4 ] / 255 * depth ] );\r\n\t\t\t\t\tpoints.push( [ - 1, - 1, data[ ( ly * width + lx ) * 4 ] / 255 * depth ] );\r\n\t\t\t\t\tpoints.push( [ 0, - 1, data[ ( ly * width + x ) * 4 ] / 255 * depth ] );\r\n\t\t\t\t\tpoints.push( [ 1, - 1, data[ ( ly * width + ux ) * 4 ] / 255 * depth ] );\r\n\t\t\t\t\tpoints.push( [ 1, 0, data[ ( y * width + ux ) * 4 ] / 255 * depth ] );\r\n\t\t\t\t\tpoints.push( [ 1, 1, data[ ( uy * width + ux ) * 4 ] / 255 * depth ] );\r\n\t\t\t\t\tpoints.push( [ 0, 1, data[ ( uy * width + x ) * 4 ] / 255 * depth ] );\r\n\t\t\t\t\tpoints.push( [ - 1, 1, data[ ( uy * width + lx ) * 4 ] / 255 * depth ] );\r\n\t\r\n\t\t\t\t\tvar normals = [];\r\n\t\t\t\t\tvar num_points = points.length;\r\n\t\r\n\t\t\t\t\tfor ( var i = 0; i < num_points; i ++ ) {\r\n\t\r\n\t\t\t\t\t\tvar v1 = points[ i ];\r\n\t\t\t\t\t\tvar v2 = points[ ( i + 1 ) % num_points ];\r\n\t\t\t\t\t\tv1 = subtract( v1, origin );\r\n\t\t\t\t\t\tv2 = subtract( v2, origin );\r\n\t\t\t\t\t\tnormals.push( normalize( cross( v1, v2 ) ) );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tvar normal = [ 0, 0, 0 ];\r\n\t\r\n\t\t\t\t\tfor ( var i = 0; i < normals.length; i ++ ) {\r\n\t\r\n\t\t\t\t\t\tnormal[ 0 ] += normals[ i ][ 0 ];\r\n\t\t\t\t\t\tnormal[ 1 ] += normals[ i ][ 1 ];\r\n\t\t\t\t\t\tnormal[ 2 ] += normals[ i ][ 2 ];\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tnormal[ 0 ] /= normals.length;\r\n\t\t\t\t\tnormal[ 1 ] /= normals.length;\r\n\t\t\t\t\tnormal[ 2 ] /= normals.length;\r\n\t\r\n\t\t\t\t\tvar idx = ( y * width + x ) * 4;\r\n\t\r\n\t\t\t\t\toutput[ idx ] = ( ( normal[ 0 ] + 1.0 ) / 2.0 * 255 ) | 0;\r\n\t\t\t\t\toutput[ idx + 1 ] = ( ( normal[ 1 ] + 1.0 ) / 2.0 * 255 ) | 0;\r\n\t\t\t\t\toutput[ idx + 2 ] = ( normal[ 2 ] * 255 ) | 0;\r\n\t\t\t\t\toutput[ idx + 3 ] = 255;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tcontext.putImageData( imageData, 0, 0 );\r\n\t\r\n\t\t\treturn canvas;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tgenerateDataTexture: function ( width, height, color ) {\r\n\t\r\n\t\t\tvar size = width * height;\r\n\t\t\tvar data = new Uint8Array( 3 * size );\r\n\t\r\n\t\t\tvar r = Math.floor( color.r * 255 );\r\n\t\t\tvar g = Math.floor( color.g * 255 );\r\n\t\t\tvar b = Math.floor( color.b * 255 );\r\n\t\r\n\t\t\tfor ( var i = 0; i < size; i ++ ) {\r\n\t\r\n\t\t\t\tdata[ i * 3 ] \t   = r;\r\n\t\t\t\tdata[ i * 3 + 1 ] = g;\r\n\t\t\t\tdata[ i * 3 + 2 ] = b;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar texture = new THREE.DataTexture( data, width, height, THREE.RGBFormat );\r\n\t\t\ttexture.needsUpdate = true;\r\n\t\r\n\t\t\treturn texture;\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/extras/SceneUtils.js\r\n\t\r\n\t/**\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t */\r\n\t\r\n\tTHREE.SceneUtils = {\r\n\t\r\n\t\tcreateMultiMaterialObject: function ( geometry, materials ) {\r\n\t\r\n\t\t\tvar group = new THREE.Object3D();\r\n\t\r\n\t\t\tfor ( var i = 0, l = materials.length; i < l; i ++ ) {\r\n\t\r\n\t\t\t\tgroup.add( new THREE.Mesh( geometry, materials[ i ] ) );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn group;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tdetach: function ( child, parent, scene ) {\r\n\t\r\n\t\t\tchild.applyMatrix( parent.matrixWorld );\r\n\t\t\tparent.remove( child );\r\n\t\t\tscene.add( child );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tattach: function ( child, scene, parent ) {\r\n\t\r\n\t\t\tvar matrixWorldInverse = new THREE.Matrix4();\r\n\t\t\tmatrixWorldInverse.getInverse( parent.matrixWorld );\r\n\t\t\tchild.applyMatrix( matrixWorldInverse );\r\n\t\r\n\t\t\tscene.remove( child );\r\n\t\t\tparent.add( child );\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/extras/FontUtils.js\r\n\t\r\n\t/**\r\n\t * @author zz85 / http://www.lab4games.net/zz85/blog\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t *\r\n\t * For Text operations in three.js (See TextGeometry)\r\n\t *\r\n\t * It uses techniques used in:\r\n\t *\r\n\t * \ttypeface.js and canvastext\r\n\t * \t\tFor converting fonts and rendering with javascript\r\n\t *\t\thttp://typeface.neocracy.org\r\n\t *\r\n\t *\tTriangulation ported from AS3\r\n\t *\t\tSimple Polygon Triangulation\r\n\t *\t\thttp://actionsnippet.com/?p=1462\r\n\t *\r\n\t * \tA Method to triangulate shapes with holes\r\n\t *\t\thttp://www.sakri.net/blog/2009/06/12/an-approach-to-triangulating-polygons-with-holes/\r\n\t *\r\n\t */\r\n\t\r\n\tTHREE.FontUtils = {\r\n\t\r\n\t\tfaces: {},\r\n\t\r\n\t\t// Just for now. face[weight][style]\r\n\t\r\n\t\tface: 'helvetiker',\r\n\t\tweight: 'normal',\r\n\t\tstyle: 'normal',\r\n\t\tsize: 150,\r\n\t\tdivisions: 10,\r\n\t\r\n\t\tgetFace: function () {\r\n\t\r\n\t\t\ttry {\r\n\t\r\n\t\t\t\treturn this.faces[ this.face ][ this.weight ][ this.style ];\r\n\t\r\n\t\t\t} catch (e) {\r\n\t\r\n\t\t\t\tthrow \"The font \" + this.face + \" with \" + this.weight + \" weight and \" + this.style + \" style is missing.\"\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t},\r\n\t\r\n\t\tloadFace: function ( data ) {\r\n\t\r\n\t\t\tvar family = data.familyName.toLowerCase();\r\n\t\r\n\t\t\tvar ThreeFont = this;\r\n\t\r\n\t\t\tThreeFont.faces[ family ] = ThreeFont.faces[ family ] || {};\r\n\t\r\n\t\t\tThreeFont.faces[ family ][ data.cssFontWeight ] = ThreeFont.faces[ family ][ data.cssFontWeight ] || {};\r\n\t\t\tThreeFont.faces[ family ][ data.cssFontWeight ][ data.cssFontStyle ] = data;\r\n\t\r\n\t\t\tThreeFont.faces[ family ][ data.cssFontWeight ][ data.cssFontStyle ] = data;\r\n\t\r\n\t\t\treturn data;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tdrawText: function ( text ) {\r\n\t\r\n\t\t\t// RenderText\r\n\t\r\n\t\t\tvar i,\r\n\t\t\t\tface = this.getFace(),\r\n\t\t\t\tscale = this.size / face.resolution,\r\n\t\t\t\toffset = 0,\r\n\t\t\t\tchars = String( text ).split( '' ),\r\n\t\t\t\tlength = chars.length;\r\n\t\r\n\t\t\tvar fontPaths = [];\r\n\t\r\n\t\t\tfor ( i = 0; i < length; i ++ ) {\r\n\t\r\n\t\t\t\tvar path = new THREE.Path();\r\n\t\r\n\t\t\t\tvar ret = this.extractGlyphPoints( chars[ i ], face, scale, offset, path );\r\n\t\t\t\toffset += ret.offset;\r\n\t\r\n\t\t\t\tfontPaths.push( ret.path );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// get the width\r\n\t\r\n\t\t\tvar width = offset / 2;\r\n\t\t\t//\r\n\t\t\t// for ( p = 0; p < allPts.length; p++ ) {\r\n\t\t\t//\r\n\t\t\t// \tallPts[ p ].x -= width;\r\n\t\t\t//\r\n\t\t\t// }\r\n\t\r\n\t\t\t//var extract = this.extractPoints( allPts, characterPts );\r\n\t\t\t//extract.contour = allPts;\r\n\t\r\n\t\t\t//extract.paths = fontPaths;\r\n\t\t\t//extract.offset = width;\r\n\t\r\n\t\t\treturn { paths: fontPaths, offset: width };\r\n\t\r\n\t\t},\r\n\t\r\n\t\r\n\t\r\n\t\r\n\t\textractGlyphPoints: function ( c, face, scale, offset, path ) {\r\n\t\r\n\t\t\tvar pts = [];\r\n\t\r\n\t\t\tvar i, i2, divisions,\r\n\t\t\t\toutline, action, length,\r\n\t\t\t\tscaleX, scaleY,\r\n\t\t\t\tx, y, cpx, cpy, cpx0, cpy0, cpx1, cpy1, cpx2, cpy2,\r\n\t\t\t\tlaste,\r\n\t\t\t\tglyph = face.glyphs[ c ] || face.glyphs[ '?' ];\r\n\t\r\n\t\t\tif ( ! glyph ) return;\r\n\t\r\n\t\t\tif ( glyph.o ) {\r\n\t\r\n\t\t\t\toutline = glyph._cachedOutline || ( glyph._cachedOutline = glyph.o.split( ' ' ) );\r\n\t\t\t\tlength = outline.length;\r\n\t\r\n\t\t\t\tscaleX = scale;\r\n\t\t\t\tscaleY = scale;\r\n\t\r\n\t\t\t\tfor ( i = 0; i < length; ) {\r\n\t\r\n\t\t\t\t\taction = outline[ i ++ ];\r\n\t\r\n\t\t\t\t\t//console.log( action );\r\n\t\r\n\t\t\t\t\tswitch ( action ) {\r\n\t\r\n\t\t\t\t\tcase 'm':\r\n\t\r\n\t\t\t\t\t\t// Move To\r\n\t\r\n\t\t\t\t\t\tx = outline[ i ++ ] * scaleX + offset;\r\n\t\t\t\t\t\ty = outline[ i ++ ] * scaleY;\r\n\t\r\n\t\t\t\t\t\tpath.moveTo( x, y );\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\tcase 'l':\r\n\t\r\n\t\t\t\t\t\t// Line To\r\n\t\r\n\t\t\t\t\t\tx = outline[ i ++ ] * scaleX + offset;\r\n\t\t\t\t\t\ty = outline[ i ++ ] * scaleY;\r\n\t\t\t\t\t\tpath.lineTo( x, y );\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\tcase 'q':\r\n\t\r\n\t\t\t\t\t\t// QuadraticCurveTo\r\n\t\r\n\t\t\t\t\t\tcpx  = outline[ i ++ ] * scaleX + offset;\r\n\t\t\t\t\t\tcpy  = outline[ i ++ ] * scaleY;\r\n\t\t\t\t\t\tcpx1 = outline[ i ++ ] * scaleX + offset;\r\n\t\t\t\t\t\tcpy1 = outline[ i ++ ] * scaleY;\r\n\t\r\n\t\t\t\t\t\tpath.quadraticCurveTo( cpx1, cpy1, cpx, cpy );\r\n\t\r\n\t\t\t\t\t\tlaste = pts[ pts.length - 1 ];\r\n\t\r\n\t\t\t\t\t\tif ( laste ) {\r\n\t\r\n\t\t\t\t\t\t\tcpx0 = laste.x;\r\n\t\t\t\t\t\t\tcpy0 = laste.y;\r\n\t\r\n\t\t\t\t\t\t\tfor ( i2 = 1, divisions = this.divisions; i2 <= divisions; i2 ++ ) {\r\n\t\r\n\t\t\t\t\t\t\t\tvar t = i2 / divisions;\r\n\t\t\t\t\t\t\t\tTHREE.Shape.Utils.b2( t, cpx0, cpx1, cpx );\r\n\t\t\t\t\t\t\t\tTHREE.Shape.Utils.b2( t, cpy0, cpy1, cpy );\r\n\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\tcase 'b':\r\n\t\r\n\t\t\t\t\t\t// Cubic Bezier Curve\r\n\t\r\n\t\t\t\t\t\tcpx  = outline[ i ++ ] *  scaleX + offset;\r\n\t\t\t\t\t\tcpy  = outline[ i ++ ] *  scaleY;\r\n\t\t\t\t\t\tcpx1 = outline[ i ++ ] *  scaleX + offset;\r\n\t\t\t\t\t\tcpy1 = outline[ i ++ ] *  scaleY;\r\n\t\t\t\t\t\tcpx2 = outline[ i ++ ] *  scaleX + offset;\r\n\t\t\t\t\t\tcpy2 = outline[ i ++ ] *  scaleY;\r\n\t\r\n\t\t\t\t\t\tpath.bezierCurveTo( cpx1, cpy1, cpx2, cpy2, cpx, cpy );\r\n\t\r\n\t\t\t\t\t\tlaste = pts[ pts.length - 1 ];\r\n\t\r\n\t\t\t\t\t\tif ( laste ) {\r\n\t\r\n\t\t\t\t\t\t\tcpx0 = laste.x;\r\n\t\t\t\t\t\t\tcpy0 = laste.y;\r\n\t\r\n\t\t\t\t\t\t\tfor ( i2 = 1, divisions = this.divisions; i2 <= divisions; i2 ++ ) {\r\n\t\r\n\t\t\t\t\t\t\t\tvar t = i2 / divisions;\r\n\t\t\t\t\t\t\t\tTHREE.Shape.Utils.b3( t, cpx0, cpx1, cpx2, cpx );\r\n\t\t\t\t\t\t\t\tTHREE.Shape.Utils.b3( t, cpy0, cpy1, cpy2, cpy );\r\n\t\r\n\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\r\n\t\r\n\t\r\n\t\t\treturn { offset: glyph.ha * scale, path:path };\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t\r\n\tTHREE.FontUtils.generateShapes = function ( text, parameters ) {\r\n\t\r\n\t\t// Parameters \r\n\t\r\n\t\tparameters = parameters || {};\r\n\t\r\n\t\tvar size = parameters.size !== undefined ? parameters.size : 100;\r\n\t\tvar curveSegments = parameters.curveSegments !== undefined ? parameters.curveSegments : 4;\r\n\t\r\n\t\tvar font = parameters.font !== undefined ? parameters.font : 'helvetiker';\r\n\t\tvar weight = parameters.weight !== undefined ? parameters.weight : 'normal';\r\n\t\tvar style = parameters.style !== undefined ? parameters.style : 'normal';\r\n\t\r\n\t\tTHREE.FontUtils.size = size;\r\n\t\tTHREE.FontUtils.divisions = curveSegments;\r\n\t\r\n\t\tTHREE.FontUtils.face = font;\r\n\t\tTHREE.FontUtils.weight = weight;\r\n\t\tTHREE.FontUtils.style = style;\r\n\t\r\n\t\t// Get a Font data json object\r\n\t\r\n\t\tvar data = THREE.FontUtils.drawText( text );\r\n\t\r\n\t\tvar paths = data.paths;\r\n\t\tvar shapes = [];\r\n\t\r\n\t\tfor ( var p = 0, pl = paths.length; p < pl; p ++ ) {\r\n\t\r\n\t\t\tArray.prototype.push.apply( shapes, paths[ p ].toShapes() );\r\n\t\r\n\t\t}\r\n\t\r\n\t\treturn shapes;\r\n\t\r\n\t};\r\n\t\r\n\t\r\n\t/**\r\n\t * This code is a quick port of code written in C++ which was submitted to\r\n\t * flipcode.com by John W. Ratcliff  // July 22, 2000\r\n\t * See original code and more information here:\r\n\t * http://www.flipcode.com/archives/Efficient_Polygon_Triangulation.shtml\r\n\t *\r\n\t * ported to actionscript by Zevan Rosser\r\n\t * www.actionsnippet.com\r\n\t *\r\n\t * ported to javascript by Joshua Koo\r\n\t * http://www.lab4games.net/zz85/blog\r\n\t *\r\n\t */\r\n\t\r\n\t\r\n\t( function ( namespace ) {\r\n\t\r\n\t\tvar EPSILON = 0.0000000001;\r\n\t\r\n\t\t// takes in an contour array and returns\r\n\t\r\n\t\tvar process = function ( contour, indices ) {\r\n\t\r\n\t\t\tvar n = contour.length;\r\n\t\r\n\t\t\tif ( n < 3 ) return null;\r\n\t\r\n\t\t\tvar result = [],\r\n\t\t\t\tverts = [],\r\n\t\t\t\tvertIndices = [];\r\n\t\r\n\t\t\t/* we want a counter-clockwise polygon in verts */\r\n\t\r\n\t\t\tvar u, v, w;\r\n\t\r\n\t\t\tif ( area( contour ) > 0.0 ) {\r\n\t\r\n\t\t\t\tfor ( v = 0; v < n; v ++ ) verts[ v ] = v;\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\tfor ( v = 0; v < n; v ++ ) verts[ v ] = ( n - 1 ) - v;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar nv = n;\r\n\t\r\n\t\t\t/*  remove nv - 2 vertices, creating 1 triangle every time */\r\n\t\r\n\t\t\tvar count = 2 * nv;   /* error detection */\r\n\t\r\n\t\t\tfor ( v = nv - 1; nv > 2; ) {\r\n\t\r\n\t\t\t\t/* if we loop, it is probably a non-simple polygon */\r\n\t\r\n\t\t\t\tif ( ( count -- ) <= 0 ) {\r\n\t\r\n\t\t\t\t\t//** Triangulate: ERROR - probable bad polygon!\r\n\t\r\n\t\t\t\t\t//throw ( \"Warning, unable to triangulate polygon!\" );\r\n\t\t\t\t\t//return null;\r\n\t\t\t\t\t// Sometimes warning is fine, especially polygons are triangulated in reverse.\r\n\t\t\t\t\tTHREE.warn( 'THREE.FontUtils: Warning, unable to triangulate polygon! in Triangulate.process()' );\r\n\t\r\n\t\t\t\t\tif ( indices ) return vertIndices;\r\n\t\t\t\t\treturn result;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\t/* three consecutive vertices in current polygon, <u,v,w> */\r\n\t\r\n\t\t\t\tu = v; \t \tif ( nv <= u ) u = 0;     /* previous */\r\n\t\t\t\tv = u + 1;  if ( nv <= v ) v = 0;     /* new v    */\r\n\t\t\t\tw = v + 1;  if ( nv <= w ) w = 0;     /* next     */\r\n\t\r\n\t\t\t\tif ( snip( contour, u, v, w, nv, verts ) ) {\r\n\t\r\n\t\t\t\t\tvar a, b, c, s, t;\r\n\t\r\n\t\t\t\t\t/* true names of the vertices */\r\n\t\r\n\t\t\t\t\ta = verts[ u ];\r\n\t\t\t\t\tb = verts[ v ];\r\n\t\t\t\t\tc = verts[ w ];\r\n\t\r\n\t\t\t\t\t/* output Triangle */\r\n\t\r\n\t\t\t\t\tresult.push( [ contour[ a ],\r\n\t\t\t\t\t\tcontour[ b ],\r\n\t\t\t\t\t\tcontour[ c ] ] );\r\n\t\r\n\t\r\n\t\t\t\t\tvertIndices.push( [ verts[ u ], verts[ v ], verts[ w ] ] );\r\n\t\r\n\t\t\t\t\t/* remove v from the remaining polygon */\r\n\t\r\n\t\t\t\t\tfor ( s = v, t = v + 1; t < nv; s ++, t ++ ) {\r\n\t\r\n\t\t\t\t\t\tverts[ s ] = verts[ t ];\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tnv --;\r\n\t\r\n\t\t\t\t\t/* reset error detection counter */\r\n\t\r\n\t\t\t\t\tcount = 2 * nv;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( indices ) return vertIndices;\r\n\t\t\treturn result;\r\n\t\r\n\t\t};\r\n\t\r\n\t\t// calculate area of the contour polygon\r\n\t\r\n\t\tvar area = function ( contour ) {\r\n\t\r\n\t\t\tvar n = contour.length;\r\n\t\t\tvar a = 0.0;\r\n\t\r\n\t\t\tfor ( var p = n - 1, q = 0; q < n; p = q ++ ) {\r\n\t\r\n\t\t\t\ta += contour[ p ].x * contour[ q ].y - contour[ q ].x * contour[ p ].y;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn a * 0.5;\r\n\t\r\n\t\t};\r\n\t\r\n\t\tvar snip = function ( contour, u, v, w, n, verts ) {\r\n\t\r\n\t\t\tvar p;\r\n\t\t\tvar ax, ay, bx, by;\r\n\t\t\tvar cx, cy, px, py;\r\n\t\r\n\t\t\tax = contour[ verts[ u ] ].x;\r\n\t\t\tay = contour[ verts[ u ] ].y;\r\n\t\r\n\t\t\tbx = contour[ verts[ v ] ].x;\r\n\t\t\tby = contour[ verts[ v ] ].y;\r\n\t\r\n\t\t\tcx = contour[ verts[ w ] ].x;\r\n\t\t\tcy = contour[ verts[ w ] ].y;\r\n\t\r\n\t\t\tif ( EPSILON > ( ( ( bx - ax ) * ( cy - ay ) ) - ( ( by - ay ) * ( cx - ax ) ) ) ) return false;\r\n\t\r\n\t\t\tvar aX, aY, bX, bY, cX, cY;\r\n\t\t\tvar apx, apy, bpx, bpy, cpx, cpy;\r\n\t\t\tvar cCROSSap, bCROSScp, aCROSSbp;\r\n\t\r\n\t\t\taX = cx - bx;  aY = cy - by;\r\n\t\t\tbX = ax - cx;  bY = ay - cy;\r\n\t\t\tcX = bx - ax;  cY = by - ay;\r\n\t\r\n\t\t\tfor ( p = 0; p < n; p ++ ) {\r\n\t\r\n\t\t\t\tpx = contour[ verts[ p ] ].x\r\n\t\t\t\tpy = contour[ verts[ p ] ].y\r\n\t\r\n\t\t\t\tif ( ( ( px === ax ) && ( py === ay ) ) ||\r\n\t\t\t\t\t ( ( px === bx ) && ( py === by ) ) ||\r\n\t\t\t\t\t ( ( px === cx ) && ( py === cy ) ) )\tcontinue;\r\n\t\r\n\t\t\t\tapx = px - ax;  apy = py - ay;\r\n\t\t\t\tbpx = px - bx;  bpy = py - by;\r\n\t\t\t\tcpx = px - cx;  cpy = py - cy;\r\n\t\r\n\t\t\t\t// see if p is inside triangle abc\r\n\t\r\n\t\t\t\taCROSSbp = aX * bpy - aY * bpx;\r\n\t\t\t\tcCROSSap = cX * apy - cY * apx;\r\n\t\t\t\tbCROSScp = bX * cpy - bY * cpx;\r\n\t\r\n\t\t\t\tif ( ( aCROSSbp >= - EPSILON ) && ( bCROSScp >= - EPSILON ) && ( cCROSSap >= - EPSILON ) ) return false;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn true;\r\n\t\r\n\t\t};\r\n\t\r\n\t\r\n\t\tnamespace.Triangulate = process;\r\n\t\tnamespace.Triangulate.area = area;\r\n\t\r\n\t\treturn namespace;\r\n\t\r\n\t} )( THREE.FontUtils );\r\n\t\r\n\t// To use the typeface.js face files, hook up the API\r\n\tself._typeface_js = { faces: THREE.FontUtils.faces, loadFace: THREE.FontUtils.loadFace };\r\n\tTHREE.typeface_js = self._typeface_js;\r\n\t\r\n\t// File:src/extras/audio/Audio.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tTHREE.Audio = function ( listener ) {\r\n\t\r\n\t\tTHREE.Object3D.call( this );\r\n\t\r\n\t\tthis.type = 'Audio';\r\n\t\r\n\t\tthis.context = listener.context;\r\n\t\tthis.source = this.context.createBufferSource();\r\n\t\tthis.source.onended = this.onEnded.bind(this);\r\n\t\r\n\t\tthis.gain = this.context.createGain();\r\n\t\tthis.gain.connect( this.context.destination );\r\n\t\r\n\t\tthis.panner = this.context.createPanner();\r\n\t\tthis.panner.connect( this.gain );\r\n\t\r\n\t\tthis.autoplay = false;\r\n\t\r\n\t\tthis.startTime = 0;\r\n\t\tthis.isPlaying = false;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Audio.prototype = Object.create( THREE.Object3D.prototype );\r\n\tTHREE.Audio.prototype.constructor = THREE.Audio;\r\n\t\r\n\tTHREE.Audio.prototype.load = function ( file ) {\r\n\t\r\n\t\tvar scope = this;\r\n\t\r\n\t\tvar request = new XMLHttpRequest();\r\n\t\trequest.open( 'GET', file, true );\r\n\t\trequest.responseType = 'arraybuffer';\r\n\t\trequest.onload = function ( e ) {\r\n\t\r\n\t\t\tscope.context.decodeAudioData( this.response, function ( buffer ) {\r\n\t\r\n\t\t\t\tscope.source.buffer = buffer;\r\n\t\r\n\t\t\t\tif( scope.autoplay ) scope.play();\r\n\t\r\n\t\t\t} );\r\n\t\r\n\t\t};\r\n\t\trequest.send();\r\n\t\r\n\t\treturn this;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Audio.prototype.play = function () {\r\n\t\r\n\t\tif ( this.isPlaying === true ) {\r\n\t\r\n\t\t\tTHREE.warn( 'THREE.Audio: Audio is already playing.' );\r\n\t\t\treturn;\r\n\t\r\n\t\t}\r\n\t\r\n\t\tvar source = this.context.createBufferSource();\r\n\t\r\n\t\tsource.buffer = this.source.buffer;\r\n\t\tsource.loop = this.source.loop;\r\n\t\tsource.onended = this.source.onended;\r\n\t\tsource.connect( this.panner );\r\n\t\tsource.start( 0, this.startTime );\r\n\t\r\n\t\tthis.isPlaying = true;\r\n\t\r\n\t\tthis.source = source;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Audio.prototype.pause = function () {\r\n\t\r\n\t\tthis.source.stop();\r\n\t\tthis.startTime = this.context.currentTime;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Audio.prototype.stop = function () {\r\n\t\r\n\t\tthis.source.stop();\r\n\t\tthis.startTime = 0;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Audio.prototype.onEnded = function() {\r\n\t\r\n\t\tthis.isPlaying = false;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Audio.prototype.setLoop = function ( value ) {\r\n\t\r\n\t\tthis.source.loop = value;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Audio.prototype.setRefDistance = function ( value ) {\r\n\t\r\n\t\tthis.panner.refDistance = value;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Audio.prototype.setRolloffFactor = function ( value ) {\r\n\t\r\n\t\tthis.panner.rolloffFactor = value;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Audio.prototype.setVolume = function ( value ) {\r\n\t\r\n\t\tthis.gain.gain.value = value;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Audio.prototype.updateMatrixWorld = ( function () {\r\n\t\r\n\t\tvar position = new THREE.Vector3();\r\n\t\r\n\t\treturn function ( force ) {\r\n\t\r\n\t\t\tTHREE.Object3D.prototype.updateMatrixWorld.call( this, force );\r\n\t\r\n\t\t\tposition.setFromMatrixPosition( this.matrixWorld );\r\n\t\r\n\t\t\tthis.panner.setPosition( position.x, position.y, position.z );\r\n\t\r\n\t\t};\r\n\t\r\n\t} )();\r\n\t\r\n\t// File:src/extras/audio/AudioListener.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tTHREE.AudioListener = function () {\r\n\t\r\n\t\tTHREE.Object3D.call( this );\r\n\t\r\n\t\tthis.type = 'AudioListener';\r\n\t\r\n\t\tthis.context = new ( window.AudioContext || window.webkitAudioContext )();\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.AudioListener.prototype = Object.create( THREE.Object3D.prototype );\r\n\tTHREE.AudioListener.prototype.constructor = THREE.AudioListener;\r\n\t\r\n\tTHREE.AudioListener.prototype.updateMatrixWorld = ( function () {\r\n\t\r\n\t\tvar position = new THREE.Vector3();\r\n\t\tvar quaternion = new THREE.Quaternion();\r\n\t\tvar scale = new THREE.Vector3();\r\n\t\r\n\t\tvar orientation = new THREE.Vector3();\r\n\t\tvar velocity = new THREE.Vector3();\r\n\t\r\n\t\tvar positionPrev = new THREE.Vector3();\r\n\t\r\n\t\treturn function ( force ) {\r\n\t\r\n\t\t\tTHREE.Object3D.prototype.updateMatrixWorld.call( this, force );\r\n\t\r\n\t\t\tvar listener = this.context.listener;\r\n\t\t\tvar up = this.up;\r\n\t\r\n\t\t\tthis.matrixWorld.decompose( position, quaternion, scale );\r\n\t\r\n\t\t\torientation.set( 0, 0, -1 ).applyQuaternion( quaternion );\r\n\t\t\tvelocity.subVectors( position, positionPrev );\r\n\t\r\n\t\t\tlistener.setPosition( position.x, position.y, position.z );\r\n\t\t\tlistener.setOrientation( orientation.x, orientation.y, orientation.z, up.x, up.y, up.z );\r\n\t\t\tlistener.setVelocity( velocity.x, velocity.y, velocity.z );\r\n\t\r\n\t\t\tpositionPrev.copy( position );\r\n\t\r\n\t\t};\r\n\t\r\n\t} )();\r\n\t\r\n\t// File:src/extras/core/Curve.js\r\n\t\r\n\t/**\r\n\t * @author zz85 / http://www.lab4games.net/zz85/blog\r\n\t * Extensible curve object\r\n\t *\r\n\t * Some common of Curve methods\r\n\t * .getPoint(t), getTangent(t)\r\n\t * .getPointAt(u), getTagentAt(u)\r\n\t * .getPoints(), .getSpacedPoints()\r\n\t * .getLength()\r\n\t * .updateArcLengths()\r\n\t *\r\n\t * This following classes subclasses THREE.Curve:\r\n\t *\r\n\t * -- 2d classes --\r\n\t * THREE.LineCurve\r\n\t * THREE.QuadraticBezierCurve\r\n\t * THREE.CubicBezierCurve\r\n\t * THREE.SplineCurve\r\n\t * THREE.ArcCurve\r\n\t * THREE.EllipseCurve\r\n\t *\r\n\t * -- 3d classes --\r\n\t * THREE.LineCurve3\r\n\t * THREE.QuadraticBezierCurve3\r\n\t * THREE.CubicBezierCurve3\r\n\t * THREE.SplineCurve3\r\n\t * THREE.ClosedSplineCurve3\r\n\t *\r\n\t * A series of curves can be represented as a THREE.CurvePath\r\n\t *\r\n\t **/\r\n\t\r\n\t/**************************************************************\r\n\t *\tAbstract Curve base class\r\n\t **************************************************************/\r\n\t\r\n\tTHREE.Curve = function () {\r\n\t\r\n\t};\r\n\t\r\n\t// Virtual base class method to overwrite and implement in subclasses\r\n\t//\t- t [0 .. 1]\r\n\t\r\n\tTHREE.Curve.prototype.getPoint = function ( t ) {\r\n\t\r\n\t\tTHREE.warn( \"THREE.Curve: Warning, getPoint() not implemented!\" );\r\n\t\treturn null;\r\n\t\r\n\t};\r\n\t\r\n\t// Get point at relative position in curve according to arc length\r\n\t// - u [0 .. 1]\r\n\t\r\n\tTHREE.Curve.prototype.getPointAt = function ( u ) {\r\n\t\r\n\t\tvar t = this.getUtoTmapping( u );\r\n\t\treturn this.getPoint( t );\r\n\t\r\n\t};\r\n\t\r\n\t// Get sequence of points using getPoint( t )\r\n\t\r\n\tTHREE.Curve.prototype.getPoints = function ( divisions ) {\r\n\t\r\n\t\tif ( ! divisions ) divisions = 5;\r\n\t\r\n\t\tvar d, pts = [];\r\n\t\r\n\t\tfor ( d = 0; d <= divisions; d ++ ) {\r\n\t\r\n\t\t\tpts.push( this.getPoint( d / divisions ) );\r\n\t\r\n\t\t}\r\n\t\r\n\t\treturn pts;\r\n\t\r\n\t};\r\n\t\r\n\t// Get sequence of points using getPointAt( u )\r\n\t\r\n\tTHREE.Curve.prototype.getSpacedPoints = function ( divisions ) {\r\n\t\r\n\t\tif ( ! divisions ) divisions = 5;\r\n\t\r\n\t\tvar d, pts = [];\r\n\t\r\n\t\tfor ( d = 0; d <= divisions; d ++ ) {\r\n\t\r\n\t\t\tpts.push( this.getPointAt( d / divisions ) );\r\n\t\r\n\t\t}\r\n\t\r\n\t\treturn pts;\r\n\t\r\n\t};\r\n\t\r\n\t// Get total curve arc length\r\n\t\r\n\tTHREE.Curve.prototype.getLength = function () {\r\n\t\r\n\t\tvar lengths = this.getLengths();\r\n\t\treturn lengths[ lengths.length - 1 ];\r\n\t\r\n\t};\r\n\t\r\n\t// Get list of cumulative segment lengths\r\n\t\r\n\tTHREE.Curve.prototype.getLengths = function ( divisions ) {\r\n\t\r\n\t\tif ( ! divisions ) divisions = (this.__arcLengthDivisions) ? (this.__arcLengthDivisions) : 200;\r\n\t\r\n\t\tif ( this.cacheArcLengths\r\n\t\t\t&& ( this.cacheArcLengths.length == divisions + 1 )\r\n\t\t\t&& ! this.needsUpdate) {\r\n\t\r\n\t\t\t//console.log( \"cached\", this.cacheArcLengths );\r\n\t\t\treturn this.cacheArcLengths;\r\n\t\r\n\t\t}\r\n\t\r\n\t\tthis.needsUpdate = false;\r\n\t\r\n\t\tvar cache = [];\r\n\t\tvar current, last = this.getPoint( 0 );\r\n\t\tvar p, sum = 0;\r\n\t\r\n\t\tcache.push( 0 );\r\n\t\r\n\t\tfor ( p = 1; p <= divisions; p ++ ) {\r\n\t\r\n\t\t\tcurrent = this.getPoint ( p / divisions );\r\n\t\t\tsum += current.distanceTo( last );\r\n\t\t\tcache.push( sum );\r\n\t\t\tlast = current;\r\n\t\r\n\t\t}\r\n\t\r\n\t\tthis.cacheArcLengths = cache;\r\n\t\r\n\t\treturn cache; // { sums: cache, sum:sum }; Sum is in the last element.\r\n\t\r\n\t};\r\n\t\r\n\t\r\n\tTHREE.Curve.prototype.updateArcLengths = function() {\r\n\t\tthis.needsUpdate = true;\r\n\t\tthis.getLengths();\r\n\t};\r\n\t\r\n\t// Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equi distance\r\n\t\r\n\tTHREE.Curve.prototype.getUtoTmapping = function ( u, distance ) {\r\n\t\r\n\t\tvar arcLengths = this.getLengths();\r\n\t\r\n\t\tvar i = 0, il = arcLengths.length;\r\n\t\r\n\t\tvar targetArcLength; // The targeted u distance value to get\r\n\t\r\n\t\tif ( distance ) {\r\n\t\r\n\t\t\ttargetArcLength = distance;\r\n\t\r\n\t\t} else {\r\n\t\r\n\t\t\ttargetArcLength = u * arcLengths[ il - 1 ];\r\n\t\r\n\t\t}\r\n\t\r\n\t\t//var time = Date.now();\r\n\t\r\n\t\t// binary search for the index with largest value smaller than target u distance\r\n\t\r\n\t\tvar low = 0, high = il - 1, comparison;\r\n\t\r\n\t\twhile ( low <= high ) {\r\n\t\r\n\t\t\ti = Math.floor( low + ( high - low ) / 2 ); // less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats\r\n\t\r\n\t\t\tcomparison = arcLengths[ i ] - targetArcLength;\r\n\t\r\n\t\t\tif ( comparison < 0 ) {\r\n\t\r\n\t\t\t\tlow = i + 1;\r\n\t\r\n\t\t\t} else if ( comparison > 0 ) {\r\n\t\r\n\t\t\t\thigh = i - 1;\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\thigh = i;\r\n\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t// DONE\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\ti = high;\r\n\t\r\n\t\t//console.log('b' , i, low, high, Date.now()- time);\r\n\t\r\n\t\tif ( arcLengths[ i ] == targetArcLength ) {\r\n\t\r\n\t\t\tvar t = i / ( il - 1 );\r\n\t\t\treturn t;\r\n\t\r\n\t\t}\r\n\t\r\n\t\t// we could get finer grain at lengths, or use simple interpolatation between two points\r\n\t\r\n\t\tvar lengthBefore = arcLengths[ i ];\r\n\t\tvar lengthAfter = arcLengths[ i + 1 ];\r\n\t\r\n\t\tvar segmentLength = lengthAfter - lengthBefore;\r\n\t\r\n\t    // determine where we are between the 'before' and 'after' points\r\n\t\r\n\t\tvar segmentFraction = ( targetArcLength - lengthBefore ) / segmentLength;\r\n\t\r\n\t    // add that fractional amount to t\r\n\t\r\n\t\tvar t = ( i + segmentFraction ) / ( il - 1 );\r\n\t\r\n\t\treturn t;\r\n\t\r\n\t};\r\n\t\r\n\t// Returns a unit vector tangent at t\r\n\t// In case any sub curve does not implement its tangent derivation,\r\n\t// 2 points a small delta apart will be used to find its gradient\r\n\t// which seems to give a reasonable approximation\r\n\t\r\n\tTHREE.Curve.prototype.getTangent = function( t ) {\r\n\t\r\n\t\tvar delta = 0.0001;\r\n\t\tvar t1 = t - delta;\r\n\t\tvar t2 = t + delta;\r\n\t\r\n\t\t// Capping in case of danger\r\n\t\r\n\t\tif ( t1 < 0 ) t1 = 0;\r\n\t\tif ( t2 > 1 ) t2 = 1;\r\n\t\r\n\t\tvar pt1 = this.getPoint( t1 );\r\n\t\tvar pt2 = this.getPoint( t2 );\r\n\t\r\n\t\tvar vec = pt2.clone().sub(pt1);\r\n\t\treturn vec.normalize();\r\n\t\r\n\t};\r\n\t\r\n\t\r\n\tTHREE.Curve.prototype.getTangentAt = function ( u ) {\r\n\t\r\n\t\tvar t = this.getUtoTmapping( u );\r\n\t\treturn this.getTangent( t );\r\n\t\r\n\t};\r\n\t\r\n\t\r\n\t\r\n\t\r\n\t\r\n\t/**************************************************************\r\n\t *\tUtils\r\n\t **************************************************************/\r\n\t\r\n\tTHREE.Curve.Utils = {\r\n\t\r\n\t\ttangentQuadraticBezier: function ( t, p0, p1, p2 ) {\r\n\t\r\n\t\t\treturn 2 * ( 1 - t ) * ( p1 - p0 ) + 2 * t * ( p2 - p1 );\r\n\t\r\n\t\t},\r\n\t\r\n\t\t// Puay Bing, thanks for helping with this derivative!\r\n\t\r\n\t\ttangentCubicBezier: function (t, p0, p1, p2, p3 ) {\r\n\t\r\n\t\t\treturn - 3 * p0 * (1 - t) * (1 - t)  +\r\n\t\t\t\t3 * p1 * (1 - t) * (1 - t) - 6 * t * p1 * (1 - t) +\r\n\t\t\t\t6 * t *  p2 * (1 - t) - 3 * t * t * p2 +\r\n\t\t\t\t3 * t * t * p3;\r\n\t\r\n\t\t},\r\n\t\r\n\t\ttangentSpline: function ( t, p0, p1, p2, p3 ) {\r\n\t\r\n\t\t\t// To check if my formulas are correct\r\n\t\r\n\t\t\tvar h00 = 6 * t * t - 6 * t; \t// derived from 2t^3 − 3t^2 + 1\r\n\t\t\tvar h10 = 3 * t * t - 4 * t + 1; // t^3 − 2t^2 + t\r\n\t\t\tvar h01 = - 6 * t * t + 6 * t; \t// − 2t3 + 3t2\r\n\t\t\tvar h11 = 3 * t * t - 2 * t;\t// t3 − t2\r\n\t\r\n\t\t\treturn h00 + h10 + h01 + h11;\r\n\t\r\n\t\t},\r\n\t\r\n\t\t// Catmull-Rom\r\n\t\r\n\t\tinterpolate: function( p0, p1, p2, p3, t ) {\r\n\t\r\n\t\t\tvar v0 = ( p2 - p0 ) * 0.5;\r\n\t\t\tvar v1 = ( p3 - p1 ) * 0.5;\r\n\t\t\tvar t2 = t * t;\r\n\t\t\tvar t3 = t * t2;\r\n\t\t\treturn ( 2 * p1 - 2 * p2 + v0 + v1 ) * t3 + ( - 3 * p1 + 3 * p2 - 2 * v0 - v1 ) * t2 + v0 * t + p1;\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t\r\n\t// TODO: Transformation for Curves?\r\n\t\r\n\t/**************************************************************\r\n\t *\t3D Curves\r\n\t **************************************************************/\r\n\t\r\n\t// A Factory method for creating new curve subclasses\r\n\t\r\n\tTHREE.Curve.create = function ( constructor, getPointFunc ) {\r\n\t\r\n\t\tconstructor.prototype = Object.create( THREE.Curve.prototype );\r\n\t\tconstructor.prototype.constructor = constructor;\r\n\t\tconstructor.prototype.getPoint = getPointFunc;\r\n\t\r\n\t\treturn constructor;\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/extras/core/CurvePath.js\r\n\t\r\n\t/**\r\n\t * @author zz85 / http://www.lab4games.net/zz85/blog\r\n\t *\r\n\t **/\r\n\t\r\n\t/**************************************************************\r\n\t *\tCurved Path - a curve path is simply a array of connected\r\n\t *  curves, but retains the api of a curve\r\n\t **************************************************************/\r\n\t\r\n\tTHREE.CurvePath = function () {\r\n\t\r\n\t\tthis.curves = [];\r\n\t\tthis.bends = [];\r\n\t\t\r\n\t\tthis.autoClose = false; // Automatically closes the path\r\n\t};\r\n\t\r\n\tTHREE.CurvePath.prototype = Object.create( THREE.Curve.prototype );\r\n\tTHREE.CurvePath.prototype.constructor = THREE.CurvePath;\r\n\t\r\n\tTHREE.CurvePath.prototype.add = function ( curve ) {\r\n\t\r\n\t\tthis.curves.push( curve );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.CurvePath.prototype.checkConnection = function() {\r\n\t\t// TODO\r\n\t\t// If the ending of curve is not connected to the starting\r\n\t\t// or the next curve, then, this is not a real path\r\n\t};\r\n\t\r\n\tTHREE.CurvePath.prototype.closePath = function() {\r\n\t\t// TODO Test\r\n\t\t// and verify for vector3 (needs to implement equals)\r\n\t\t// Add a line curve if start and end of lines are not connected\r\n\t\tvar startPoint = this.curves[0].getPoint(0);\r\n\t\tvar endPoint = this.curves[this.curves.length - 1].getPoint(1);\r\n\t\t\r\n\t\tif (! startPoint.equals(endPoint)) {\r\n\t\t\tthis.curves.push( new THREE.LineCurve(endPoint, startPoint) );\r\n\t\t}\r\n\t\t\r\n\t};\r\n\t\r\n\t// To get accurate point with reference to\r\n\t// entire path distance at time t,\r\n\t// following has to be done:\r\n\t\r\n\t// 1. Length of each sub path have to be known\r\n\t// 2. Locate and identify type of curve\r\n\t// 3. Get t for the curve\r\n\t// 4. Return curve.getPointAt(t')\r\n\t\r\n\tTHREE.CurvePath.prototype.getPoint = function( t ) {\r\n\t\r\n\t\tvar d = t * this.getLength();\r\n\t\tvar curveLengths = this.getCurveLengths();\r\n\t\tvar i = 0, diff, curve;\r\n\t\r\n\t\t// To think about boundaries points.\r\n\t\r\n\t\twhile ( i < curveLengths.length ) {\r\n\t\r\n\t\t\tif ( curveLengths[ i ] >= d ) {\r\n\t\r\n\t\t\t\tdiff = curveLengths[ i ] - d;\r\n\t\t\t\tcurve = this.curves[ i ];\r\n\t\r\n\t\t\t\tvar u = 1 - diff / curve.getLength();\r\n\t\r\n\t\t\t\treturn curve.getPointAt( u );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\ti ++;\r\n\t\r\n\t\t}\r\n\t\r\n\t\treturn null;\r\n\t\r\n\t\t// loop where sum != 0, sum > d , sum+1 <d\r\n\t\r\n\t};\r\n\t\r\n\t/*\r\n\tTHREE.CurvePath.prototype.getTangent = function( t ) {\r\n\t};*/\r\n\t\r\n\t\r\n\t// We cannot use the default THREE.Curve getPoint() with getLength() because in\r\n\t// THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath\r\n\t// getPoint() depends on getLength\r\n\t\r\n\tTHREE.CurvePath.prototype.getLength = function() {\r\n\t\r\n\t\tvar lens = this.getCurveLengths();\r\n\t\treturn lens[ lens.length - 1 ];\r\n\t\r\n\t};\r\n\t\r\n\t// Compute lengths and cache them\r\n\t// We cannot overwrite getLengths() because UtoT mapping uses it.\r\n\t\r\n\tTHREE.CurvePath.prototype.getCurveLengths = function() {\r\n\t\r\n\t\t// We use cache values if curves and cache array are same length\r\n\t\r\n\t\tif ( this.cacheLengths && this.cacheLengths.length == this.curves.length ) {\r\n\t\r\n\t\t\treturn this.cacheLengths;\r\n\t\r\n\t\t};\r\n\t\r\n\t\t// Get length of subsurve\r\n\t\t// Push sums into cached array\r\n\t\r\n\t\tvar lengths = [], sums = 0;\r\n\t\tvar i, il = this.curves.length;\r\n\t\r\n\t\tfor ( i = 0; i < il; i ++ ) {\r\n\t\r\n\t\t\tsums += this.curves[ i ].getLength();\r\n\t\t\tlengths.push( sums );\r\n\t\r\n\t\t}\r\n\t\r\n\t\tthis.cacheLengths = lengths;\r\n\t\r\n\t\treturn lengths;\r\n\t\r\n\t};\r\n\t\r\n\t\r\n\t\r\n\t// Returns min and max coordinates\r\n\t\r\n\tTHREE.CurvePath.prototype.getBoundingBox = function () {\r\n\t\r\n\t\tvar points = this.getPoints();\r\n\t\r\n\t\tvar maxX, maxY, maxZ;\r\n\t\tvar minX, minY, minZ;\r\n\t\r\n\t\tmaxX = maxY = Number.NEGATIVE_INFINITY;\r\n\t\tminX = minY = Number.POSITIVE_INFINITY;\r\n\t\r\n\t\tvar p, i, il, sum;\r\n\t\r\n\t\tvar v3 = points[0] instanceof THREE.Vector3;\r\n\t\r\n\t\tsum = v3 ? new THREE.Vector3() : new THREE.Vector2();\r\n\t\r\n\t\tfor ( i = 0, il = points.length; i < il; i ++ ) {\r\n\t\r\n\t\t\tp = points[ i ];\r\n\t\r\n\t\t\tif ( p.x > maxX ) maxX = p.x;\r\n\t\t\telse if ( p.x < minX ) minX = p.x;\r\n\t\r\n\t\t\tif ( p.y > maxY ) maxY = p.y;\r\n\t\t\telse if ( p.y < minY ) minY = p.y;\r\n\t\r\n\t\t\tif ( v3 ) {\r\n\t\r\n\t\t\t\tif ( p.z > maxZ ) maxZ = p.z;\r\n\t\t\t\telse if ( p.z < minZ ) minZ = p.z;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tsum.add( p );\r\n\t\r\n\t\t}\r\n\t\r\n\t\tvar ret = {\r\n\t\r\n\t\t\tminX: minX,\r\n\t\t\tminY: minY,\r\n\t\t\tmaxX: maxX,\r\n\t\t\tmaxY: maxY\r\n\t\r\n\t\t};\r\n\t\r\n\t\tif ( v3 ) {\r\n\t\r\n\t\t\tret.maxZ = maxZ;\r\n\t\t\tret.minZ = minZ;\r\n\t\r\n\t\t}\r\n\t\r\n\t\treturn ret;\r\n\t\r\n\t};\r\n\t\r\n\t/**************************************************************\r\n\t *\tCreate Geometries Helpers\r\n\t **************************************************************/\r\n\t\r\n\t/// Generate geometry from path points (for Line or Points objects)\r\n\t\r\n\tTHREE.CurvePath.prototype.createPointsGeometry = function( divisions ) {\r\n\t\r\n\t\tvar pts = this.getPoints( divisions, true );\r\n\t\treturn this.createGeometry( pts );\r\n\t\r\n\t};\r\n\t\r\n\t// Generate geometry from equidistance sampling along the path\r\n\t\r\n\tTHREE.CurvePath.prototype.createSpacedPointsGeometry = function( divisions ) {\r\n\t\r\n\t\tvar pts = this.getSpacedPoints( divisions, true );\r\n\t\treturn this.createGeometry( pts );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.CurvePath.prototype.createGeometry = function( points ) {\r\n\t\r\n\t\tvar geometry = new THREE.Geometry();\r\n\t\r\n\t\tfor ( var i = 0; i < points.length; i ++ ) {\r\n\t\r\n\t\t\tgeometry.vertices.push( new THREE.Vector3( points[ i ].x, points[ i ].y, points[ i ].z || 0) );\r\n\t\r\n\t\t}\r\n\t\r\n\t\treturn geometry;\r\n\t\r\n\t};\r\n\t\r\n\t\r\n\t/**************************************************************\r\n\t *\tBend / Wrap Helper Methods\r\n\t **************************************************************/\r\n\t\r\n\t// Wrap path / Bend modifiers?\r\n\t\r\n\tTHREE.CurvePath.prototype.addWrapPath = function ( bendpath ) {\r\n\t\r\n\t\tthis.bends.push( bendpath );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.CurvePath.prototype.getTransformedPoints = function( segments, bends ) {\r\n\t\r\n\t\tvar oldPts = this.getPoints( segments ); // getPoints getSpacedPoints\r\n\t\tvar i, il;\r\n\t\r\n\t\tif ( ! bends ) {\r\n\t\r\n\t\t\tbends = this.bends;\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfor ( i = 0, il = bends.length; i < il; i ++ ) {\r\n\t\r\n\t\t\toldPts = this.getWrapPoints( oldPts, bends[ i ] );\r\n\t\r\n\t\t}\r\n\t\r\n\t\treturn oldPts;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.CurvePath.prototype.getTransformedSpacedPoints = function( segments, bends ) {\r\n\t\r\n\t\tvar oldPts = this.getSpacedPoints( segments );\r\n\t\r\n\t\tvar i, il;\r\n\t\r\n\t\tif ( ! bends ) {\r\n\t\r\n\t\t\tbends = this.bends;\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfor ( i = 0, il = bends.length; i < il; i ++ ) {\r\n\t\r\n\t\t\toldPts = this.getWrapPoints( oldPts, bends[ i ] );\r\n\t\r\n\t\t}\r\n\t\r\n\t\treturn oldPts;\r\n\t\r\n\t};\r\n\t\r\n\t// This returns getPoints() bend/wrapped around the contour of a path.\r\n\t// Read http://www.planetclegg.com/projects/WarpingTextToSplines.html\r\n\t\r\n\tTHREE.CurvePath.prototype.getWrapPoints = function ( oldPts, path ) {\r\n\t\r\n\t\tvar bounds = this.getBoundingBox();\r\n\t\r\n\t\tvar i, il, p, oldX, oldY, xNorm;\r\n\t\r\n\t\tfor ( i = 0, il = oldPts.length; i < il; i ++ ) {\r\n\t\r\n\t\t\tp = oldPts[ i ];\r\n\t\r\n\t\t\toldX = p.x;\r\n\t\t\toldY = p.y;\r\n\t\r\n\t\t\txNorm = oldX / bounds.maxX;\r\n\t\r\n\t\t\t// If using actual distance, for length > path, requires line extrusions\r\n\t\t\t//xNorm = path.getUtoTmapping(xNorm, oldX); // 3 styles. 1) wrap stretched. 2) wrap stretch by arc length 3) warp by actual distance\r\n\t\r\n\t\t\txNorm = path.getUtoTmapping( xNorm, oldX );\r\n\t\r\n\t\t\t// check for out of bounds?\r\n\t\r\n\t\t\tvar pathPt = path.getPoint( xNorm );\r\n\t\t\tvar normal = path.getTangent( xNorm );\r\n\t\t\tnormal.set( - normal.y, normal.x ).multiplyScalar( oldY );\r\n\t\r\n\t\t\tp.x = pathPt.x + normal.x;\r\n\t\t\tp.y = pathPt.y + normal.y;\r\n\t\r\n\t\t}\r\n\t\r\n\t\treturn oldPts;\r\n\t\r\n\t};\r\n\t\r\n\t\r\n\t// File:src/extras/core/Gyroscope.js\r\n\t\r\n\t/**\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t */\r\n\t\r\n\tTHREE.Gyroscope = function () {\r\n\t\r\n\t\tTHREE.Object3D.call( this );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Gyroscope.prototype = Object.create( THREE.Object3D.prototype );\r\n\tTHREE.Gyroscope.prototype.constructor = THREE.Gyroscope;\r\n\t\r\n\tTHREE.Gyroscope.prototype.updateMatrixWorld = ( function () {\r\n\t\r\n\t\tvar translationObject = new THREE.Vector3();\r\n\t\tvar quaternionObject = new THREE.Quaternion();\r\n\t\tvar scaleObject = new THREE.Vector3();\r\n\t\r\n\t\tvar translationWorld = new THREE.Vector3();\r\n\t\tvar quaternionWorld = new THREE.Quaternion();\r\n\t\tvar scaleWorld = new THREE.Vector3();\r\n\t\r\n\t\treturn function ( force ) {\r\n\t\r\n\t\t\tthis.matrixAutoUpdate && this.updateMatrix();\r\n\t\r\n\t\t\t// update matrixWorld\r\n\t\r\n\t\t\tif ( this.matrixWorldNeedsUpdate || force ) {\r\n\t\r\n\t\t\t\tif ( this.parent ) {\r\n\t\r\n\t\t\t\t\tthis.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );\r\n\t\r\n\t\t\t\t\tthis.matrixWorld.decompose( translationWorld, quaternionWorld, scaleWorld );\r\n\t\t\t\t\tthis.matrix.decompose( translationObject, quaternionObject, scaleObject );\r\n\t\r\n\t\t\t\t\tthis.matrixWorld.compose( translationWorld, quaternionObject, scaleWorld );\r\n\t\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tthis.matrixWorld.copy( this.matrix );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\r\n\t\t\t\tthis.matrixWorldNeedsUpdate = false;\r\n\t\r\n\t\t\t\tforce = true;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// update children\r\n\t\r\n\t\t\tfor ( var i = 0, l = this.children.length; i < l; i ++ ) {\r\n\t\r\n\t\t\t\tthis.children[ i ].updateMatrixWorld( force );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\t\r\n\t}() );\r\n\t\r\n\t// File:src/extras/core/Path.js\r\n\t\r\n\t/**\r\n\t * @author zz85 / http://www.lab4games.net/zz85/blog\r\n\t * Creates free form 2d path using series of points, lines or curves.\r\n\t *\r\n\t **/\r\n\t\r\n\tTHREE.Path = function ( points ) {\r\n\t\r\n\t\tTHREE.CurvePath.call(this);\r\n\t\r\n\t\tthis.actions = [];\r\n\t\r\n\t\tif ( points ) {\r\n\t\r\n\t\t\tthis.fromPoints( points );\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Path.prototype = Object.create( THREE.CurvePath.prototype );\r\n\tTHREE.Path.prototype.constructor = THREE.Path;\r\n\t\r\n\tTHREE.PathActions = {\r\n\t\r\n\t\tMOVE_TO: 'moveTo',\r\n\t\tLINE_TO: 'lineTo',\r\n\t\tQUADRATIC_CURVE_TO: 'quadraticCurveTo', // Bezier quadratic curve\r\n\t\tBEZIER_CURVE_TO: 'bezierCurveTo', \t\t// Bezier cubic curve\r\n\t\tCSPLINE_THRU: 'splineThru',\t\t\t\t// Catmull-rom spline\r\n\t\tARC: 'arc',\t\t\t\t\t\t\t\t// Circle\r\n\t\tELLIPSE: 'ellipse'\r\n\t};\r\n\t\r\n\t// TODO Clean up PATH API\r\n\t\r\n\t// Create path using straight lines to connect all points\r\n\t// - vectors: array of Vector2\r\n\t\r\n\tTHREE.Path.prototype.fromPoints = function ( vectors ) {\r\n\t\r\n\t\tthis.moveTo( vectors[ 0 ].x, vectors[ 0 ].y );\r\n\t\r\n\t\tfor ( var v = 1, vlen = vectors.length; v < vlen; v ++ ) {\r\n\t\r\n\t\t\tthis.lineTo( vectors[ v ].x, vectors[ v ].y );\r\n\t\r\n\t\t};\r\n\t\r\n\t};\r\n\t\r\n\t// startPath() endPath()?\r\n\t\r\n\tTHREE.Path.prototype.moveTo = function ( x, y ) {\r\n\t\r\n\t\tvar args = Array.prototype.slice.call( arguments );\r\n\t\tthis.actions.push( { action: THREE.PathActions.MOVE_TO, args: args } );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Path.prototype.lineTo = function ( x, y ) {\r\n\t\r\n\t\tvar args = Array.prototype.slice.call( arguments );\r\n\t\r\n\t\tvar lastargs = this.actions[ this.actions.length - 1 ].args;\r\n\t\r\n\t\tvar x0 = lastargs[ lastargs.length - 2 ];\r\n\t\tvar y0 = lastargs[ lastargs.length - 1 ];\r\n\t\r\n\t\tvar curve = new THREE.LineCurve( new THREE.Vector2( x0, y0 ), new THREE.Vector2( x, y ) );\r\n\t\tthis.curves.push( curve );\r\n\t\r\n\t\tthis.actions.push( { action: THREE.PathActions.LINE_TO, args: args } );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Path.prototype.quadraticCurveTo = function( aCPx, aCPy, aX, aY ) {\r\n\t\r\n\t\tvar args = Array.prototype.slice.call( arguments );\r\n\t\r\n\t\tvar lastargs = this.actions[ this.actions.length - 1 ].args;\r\n\t\r\n\t\tvar x0 = lastargs[ lastargs.length - 2 ];\r\n\t\tvar y0 = lastargs[ lastargs.length - 1 ];\r\n\t\r\n\t\tvar curve = new THREE.QuadraticBezierCurve( new THREE.Vector2( x0, y0 ),\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tnew THREE.Vector2( aCPx, aCPy ),\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tnew THREE.Vector2( aX, aY ) );\r\n\t\tthis.curves.push( curve );\r\n\t\r\n\t\tthis.actions.push( { action: THREE.PathActions.QUADRATIC_CURVE_TO, args: args } );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Path.prototype.bezierCurveTo = function( aCP1x, aCP1y,\r\n\t\t\t\t\t\t\t\t\t\t\t\t   aCP2x, aCP2y,\r\n\t\t\t\t\t\t\t\t\t\t\t\t   aX, aY ) {\r\n\t\r\n\t\tvar args = Array.prototype.slice.call( arguments );\r\n\t\r\n\t\tvar lastargs = this.actions[ this.actions.length - 1 ].args;\r\n\t\r\n\t\tvar x0 = lastargs[ lastargs.length - 2 ];\r\n\t\tvar y0 = lastargs[ lastargs.length - 1 ];\r\n\t\r\n\t\tvar curve = new THREE.CubicBezierCurve( new THREE.Vector2( x0, y0 ),\r\n\t\t\t\t\t\t\t\t\t\t\t\tnew THREE.Vector2( aCP1x, aCP1y ),\r\n\t\t\t\t\t\t\t\t\t\t\t\tnew THREE.Vector2( aCP2x, aCP2y ),\r\n\t\t\t\t\t\t\t\t\t\t\t\tnew THREE.Vector2( aX, aY ) );\r\n\t\tthis.curves.push( curve );\r\n\t\r\n\t\tthis.actions.push( { action: THREE.PathActions.BEZIER_CURVE_TO, args: args } );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Path.prototype.splineThru = function( pts /*Array of Vector*/ ) {\r\n\t\r\n\t\tvar args = Array.prototype.slice.call( arguments );\r\n\t\tvar lastargs = this.actions[ this.actions.length - 1 ].args;\r\n\t\r\n\t\tvar x0 = lastargs[ lastargs.length - 2 ];\r\n\t\tvar y0 = lastargs[ lastargs.length - 1 ];\r\n\t//---\r\n\t\tvar npts = [ new THREE.Vector2( x0, y0 ) ];\r\n\t\tArray.prototype.push.apply( npts, pts );\r\n\t\r\n\t\tvar curve = new THREE.SplineCurve( npts );\r\n\t\tthis.curves.push( curve );\r\n\t\r\n\t\tthis.actions.push( { action: THREE.PathActions.CSPLINE_THRU, args: args } );\r\n\t\r\n\t};\r\n\t\r\n\t// FUTURE: Change the API or follow canvas API?\r\n\t\r\n\tTHREE.Path.prototype.arc = function ( aX, aY, aRadius,\r\n\t\t\t\t\t\t\t\t\t\t  aStartAngle, aEndAngle, aClockwise ) {\r\n\t\r\n\t\tvar lastargs = this.actions[ this.actions.length - 1].args;\r\n\t\tvar x0 = lastargs[ lastargs.length - 2 ];\r\n\t\tvar y0 = lastargs[ lastargs.length - 1 ];\r\n\t\r\n\t\tthis.absarc(aX + x0, aY + y0, aRadius,\r\n\t\t\taStartAngle, aEndAngle, aClockwise );\r\n\t\r\n\t };\r\n\t\r\n\t THREE.Path.prototype.absarc = function ( aX, aY, aRadius,\r\n\t\t\t\t\t\t\t\t\t\t  aStartAngle, aEndAngle, aClockwise ) {\r\n\t\tthis.absellipse(aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);\r\n\t };\r\n\t\r\n\tTHREE.Path.prototype.ellipse = function ( aX, aY, xRadius, yRadius,\r\n\t\t\t\t\t\t\t\t\t\t  aStartAngle, aEndAngle, aClockwise ) {\r\n\t\r\n\t\tvar lastargs = this.actions[ this.actions.length - 1].args;\r\n\t\tvar x0 = lastargs[ lastargs.length - 2 ];\r\n\t\tvar y0 = lastargs[ lastargs.length - 1 ];\r\n\t\r\n\t\tthis.absellipse(aX + x0, aY + y0, xRadius, yRadius,\r\n\t\t\taStartAngle, aEndAngle, aClockwise );\r\n\t\r\n\t };\r\n\t\r\n\t\r\n\tTHREE.Path.prototype.absellipse = function ( aX, aY, xRadius, yRadius,\r\n\t\t\t\t\t\t\t\t\t\t  aStartAngle, aEndAngle, aClockwise ) {\r\n\t\r\n\t\tvar args = Array.prototype.slice.call( arguments );\r\n\t\tvar curve = new THREE.EllipseCurve( aX, aY, xRadius, yRadius,\r\n\t\t\t\t\t\t\t\t\t\taStartAngle, aEndAngle, aClockwise );\r\n\t\tthis.curves.push( curve );\r\n\t\r\n\t\tvar lastPoint = curve.getPoint(1);\r\n\t\targs.push(lastPoint.x);\r\n\t\targs.push(lastPoint.y);\r\n\t\r\n\t\tthis.actions.push( { action: THREE.PathActions.ELLIPSE, args: args } );\r\n\t\r\n\t };\r\n\t\r\n\tTHREE.Path.prototype.getSpacedPoints = function ( divisions, closedPath ) {\r\n\t\r\n\t\tif ( ! divisions ) divisions = 40;\r\n\t\r\n\t\tvar points = [];\r\n\t\r\n\t\tfor ( var i = 0; i < divisions; i ++ ) {\r\n\t\r\n\t\t\tpoints.push( this.getPoint( i / divisions ) );\r\n\t\r\n\t\t\t//if( !this.getPoint( i / divisions ) ) throw \"DIE\";\r\n\t\r\n\t\t}\r\n\t\r\n\t\t// if ( closedPath ) {\r\n\t\t//\r\n\t\t// \tpoints.push( points[ 0 ] );\r\n\t\t//\r\n\t\t// }\r\n\t\r\n\t\treturn points;\r\n\t\r\n\t};\r\n\t\r\n\t/* Return an array of vectors based on contour of the path */\r\n\t\r\n\tTHREE.Path.prototype.getPoints = function( divisions, closedPath ) {\r\n\t\r\n\t\tif (this.useSpacedPoints) {\r\n\t\t\tconsole.log('tata');\r\n\t\t\treturn this.getSpacedPoints( divisions, closedPath );\r\n\t\t}\r\n\t\r\n\t\tdivisions = divisions || 12;\r\n\t\r\n\t\tvar points = [];\r\n\t\r\n\t\tvar i, il, item, action, args;\r\n\t\tvar cpx, cpy, cpx2, cpy2, cpx1, cpy1, cpx0, cpy0,\r\n\t\t\tlaste, j,\r\n\t\t\tt, tx, ty;\r\n\t\r\n\t\tfor ( i = 0, il = this.actions.length; i < il; i ++ ) {\r\n\t\r\n\t\t\titem = this.actions[ i ];\r\n\t\r\n\t\t\taction = item.action;\r\n\t\t\targs = item.args;\r\n\t\r\n\t\t\tswitch ( action ) {\r\n\t\r\n\t\t\tcase THREE.PathActions.MOVE_TO:\r\n\t\r\n\t\t\t\tpoints.push( new THREE.Vector2( args[ 0 ], args[ 1 ] ) );\r\n\t\r\n\t\t\t\tbreak;\r\n\t\r\n\t\t\tcase THREE.PathActions.LINE_TO:\r\n\t\r\n\t\t\t\tpoints.push( new THREE.Vector2( args[ 0 ], args[ 1 ] ) );\r\n\t\r\n\t\t\t\tbreak;\r\n\t\r\n\t\t\tcase THREE.PathActions.QUADRATIC_CURVE_TO:\r\n\t\r\n\t\t\t\tcpx  = args[ 2 ];\r\n\t\t\t\tcpy  = args[ 3 ];\r\n\t\r\n\t\t\t\tcpx1 = args[ 0 ];\r\n\t\t\t\tcpy1 = args[ 1 ];\r\n\t\r\n\t\t\t\tif ( points.length > 0 ) {\r\n\t\r\n\t\t\t\t\tlaste = points[ points.length - 1 ];\r\n\t\r\n\t\t\t\t\tcpx0 = laste.x;\r\n\t\t\t\t\tcpy0 = laste.y;\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tlaste = this.actions[ i - 1 ].args;\r\n\t\r\n\t\t\t\t\tcpx0 = laste[ laste.length - 2 ];\r\n\t\t\t\t\tcpy0 = laste[ laste.length - 1 ];\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tfor ( j = 1; j <= divisions; j ++ ) {\r\n\t\r\n\t\t\t\t\tt = j / divisions;\r\n\t\r\n\t\t\t\t\ttx = THREE.Shape.Utils.b2( t, cpx0, cpx1, cpx );\r\n\t\t\t\t\tty = THREE.Shape.Utils.b2( t, cpy0, cpy1, cpy );\r\n\t\r\n\t\t\t\t\tpoints.push( new THREE.Vector2( tx, ty ) );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tbreak;\r\n\t\r\n\t\t\tcase THREE.PathActions.BEZIER_CURVE_TO:\r\n\t\r\n\t\t\t\tcpx  = args[ 4 ];\r\n\t\t\t\tcpy  = args[ 5 ];\r\n\t\r\n\t\t\t\tcpx1 = args[ 0 ];\r\n\t\t\t\tcpy1 = args[ 1 ];\r\n\t\r\n\t\t\t\tcpx2 = args[ 2 ];\r\n\t\t\t\tcpy2 = args[ 3 ];\r\n\t\r\n\t\t\t\tif ( points.length > 0 ) {\r\n\t\r\n\t\t\t\t\tlaste = points[ points.length - 1 ];\r\n\t\r\n\t\t\t\t\tcpx0 = laste.x;\r\n\t\t\t\t\tcpy0 = laste.y;\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tlaste = this.actions[ i - 1 ].args;\r\n\t\r\n\t\t\t\t\tcpx0 = laste[ laste.length - 2 ];\r\n\t\t\t\t\tcpy0 = laste[ laste.length - 1 ];\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\r\n\t\t\t\tfor ( j = 1; j <= divisions; j ++ ) {\r\n\t\r\n\t\t\t\t\tt = j / divisions;\r\n\t\r\n\t\t\t\t\ttx = THREE.Shape.Utils.b3( t, cpx0, cpx1, cpx2, cpx );\r\n\t\t\t\t\tty = THREE.Shape.Utils.b3( t, cpy0, cpy1, cpy2, cpy );\r\n\t\r\n\t\t\t\t\tpoints.push( new THREE.Vector2( tx, ty ) );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tbreak;\r\n\t\r\n\t\t\tcase THREE.PathActions.CSPLINE_THRU:\r\n\t\r\n\t\t\t\tlaste = this.actions[ i - 1 ].args;\r\n\t\r\n\t\t\t\tvar last = new THREE.Vector2( laste[ laste.length - 2 ], laste[ laste.length - 1 ] );\r\n\t\t\t\tvar spts = [ last ];\r\n\t\r\n\t\t\t\tvar n = divisions * args[ 0 ].length;\r\n\t\r\n\t\t\t\tspts = spts.concat( args[ 0 ] );\r\n\t\r\n\t\t\t\tvar spline = new THREE.SplineCurve( spts );\r\n\t\r\n\t\t\t\tfor ( j = 1; j <= n; j ++ ) {\r\n\t\r\n\t\t\t\t\tpoints.push( spline.getPointAt( j / n ) ) ;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tbreak;\r\n\t\r\n\t\t\tcase THREE.PathActions.ARC:\r\n\t\r\n\t\t\t\tvar aX = args[ 0 ], aY = args[ 1 ],\r\n\t\t\t\t\taRadius = args[ 2 ],\r\n\t\t\t\t\taStartAngle = args[ 3 ], aEndAngle = args[ 4 ],\r\n\t\t\t\t\taClockwise = !! args[ 5 ];\r\n\t\r\n\t\t\t\tvar deltaAngle = aEndAngle - aStartAngle;\r\n\t\t\t\tvar angle;\r\n\t\t\t\tvar tdivisions = divisions * 2;\r\n\t\r\n\t\t\t\tfor ( j = 1; j <= tdivisions; j ++ ) {\r\n\t\r\n\t\t\t\t\tt = j / tdivisions;\r\n\t\r\n\t\t\t\t\tif ( ! aClockwise ) {\r\n\t\r\n\t\t\t\t\t\tt = 1 - t;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tangle = aStartAngle + t * deltaAngle;\r\n\t\r\n\t\t\t\t\ttx = aX + aRadius * Math.cos( angle );\r\n\t\t\t\t\tty = aY + aRadius * Math.sin( angle );\r\n\t\r\n\t\t\t\t\t//console.log('t', t, 'angle', angle, 'tx', tx, 'ty', ty);\r\n\t\r\n\t\t\t\t\tpoints.push( new THREE.Vector2( tx, ty ) );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\t//console.log(points);\r\n\t\r\n\t\t\t\tbreak;\r\n\t\t\t  \r\n\t\t\tcase THREE.PathActions.ELLIPSE:\r\n\t\r\n\t\t\t\tvar aX = args[ 0 ], aY = args[ 1 ],\r\n\t\t\t\t\txRadius = args[ 2 ],\r\n\t\t\t\t\tyRadius = args[ 3 ],\r\n\t\t\t\t\taStartAngle = args[ 4 ], aEndAngle = args[ 5 ],\r\n\t\t\t\t\taClockwise = !! args[ 6 ];\r\n\t\r\n\t\r\n\t\t\t\tvar deltaAngle = aEndAngle - aStartAngle;\r\n\t\t\t\tvar angle;\r\n\t\t\t\tvar tdivisions = divisions * 2;\r\n\t\r\n\t\t\t\tfor ( j = 1; j <= tdivisions; j ++ ) {\r\n\t\r\n\t\t\t\t\tt = j / tdivisions;\r\n\t\r\n\t\t\t\t\tif ( ! aClockwise ) {\r\n\t\r\n\t\t\t\t\t\tt = 1 - t;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tangle = aStartAngle + t * deltaAngle;\r\n\t\r\n\t\t\t\t\ttx = aX + xRadius * Math.cos( angle );\r\n\t\t\t\t\tty = aY + yRadius * Math.sin( angle );\r\n\t\r\n\t\t\t\t\t//console.log('t', t, 'angle', angle, 'tx', tx, 'ty', ty);\r\n\t\r\n\t\t\t\t\tpoints.push( new THREE.Vector2( tx, ty ) );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\t//console.log(points);\r\n\t\r\n\t\t\t\tbreak;\r\n\t\r\n\t\t\t} // end switch\r\n\t\r\n\t\t}\r\n\t\r\n\t\r\n\t\r\n\t\t// Normalize to remove the closing point by default.\r\n\t\tvar lastPoint = points[ points.length - 1];\r\n\t\tvar EPSILON = 0.0000000001;\r\n\t\tif ( Math.abs(lastPoint.x - points[ 0 ].x) < EPSILON &&\r\n\t\t\t\t Math.abs(lastPoint.y - points[ 0 ].y) < EPSILON)\r\n\t\t\tpoints.splice( points.length - 1, 1);\r\n\t\tif ( closedPath ) {\r\n\t\r\n\t\t\tpoints.push( points[ 0 ] );\r\n\t\r\n\t\t}\r\n\t\r\n\t\treturn points;\r\n\t\r\n\t};\r\n\t\r\n\t//\r\n\t// Breaks path into shapes\r\n\t//\r\n\t//\tAssumptions (if parameter isCCW==true the opposite holds):\r\n\t//\t- solid shapes are defined clockwise (CW)\r\n\t//\t- holes are defined counterclockwise (CCW)\r\n\t//\r\n\t//\tIf parameter noHoles==true:\r\n\t//  - all subPaths are regarded as solid shapes\r\n\t//  - definition order CW/CCW has no relevance\r\n\t//\r\n\t\r\n\tTHREE.Path.prototype.toShapes = function( isCCW, noHoles ) {\r\n\t\r\n\t\tfunction extractSubpaths( inActions ) {\r\n\t\r\n\t\t\tvar i, il, item, action, args;\r\n\t\r\n\t\t\tvar subPaths = [], lastPath = new THREE.Path();\r\n\t\r\n\t\t\tfor ( i = 0, il = inActions.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\titem = inActions[ i ];\r\n\t\r\n\t\t\t\targs = item.args;\r\n\t\t\t\taction = item.action;\r\n\t\r\n\t\t\t\tif ( action == THREE.PathActions.MOVE_TO ) {\r\n\t\r\n\t\t\t\t\tif ( lastPath.actions.length != 0 ) {\r\n\t\r\n\t\t\t\t\t\tsubPaths.push( lastPath );\r\n\t\t\t\t\t\tlastPath = new THREE.Path();\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tlastPath[ action ].apply( lastPath, args );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( lastPath.actions.length != 0 ) {\r\n\t\r\n\t\t\t\tsubPaths.push( lastPath );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// console.log(subPaths);\r\n\t\r\n\t\t\treturn\tsubPaths;\r\n\t\t}\r\n\t\r\n\t\tfunction toShapesNoHoles( inSubpaths ) {\r\n\t\r\n\t\t\tvar shapes = [];\r\n\t\r\n\t\t\tfor ( var i = 0, il = inSubpaths.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\tvar tmpPath = inSubpaths[ i ];\r\n\t\r\n\t\t\t\tvar tmpShape = new THREE.Shape();\r\n\t\t\t\ttmpShape.actions = tmpPath.actions;\r\n\t\t\t\ttmpShape.curves = tmpPath.curves;\r\n\t\r\n\t\t\t\tshapes.push( tmpShape );\r\n\t\t\t}\r\n\t\r\n\t\t\t//console.log(\"shape\", shapes);\r\n\t\r\n\t\t\treturn shapes;\r\n\t\t};\r\n\t\r\n\t\tfunction isPointInsidePolygon( inPt, inPolygon ) {\r\n\t\t\tvar EPSILON = 0.0000000001;\r\n\t\r\n\t\t\tvar polyLen = inPolygon.length;\r\n\t\r\n\t\t\t// inPt on polygon contour => immediate success    or\r\n\t\t\t// toggling of inside/outside at every single! intersection point of an edge\r\n\t\t\t//  with the horizontal line through inPt, left of inPt\r\n\t\t\t//  not counting lowerY endpoints of edges and whole edges on that line\r\n\t\t\tvar inside = false;\r\n\t\t\tfor ( var p = polyLen - 1, q = 0; q < polyLen; p = q ++ ) {\r\n\t\t\t\tvar edgeLowPt  = inPolygon[ p ];\r\n\t\t\t\tvar edgeHighPt = inPolygon[ q ];\r\n\t\r\n\t\t\t\tvar edgeDx = edgeHighPt.x - edgeLowPt.x;\r\n\t\t\t\tvar edgeDy = edgeHighPt.y - edgeLowPt.y;\r\n\t\r\n\t\t\t\tif ( Math.abs(edgeDy) > EPSILON ) {\t\t\t// not parallel\r\n\t\t\t\t\tif ( edgeDy < 0 ) {\r\n\t\t\t\t\t\tedgeLowPt  = inPolygon[ q ]; edgeDx = - edgeDx;\r\n\t\t\t\t\t\tedgeHighPt = inPolygon[ p ]; edgeDy = - edgeDy;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif ( ( inPt.y < edgeLowPt.y ) || ( inPt.y > edgeHighPt.y ) ) \t\tcontinue;\r\n\t\r\n\t\t\t\t\tif ( inPt.y == edgeLowPt.y ) {\r\n\t\t\t\t\t\tif ( inPt.x == edgeLowPt.x )\t\treturn\ttrue;\t\t// inPt is on contour ?\r\n\t\t\t\t\t\t// continue;\t\t\t\t// no intersection or edgeLowPt => doesn't count !!!\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tvar perpEdge = edgeDy * (inPt.x - edgeLowPt.x) - edgeDx * (inPt.y - edgeLowPt.y);\r\n\t\t\t\t\t\tif ( perpEdge == 0 )\t\t\t\treturn\ttrue;\t\t// inPt is on contour ?\r\n\t\t\t\t\t\tif ( perpEdge < 0 ) \t\t\t\tcontinue;\r\n\t\t\t\t\t\tinside = ! inside;\t\t// true intersection left of inPt\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\t\t// parallel or colinear\r\n\t\t\t\t\tif ( inPt.y != edgeLowPt.y ) \t\tcontinue;\t\t\t// parallel\r\n\t\t\t\t\t// egde lies on the same horizontal line as inPt\r\n\t\t\t\t\tif ( ( ( edgeHighPt.x <= inPt.x ) && ( inPt.x <= edgeLowPt.x ) ) ||\r\n\t\t\t\t\t\t ( ( edgeLowPt.x <= inPt.x ) && ( inPt.x <= edgeHighPt.x ) ) )\t\treturn\ttrue;\t// inPt: Point on contour !\r\n\t\t\t\t\t// continue;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\r\n\t\t\treturn\tinside;\r\n\t\t}\r\n\t\r\n\t\r\n\t\tvar subPaths = extractSubpaths( this.actions );\r\n\t\tif ( subPaths.length == 0 ) return [];\r\n\t\r\n\t\tif ( noHoles === true )\treturn\ttoShapesNoHoles( subPaths );\r\n\t\r\n\t\r\n\t\tvar solid, tmpPath, tmpShape, shapes = [];\r\n\t\r\n\t\tif ( subPaths.length == 1) {\r\n\t\r\n\t\t\ttmpPath = subPaths[0];\r\n\t\t\ttmpShape = new THREE.Shape();\r\n\t\t\ttmpShape.actions = tmpPath.actions;\r\n\t\t\ttmpShape.curves = tmpPath.curves;\r\n\t\t\tshapes.push( tmpShape );\r\n\t\t\treturn shapes;\r\n\t\r\n\t\t}\r\n\t\r\n\t\tvar holesFirst = ! THREE.Shape.Utils.isClockWise( subPaths[ 0 ].getPoints() );\r\n\t\tholesFirst = isCCW ? ! holesFirst : holesFirst;\r\n\t\r\n\t\t// console.log(\"Holes first\", holesFirst);\r\n\t\t\r\n\t\tvar betterShapeHoles = [];\r\n\t\tvar newShapes = [];\r\n\t\tvar newShapeHoles = [];\r\n\t\tvar mainIdx = 0;\r\n\t\tvar tmpPoints;\r\n\t\r\n\t\tnewShapes[mainIdx] = undefined;\r\n\t\tnewShapeHoles[mainIdx] = [];\r\n\t\r\n\t\tvar i, il;\r\n\t\r\n\t\tfor ( i = 0, il = subPaths.length; i < il; i ++ ) {\r\n\t\r\n\t\t\ttmpPath = subPaths[ i ];\r\n\t\t\ttmpPoints = tmpPath.getPoints();\r\n\t\t\tsolid = THREE.Shape.Utils.isClockWise( tmpPoints );\r\n\t\t\tsolid = isCCW ? ! solid : solid;\r\n\t\r\n\t\t\tif ( solid ) {\r\n\t\r\n\t\t\t\tif ( (! holesFirst ) && ( newShapes[mainIdx] ) )\tmainIdx ++;\r\n\t\r\n\t\t\t\tnewShapes[mainIdx] = { s: new THREE.Shape(), p: tmpPoints };\r\n\t\t\t\tnewShapes[mainIdx].s.actions = tmpPath.actions;\r\n\t\t\t\tnewShapes[mainIdx].s.curves = tmpPath.curves;\r\n\t\t\t\t\r\n\t\t\t\tif ( holesFirst )\tmainIdx ++;\r\n\t\t\t\tnewShapeHoles[mainIdx] = [];\r\n\t\r\n\t\t\t\t//console.log('cw', i);\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\tnewShapeHoles[mainIdx].push( { h: tmpPath, p: tmpPoints[0] } );\r\n\t\r\n\t\t\t\t//console.log('ccw', i);\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\t// only Holes? -> probably all Shapes with wrong orientation\r\n\t\tif ( ! newShapes[0] )\treturn\ttoShapesNoHoles( subPaths );\r\n\t\r\n\t\r\n\t\tif ( newShapes.length > 1 ) {\r\n\t\t\tvar ambigious = false;\r\n\t\t\tvar toChange = [];\r\n\t\r\n\t\t\tfor (var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {\r\n\t\t\t\tbetterShapeHoles[sIdx] = [];\r\n\t\t\t}\r\n\t\t\tfor (var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {\r\n\t\t\t\tvar sho = newShapeHoles[sIdx];\r\n\t\t\t\tfor (var hIdx = 0; hIdx < sho.length; hIdx ++ ) {\r\n\t\t\t\t\tvar ho = sho[hIdx];\r\n\t\t\t\t\tvar hole_unassigned = true;\r\n\t\t\t\t\tfor (var s2Idx = 0; s2Idx < newShapes.length; s2Idx ++ ) {\r\n\t\t\t\t\t\tif ( isPointInsidePolygon( ho.p, newShapes[s2Idx].p ) ) {\r\n\t\t\t\t\t\t\tif ( sIdx != s2Idx )\t\ttoChange.push( { froms: sIdx, tos: s2Idx, hole: hIdx } );\r\n\t\t\t\t\t\t\tif ( hole_unassigned ) {\r\n\t\t\t\t\t\t\t\thole_unassigned = false;\r\n\t\t\t\t\t\t\t\tbetterShapeHoles[s2Idx].push( ho );\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\tambigious = true;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif ( hole_unassigned ) { betterShapeHoles[sIdx].push( ho ); }\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t// console.log(\"ambigious: \", ambigious);\r\n\t\t\tif ( toChange.length > 0 ) {\r\n\t\t\t\t// console.log(\"to change: \", toChange);\r\n\t\t\t\tif (! ambigious)\tnewShapeHoles = betterShapeHoles;\r\n\t\t\t}\r\n\t\t}\r\n\t\r\n\t\tvar tmpHoles, j, jl;\r\n\t\tfor ( i = 0, il = newShapes.length; i < il; i ++ ) {\r\n\t\t\ttmpShape = newShapes[i].s;\r\n\t\t\tshapes.push( tmpShape );\r\n\t\t\ttmpHoles = newShapeHoles[i];\r\n\t\t\tfor ( j = 0, jl = tmpHoles.length; j < jl; j ++ ) {\r\n\t\t\t\ttmpShape.holes.push( tmpHoles[j].h );\r\n\t\t\t}\r\n\t\t}\r\n\t\r\n\t\t//console.log(\"shape\", shapes);\r\n\t\r\n\t\treturn shapes;\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/extras/core/Shape.js\r\n\t\r\n\t/**\r\n\t * @author zz85 / http://www.lab4games.net/zz85/blog\r\n\t * Defines a 2d shape plane using paths.\r\n\t **/\r\n\t\r\n\t// STEP 1 Create a path.\r\n\t// STEP 2 Turn path into shape.\r\n\t// STEP 3 ExtrudeGeometry takes in Shape/Shapes\r\n\t// STEP 3a - Extract points from each shape, turn to vertices\r\n\t// STEP 3b - Triangulate each shape, add faces.\r\n\t\r\n\tTHREE.Shape = function () {\r\n\t\r\n\t\tTHREE.Path.apply( this, arguments );\r\n\t\tthis.holes = [];\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Shape.prototype = Object.create( THREE.Path.prototype );\r\n\tTHREE.Shape.prototype.constructor = THREE.Shape;\r\n\t\r\n\t// Convenience method to return ExtrudeGeometry\r\n\t\r\n\tTHREE.Shape.prototype.extrude = function ( options ) {\r\n\t\r\n\t\tvar extruded = new THREE.ExtrudeGeometry( this, options );\r\n\t\treturn extruded;\r\n\t\r\n\t};\r\n\t\r\n\t// Convenience method to return ShapeGeometry\r\n\t\r\n\tTHREE.Shape.prototype.makeGeometry = function ( options ) {\r\n\t\r\n\t\tvar geometry = new THREE.ShapeGeometry( this, options );\r\n\t\treturn geometry;\r\n\t\r\n\t};\r\n\t\r\n\t// Get points of holes\r\n\t\r\n\tTHREE.Shape.prototype.getPointsHoles = function ( divisions ) {\r\n\t\r\n\t\tvar i, il = this.holes.length, holesPts = [];\r\n\t\r\n\t\tfor ( i = 0; i < il; i ++ ) {\r\n\t\r\n\t\t\tholesPts[ i ] = this.holes[ i ].getTransformedPoints( divisions, this.bends );\r\n\t\r\n\t\t}\r\n\t\r\n\t\treturn holesPts;\r\n\t\r\n\t};\r\n\t\r\n\t// Get points of holes (spaced by regular distance)\r\n\t\r\n\tTHREE.Shape.prototype.getSpacedPointsHoles = function ( divisions ) {\r\n\t\r\n\t\tvar i, il = this.holes.length, holesPts = [];\r\n\t\r\n\t\tfor ( i = 0; i < il; i ++ ) {\r\n\t\r\n\t\t\tholesPts[ i ] = this.holes[ i ].getTransformedSpacedPoints( divisions, this.bends );\r\n\t\r\n\t\t}\r\n\t\r\n\t\treturn holesPts;\r\n\t\r\n\t};\r\n\t\r\n\t\r\n\t// Get points of shape and holes (keypoints based on segments parameter)\r\n\t\r\n\tTHREE.Shape.prototype.extractAllPoints = function ( divisions ) {\r\n\t\r\n\t\treturn {\r\n\t\r\n\t\t\tshape: this.getTransformedPoints( divisions ),\r\n\t\t\tholes: this.getPointsHoles( divisions )\r\n\t\r\n\t\t};\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Shape.prototype.extractPoints = function ( divisions ) {\r\n\t\r\n\t\tif (this.useSpacedPoints) {\r\n\t\t\treturn this.extractAllSpacedPoints(divisions);\r\n\t\t}\r\n\t\r\n\t\treturn this.extractAllPoints(divisions);\r\n\t\r\n\t};\r\n\t\r\n\t//\r\n\t// THREE.Shape.prototype.extractAllPointsWithBend = function ( divisions, bend ) {\r\n\t//\r\n\t// \treturn {\r\n\t//\r\n\t// \t\tshape: this.transform( bend, divisions ),\r\n\t// \t\tholes: this.getPointsHoles( divisions, bend )\r\n\t//\r\n\t// \t};\r\n\t//\r\n\t// };\r\n\t\r\n\t// Get points of shape and holes (spaced by regular distance)\r\n\t\r\n\tTHREE.Shape.prototype.extractAllSpacedPoints = function ( divisions ) {\r\n\t\r\n\t\treturn {\r\n\t\r\n\t\t\tshape: this.getTransformedSpacedPoints( divisions ),\r\n\t\t\tholes: this.getSpacedPointsHoles( divisions )\r\n\t\r\n\t\t};\r\n\t\r\n\t};\r\n\t\r\n\t/**************************************************************\r\n\t *\tUtils\r\n\t **************************************************************/\r\n\t\r\n\tTHREE.Shape.Utils = {\r\n\t\r\n\t\ttriangulateShape: function ( contour, holes ) {\r\n\t\r\n\t\t\tfunction point_in_segment_2D_colin( inSegPt1, inSegPt2, inOtherPt ) {\r\n\t\t\t\t// inOtherPt needs to be colinear to the inSegment\r\n\t\t\t\tif ( inSegPt1.x != inSegPt2.x ) {\r\n\t\t\t\t\tif ( inSegPt1.x < inSegPt2.x ) {\r\n\t\t\t\t\t\treturn\t( ( inSegPt1.x <= inOtherPt.x ) && ( inOtherPt.x <= inSegPt2.x ) );\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\treturn\t( ( inSegPt2.x <= inOtherPt.x ) && ( inOtherPt.x <= inSegPt1.x ) );\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\tif ( inSegPt1.y < inSegPt2.y ) {\r\n\t\t\t\t\t\treturn\t( ( inSegPt1.y <= inOtherPt.y ) && ( inOtherPt.y <= inSegPt2.y ) );\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\treturn\t( ( inSegPt2.y <= inOtherPt.y ) && ( inOtherPt.y <= inSegPt1.y ) );\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\r\n\t\t\tfunction intersect_segments_2D( inSeg1Pt1, inSeg1Pt2, inSeg2Pt1, inSeg2Pt2, inExcludeAdjacentSegs ) {\r\n\t\t\t\tvar EPSILON = 0.0000000001;\r\n\t\r\n\t\t\t\tvar seg1dx = inSeg1Pt2.x - inSeg1Pt1.x,   seg1dy = inSeg1Pt2.y - inSeg1Pt1.y;\r\n\t\t\t\tvar seg2dx = inSeg2Pt2.x - inSeg2Pt1.x,   seg2dy = inSeg2Pt2.y - inSeg2Pt1.y;\r\n\t\r\n\t\t\t\tvar seg1seg2dx = inSeg1Pt1.x - inSeg2Pt1.x;\r\n\t\t\t\tvar seg1seg2dy = inSeg1Pt1.y - inSeg2Pt1.y;\r\n\t\r\n\t\t\t\tvar limit\t\t= seg1dy * seg2dx - seg1dx * seg2dy;\r\n\t\t\t\tvar perpSeg1\t= seg1dy * seg1seg2dx - seg1dx * seg1seg2dy;\r\n\t\r\n\t\t\t\tif ( Math.abs(limit) > EPSILON ) {\t\t\t// not parallel\r\n\t\r\n\t\t\t\t\tvar perpSeg2;\r\n\t\t\t\t\tif ( limit > 0 ) {\r\n\t\t\t\t\t\tif ( ( perpSeg1 < 0 ) || ( perpSeg1 > limit ) ) \t\treturn [];\r\n\t\t\t\t\t\tperpSeg2 = seg2dy * seg1seg2dx - seg2dx * seg1seg2dy;\r\n\t\t\t\t\t\tif ( ( perpSeg2 < 0 ) || ( perpSeg2 > limit ) ) \t\treturn [];\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tif ( ( perpSeg1 > 0 ) || ( perpSeg1 < limit ) ) \t\treturn [];\r\n\t\t\t\t\t\tperpSeg2 = seg2dy * seg1seg2dx - seg2dx * seg1seg2dy;\r\n\t\t\t\t\t\tif ( ( perpSeg2 > 0 ) || ( perpSeg2 < limit ) ) \t\treturn [];\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t// i.e. to reduce rounding errors\r\n\t\t\t\t\t// intersection at endpoint of segment#1?\r\n\t\t\t\t\tif ( perpSeg2 == 0 ) {\r\n\t\t\t\t\t\tif ( ( inExcludeAdjacentSegs ) &&\r\n\t\t\t\t\t\t\t ( ( perpSeg1 == 0 ) || ( perpSeg1 == limit ) ) )\t\treturn [];\r\n\t\t\t\t\t\treturn [ inSeg1Pt1 ];\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif ( perpSeg2 == limit ) {\r\n\t\t\t\t\t\tif ( ( inExcludeAdjacentSegs ) &&\r\n\t\t\t\t\t\t\t ( ( perpSeg1 == 0 ) || ( perpSeg1 == limit ) ) )\t\treturn [];\r\n\t\t\t\t\t\treturn [ inSeg1Pt2 ];\r\n\t\t\t\t\t}\r\n\t\t\t\t\t// intersection at endpoint of segment#2?\r\n\t\t\t\t\tif ( perpSeg1 == 0 )\t\treturn [ inSeg2Pt1 ];\r\n\t\t\t\t\tif ( perpSeg1 == limit )\treturn [ inSeg2Pt2 ];\r\n\t\r\n\t\t\t\t\t// return real intersection point\r\n\t\t\t\t\tvar factorSeg1 = perpSeg2 / limit;\r\n\t\t\t\t\treturn\t[ { x: inSeg1Pt1.x + factorSeg1 * seg1dx,\r\n\t\t\t\t\t\t\t\ty: inSeg1Pt1.y + factorSeg1 * seg1dy } ];\r\n\t\r\n\t\t\t\t} else {\t\t// parallel or colinear\r\n\t\t\t\t\tif ( ( perpSeg1 != 0 ) ||\r\n\t\t\t\t\t\t ( seg2dy * seg1seg2dx != seg2dx * seg1seg2dy ) ) \t\t\treturn [];\r\n\t\r\n\t\t\t\t\t// they are collinear or degenerate\r\n\t\t\t\t\tvar seg1Pt = ( (seg1dx == 0) && (seg1dy == 0) );\t// segment1 ist just a point?\r\n\t\t\t\t\tvar seg2Pt = ( (seg2dx == 0) && (seg2dy == 0) );\t// segment2 ist just a point?\r\n\t\t\t\t\t// both segments are points\r\n\t\t\t\t\tif ( seg1Pt && seg2Pt ) {\r\n\t\t\t\t\t\tif ( (inSeg1Pt1.x != inSeg2Pt1.x) ||\r\n\t\t\t\t\t\t\t (inSeg1Pt1.y != inSeg2Pt1.y) )\t\treturn [];   \t// they are distinct  points\r\n\t\t\t\t\t\treturn [ inSeg1Pt1 ];                 \t\t\t\t\t// they are the same point\r\n\t\t\t\t\t}\r\n\t\t\t\t\t// segment#1  is a single point\r\n\t\t\t\t\tif ( seg1Pt ) {\r\n\t\t\t\t\t\tif (! point_in_segment_2D_colin( inSeg2Pt1, inSeg2Pt2, inSeg1Pt1 ) )\t\treturn [];\t\t// but not in segment#2\r\n\t\t\t\t\t\treturn [ inSeg1Pt1 ];\r\n\t\t\t\t\t}\r\n\t\t\t\t\t// segment#2  is a single point\r\n\t\t\t\t\tif ( seg2Pt ) {\r\n\t\t\t\t\t\tif (! point_in_segment_2D_colin( inSeg1Pt1, inSeg1Pt2, inSeg2Pt1 ) )\t\treturn [];\t\t// but not in segment#1\r\n\t\t\t\t\t\treturn [ inSeg2Pt1 ];\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t// they are collinear segments, which might overlap\r\n\t\t\t\t\tvar seg1min, seg1max, seg1minVal, seg1maxVal;\r\n\t\t\t\t\tvar seg2min, seg2max, seg2minVal, seg2maxVal;\r\n\t\t\t\t\tif (seg1dx != 0) {\t\t// the segments are NOT on a vertical line\r\n\t\t\t\t\t\tif ( inSeg1Pt1.x < inSeg1Pt2.x ) {\r\n\t\t\t\t\t\t\tseg1min = inSeg1Pt1; seg1minVal = inSeg1Pt1.x;\r\n\t\t\t\t\t\t\tseg1max = inSeg1Pt2; seg1maxVal = inSeg1Pt2.x;\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tseg1min = inSeg1Pt2; seg1minVal = inSeg1Pt2.x;\r\n\t\t\t\t\t\t\tseg1max = inSeg1Pt1; seg1maxVal = inSeg1Pt1.x;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif ( inSeg2Pt1.x < inSeg2Pt2.x ) {\r\n\t\t\t\t\t\t\tseg2min = inSeg2Pt1; seg2minVal = inSeg2Pt1.x;\r\n\t\t\t\t\t\t\tseg2max = inSeg2Pt2; seg2maxVal = inSeg2Pt2.x;\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tseg2min = inSeg2Pt2; seg2minVal = inSeg2Pt2.x;\r\n\t\t\t\t\t\t\tseg2max = inSeg2Pt1; seg2maxVal = inSeg2Pt1.x;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else {\t\t\t\t// the segments are on a vertical line\r\n\t\t\t\t\t\tif ( inSeg1Pt1.y < inSeg1Pt2.y ) {\r\n\t\t\t\t\t\t\tseg1min = inSeg1Pt1; seg1minVal = inSeg1Pt1.y;\r\n\t\t\t\t\t\t\tseg1max = inSeg1Pt2; seg1maxVal = inSeg1Pt2.y;\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tseg1min = inSeg1Pt2; seg1minVal = inSeg1Pt2.y;\r\n\t\t\t\t\t\t\tseg1max = inSeg1Pt1; seg1maxVal = inSeg1Pt1.y;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif ( inSeg2Pt1.y < inSeg2Pt2.y ) {\r\n\t\t\t\t\t\t\tseg2min = inSeg2Pt1; seg2minVal = inSeg2Pt1.y;\r\n\t\t\t\t\t\t\tseg2max = inSeg2Pt2; seg2maxVal = inSeg2Pt2.y;\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tseg2min = inSeg2Pt2; seg2minVal = inSeg2Pt2.y;\r\n\t\t\t\t\t\t\tseg2max = inSeg2Pt1; seg2maxVal = inSeg2Pt1.y;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif ( seg1minVal <= seg2minVal ) {\r\n\t\t\t\t\t\tif ( seg1maxVal <  seg2minVal )\treturn [];\r\n\t\t\t\t\t\tif ( seg1maxVal == seg2minVal )\t{\r\n\t\t\t\t\t\t\tif ( inExcludeAdjacentSegs )\t\treturn [];\r\n\t\t\t\t\t\t\treturn [ seg2min ];\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif ( seg1maxVal <= seg2maxVal )\treturn [ seg2min, seg1max ];\r\n\t\t\t\t\t\treturn\t[ seg2min, seg2max ];\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tif ( seg1minVal >  seg2maxVal )\treturn [];\r\n\t\t\t\t\t\tif ( seg1minVal == seg2maxVal )\t{\r\n\t\t\t\t\t\t\tif ( inExcludeAdjacentSegs )\t\treturn [];\r\n\t\t\t\t\t\t\treturn [ seg1min ];\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif ( seg1maxVal <= seg2maxVal )\treturn [ seg1min, seg1max ];\r\n\t\t\t\t\t\treturn\t[ seg1min, seg2max ];\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\r\n\t\t\tfunction isPointInsideAngle( inVertex, inLegFromPt, inLegToPt, inOtherPt ) {\r\n\t\t\t\t// The order of legs is important\r\n\t\r\n\t\t\t\tvar EPSILON = 0.0000000001;\r\n\t\r\n\t\t\t\t// translation of all points, so that Vertex is at (0,0)\r\n\t\t\t\tvar legFromPtX\t= inLegFromPt.x - inVertex.x,  legFromPtY\t= inLegFromPt.y - inVertex.y;\r\n\t\t\t\tvar legToPtX\t= inLegToPt.x\t- inVertex.x,  legToPtY\t\t= inLegToPt.y\t- inVertex.y;\r\n\t\t\t\tvar otherPtX\t= inOtherPt.x\t- inVertex.x,  otherPtY\t\t= inOtherPt.y\t- inVertex.y;\r\n\t\r\n\t\t\t\t// main angle >0: < 180 deg.; 0: 180 deg.; <0: > 180 deg.\r\n\t\t\t\tvar from2toAngle\t= legFromPtX * legToPtY - legFromPtY * legToPtX;\r\n\t\t\t\tvar from2otherAngle\t= legFromPtX * otherPtY - legFromPtY * otherPtX;\r\n\t\r\n\t\t\t\tif ( Math.abs(from2toAngle) > EPSILON ) {\t\t\t// angle != 180 deg.\r\n\t\r\n\t\t\t\t\tvar other2toAngle\t\t= otherPtX * legToPtY - otherPtY * legToPtX;\r\n\t\t\t\t\t// console.log( \"from2to: \" + from2toAngle + \", from2other: \" + from2otherAngle + \", other2to: \" + other2toAngle );\r\n\t\r\n\t\t\t\t\tif ( from2toAngle > 0 ) {\t\t\t\t// main angle < 180 deg.\r\n\t\t\t\t\t\treturn\t( ( from2otherAngle >= 0 ) && ( other2toAngle >= 0 ) );\r\n\t\t\t\t\t} else {\t\t\t\t\t\t\t\t// main angle > 180 deg.\r\n\t\t\t\t\t\treturn\t( ( from2otherAngle >= 0 ) || ( other2toAngle >= 0 ) );\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\t\t\t\t\t\t\t\t\t\t// angle == 180 deg.\r\n\t\t\t\t\t// console.log( \"from2to: 180 deg., from2other: \" + from2otherAngle  );\r\n\t\t\t\t\treturn\t( from2otherAngle > 0 );\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\r\n\t\r\n\t\t\tfunction removeHoles( contour, holes ) {\r\n\t\r\n\t\t\t\tvar shape = contour.concat(); // work on this shape\r\n\t\t\t\tvar hole;\r\n\t\r\n\t\t\t\tfunction isCutLineInsideAngles( inShapeIdx, inHoleIdx ) {\r\n\t\t\t\t\t// Check if hole point lies within angle around shape point\r\n\t\t\t\t\tvar lastShapeIdx = shape.length - 1;\r\n\t\r\n\t\t\t\t\tvar prevShapeIdx = inShapeIdx - 1;\r\n\t\t\t\t\tif ( prevShapeIdx < 0 )\t\t\tprevShapeIdx = lastShapeIdx;\r\n\t\r\n\t\t\t\t\tvar nextShapeIdx = inShapeIdx + 1;\r\n\t\t\t\t\tif ( nextShapeIdx > lastShapeIdx )\tnextShapeIdx = 0;\r\n\t\r\n\t\t\t\t\tvar insideAngle = isPointInsideAngle( shape[inShapeIdx], shape[ prevShapeIdx ], shape[ nextShapeIdx ], hole[inHoleIdx] );\r\n\t\t\t\t\tif (! insideAngle ) {\r\n\t\t\t\t\t\t// console.log( \"Vertex (Shape): \" + inShapeIdx + \", Point: \" + hole[inHoleIdx].x + \"/\" + hole[inHoleIdx].y );\r\n\t\t\t\t\t\treturn\tfalse;\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t// Check if shape point lies within angle around hole point\r\n\t\t\t\t\tvar lastHoleIdx = hole.length - 1;\r\n\t\r\n\t\t\t\t\tvar prevHoleIdx = inHoleIdx - 1;\r\n\t\t\t\t\tif ( prevHoleIdx < 0 )\t\t\tprevHoleIdx = lastHoleIdx;\r\n\t\r\n\t\t\t\t\tvar nextHoleIdx = inHoleIdx + 1;\r\n\t\t\t\t\tif ( nextHoleIdx > lastHoleIdx )\tnextHoleIdx = 0;\r\n\t\r\n\t\t\t\t\tinsideAngle = isPointInsideAngle( hole[inHoleIdx], hole[ prevHoleIdx ], hole[ nextHoleIdx ], shape[inShapeIdx] );\r\n\t\t\t\t\tif (! insideAngle ) {\r\n\t\t\t\t\t\t// console.log( \"Vertex (Hole): \" + inHoleIdx + \", Point: \" + shape[inShapeIdx].x + \"/\" + shape[inShapeIdx].y );\r\n\t\t\t\t\t\treturn\tfalse;\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\treturn\ttrue;\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tfunction intersectsShapeEdge( inShapePt, inHolePt ) {\r\n\t\t\t\t\t// checks for intersections with shape edges\r\n\t\t\t\t\tvar sIdx, nextIdx, intersection;\r\n\t\t\t\t\tfor ( sIdx = 0; sIdx < shape.length; sIdx ++ ) {\r\n\t\t\t\t\t\tnextIdx = sIdx + 1; nextIdx %= shape.length;\r\n\t\t\t\t\t\tintersection = intersect_segments_2D( inShapePt, inHolePt, shape[sIdx], shape[nextIdx], true );\r\n\t\t\t\t\t\tif ( intersection.length > 0 )\t\treturn\ttrue;\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\treturn\tfalse;\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tvar indepHoles = [];\r\n\t\r\n\t\t\t\tfunction intersectsHoleEdge( inShapePt, inHolePt ) {\r\n\t\t\t\t\t// checks for intersections with hole edges\r\n\t\t\t\t\tvar ihIdx, chkHole,\r\n\t\t\t\t\t\thIdx, nextIdx, intersection;\r\n\t\t\t\t\tfor ( ihIdx = 0; ihIdx < indepHoles.length; ihIdx ++ ) {\r\n\t\t\t\t\t\tchkHole = holes[indepHoles[ihIdx]];\r\n\t\t\t\t\t\tfor ( hIdx = 0; hIdx < chkHole.length; hIdx ++ ) {\r\n\t\t\t\t\t\t\tnextIdx = hIdx + 1; nextIdx %= chkHole.length;\r\n\t\t\t\t\t\t\tintersection = intersect_segments_2D( inShapePt, inHolePt, chkHole[hIdx], chkHole[nextIdx], true );\r\n\t\t\t\t\t\t\tif ( intersection.length > 0 )\t\treturn\ttrue;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn\tfalse;\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tvar holeIndex, shapeIndex,\r\n\t\t\t\t\tshapePt, holePt,\r\n\t\t\t\t\tholeIdx, cutKey, failedCuts = [],\r\n\t\t\t\t\ttmpShape1, tmpShape2,\r\n\t\t\t\t\ttmpHole1, tmpHole2;\r\n\t\r\n\t\t\t\tfor ( var h = 0, hl = holes.length; h < hl; h ++ ) {\r\n\t\r\n\t\t\t\t\tindepHoles.push( h );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tvar minShapeIndex = 0;\r\n\t\t\t\tvar counter = indepHoles.length * 2;\r\n\t\t\t\twhile ( indepHoles.length > 0 ) {\r\n\t\t\t\t\tcounter --;\r\n\t\t\t\t\tif ( counter < 0 ) {\r\n\t\t\t\t\t\tconsole.log( \"Infinite Loop! Holes left:\" + indepHoles.length + \", Probably Hole outside Shape!\" );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t// search for shape-vertex and hole-vertex,\r\n\t\t\t\t\t// which can be connected without intersections\r\n\t\t\t\t\tfor ( shapeIndex = minShapeIndex; shapeIndex < shape.length; shapeIndex ++ ) {\r\n\t\r\n\t\t\t\t\t\tshapePt = shape[ shapeIndex ];\r\n\t\t\t\t\t\tholeIndex\t= - 1;\r\n\t\r\n\t\t\t\t\t\t// search for hole which can be reached without intersections\r\n\t\t\t\t\t\tfor ( var h = 0; h < indepHoles.length; h ++ ) {\r\n\t\t\t\t\t\t\tholeIdx = indepHoles[h];\r\n\t\r\n\t\t\t\t\t\t\t// prevent multiple checks\r\n\t\t\t\t\t\t\tcutKey = shapePt.x + \":\" + shapePt.y + \":\" + holeIdx;\r\n\t\t\t\t\t\t\tif ( failedCuts[cutKey] !== undefined )\t\t\tcontinue;\r\n\t\r\n\t\t\t\t\t\t\thole = holes[holeIdx];\r\n\t\t\t\t\t\t\tfor ( var h2 = 0; h2 < hole.length; h2 ++ ) {\r\n\t\t\t\t\t\t\t\tholePt = hole[ h2 ];\r\n\t\t\t\t\t\t\t\tif (! isCutLineInsideAngles( shapeIndex, h2 ) )\t\tcontinue;\r\n\t\t\t\t\t\t\t\tif ( intersectsShapeEdge( shapePt, holePt ) )\t\tcontinue;\r\n\t\t\t\t\t\t\t\tif ( intersectsHoleEdge( shapePt, holePt ) )\t\tcontinue;\r\n\t\r\n\t\t\t\t\t\t\t\tholeIndex = h2;\r\n\t\t\t\t\t\t\t\tindepHoles.splice(h, 1);\r\n\t\r\n\t\t\t\t\t\t\t\ttmpShape1 = shape.slice( 0, shapeIndex + 1 );\r\n\t\t\t\t\t\t\t\ttmpShape2 = shape.slice( shapeIndex );\r\n\t\t\t\t\t\t\t\ttmpHole1 = hole.slice( holeIndex );\r\n\t\t\t\t\t\t\t\ttmpHole2 = hole.slice( 0, holeIndex + 1 );\r\n\t\r\n\t\t\t\t\t\t\t\tshape = tmpShape1.concat( tmpHole1 ).concat( tmpHole2 ).concat( tmpShape2 );\r\n\t\r\n\t\t\t\t\t\t\t\tminShapeIndex = shapeIndex;\r\n\t\r\n\t\t\t\t\t\t\t\t// Debug only, to show the selected cuts\r\n\t\t\t\t\t\t\t\t// glob_CutLines.push( [ shapePt, holePt ] );\r\n\t\r\n\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tif ( holeIndex >= 0 )\tbreak;\t\t// hole-vertex found\r\n\t\r\n\t\t\t\t\t\t\tfailedCuts[cutKey] = true;\t\t\t// remember failure\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif ( holeIndex >= 0 )\tbreak;\t\t// hole-vertex found\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\treturn shape; \t\t\t/* shape with no holes */\r\n\t\t\t}\r\n\t\r\n\t\r\n\t\t\tvar i, il, f, face,\r\n\t\t\t\tkey, index,\r\n\t\t\t\tallPointsMap = {};\r\n\t\r\n\t\t\t// To maintain reference to old shape, one must match coordinates, or offset the indices from original arrays. It's probably easier to do the first.\r\n\t\r\n\t\t\tvar allpoints = contour.concat();\r\n\t\r\n\t\t\tfor ( var h = 0, hl = holes.length; h < hl; h ++ ) {\r\n\t\r\n\t\t\t\tArray.prototype.push.apply( allpoints, holes[h] );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t//console.log( \"allpoints\",allpoints, allpoints.length );\r\n\t\r\n\t\t\t// prepare all points map\r\n\t\r\n\t\t\tfor ( i = 0, il = allpoints.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\tkey = allpoints[ i ].x + \":\" + allpoints[ i ].y;\r\n\t\r\n\t\t\t\tif ( allPointsMap[ key ] !== undefined ) {\r\n\t\r\n\t\t\t\t\tTHREE.warn( \"THREE.Shape: Duplicate point\", key );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tallPointsMap[ key ] = i;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// remove holes by cutting paths to holes and adding them to the shape\r\n\t\t\tvar shapeWithoutHoles = removeHoles( contour, holes );\r\n\t\r\n\t\t\tvar triangles = THREE.FontUtils.Triangulate( shapeWithoutHoles, false ); // True returns indices for points of spooled shape\r\n\t\t\t//console.log( \"triangles\",triangles, triangles.length );\r\n\t\r\n\t\t\t// check all face vertices against all points map\r\n\t\r\n\t\t\tfor ( i = 0, il = triangles.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\tface = triangles[ i ];\r\n\t\r\n\t\t\t\tfor ( f = 0; f < 3; f ++ ) {\r\n\t\r\n\t\t\t\t\tkey = face[ f ].x + \":\" + face[ f ].y;\r\n\t\r\n\t\t\t\t\tindex = allPointsMap[ key ];\r\n\t\r\n\t\t\t\t\tif ( index !== undefined ) {\r\n\t\r\n\t\t\t\t\t\tface[ f ] = index;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn triangles.concat();\r\n\t\r\n\t\t},\r\n\t\r\n\t\tisClockWise: function ( pts ) {\r\n\t\r\n\t\t\treturn THREE.FontUtils.Triangulate.area( pts ) < 0;\r\n\t\r\n\t\t},\r\n\t\r\n\t\t// Bezier Curves formulas obtained from\r\n\t\t// http://en.wikipedia.org/wiki/B%C3%A9zier_curve\r\n\t\r\n\t\t// Quad Bezier Functions\r\n\t\r\n\t\tb2p0: function ( t, p ) {\r\n\t\r\n\t\t\tvar k = 1 - t;\r\n\t\t\treturn k * k * p;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tb2p1: function ( t, p ) {\r\n\t\r\n\t\t\treturn 2 * ( 1 - t ) * t * p;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tb2p2: function ( t, p ) {\r\n\t\r\n\t\t\treturn t * t * p;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tb2: function ( t, p0, p1, p2 ) {\r\n\t\r\n\t\t\treturn this.b2p0( t, p0 ) + this.b2p1( t, p1 ) + this.b2p2( t, p2 );\r\n\t\r\n\t\t},\r\n\t\r\n\t\t// Cubic Bezier Functions\r\n\t\r\n\t\tb3p0: function ( t, p ) {\r\n\t\r\n\t\t\tvar k = 1 - t;\r\n\t\t\treturn k * k * k * p;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tb3p1: function ( t, p ) {\r\n\t\r\n\t\t\tvar k = 1 - t;\r\n\t\t\treturn 3 * k * k * t * p;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tb3p2: function ( t, p ) {\r\n\t\r\n\t\t\tvar k = 1 - t;\r\n\t\t\treturn 3 * k * t * t * p;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tb3p3: function ( t, p ) {\r\n\t\r\n\t\t\treturn t * t * t * p;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tb3: function ( t, p0, p1, p2, p3 ) {\r\n\t\r\n\t\t\treturn this.b3p0( t, p0 ) + this.b3p1( t, p1 ) + this.b3p2( t, p2 ) +  this.b3p3( t, p3 );\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t\r\n\t// File:src/extras/curves/LineCurve.js\r\n\t\r\n\t/**************************************************************\r\n\t *\tLine\r\n\t **************************************************************/\r\n\t\r\n\tTHREE.LineCurve = function ( v1, v2 ) {\r\n\t\r\n\t\tthis.v1 = v1;\r\n\t\tthis.v2 = v2;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.LineCurve.prototype = Object.create( THREE.Curve.prototype );\r\n\tTHREE.LineCurve.prototype.constructor = THREE.LineCurve;\r\n\t\r\n\tTHREE.LineCurve.prototype.getPoint = function ( t ) {\r\n\t\r\n\t\tvar point = this.v2.clone().sub(this.v1);\r\n\t\tpoint.multiplyScalar( t ).add( this.v1 );\r\n\t\r\n\t\treturn point;\r\n\t\r\n\t};\r\n\t\r\n\t// Line curve is linear, so we can overwrite default getPointAt\r\n\t\r\n\tTHREE.LineCurve.prototype.getPointAt = function ( u ) {\r\n\t\r\n\t\treturn this.getPoint( u );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.LineCurve.prototype.getTangent = function( t ) {\r\n\t\r\n\t\tvar tangent = this.v2.clone().sub(this.v1);\r\n\t\r\n\t\treturn tangent.normalize();\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/extras/curves/QuadraticBezierCurve.js\r\n\t\r\n\t/**************************************************************\r\n\t *\tQuadratic Bezier curve\r\n\t **************************************************************/\r\n\t\r\n\t\r\n\tTHREE.QuadraticBezierCurve = function ( v0, v1, v2 ) {\r\n\t\r\n\t\tthis.v0 = v0;\r\n\t\tthis.v1 = v1;\r\n\t\tthis.v2 = v2;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.QuadraticBezierCurve.prototype = Object.create( THREE.Curve.prototype );\r\n\tTHREE.QuadraticBezierCurve.prototype.constructor = THREE.QuadraticBezierCurve;\r\n\t\r\n\t\r\n\tTHREE.QuadraticBezierCurve.prototype.getPoint = function ( t ) {\r\n\t\r\n\t\tvar vector = new THREE.Vector2();\r\n\t\r\n\t\tvector.x = THREE.Shape.Utils.b2( t, this.v0.x, this.v1.x, this.v2.x );\r\n\t\tvector.y = THREE.Shape.Utils.b2( t, this.v0.y, this.v1.y, this.v2.y );\r\n\t\r\n\t\treturn vector;\r\n\t\r\n\t};\r\n\t\r\n\t\r\n\tTHREE.QuadraticBezierCurve.prototype.getTangent = function( t ) {\r\n\t\r\n\t\tvar vector = new THREE.Vector2();\r\n\t\r\n\t\tvector.x = THREE.Curve.Utils.tangentQuadraticBezier( t, this.v0.x, this.v1.x, this.v2.x );\r\n\t\tvector.y = THREE.Curve.Utils.tangentQuadraticBezier( t, this.v0.y, this.v1.y, this.v2.y );\r\n\t\r\n\t\t// returns unit vector\r\n\t\r\n\t\treturn vector.normalize();\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/extras/curves/CubicBezierCurve.js\r\n\t\r\n\t/**************************************************************\r\n\t *\tCubic Bezier curve\r\n\t **************************************************************/\r\n\t\r\n\tTHREE.CubicBezierCurve = function ( v0, v1, v2, v3 ) {\r\n\t\r\n\t\tthis.v0 = v0;\r\n\t\tthis.v1 = v1;\r\n\t\tthis.v2 = v2;\r\n\t\tthis.v3 = v3;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.CubicBezierCurve.prototype = Object.create( THREE.Curve.prototype );\r\n\tTHREE.CubicBezierCurve.prototype.constructor = THREE.CubicBezierCurve;\r\n\t\r\n\tTHREE.CubicBezierCurve.prototype.getPoint = function ( t ) {\r\n\t\r\n\t\tvar tx, ty;\r\n\t\r\n\t\ttx = THREE.Shape.Utils.b3( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x );\r\n\t\tty = THREE.Shape.Utils.b3( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y );\r\n\t\r\n\t\treturn new THREE.Vector2( tx, ty );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.CubicBezierCurve.prototype.getTangent = function( t ) {\r\n\t\r\n\t\tvar tx, ty;\r\n\t\r\n\t\ttx = THREE.Curve.Utils.tangentCubicBezier( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x );\r\n\t\tty = THREE.Curve.Utils.tangentCubicBezier( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y );\r\n\t\r\n\t\tvar tangent = new THREE.Vector2( tx, ty );\r\n\t\ttangent.normalize();\r\n\t\r\n\t\treturn tangent;\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/extras/curves/SplineCurve.js\r\n\t\r\n\t/**************************************************************\r\n\t *\tSpline curve\r\n\t **************************************************************/\r\n\t\r\n\tTHREE.SplineCurve = function ( points /* array of Vector2 */ ) {\r\n\t\r\n\t\tthis.points = ( points == undefined ) ? [] : points;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.SplineCurve.prototype = Object.create( THREE.Curve.prototype );\r\n\tTHREE.SplineCurve.prototype.constructor = THREE.SplineCurve;\r\n\t\r\n\tTHREE.SplineCurve.prototype.getPoint = function ( t ) {\r\n\t\r\n\t\tvar points = this.points;\r\n\t\tvar point = ( points.length - 1 ) * t;\r\n\t\r\n\t\tvar intPoint = Math.floor( point );\r\n\t\tvar weight = point - intPoint;\r\n\t\r\n\t\tvar point0 = points[ intPoint == 0 ? intPoint : intPoint - 1 ]\r\n\t\tvar point1 = points[ intPoint ]\r\n\t\tvar point2 = points[ intPoint > points.length - 2 ? points.length - 1 : intPoint + 1 ]\r\n\t\tvar point3 = points[ intPoint > points.length - 3 ? points.length - 1 : intPoint + 2 ]\r\n\t\r\n\t\tvar vector = new THREE.Vector2();\r\n\t\r\n\t\tvector.x = THREE.Curve.Utils.interpolate( point0.x, point1.x, point2.x, point3.x, weight );\r\n\t\tvector.y = THREE.Curve.Utils.interpolate( point0.y, point1.y, point2.y, point3.y, weight );\r\n\t\r\n\t\treturn vector;\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/extras/curves/EllipseCurve.js\r\n\t\r\n\t/**************************************************************\r\n\t *\tEllipse curve\r\n\t **************************************************************/\r\n\t\r\n\tTHREE.EllipseCurve = function ( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise ) {\r\n\t\r\n\t\tthis.aX = aX;\r\n\t\tthis.aY = aY;\r\n\t\r\n\t\tthis.xRadius = xRadius;\r\n\t\tthis.yRadius = yRadius;\r\n\t\r\n\t\tthis.aStartAngle = aStartAngle;\r\n\t\tthis.aEndAngle = aEndAngle;\r\n\t\r\n\t\tthis.aClockwise = aClockwise;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.EllipseCurve.prototype = Object.create( THREE.Curve.prototype );\r\n\tTHREE.EllipseCurve.prototype.constructor = THREE.EllipseCurve;\r\n\t\r\n\tTHREE.EllipseCurve.prototype.getPoint = function ( t ) {\r\n\t\r\n\t\tvar deltaAngle = this.aEndAngle - this.aStartAngle;\r\n\t\r\n\t\tif ( deltaAngle < 0 ) deltaAngle += Math.PI * 2;\r\n\t\tif ( deltaAngle > Math.PI * 2 ) deltaAngle -= Math.PI * 2;\r\n\t\r\n\t\tvar angle;\r\n\t\r\n\t\tif ( this.aClockwise === true ) {\r\n\t\r\n\t\t\tangle = this.aEndAngle + ( 1 - t ) * ( Math.PI * 2 - deltaAngle );\r\n\t\r\n\t\t} else {\r\n\t\r\n\t\t\tangle = this.aStartAngle + t * deltaAngle;\r\n\t\r\n\t\t}\r\n\t\t\r\n\t\tvar vector = new THREE.Vector2();\r\n\t\r\n\t\tvector.x = this.aX + this.xRadius * Math.cos( angle );\r\n\t\tvector.y = this.aY + this.yRadius * Math.sin( angle );\r\n\t\r\n\t\treturn vector;\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/extras/curves/ArcCurve.js\r\n\t\r\n\t/**************************************************************\r\n\t *\tArc curve\r\n\t **************************************************************/\r\n\t\r\n\tTHREE.ArcCurve = function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {\r\n\t\r\n\t\tTHREE.EllipseCurve.call( this, aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );\r\n\t};\r\n\t\r\n\tTHREE.ArcCurve.prototype = Object.create( THREE.EllipseCurve.prototype );\r\n\tTHREE.ArcCurve.prototype.constructor = THREE.ArcCurve;\r\n\t\r\n\t// File:src/extras/curves/LineCurve3.js\r\n\t\r\n\t/**************************************************************\r\n\t *\tLine3D\r\n\t **************************************************************/\r\n\t\r\n\tTHREE.LineCurve3 = THREE.Curve.create(\r\n\t\r\n\t\tfunction ( v1, v2 ) {\r\n\t\r\n\t\t\tthis.v1 = v1;\r\n\t\t\tthis.v2 = v2;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tfunction ( t ) {\r\n\t\r\n\t\t\tvar vector = new THREE.Vector3();\r\n\t\r\n\t\t\tvector.subVectors( this.v2, this.v1 ); // diff\r\n\t\t\tvector.multiplyScalar( t );\r\n\t\t\tvector.add( this.v1 );\r\n\t\r\n\t\t\treturn vector;\r\n\t\r\n\t\t}\r\n\t\r\n\t);\r\n\t\r\n\t// File:src/extras/curves/QuadraticBezierCurve3.js\r\n\t\r\n\t/**************************************************************\r\n\t *\tQuadratic Bezier 3D curve\r\n\t **************************************************************/\r\n\t\r\n\tTHREE.QuadraticBezierCurve3 = THREE.Curve.create(\r\n\t\r\n\t\tfunction ( v0, v1, v2 ) {\r\n\t\r\n\t\t\tthis.v0 = v0;\r\n\t\t\tthis.v1 = v1;\r\n\t\t\tthis.v2 = v2;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tfunction ( t ) {\r\n\t\r\n\t\t\tvar vector = new THREE.Vector3();\r\n\t\r\n\t\t\tvector.x = THREE.Shape.Utils.b2( t, this.v0.x, this.v1.x, this.v2.x );\r\n\t\t\tvector.y = THREE.Shape.Utils.b2( t, this.v0.y, this.v1.y, this.v2.y );\r\n\t\t\tvector.z = THREE.Shape.Utils.b2( t, this.v0.z, this.v1.z, this.v2.z );\r\n\t\r\n\t\t\treturn vector;\r\n\t\r\n\t\t}\r\n\t\r\n\t);\r\n\t\r\n\t// File:src/extras/curves/CubicBezierCurve3.js\r\n\t\r\n\t/**************************************************************\r\n\t *\tCubic Bezier 3D curve\r\n\t **************************************************************/\r\n\t\r\n\tTHREE.CubicBezierCurve3 = THREE.Curve.create(\r\n\t\r\n\t\tfunction ( v0, v1, v2, v3 ) {\r\n\t\r\n\t\t\tthis.v0 = v0;\r\n\t\t\tthis.v1 = v1;\r\n\t\t\tthis.v2 = v2;\r\n\t\t\tthis.v3 = v3;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tfunction ( t ) {\r\n\t\r\n\t\t\tvar vector = new THREE.Vector3();\r\n\t\r\n\t\t\tvector.x = THREE.Shape.Utils.b3( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x );\r\n\t\t\tvector.y = THREE.Shape.Utils.b3( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y );\r\n\t\t\tvector.z = THREE.Shape.Utils.b3( t, this.v0.z, this.v1.z, this.v2.z, this.v3.z );\r\n\t\r\n\t\t\treturn vector;\r\n\t\r\n\t\t}\r\n\t\r\n\t);\r\n\t\r\n\t// File:src/extras/curves/SplineCurve3.js\r\n\t\r\n\t/**************************************************************\r\n\t *\tSpline 3D curve\r\n\t **************************************************************/\r\n\t\r\n\t\r\n\tTHREE.SplineCurve3 = THREE.Curve.create(\r\n\t\r\n\t\tfunction ( points /* array of Vector3 */) {\r\n\t\r\n\t\t\tthis.points = ( points == undefined ) ? [] : points;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tfunction ( t ) {\r\n\t\r\n\t\t\tvar points = this.points;\r\n\t\t\tvar point = ( points.length - 1 ) * t;\r\n\t\r\n\t\t\tvar intPoint = Math.floor( point );\r\n\t\t\tvar weight = point - intPoint;\r\n\t\r\n\t\t\tvar point0 = points[ intPoint == 0 ? intPoint : intPoint - 1 ];\r\n\t\t\tvar point1 = points[ intPoint ];\r\n\t\t\tvar point2 = points[ intPoint > points.length - 2 ? points.length - 1 : intPoint + 1 ];\r\n\t\t\tvar point3 = points[ intPoint > points.length - 3 ? points.length - 1 : intPoint + 2 ];\r\n\t\r\n\t\t\tvar vector = new THREE.Vector3();\r\n\t\r\n\t\t\tvector.x = THREE.Curve.Utils.interpolate( point0.x, point1.x, point2.x, point3.x, weight );\r\n\t\t\tvector.y = THREE.Curve.Utils.interpolate( point0.y, point1.y, point2.y, point3.y, weight );\r\n\t\t\tvector.z = THREE.Curve.Utils.interpolate( point0.z, point1.z, point2.z, point3.z, weight );\r\n\t\r\n\t\t\treturn vector;\r\n\t\r\n\t\t}\r\n\t\r\n\t);\r\n\t\r\n\t// File:src/extras/curves/ClosedSplineCurve3.js\r\n\t\r\n\t/**************************************************************\r\n\t *\tClosed Spline 3D curve\r\n\t **************************************************************/\r\n\t\r\n\t\r\n\tTHREE.ClosedSplineCurve3 = THREE.Curve.create(\r\n\t\r\n\t\tfunction ( points /* array of Vector3 */) {\r\n\t\r\n\t\t\tthis.points = ( points == undefined ) ? [] : points;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tfunction ( t ) {\r\n\t\r\n\t\t\tvar points = this.points;\r\n\t\t\tvar point = ( points.length - 0 ) * t; // This needs to be from 0-length +1\r\n\t\r\n\t\t\tvar intPoint = Math.floor( point );\r\n\t\t\tvar weight = point - intPoint;\r\n\t\r\n\t\t\tintPoint += intPoint > 0 ? 0 : ( Math.floor( Math.abs( intPoint ) / points.length ) + 1 ) * points.length;\r\n\t\r\n\t\t\tvar point0 = points[ ( intPoint - 1 ) % points.length ];\r\n\t\t\tvar point1 = points[ ( intPoint     ) % points.length ];\r\n\t\t\tvar point2 = points[ ( intPoint + 1 ) % points.length ];\r\n\t\t\tvar point3 = points[ ( intPoint + 2 ) % points.length ];\r\n\t\r\n\t\t\tvar vector = new THREE.Vector3();\r\n\t\r\n\t\t\tvector.x = THREE.Curve.Utils.interpolate( point0.x, point1.x, point2.x, point3.x, weight );\r\n\t\t\tvector.y = THREE.Curve.Utils.interpolate( point0.y, point1.y, point2.y, point3.y, weight );\r\n\t\t\tvector.z = THREE.Curve.Utils.interpolate( point0.z, point1.z, point2.z, point3.z, weight );\r\n\t\r\n\t\t\treturn vector;\r\n\t\r\n\t\t}\r\n\t\r\n\t);\r\n\t\r\n\t// File:src/extras/animation/AnimationHandler.js\r\n\t\r\n\t/**\r\n\t * @author mikael emtinger / http://gomo.se/\r\n\t */\r\n\t\r\n\tTHREE.AnimationHandler = {\r\n\t\r\n\t\tLINEAR: 0,\r\n\t\tCATMULLROM: 1,\r\n\t\tCATMULLROM_FORWARD: 2,\r\n\t\r\n\t\t//\r\n\t\r\n\t\tadd: function () { THREE.warn( 'THREE.AnimationHandler.add() has been deprecated.' ); },\r\n\t\tget: function () { THREE.warn( 'THREE.AnimationHandler.get() has been deprecated.' ); },\r\n\t\tremove: function () { THREE.warn( 'THREE.AnimationHandler.remove() has been deprecated.' ); },\r\n\t\r\n\t\t//\r\n\t\r\n\t\tanimations: [],\r\n\t\r\n\t\tinit: function ( data ) {\r\n\t\r\n\t\t\tif ( data.initialized === true ) return data;\r\n\t\r\n\t\t\t// loop through all keys\r\n\t\r\n\t\t\tfor ( var h = 0; h < data.hierarchy.length; h ++ ) {\r\n\t\r\n\t\t\t\tfor ( var k = 0; k < data.hierarchy[ h ].keys.length; k ++ ) {\r\n\t\r\n\t\t\t\t\t// remove minus times\r\n\t\r\n\t\t\t\t\tif ( data.hierarchy[ h ].keys[ k ].time < 0 ) {\r\n\t\r\n\t\t\t\t\t\t data.hierarchy[ h ].keys[ k ].time = 0;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t// create quaternions\r\n\t\r\n\t\t\t\t\tif ( data.hierarchy[ h ].keys[ k ].rot !== undefined &&\r\n\t\t\t\t\t  ! ( data.hierarchy[ h ].keys[ k ].rot instanceof THREE.Quaternion ) ) {\r\n\t\r\n\t\t\t\t\t\tvar quat = data.hierarchy[ h ].keys[ k ].rot;\r\n\t\t\t\t\t\tdata.hierarchy[ h ].keys[ k ].rot = new THREE.Quaternion().fromArray( quat );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\t// prepare morph target keys\r\n\t\r\n\t\t\t\tif ( data.hierarchy[ h ].keys.length && data.hierarchy[ h ].keys[ 0 ].morphTargets !== undefined ) {\r\n\t\r\n\t\t\t\t\t// get all used\r\n\t\r\n\t\t\t\t\tvar usedMorphTargets = {};\r\n\t\r\n\t\t\t\t\tfor ( var k = 0; k < data.hierarchy[ h ].keys.length; k ++ ) {\r\n\t\r\n\t\t\t\t\t\tfor ( var m = 0; m < data.hierarchy[ h ].keys[ k ].morphTargets.length; m ++ ) {\r\n\t\r\n\t\t\t\t\t\t\tvar morphTargetName = data.hierarchy[ h ].keys[ k ].morphTargets[ m ];\r\n\t\t\t\t\t\t\tusedMorphTargets[ morphTargetName ] = - 1;\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tdata.hierarchy[ h ].usedMorphTargets = usedMorphTargets;\r\n\t\r\n\t\r\n\t\t\t\t\t// set all used on all frames\r\n\t\r\n\t\t\t\t\tfor ( var k = 0; k < data.hierarchy[ h ].keys.length; k ++ ) {\r\n\t\r\n\t\t\t\t\t\tvar influences = {};\r\n\t\r\n\t\t\t\t\t\tfor ( var morphTargetName in usedMorphTargets ) {\r\n\t\r\n\t\t\t\t\t\t\tfor ( var m = 0; m < data.hierarchy[ h ].keys[ k ].morphTargets.length; m ++ ) {\r\n\t\r\n\t\t\t\t\t\t\t\tif ( data.hierarchy[ h ].keys[ k ].morphTargets[ m ] === morphTargetName ) {\r\n\t\r\n\t\t\t\t\t\t\t\t\tinfluences[ morphTargetName ] = data.hierarchy[ h ].keys[ k ].morphTargetsInfluences[ m ];\r\n\t\t\t\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t\tif ( m === data.hierarchy[ h ].keys[ k ].morphTargets.length ) {\r\n\t\r\n\t\t\t\t\t\t\t\tinfluences[ morphTargetName ] = 0;\r\n\t\r\n\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\tdata.hierarchy[ h ].keys[ k ].morphTargetsInfluences = influences;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\r\n\t\t\t\t// remove all keys that are on the same time\r\n\t\r\n\t\t\t\tfor ( var k = 1; k < data.hierarchy[ h ].keys.length; k ++ ) {\r\n\t\r\n\t\t\t\t\tif ( data.hierarchy[ h ].keys[ k ].time === data.hierarchy[ h ].keys[ k - 1 ].time ) {\r\n\t\r\n\t\t\t\t\t\tdata.hierarchy[ h ].keys.splice( k, 1 );\r\n\t\t\t\t\t\tk --;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\r\n\t\t\t\t// set index\r\n\t\r\n\t\t\t\tfor ( var k = 0; k < data.hierarchy[ h ].keys.length; k ++ ) {\r\n\t\r\n\t\t\t\t\tdata.hierarchy[ h ].keys[ k ].index = k;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tdata.initialized = true;\r\n\t\r\n\t\t\treturn data;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tparse: function ( root ) {\r\n\t\r\n\t\t\tvar parseRecurseHierarchy = function ( root, hierarchy ) {\r\n\t\r\n\t\t\t\thierarchy.push( root );\r\n\t\r\n\t\t\t\tfor ( var c = 0; c < root.children.length; c ++ )\r\n\t\t\t\t\tparseRecurseHierarchy( root.children[ c ], hierarchy );\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t\t// setup hierarchy\r\n\t\r\n\t\t\tvar hierarchy = [];\r\n\t\r\n\t\t\tif ( root instanceof THREE.SkinnedMesh ) {\r\n\t\r\n\t\t\t\tfor ( var b = 0; b < root.skeleton.bones.length; b ++ ) {\r\n\t\r\n\t\t\t\t\thierarchy.push( root.skeleton.bones[ b ] );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\tparseRecurseHierarchy( root, hierarchy );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn hierarchy;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tplay: function ( animation ) {\r\n\t\r\n\t\t\tif ( this.animations.indexOf( animation ) === - 1 ) {\r\n\t\r\n\t\t\t\tthis.animations.push( animation );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t},\r\n\t\r\n\t\tstop: function ( animation ) {\r\n\t\r\n\t\t\tvar index = this.animations.indexOf( animation );\r\n\t\r\n\t\t\tif ( index !== - 1 ) {\r\n\t\r\n\t\t\t\tthis.animations.splice( index, 1 );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t},\r\n\t\r\n\t\tupdate: function ( deltaTimeMS ) {\r\n\t\r\n\t\t\tfor ( var i = 0; i < this.animations.length; i ++ ) {\r\n\t\r\n\t\t\t\tthis.animations[ i ].resetBlendWeights( );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tfor ( var i = 0; i < this.animations.length; i ++ ) {\r\n\t\r\n\t\t\t\tthis.animations[ i ].update( deltaTimeMS );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/extras/animation/Animation.js\r\n\t\r\n\t/**\r\n\t * @author mikael emtinger / http://gomo.se/\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t */\r\n\t\r\n\tTHREE.Animation = function ( root, data ) {\r\n\t\r\n\t\tthis.root = root;\r\n\t\tthis.data = THREE.AnimationHandler.init( data );\r\n\t\tthis.hierarchy = THREE.AnimationHandler.parse( root );\r\n\t\r\n\t\tthis.currentTime = 0;\r\n\t\tthis.timeScale = 1;\r\n\t\r\n\t\tthis.isPlaying = false;\r\n\t\tthis.loop = true;\r\n\t\tthis.weight = 0;\r\n\t\r\n\t\tthis.interpolationType = THREE.AnimationHandler.LINEAR;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Animation.prototype = {\r\n\t\r\n\t\tconstructor: THREE.Animation,\r\n\t\r\n\t\tkeyTypes:  [ \"pos\", \"rot\", \"scl\" ],\r\n\t\r\n\t\tplay: function ( startTime, weight ) {\r\n\t\r\n\t\t\tthis.currentTime = startTime !== undefined ? startTime : 0;\r\n\t\t\tthis.weight = weight !== undefined ? weight : 1;\r\n\t\r\n\t\t\tthis.isPlaying = true;\r\n\t\r\n\t\t\tthis.reset();\r\n\t\r\n\t\t\tTHREE.AnimationHandler.play( this );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tstop: function() {\r\n\t\r\n\t\t\tthis.isPlaying = false;\r\n\t\r\n\t\t\tTHREE.AnimationHandler.stop( this );\r\n\t\r\n\t\t},\r\n\t\r\n\t\treset: function () {\r\n\t\r\n\t\t\tfor ( var h = 0, hl = this.hierarchy.length; h < hl; h ++ ) {\r\n\t\r\n\t\t\t\tvar object = this.hierarchy[ h ];\r\n\t\r\n\t\t\t\tif ( object.animationCache === undefined ) {\r\n\t\r\n\t\t\t\t\tobject.animationCache = {\r\n\t\t\t\t\t\tanimations: {},\r\n\t\t\t\t\t\tblending: {\r\n\t\t\t\t\t\t\tpositionWeight: 0.0,\r\n\t\t\t\t\t\t\tquaternionWeight: 0.0,\r\n\t\t\t\t\t\t\tscaleWeight: 0.0\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t};\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tvar name = this.data.name;\r\n\t\t\t\tvar animations = object.animationCache.animations;\r\n\t\t\t\tvar animationCache = animations[ name ];\r\n\t\r\n\t\t\t\tif ( animationCache === undefined ) {\r\n\t\r\n\t\t\t\t\tanimationCache = {\r\n\t\t\t\t\t\tprevKey: { pos: 0, rot: 0, scl: 0 },\r\n\t\t\t\t\t\tnextKey: { pos: 0, rot: 0, scl: 0 },\r\n\t\t\t\t\t\toriginalMatrix: object.matrix\r\n\t\t\t\t\t};\r\n\t\r\n\t\t\t\t\tanimations[ name ] = animationCache;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\t// Get keys to match our current time\r\n\t\r\n\t\t\t\tfor ( var t = 0; t < 3; t ++ ) {\r\n\t\r\n\t\t\t\t\tvar type = this.keyTypes[ t ];\r\n\t\r\n\t\t\t\t\tvar prevKey = this.data.hierarchy[ h ].keys[ 0 ];\r\n\t\t\t\t\tvar nextKey = this.getNextKeyWith( type, h, 1 );\r\n\t\r\n\t\t\t\t\twhile ( nextKey.time < this.currentTime && nextKey.index > prevKey.index ) {\r\n\t\r\n\t\t\t\t\t\tprevKey = nextKey;\r\n\t\t\t\t\t\tnextKey = this.getNextKeyWith( type, h, nextKey.index + 1 );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tanimationCache.prevKey[ type ] = prevKey;\r\n\t\t\t\t\tanimationCache.nextKey[ type ] = nextKey;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t},\r\n\t\r\n\t\tresetBlendWeights: function () {\r\n\t\r\n\t\t\tfor ( var h = 0, hl = this.hierarchy.length; h < hl; h ++ ) {\r\n\t\r\n\t\t\t\tvar object = this.hierarchy[ h ];\r\n\t\t\t\tvar animationCache = object.animationCache;\r\n\t\r\n\t\t\t\tif ( animationCache !== undefined ) {\r\n\t\r\n\t\t\t\t\tvar blending = animationCache.blending;\r\n\t\r\n\t\t\t\t\tblending.positionWeight = 0.0;\r\n\t\t\t\t\tblending.quaternionWeight = 0.0;\r\n\t\t\t\t\tblending.scaleWeight = 0.0;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t},\r\n\t\r\n\t\tupdate: ( function() {\r\n\t\r\n\t\t\tvar points = [];\r\n\t\t\tvar target = new THREE.Vector3();\r\n\t\t\tvar newVector = new THREE.Vector3();\r\n\t\t\tvar newQuat = new THREE.Quaternion();\r\n\t\r\n\t\t\t// Catmull-Rom spline\r\n\t\r\n\t\t\tvar interpolateCatmullRom = function ( points, scale ) {\r\n\t\r\n\t\t\t\tvar c = [], v3 = [],\r\n\t\t\t\tpoint, intPoint, weight, w2, w3,\r\n\t\t\t\tpa, pb, pc, pd;\r\n\t\r\n\t\t\t\tpoint = ( points.length - 1 ) * scale;\r\n\t\t\t\tintPoint = Math.floor( point );\r\n\t\t\t\tweight = point - intPoint;\r\n\t\r\n\t\t\t\tc[ 0 ] = intPoint === 0 ? intPoint : intPoint - 1;\r\n\t\t\t\tc[ 1 ] = intPoint;\r\n\t\t\t\tc[ 2 ] = intPoint > points.length - 2 ? intPoint : intPoint + 1;\r\n\t\t\t\tc[ 3 ] = intPoint > points.length - 3 ? intPoint : intPoint + 2;\r\n\t\r\n\t\t\t\tpa = points[ c[ 0 ] ];\r\n\t\t\t\tpb = points[ c[ 1 ] ];\r\n\t\t\t\tpc = points[ c[ 2 ] ];\r\n\t\t\t\tpd = points[ c[ 3 ] ];\r\n\t\r\n\t\t\t\tw2 = weight * weight;\r\n\t\t\t\tw3 = weight * w2;\r\n\t\r\n\t\t\t\tv3[ 0 ] = interpolate( pa[ 0 ], pb[ 0 ], pc[ 0 ], pd[ 0 ], weight, w2, w3 );\r\n\t\t\t\tv3[ 1 ] = interpolate( pa[ 1 ], pb[ 1 ], pc[ 1 ], pd[ 1 ], weight, w2, w3 );\r\n\t\t\t\tv3[ 2 ] = interpolate( pa[ 2 ], pb[ 2 ], pc[ 2 ], pd[ 2 ], weight, w2, w3 );\r\n\t\r\n\t\t\t\treturn v3;\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t\tvar interpolate = function ( p0, p1, p2, p3, t, t2, t3 ) {\r\n\t\r\n\t\t\t\tvar v0 = ( p2 - p0 ) * 0.5,\r\n\t\t\t\t\tv1 = ( p3 - p1 ) * 0.5;\r\n\t\r\n\t\t\t\treturn ( 2 * ( p1 - p2 ) + v0 + v1 ) * t3 + ( - 3 * ( p1 - p2 ) - 2 * v0 - v1 ) * t2 + v0 * t + p1;\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t\treturn function ( delta ) {\r\n\t\r\n\t\t\t\tif ( this.isPlaying === false ) return;\r\n\t\r\n\t\t\t\tthis.currentTime += delta * this.timeScale;\r\n\t\r\n\t\t\t\tif ( this.weight === 0 )\r\n\t\t\t\t\treturn;\r\n\t\r\n\t\t\t\t//\r\n\t\r\n\t\t\t\tvar duration = this.data.length;\r\n\t\r\n\t\t\t\tif ( this.currentTime > duration || this.currentTime < 0 ) {\r\n\t\r\n\t\t\t\t\tif ( this.loop ) {\r\n\t\r\n\t\t\t\t\t\tthis.currentTime %= duration;\r\n\t\r\n\t\t\t\t\t\tif ( this.currentTime < 0 )\r\n\t\t\t\t\t\t\tthis.currentTime += duration;\r\n\t\r\n\t\t\t\t\t\tthis.reset();\r\n\t\r\n\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\tthis.stop();\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tfor ( var h = 0, hl = this.hierarchy.length; h < hl; h ++ ) {\r\n\t\r\n\t\t\t\t\tvar object = this.hierarchy[ h ];\r\n\t\t\t\t\tvar animationCache = object.animationCache.animations[this.data.name];\r\n\t\t\t\t\tvar blending = object.animationCache.blending;\r\n\t\r\n\t\t\t\t\t// loop through pos/rot/scl\r\n\t\r\n\t\t\t\t\tfor ( var t = 0; t < 3; t ++ ) {\r\n\t\r\n\t\t\t\t\t\t// get keys\r\n\t\r\n\t\t\t\t\t\tvar type    = this.keyTypes[ t ];\r\n\t\t\t\t\t\tvar prevKey = animationCache.prevKey[ type ];\r\n\t\t\t\t\t\tvar nextKey = animationCache.nextKey[ type ];\r\n\t\r\n\t\t\t\t\t\tif ( ( this.timeScale > 0 && nextKey.time <= this.currentTime ) ||\r\n\t\t\t\t\t\t\t( this.timeScale < 0 && prevKey.time >= this.currentTime ) ) {\r\n\t\r\n\t\t\t\t\t\t\tprevKey = this.data.hierarchy[ h ].keys[ 0 ];\r\n\t\t\t\t\t\t\tnextKey = this.getNextKeyWith( type, h, 1 );\r\n\t\r\n\t\t\t\t\t\t\twhile ( nextKey.time < this.currentTime && nextKey.index > prevKey.index ) {\r\n\t\r\n\t\t\t\t\t\t\t\tprevKey = nextKey;\r\n\t\t\t\t\t\t\t\tnextKey = this.getNextKeyWith( type, h, nextKey.index + 1 );\r\n\t\r\n\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t\tanimationCache.prevKey[ type ] = prevKey;\r\n\t\t\t\t\t\t\tanimationCache.nextKey[ type ] = nextKey;\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\tvar scale = ( this.currentTime - prevKey.time ) / ( nextKey.time - prevKey.time );\r\n\t\r\n\t\t\t\t\t\tvar prevXYZ = prevKey[ type ];\r\n\t\t\t\t\t\tvar nextXYZ = nextKey[ type ];\r\n\t\r\n\t\t\t\t\t\tif ( scale < 0 ) scale = 0;\r\n\t\t\t\t\t\tif ( scale > 1 ) scale = 1;\r\n\t\r\n\t\t\t\t\t\t// interpolate\r\n\t\r\n\t\t\t\t\t\tif ( type === \"pos\" ) {\r\n\t\r\n\t\t\t\t\t\t\tif ( this.interpolationType === THREE.AnimationHandler.LINEAR ) {\r\n\t\r\n\t\t\t\t\t\t\t\tnewVector.x = prevXYZ[ 0 ] + ( nextXYZ[ 0 ] - prevXYZ[ 0 ] ) * scale;\r\n\t\t\t\t\t\t\t\tnewVector.y = prevXYZ[ 1 ] + ( nextXYZ[ 1 ] - prevXYZ[ 1 ] ) * scale;\r\n\t\t\t\t\t\t\t\tnewVector.z = prevXYZ[ 2 ] + ( nextXYZ[ 2 ] - prevXYZ[ 2 ] ) * scale;\r\n\t\r\n\t\t\t\t\t\t\t\t// blend\r\n\t\t\t\t\t\t\t\tvar proportionalWeight = this.weight / ( this.weight + blending.positionWeight );\r\n\t\t\t\t\t\t\t\tobject.position.lerp( newVector, proportionalWeight );\r\n\t\t\t\t\t\t\t\tblending.positionWeight += this.weight;\r\n\t\r\n\t\t\t\t\t\t\t} else if ( this.interpolationType === THREE.AnimationHandler.CATMULLROM ||\r\n\t\t\t\t\t\t\t\t\t\tthis.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD ) {\r\n\t\r\n\t\t\t\t\t\t\t\tpoints[ 0 ] = this.getPrevKeyWith( \"pos\", h, prevKey.index - 1 )[ \"pos\" ];\r\n\t\t\t\t\t\t\t\tpoints[ 1 ] = prevXYZ;\r\n\t\t\t\t\t\t\t\tpoints[ 2 ] = nextXYZ;\r\n\t\t\t\t\t\t\t\tpoints[ 3 ] = this.getNextKeyWith( \"pos\", h, nextKey.index + 1 )[ \"pos\" ];\r\n\t\r\n\t\t\t\t\t\t\t\tscale = scale * 0.33 + 0.33;\r\n\t\r\n\t\t\t\t\t\t\t\tvar currentPoint = interpolateCatmullRom( points, scale );\r\n\t\t\t\t\t\t\t\tvar proportionalWeight = this.weight / ( this.weight + blending.positionWeight );\r\n\t\t\t\t\t\t\t\tblending.positionWeight += this.weight;\r\n\t\r\n\t\t\t\t\t\t\t\t// blend\r\n\t\r\n\t\t\t\t\t\t\t\tvar vector = object.position;\r\n\t\r\n\t\t\t\t\t\t\t\tvector.x = vector.x + ( currentPoint[ 0 ] - vector.x ) * proportionalWeight;\r\n\t\t\t\t\t\t\t\tvector.y = vector.y + ( currentPoint[ 1 ] - vector.y ) * proportionalWeight;\r\n\t\t\t\t\t\t\t\tvector.z = vector.z + ( currentPoint[ 2 ] - vector.z ) * proportionalWeight;\r\n\t\r\n\t\t\t\t\t\t\t\tif ( this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD ) {\r\n\t\r\n\t\t\t\t\t\t\t\t\tvar forwardPoint = interpolateCatmullRom( points, scale * 1.01 );\r\n\t\r\n\t\t\t\t\t\t\t\t\ttarget.set( forwardPoint[ 0 ], forwardPoint[ 1 ], forwardPoint[ 2 ] );\r\n\t\t\t\t\t\t\t\t\ttarget.sub( vector );\r\n\t\t\t\t\t\t\t\t\ttarget.y = 0;\r\n\t\t\t\t\t\t\t\t\ttarget.normalize();\r\n\t\r\n\t\t\t\t\t\t\t\t\tvar angle = Math.atan2( target.x, target.z );\r\n\t\t\t\t\t\t\t\t\tobject.rotation.set( 0, angle, 0 );\r\n\t\r\n\t\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t} else if ( type === \"rot\" ) {\r\n\t\r\n\t\t\t\t\t\t\tTHREE.Quaternion.slerp( prevXYZ, nextXYZ, newQuat, scale );\r\n\t\r\n\t\t\t\t\t\t\t// Avoid paying the cost of an additional slerp if we don't have to\r\n\t\t\t\t\t\t\tif ( blending.quaternionWeight === 0 ) {\r\n\t\r\n\t\t\t\t\t\t\t\tobject.quaternion.copy(newQuat);\r\n\t\t\t\t\t\t\t\tblending.quaternionWeight = this.weight;\r\n\t\r\n\t\t\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\t\t\tvar proportionalWeight = this.weight / ( this.weight + blending.quaternionWeight );\r\n\t\t\t\t\t\t\t\tTHREE.Quaternion.slerp( object.quaternion, newQuat, object.quaternion, proportionalWeight );\r\n\t\t\t\t\t\t\t\tblending.quaternionWeight += this.weight;\r\n\t\r\n\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t} else if ( type === \"scl\" ) {\r\n\t\r\n\t\t\t\t\t\t\tnewVector.x = prevXYZ[ 0 ] + ( nextXYZ[ 0 ] - prevXYZ[ 0 ] ) * scale;\r\n\t\t\t\t\t\t\tnewVector.y = prevXYZ[ 1 ] + ( nextXYZ[ 1 ] - prevXYZ[ 1 ] ) * scale;\r\n\t\t\t\t\t\t\tnewVector.z = prevXYZ[ 2 ] + ( nextXYZ[ 2 ] - prevXYZ[ 2 ] ) * scale;\r\n\t\r\n\t\t\t\t\t\t\tvar proportionalWeight = this.weight / ( this.weight + blending.scaleWeight );\r\n\t\t\t\t\t\t\tobject.scale.lerp( newVector, proportionalWeight );\r\n\t\t\t\t\t\t\tblending.scaleWeight += this.weight;\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\treturn true;\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t} )(),\r\n\t\r\n\t\tgetNextKeyWith: function ( type, h, key ) {\r\n\t\r\n\t\t\tvar keys = this.data.hierarchy[ h ].keys;\r\n\t\r\n\t\t\tif ( this.interpolationType === THREE.AnimationHandler.CATMULLROM ||\r\n\t\t\t\t this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD ) {\r\n\t\r\n\t\t\t\tkey = key < keys.length - 1 ? key : keys.length - 1;\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\tkey = key % keys.length;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tfor ( ; key < keys.length; key ++ ) {\r\n\t\r\n\t\t\t\tif ( keys[ key ][ type ] !== undefined ) {\r\n\t\r\n\t\t\t\t\treturn keys[ key ];\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this.data.hierarchy[ h ].keys[ 0 ];\r\n\t\r\n\t\t},\r\n\t\r\n\t\tgetPrevKeyWith: function ( type, h, key ) {\r\n\t\r\n\t\t\tvar keys = this.data.hierarchy[ h ].keys;\r\n\t\r\n\t\t\tif ( this.interpolationType === THREE.AnimationHandler.CATMULLROM ||\r\n\t\t\t\tthis.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD ) {\r\n\t\r\n\t\t\t\tkey = key > 0 ? key : 0;\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\tkey = key >= 0 ? key : key + keys.length;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\r\n\t\t\tfor ( ; key >= 0; key -- ) {\r\n\t\r\n\t\t\t\tif ( keys[ key ][ type ] !== undefined ) {\r\n\t\r\n\t\t\t\t\treturn keys[ key ];\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this.data.hierarchy[ h ].keys[ keys.length - 1 ];\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/extras/animation/KeyFrameAnimation.js\r\n\t\r\n\t/**\r\n\t * @author mikael emtinger / http://gomo.se/\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t * @author khang duong\r\n\t * @author erik kitson\r\n\t */\r\n\t\r\n\tTHREE.KeyFrameAnimation = function ( data ) {\r\n\t\r\n\t\tthis.root = data.node;\r\n\t\tthis.data = THREE.AnimationHandler.init( data );\r\n\t\tthis.hierarchy = THREE.AnimationHandler.parse( this.root );\r\n\t\tthis.currentTime = 0;\r\n\t\tthis.timeScale = 0.001;\r\n\t\tthis.isPlaying = false;\r\n\t\tthis.isPaused = true;\r\n\t\tthis.loop = true;\r\n\t\r\n\t\t// initialize to first keyframes\r\n\t\r\n\t\tfor ( var h = 0, hl = this.hierarchy.length; h < hl; h ++ ) {\r\n\t\r\n\t\t\tvar keys = this.data.hierarchy[h].keys,\r\n\t\t\t\tsids = this.data.hierarchy[h].sids,\r\n\t\t\t\tobj = this.hierarchy[h];\r\n\t\r\n\t\t\tif ( keys.length && sids ) {\r\n\t\r\n\t\t\t\tfor ( var s = 0; s < sids.length; s ++ ) {\r\n\t\r\n\t\t\t\t\tvar sid = sids[ s ],\r\n\t\t\t\t\t\tnext = this.getNextKeyWith( sid, h, 0 );\r\n\t\r\n\t\t\t\t\tif ( next ) {\r\n\t\r\n\t\t\t\t\t\tnext.apply( sid );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tobj.matrixAutoUpdate = false;\r\n\t\t\t\tthis.data.hierarchy[h].node.updateMatrix();\r\n\t\t\t\tobj.matrixWorldNeedsUpdate = true;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.KeyFrameAnimation.prototype = {\r\n\t\r\n\t\tconstructor: THREE.KeyFrameAnimation,\r\n\t\r\n\t\tplay: function ( startTime ) {\r\n\t\r\n\t\t\tthis.currentTime = startTime !== undefined ? startTime : 0;\r\n\t\r\n\t\t\tif ( this.isPlaying === false ) {\r\n\t\r\n\t\t\t\tthis.isPlaying = true;\r\n\t\r\n\t\t\t\t// reset key cache\r\n\t\r\n\t\t\t\tvar h, hl = this.hierarchy.length,\r\n\t\t\t\t\tobject,\r\n\t\t\t\t\tnode;\r\n\t\r\n\t\t\t\tfor ( h = 0; h < hl; h ++ ) {\r\n\t\r\n\t\t\t\t\tobject = this.hierarchy[ h ];\r\n\t\t\t\t\tnode = this.data.hierarchy[ h ];\r\n\t\r\n\t\t\t\t\tif ( node.animationCache === undefined ) {\r\n\t\r\n\t\t\t\t\t\tnode.animationCache = {};\r\n\t\t\t\t\t\tnode.animationCache.prevKey = null;\r\n\t\t\t\t\t\tnode.animationCache.nextKey = null;\r\n\t\t\t\t\t\tnode.animationCache.originalMatrix = object.matrix;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tvar keys = this.data.hierarchy[h].keys;\r\n\t\r\n\t\t\t\t\tif (keys.length) {\r\n\t\r\n\t\t\t\t\t\tnode.animationCache.prevKey = keys[ 0 ];\r\n\t\t\t\t\t\tnode.animationCache.nextKey = keys[ 1 ];\r\n\t\r\n\t\t\t\t\t\tthis.startTime = Math.min( keys[0].time, this.startTime );\r\n\t\t\t\t\t\tthis.endTime = Math.max( keys[keys.length - 1].time, this.endTime );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tthis.update( 0 );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tthis.isPaused = false;\r\n\t\r\n\t\t\tTHREE.AnimationHandler.play( this );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tstop: function () {\r\n\t\r\n\t\t\tthis.isPlaying = false;\r\n\t\t\tthis.isPaused  = false;\r\n\t\r\n\t\t\tTHREE.AnimationHandler.stop( this );\r\n\t\r\n\t\t\t// reset JIT matrix and remove cache\r\n\t\r\n\t\t\tfor ( var h = 0; h < this.data.hierarchy.length; h ++ ) {\r\n\t\r\n\t\t\t\tvar obj = this.hierarchy[ h ];\r\n\t\t\t\tvar node = this.data.hierarchy[ h ];\r\n\t\r\n\t\t\t\tif ( node.animationCache !== undefined ) {\r\n\t\r\n\t\t\t\t\tvar original = node.animationCache.originalMatrix;\r\n\t\r\n\t\t\t\t\toriginal.copy( obj.matrix );\r\n\t\t\t\t\tobj.matrix = original;\r\n\t\r\n\t\t\t\t\tdelete node.animationCache;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t},\r\n\t\r\n\t\tupdate: function ( delta ) {\r\n\t\r\n\t\t\tif ( this.isPlaying === false ) return;\r\n\t\r\n\t\t\tthis.currentTime += delta * this.timeScale;\r\n\t\r\n\t\t\t//\r\n\t\r\n\t\t\tvar duration = this.data.length;\r\n\t\r\n\t\t\tif ( this.loop === true && this.currentTime > duration ) {\r\n\t\r\n\t\t\t\tthis.currentTime %= duration;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tthis.currentTime = Math.min( this.currentTime, duration );\r\n\t\r\n\t\t\tfor ( var h = 0, hl = this.hierarchy.length; h < hl; h ++ ) {\r\n\t\r\n\t\t\t\tvar object = this.hierarchy[ h ];\r\n\t\t\t\tvar node = this.data.hierarchy[ h ];\r\n\t\r\n\t\t\t\tvar keys = node.keys,\r\n\t\t\t\t\tanimationCache = node.animationCache;\r\n\t\r\n\t\r\n\t\t\t\tif ( keys.length ) {\r\n\t\r\n\t\t\t\t\tvar prevKey = animationCache.prevKey;\r\n\t\t\t\t\tvar nextKey = animationCache.nextKey;\r\n\t\r\n\t\t\t\t\tif ( nextKey.time <= this.currentTime ) {\r\n\t\r\n\t\t\t\t\t\twhile ( nextKey.time < this.currentTime && nextKey.index > prevKey.index ) {\r\n\t\r\n\t\t\t\t\t\t\tprevKey = nextKey;\r\n\t\t\t\t\t\t\tnextKey = keys[ prevKey.index + 1 ];\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\tanimationCache.prevKey = prevKey;\r\n\t\t\t\t\t\tanimationCache.nextKey = nextKey;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tif ( nextKey.time >= this.currentTime ) {\r\n\t\r\n\t\t\t\t\t\tprevKey.interpolate( nextKey, this.currentTime );\r\n\t\r\n\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\tprevKey.interpolate( nextKey, nextKey.time );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tthis.data.hierarchy[ h ].node.updateMatrix();\r\n\t\t\t\t\tobject.matrixWorldNeedsUpdate = true;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t},\r\n\t\r\n\t\tgetNextKeyWith: function ( sid, h, key ) {\r\n\t\r\n\t\t\tvar keys = this.data.hierarchy[ h ].keys;\r\n\t\t\tkey = key % keys.length;\r\n\t\r\n\t\t\tfor ( ; key < keys.length; key ++ ) {\r\n\t\r\n\t\t\t\tif ( keys[ key ].hasTarget( sid ) ) {\r\n\t\r\n\t\t\t\t\treturn keys[ key ];\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn keys[ 0 ];\r\n\t\r\n\t\t},\r\n\t\r\n\t\tgetPrevKeyWith: function ( sid, h, key ) {\r\n\t\r\n\t\t\tvar keys = this.data.hierarchy[ h ].keys;\r\n\t\t\tkey = key >= 0 ? key : key + keys.length;\r\n\t\r\n\t\t\tfor ( ; key >= 0; key -- ) {\r\n\t\r\n\t\t\t\tif ( keys[ key ].hasTarget( sid ) ) {\r\n\t\r\n\t\t\t\t\treturn keys[ key ];\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn keys[ keys.length - 1 ];\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/extras/animation/MorphAnimation.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com\r\n\t * @author willy-vvu / http://willy-vvu.github.io\r\n\t */\r\n\t\r\n\tTHREE.MorphAnimation = function ( mesh ) {\r\n\t\r\n\t\tthis.mesh = mesh;\r\n\t\tthis.frames = mesh.morphTargetInfluences.length;\r\n\t\tthis.currentTime = 0;\r\n\t\tthis.duration = 1000;\r\n\t\tthis.loop = true;\r\n\t\tthis.lastFrame = 0;\r\n\t\tthis.currentFrame = 0;\r\n\t\r\n\t\tthis.isPlaying = false;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.MorphAnimation.prototype = {\r\n\t\r\n\t\tconstructor: THREE.MorphAnimation,\r\n\t\r\n\t\tplay: function () {\r\n\t\r\n\t\t\tthis.isPlaying = true;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tpause: function () {\r\n\t\r\n\t\t\tthis.isPlaying = false;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tupdate: function ( delta ) {\r\n\t\r\n\t\t\tif ( this.isPlaying === false ) return;\r\n\t\r\n\t\t\tthis.currentTime += delta;\r\n\t\r\n\t\t\tif ( this.loop === true && this.currentTime > this.duration ) {\r\n\t\r\n\t\t\t\tthis.currentTime %= this.duration;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tthis.currentTime = Math.min( this.currentTime, this.duration );\r\n\t\r\n\t\t\tvar interpolation = this.duration / this.frames;\r\n\t\t\tvar frame = Math.floor( this.currentTime / interpolation );\r\n\t\r\n\t\t\tvar influences = this.mesh.morphTargetInfluences;\r\n\t\r\n\t\t\tif ( frame != this.currentFrame ) {\r\n\t\r\n\t\t\t\tinfluences[ this.lastFrame ] = 0;\r\n\t\t\t\tinfluences[ this.currentFrame ] = 1;\r\n\t\t\t\tinfluences[ frame ] = 0;\r\n\t\r\n\t\t\t\tthis.lastFrame = this.currentFrame;\r\n\t\t\t\tthis.currentFrame = frame;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tinfluences[ frame ] = ( this.currentTime % interpolation ) / interpolation;\r\n\t\t\tinfluences[ this.lastFrame ] = 1 - influences[ frame ];\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/extras/geometries/BoxGeometry.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Cube.as\r\n\t */\r\n\t\r\n\tTHREE.BoxGeometry = function ( width, height, depth, widthSegments, heightSegments, depthSegments ) {\r\n\t\r\n\t\tTHREE.Geometry.call( this );\r\n\t\r\n\t\tthis.type = 'BoxGeometry';\r\n\t\r\n\t\tthis.parameters = {\r\n\t\t\twidth: width,\r\n\t\t\theight: height,\r\n\t\t\tdepth: depth,\r\n\t\t\twidthSegments: widthSegments,\r\n\t\t\theightSegments: heightSegments,\r\n\t\t\tdepthSegments: depthSegments\r\n\t\t};\r\n\t\r\n\t\tthis.widthSegments = widthSegments || 1;\r\n\t\tthis.heightSegments = heightSegments || 1;\r\n\t\tthis.depthSegments = depthSegments || 1;\r\n\t\r\n\t\tvar scope = this;\r\n\t\r\n\t\tvar width_half = width / 2;\r\n\t\tvar height_half = height / 2;\r\n\t\tvar depth_half = depth / 2;\r\n\t\r\n\t\tbuildPlane( 'z', 'y', - 1, - 1, depth, height, width_half, 0 ); // px\r\n\t\tbuildPlane( 'z', 'y',   1, - 1, depth, height, - width_half, 1 ); // nx\r\n\t\tbuildPlane( 'x', 'z',   1,   1, width, depth, height_half, 2 ); // py\r\n\t\tbuildPlane( 'x', 'z',   1, - 1, width, depth, - height_half, 3 ); // ny\r\n\t\tbuildPlane( 'x', 'y',   1, - 1, width, height, depth_half, 4 ); // pz\r\n\t\tbuildPlane( 'x', 'y', - 1, - 1, width, height, - depth_half, 5 ); // nz\r\n\t\r\n\t\tfunction buildPlane( u, v, udir, vdir, width, height, depth, materialIndex ) {\r\n\t\r\n\t\t\tvar w, ix, iy,\r\n\t\t\tgridX = scope.widthSegments,\r\n\t\t\tgridY = scope.heightSegments,\r\n\t\t\twidth_half = width / 2,\r\n\t\t\theight_half = height / 2,\r\n\t\t\toffset = scope.vertices.length;\r\n\t\r\n\t\t\tif ( ( u === 'x' && v === 'y' ) || ( u === 'y' && v === 'x' ) ) {\r\n\t\r\n\t\t\t\tw = 'z';\r\n\t\r\n\t\t\t} else if ( ( u === 'x' && v === 'z' ) || ( u === 'z' && v === 'x' ) ) {\r\n\t\r\n\t\t\t\tw = 'y';\r\n\t\t\t\tgridY = scope.depthSegments;\r\n\t\r\n\t\t\t} else if ( ( u === 'z' && v === 'y' ) || ( u === 'y' && v === 'z' ) ) {\r\n\t\r\n\t\t\t\tw = 'x';\r\n\t\t\t\tgridX = scope.depthSegments;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar gridX1 = gridX + 1,\r\n\t\t\tgridY1 = gridY + 1,\r\n\t\t\tsegment_width = width / gridX,\r\n\t\t\tsegment_height = height / gridY,\r\n\t\t\tnormal = new THREE.Vector3();\r\n\t\r\n\t\t\tnormal[ w ] = depth > 0 ? 1 : - 1;\r\n\t\r\n\t\t\tfor ( iy = 0; iy < gridY1; iy ++ ) {\r\n\t\r\n\t\t\t\tfor ( ix = 0; ix < gridX1; ix ++ ) {\r\n\t\r\n\t\t\t\t\tvar vector = new THREE.Vector3();\r\n\t\t\t\t\tvector[ u ] = ( ix * segment_width - width_half ) * udir;\r\n\t\t\t\t\tvector[ v ] = ( iy * segment_height - height_half ) * vdir;\r\n\t\t\t\t\tvector[ w ] = depth;\r\n\t\r\n\t\t\t\t\tscope.vertices.push( vector );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tfor ( iy = 0; iy < gridY; iy ++ ) {\r\n\t\r\n\t\t\t\tfor ( ix = 0; ix < gridX; ix ++ ) {\r\n\t\r\n\t\t\t\t\tvar a = ix + gridX1 * iy;\r\n\t\t\t\t\tvar b = ix + gridX1 * ( iy + 1 );\r\n\t\t\t\t\tvar c = ( ix + 1 ) + gridX1 * ( iy + 1 );\r\n\t\t\t\t\tvar d = ( ix + 1 ) + gridX1 * iy;\r\n\t\r\n\t\t\t\t\tvar uva = new THREE.Vector2( ix / gridX, 1 - iy / gridY );\r\n\t\t\t\t\tvar uvb = new THREE.Vector2( ix / gridX, 1 - ( iy + 1 ) / gridY );\r\n\t\t\t\t\tvar uvc = new THREE.Vector2( ( ix + 1 ) / gridX, 1 - ( iy + 1 ) / gridY );\r\n\t\t\t\t\tvar uvd = new THREE.Vector2( ( ix + 1 ) / gridX, 1 - iy / gridY );\r\n\t\r\n\t\t\t\t\tvar face = new THREE.Face3( a + offset, b + offset, d + offset );\r\n\t\t\t\t\tface.normal.copy( normal );\r\n\t\t\t\t\tface.vertexNormals.push( normal.clone(), normal.clone(), normal.clone() );\r\n\t\t\t\t\tface.materialIndex = materialIndex;\r\n\t\r\n\t\t\t\t\tscope.faces.push( face );\r\n\t\t\t\t\tscope.faceVertexUvs[ 0 ].push( [ uva, uvb, uvd ] );\r\n\t\r\n\t\t\t\t\tface = new THREE.Face3( b + offset, c + offset, d + offset );\r\n\t\t\t\t\tface.normal.copy( normal );\r\n\t\t\t\t\tface.vertexNormals.push( normal.clone(), normal.clone(), normal.clone() );\r\n\t\t\t\t\tface.materialIndex = materialIndex;\r\n\t\r\n\t\t\t\t\tscope.faces.push( face );\r\n\t\t\t\t\tscope.faceVertexUvs[ 0 ].push( [ uvb.clone(), uvc, uvd.clone() ] );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\tthis.mergeVertices();\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.BoxGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\n\tTHREE.BoxGeometry.prototype.constructor = THREE.BoxGeometry;\r\n\t\r\n\t// File:src/extras/geometries/CircleGeometry.js\r\n\t\r\n\t/**\r\n\t * @author hughes\r\n\t */\r\n\t\r\n\tTHREE.CircleGeometry = function ( radius, segments, thetaStart, thetaLength ) {\r\n\t\r\n\t\tTHREE.Geometry.call( this );\r\n\t\r\n\t\tthis.type = 'CircleGeometry';\r\n\t\r\n\t\tthis.parameters = {\r\n\t\t\tradius: radius,\r\n\t\t\tsegments: segments,\r\n\t\t\tthetaStart: thetaStart,\r\n\t\t\tthetaLength: thetaLength\r\n\t\t};\r\n\t\r\n\t\tradius = radius || 50;\r\n\t\tsegments = segments !== undefined ? Math.max( 3, segments ) : 8;\r\n\t\r\n\t\tthetaStart = thetaStart !== undefined ? thetaStart : 0;\r\n\t\tthetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;\r\n\t\r\n\t\tvar i, uvs = [],\r\n\t\tcenter = new THREE.Vector3(), centerUV = new THREE.Vector2( 0.5, 0.5 );\r\n\t\r\n\t\tthis.vertices.push(center);\r\n\t\tuvs.push( centerUV );\r\n\t\r\n\t\tfor ( i = 0; i <= segments; i ++ ) {\r\n\t\r\n\t\t\tvar vertex = new THREE.Vector3();\r\n\t\t\tvar segment = thetaStart + i / segments * thetaLength;\r\n\t\r\n\t\t\tvertex.x = radius * Math.cos( segment );\r\n\t\t\tvertex.y = radius * Math.sin( segment );\r\n\t\r\n\t\t\tthis.vertices.push( vertex );\r\n\t\t\tuvs.push( new THREE.Vector2( ( vertex.x / radius + 1 ) / 2, ( vertex.y / radius + 1 ) / 2 ) );\r\n\t\r\n\t\t}\r\n\t\r\n\t\tvar n = new THREE.Vector3( 0, 0, 1 );\r\n\t\r\n\t\tfor ( i = 1; i <= segments; i ++ ) {\r\n\t\r\n\t\t\tthis.faces.push( new THREE.Face3( i, i + 1, 0, [ n.clone(), n.clone(), n.clone() ] ) );\r\n\t\t\tthis.faceVertexUvs[ 0 ].push( [ uvs[ i ].clone(), uvs[ i + 1 ].clone(), centerUV.clone() ] );\r\n\t\r\n\t\t}\r\n\t\r\n\t\tthis.computeFaceNormals();\r\n\t\r\n\t\tthis.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.CircleGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\n\tTHREE.CircleGeometry.prototype.constructor = THREE.CircleGeometry;\r\n\t\r\n\t// File:src/extras/geometries/CubeGeometry.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\t\r\n\tTHREE.CubeGeometry = function ( width, height, depth, widthSegments, heightSegments, depthSegments ) {\r\n\t\r\n\t\tTHREE.warn( 'THREE.CubeGeometry has been renamed to THREE.BoxGeometry.' );\r\n\t\treturn new THREE.BoxGeometry( width, height, depth, widthSegments, heightSegments, depthSegments );\r\n\t\r\n\t };\r\n\t\r\n\t// File:src/extras/geometries/CylinderGeometry.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tTHREE.CylinderGeometry = function ( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {\r\n\t\r\n\t\tTHREE.Geometry.call( this );\r\n\t\r\n\t\tthis.type = 'CylinderGeometry';\r\n\t\r\n\t\tthis.parameters = {\r\n\t\t\tradiusTop: radiusTop,\r\n\t\t\tradiusBottom: radiusBottom,\r\n\t\t\theight: height,\r\n\t\t\tradialSegments: radialSegments,\r\n\t\t\theightSegments: heightSegments,\r\n\t\t\topenEnded: openEnded,\r\n\t\t\tthetaStart: thetaStart,\r\n\t\t\tthetaLength: thetaLength\r\n\t\t};\r\n\t\r\n\t\tradiusTop = radiusTop !== undefined ? radiusTop : 20;\r\n\t\tradiusBottom = radiusBottom !== undefined ? radiusBottom : 20;\r\n\t\theight = height !== undefined ? height : 100;\r\n\t\r\n\t\tradialSegments = radialSegments || 8;\r\n\t\theightSegments = heightSegments || 1;\r\n\t\r\n\t\topenEnded = openEnded !== undefined ? openEnded : false;\r\n\t\tthetaStart = thetaStart !== undefined ? thetaStart : 0;\r\n\t\tthetaLength = thetaLength !== undefined ? thetaLength : 2 * Math.PI;\r\n\t\r\n\t\tvar heightHalf = height / 2;\r\n\t\r\n\t\tvar x, y, vertices = [], uvs = [];\r\n\t\r\n\t\tfor ( y = 0; y <= heightSegments; y ++ ) {\r\n\t\r\n\t\t\tvar verticesRow = [];\r\n\t\t\tvar uvsRow = [];\r\n\t\r\n\t\t\tvar v = y / heightSegments;\r\n\t\t\tvar radius = v * ( radiusBottom - radiusTop ) + radiusTop;\r\n\t\r\n\t\t\tfor ( x = 0; x <= radialSegments; x ++ ) {\r\n\t\r\n\t\t\t\tvar u = x / radialSegments;\r\n\t\r\n\t\t\t\tvar vertex = new THREE.Vector3();\r\n\t\t\t\tvertex.x = radius * Math.sin( u * thetaLength + thetaStart );\r\n\t\t\t\tvertex.y = - v * height + heightHalf;\r\n\t\t\t\tvertex.z = radius * Math.cos( u * thetaLength + thetaStart );\r\n\t\r\n\t\t\t\tthis.vertices.push( vertex );\r\n\t\r\n\t\t\t\tverticesRow.push( this.vertices.length - 1 );\r\n\t\t\t\tuvsRow.push( new THREE.Vector2( u, 1 - v ) );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvertices.push( verticesRow );\r\n\t\t\tuvs.push( uvsRow );\r\n\t\r\n\t\t}\r\n\t\r\n\t\tvar tanTheta = ( radiusBottom - radiusTop ) / height;\r\n\t\tvar na, nb;\r\n\t\r\n\t\tfor ( x = 0; x < radialSegments; x ++ ) {\r\n\t\r\n\t\t\tif ( radiusTop !== 0 ) {\r\n\t\r\n\t\t\t\tna = this.vertices[ vertices[ 0 ][ x ] ].clone();\r\n\t\t\t\tnb = this.vertices[ vertices[ 0 ][ x + 1 ] ].clone();\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\tna = this.vertices[ vertices[ 1 ][ x ] ].clone();\r\n\t\t\t\tnb = this.vertices[ vertices[ 1 ][ x + 1 ] ].clone();\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tna.setY( Math.sqrt( na.x * na.x + na.z * na.z ) * tanTheta ).normalize();\r\n\t\t\tnb.setY( Math.sqrt( nb.x * nb.x + nb.z * nb.z ) * tanTheta ).normalize();\r\n\t\r\n\t\t\tfor ( y = 0; y < heightSegments; y ++ ) {\r\n\t\r\n\t\t\t\tvar v1 = vertices[ y ][ x ];\r\n\t\t\t\tvar v2 = vertices[ y + 1 ][ x ];\r\n\t\t\t\tvar v3 = vertices[ y + 1 ][ x + 1 ];\r\n\t\t\t\tvar v4 = vertices[ y ][ x + 1 ];\r\n\t\r\n\t\t\t\tvar n1 = na.clone();\r\n\t\t\t\tvar n2 = na.clone();\r\n\t\t\t\tvar n3 = nb.clone();\r\n\t\t\t\tvar n4 = nb.clone();\r\n\t\r\n\t\t\t\tvar uv1 = uvs[ y ][ x ].clone();\r\n\t\t\t\tvar uv2 = uvs[ y + 1 ][ x ].clone();\r\n\t\t\t\tvar uv3 = uvs[ y + 1 ][ x + 1 ].clone();\r\n\t\t\t\tvar uv4 = uvs[ y ][ x + 1 ].clone();\r\n\t\r\n\t\t\t\tthis.faces.push( new THREE.Face3( v1, v2, v4, [ n1, n2, n4 ] ) );\r\n\t\t\t\tthis.faceVertexUvs[ 0 ].push( [ uv1, uv2, uv4 ] );\r\n\t\r\n\t\t\t\tthis.faces.push( new THREE.Face3( v2, v3, v4, [ n2.clone(), n3, n4.clone() ] ) );\r\n\t\t\t\tthis.faceVertexUvs[ 0 ].push( [ uv2.clone(), uv3, uv4.clone() ] );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\t// top cap\r\n\t\r\n\t\tif ( openEnded === false && radiusTop > 0 ) {\r\n\t\r\n\t\t\tthis.vertices.push( new THREE.Vector3( 0, heightHalf, 0 ) );\r\n\t\r\n\t\t\tfor ( x = 0; x < radialSegments; x ++ ) {\r\n\t\r\n\t\t\t\tvar v1 = vertices[ 0 ][ x ];\r\n\t\t\t\tvar v2 = vertices[ 0 ][ x + 1 ];\r\n\t\t\t\tvar v3 = this.vertices.length - 1;\r\n\t\r\n\t\t\t\tvar n1 = new THREE.Vector3( 0, 1, 0 );\r\n\t\t\t\tvar n2 = new THREE.Vector3( 0, 1, 0 );\r\n\t\t\t\tvar n3 = new THREE.Vector3( 0, 1, 0 );\r\n\t\r\n\t\t\t\tvar uv1 = uvs[ 0 ][ x ].clone();\r\n\t\t\t\tvar uv2 = uvs[ 0 ][ x + 1 ].clone();\r\n\t\t\t\tvar uv3 = new THREE.Vector2( uv2.x, 0 );\r\n\t\r\n\t\t\t\tthis.faces.push( new THREE.Face3( v1, v2, v3, [ n1, n2, n3 ] ) );\r\n\t\t\t\tthis.faceVertexUvs[ 0 ].push( [ uv1, uv2, uv3 ] );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\t// bottom cap\r\n\t\r\n\t\tif ( openEnded === false && radiusBottom > 0 ) {\r\n\t\r\n\t\t\tthis.vertices.push( new THREE.Vector3( 0, - heightHalf, 0 ) );\r\n\t\r\n\t\t\tfor ( x = 0; x < radialSegments; x ++ ) {\r\n\t\r\n\t\t\t\tvar v1 = vertices[ heightSegments ][ x + 1 ];\r\n\t\t\t\tvar v2 = vertices[ heightSegments ][ x ];\r\n\t\t\t\tvar v3 = this.vertices.length - 1;\r\n\t\r\n\t\t\t\tvar n1 = new THREE.Vector3( 0, - 1, 0 );\r\n\t\t\t\tvar n2 = new THREE.Vector3( 0, - 1, 0 );\r\n\t\t\t\tvar n3 = new THREE.Vector3( 0, - 1, 0 );\r\n\t\r\n\t\t\t\tvar uv1 = uvs[ heightSegments ][ x + 1 ].clone();\r\n\t\t\t\tvar uv2 = uvs[ heightSegments ][ x ].clone();\r\n\t\t\t\tvar uv3 = new THREE.Vector2( uv2.x, 1 );\r\n\t\r\n\t\t\t\tthis.faces.push( new THREE.Face3( v1, v2, v3, [ n1, n2, n3 ] ) );\r\n\t\t\t\tthis.faceVertexUvs[ 0 ].push( [ uv1, uv2, uv3 ] );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\tthis.computeFaceNormals();\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.CylinderGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\n\tTHREE.CylinderGeometry.prototype.constructor = THREE.CylinderGeometry;\r\n\t\r\n\t// File:src/extras/geometries/ExtrudeGeometry.js\r\n\t\r\n\t/**\r\n\t * @author zz85 / http://www.lab4games.net/zz85/blog\r\n\t *\r\n\t * Creates extruded geometry from a path shape.\r\n\t *\r\n\t * parameters = {\r\n\t *\r\n\t *  curveSegments: <int>, // number of points on the curves\r\n\t *  steps: <int>, // number of points for z-side extrusions / used for subdividing segements of extrude spline too\r\n\t *  amount: <int>, // Depth to extrude the shape\r\n\t *\r\n\t *  bevelEnabled: <bool>, // turn on bevel\r\n\t *  bevelThickness: <float>, // how deep into the original shape bevel goes\r\n\t *  bevelSize: <float>, // how far from shape outline is bevel\r\n\t *  bevelSegments: <int>, // number of bevel layers\r\n\t *\r\n\t *  extrudePath: <THREE.CurvePath> // 3d spline path to extrude shape along. (creates Frames if .frames aren't defined)\r\n\t *  frames: <THREE.TubeGeometry.FrenetFrames> // containing arrays of tangents, normals, binormals\r\n\t *\r\n\t *  material: <int> // material index for front and back faces\r\n\t *  extrudeMaterial: <int> // material index for extrusion and beveled faces\r\n\t *  uvGenerator: <Object> // object that provides UV generator functions\r\n\t *\r\n\t * }\r\n\t **/\r\n\t\r\n\tTHREE.ExtrudeGeometry = function ( shapes, options ) {\r\n\t\r\n\t\tif ( typeof( shapes ) === \"undefined\" ) {\r\n\t\t\tshapes = [];\r\n\t\t\treturn;\r\n\t\t}\r\n\t\r\n\t\tTHREE.Geometry.call( this );\r\n\t\r\n\t\tthis.type = 'ExtrudeGeometry';\r\n\t\r\n\t\tshapes = shapes instanceof Array ? shapes : [ shapes ];\r\n\t\r\n\t\tthis.addShapeList( shapes, options );\r\n\t\r\n\t\tthis.computeFaceNormals();\r\n\t\r\n\t\t// can't really use automatic vertex normals\r\n\t\t// as then front and back sides get smoothed too\r\n\t\t// should do separate smoothing just for sides\r\n\t\r\n\t\t//this.computeVertexNormals();\r\n\t\r\n\t\t//console.log( \"took\", ( Date.now() - startTime ) );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.ExtrudeGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\n\tTHREE.ExtrudeGeometry.prototype.constructor = THREE.ExtrudeGeometry;\r\n\t\r\n\tTHREE.ExtrudeGeometry.prototype.addShapeList = function ( shapes, options ) {\r\n\t\tvar sl = shapes.length;\r\n\t\r\n\t\tfor ( var s = 0; s < sl; s ++ ) {\r\n\t\t\tvar shape = shapes[ s ];\r\n\t\t\tthis.addShape( shape, options );\r\n\t\t}\r\n\t};\r\n\t\r\n\tTHREE.ExtrudeGeometry.prototype.addShape = function ( shape, options ) {\r\n\t\r\n\t\tvar amount = options.amount !== undefined ? options.amount : 100;\r\n\t\r\n\t\tvar bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 6; // 10\r\n\t\tvar bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 2; // 8\r\n\t\tvar bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;\r\n\t\r\n\t\tvar bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true; // false\r\n\t\r\n\t\tvar curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;\r\n\t\r\n\t\tvar steps = options.steps !== undefined ? options.steps : 1;\r\n\t\r\n\t\tvar extrudePath = options.extrudePath;\r\n\t\tvar extrudePts, extrudeByPath = false;\r\n\t\r\n\t\tvar material = options.material;\r\n\t\tvar extrudeMaterial = options.extrudeMaterial;\r\n\t\r\n\t\t// Use default WorldUVGenerator if no UV generators are specified.\r\n\t\tvar uvgen = options.UVGenerator !== undefined ? options.UVGenerator : THREE.ExtrudeGeometry.WorldUVGenerator;\r\n\t\r\n\t\tvar splineTube, binormal, normal, position2;\r\n\t\tif ( extrudePath ) {\r\n\t\r\n\t\t\textrudePts = extrudePath.getSpacedPoints( steps );\r\n\t\r\n\t\t\textrudeByPath = true;\r\n\t\t\tbevelEnabled = false; // bevels not supported for path extrusion\r\n\t\r\n\t\t\t// SETUP TNB variables\r\n\t\r\n\t\t\t// Reuse TNB from TubeGeomtry for now.\r\n\t\t\t// TODO1 - have a .isClosed in spline?\r\n\t\r\n\t\t\tsplineTube = options.frames !== undefined ? options.frames : new THREE.TubeGeometry.FrenetFrames(extrudePath, steps, false);\r\n\t\r\n\t\t\t// console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length);\r\n\t\r\n\t\t\tbinormal = new THREE.Vector3();\r\n\t\t\tnormal = new THREE.Vector3();\r\n\t\t\tposition2 = new THREE.Vector3();\r\n\t\r\n\t\t}\r\n\t\r\n\t\t// Safeguards if bevels are not enabled\r\n\t\r\n\t\tif ( ! bevelEnabled ) {\r\n\t\r\n\t\t\tbevelSegments = 0;\r\n\t\t\tbevelThickness = 0;\r\n\t\t\tbevelSize = 0;\r\n\t\r\n\t\t}\r\n\t\r\n\t\t// Variables initalization\r\n\t\r\n\t\tvar ahole, h, hl; // looping of holes\r\n\t\tvar scope = this;\r\n\t\r\n\t\tvar shapesOffset = this.vertices.length;\r\n\t\r\n\t\tvar shapePoints = shape.extractPoints( curveSegments );\r\n\t\r\n\t\tvar vertices = shapePoints.shape;\r\n\t\tvar holes = shapePoints.holes;\r\n\t\r\n\t\tvar reverse = ! THREE.Shape.Utils.isClockWise( vertices ) ;\r\n\t\r\n\t\tif ( reverse ) {\r\n\t\r\n\t\t\tvertices = vertices.reverse();\r\n\t\r\n\t\t\t// Maybe we should also check if holes are in the opposite direction, just to be safe ...\r\n\t\r\n\t\t\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\r\n\t\r\n\t\t\t\tahole = holes[ h ];\r\n\t\r\n\t\t\t\tif ( THREE.Shape.Utils.isClockWise( ahole ) ) {\r\n\t\r\n\t\t\t\t\tholes[ h ] = ahole.reverse();\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treverse = false; // If vertices are in order now, we shouldn't need to worry about them again (hopefully)!\r\n\t\r\n\t\t}\r\n\t\r\n\t\r\n\t\tvar faces = THREE.Shape.Utils.triangulateShape ( vertices, holes );\r\n\t\r\n\t\t/* Vertices */\r\n\t\r\n\t\tvar contour = vertices; // vertices has all points but contour has only points of circumference\r\n\t\r\n\t\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\r\n\t\r\n\t\t\tahole = holes[ h ];\r\n\t\r\n\t\t\tvertices = vertices.concat( ahole );\r\n\t\r\n\t\t}\r\n\t\r\n\t\r\n\t\tfunction scalePt2 ( pt, vec, size ) {\r\n\t\r\n\t\t\tif ( ! vec ) THREE.error( \"THREE.ExtrudeGeometry: vec does not exist\" );\r\n\t\r\n\t\t\treturn vec.clone().multiplyScalar( size ).add( pt );\r\n\t\r\n\t\t}\r\n\t\r\n\t\tvar b, bs, t, z,\r\n\t\t\tvert, vlen = vertices.length,\r\n\t\t\tface, flen = faces.length;\r\n\t\r\n\t\r\n\t\t// Find directions for point movement\r\n\t\r\n\t\r\n\t\tfunction getBevelVec( inPt, inPrev, inNext ) {\r\n\t\r\n\t\t\tvar EPSILON = 0.0000000001;\r\n\t\t\t\r\n\t\t\t// computes for inPt the corresponding point inPt' on a new contour\r\n\t\t\t//   shiftet by 1 unit (length of normalized vector) to the left\r\n\t\t\t// if we walk along contour clockwise, this new contour is outside the old one\r\n\t\t\t//\r\n\t\t\t// inPt' is the intersection of the two lines parallel to the two\r\n\t\t\t//  adjacent edges of inPt at a distance of 1 unit on the left side.\r\n\t\t\t\r\n\t\t\tvar v_trans_x, v_trans_y, shrink_by = 1;\t\t// resulting translation vector for inPt\r\n\t\r\n\t\t\t// good reading for geometry algorithms (here: line-line intersection)\r\n\t\t\t// http://geomalgorithms.com/a05-_intersect-1.html\r\n\t\r\n\t\t\tvar v_prev_x = inPt.x - inPrev.x, v_prev_y = inPt.y - inPrev.y;\r\n\t\t\tvar v_next_x = inNext.x - inPt.x, v_next_y = inNext.y - inPt.y;\r\n\t\t\t\r\n\t\t\tvar v_prev_lensq = ( v_prev_x * v_prev_x + v_prev_y * v_prev_y );\r\n\t\t\t\r\n\t\t\t// check for colinear edges\r\n\t\t\tvar colinear0 = ( v_prev_x * v_next_y - v_prev_y * v_next_x );\r\n\t\t\t\r\n\t\t\tif ( Math.abs( colinear0 ) > EPSILON ) {\t\t// not colinear\r\n\t\t\t\t\r\n\t\t\t\t// length of vectors for normalizing\r\n\t\t\r\n\t\t\t\tvar v_prev_len = Math.sqrt( v_prev_lensq );\r\n\t\t\t\tvar v_next_len = Math.sqrt( v_next_x * v_next_x + v_next_y * v_next_y );\r\n\t\t\t\t\r\n\t\t\t\t// shift adjacent points by unit vectors to the left\r\n\t\t\r\n\t\t\t\tvar ptPrevShift_x = ( inPrev.x - v_prev_y / v_prev_len );\r\n\t\t\t\tvar ptPrevShift_y = ( inPrev.y + v_prev_x / v_prev_len );\r\n\t\t\t\t\r\n\t\t\t\tvar ptNextShift_x = ( inNext.x - v_next_y / v_next_len );\r\n\t\t\t\tvar ptNextShift_y = ( inNext.y + v_next_x / v_next_len );\r\n\t\t\r\n\t\t\t\t// scaling factor for v_prev to intersection point\r\n\t\t\r\n\t\t\t\tvar sf = (  ( ptNextShift_x - ptPrevShift_x ) * v_next_y -\r\n\t\t\t\t\t\t\t( ptNextShift_y - ptPrevShift_y ) * v_next_x    ) /\r\n\t\t\t\t\t\t  ( v_prev_x * v_next_y - v_prev_y * v_next_x );\r\n\t\t\r\n\t\t\t\t// vector from inPt to intersection point\r\n\t\t\r\n\t\t\t\tv_trans_x = ( ptPrevShift_x + v_prev_x * sf - inPt.x );\r\n\t\t\t\tv_trans_y = ( ptPrevShift_y + v_prev_y * sf - inPt.y );\r\n\t\t\r\n\t\t\t\t// Don't normalize!, otherwise sharp corners become ugly\r\n\t\t\t\t//  but prevent crazy spikes\r\n\t\t\t\tvar v_trans_lensq = ( v_trans_x * v_trans_x + v_trans_y * v_trans_y )\r\n\t\t\t\tif ( v_trans_lensq <= 2 ) {\r\n\t\t\t\t\treturn\tnew THREE.Vector2( v_trans_x, v_trans_y );\r\n\t\t\t\t} else {\r\n\t\t\t\t\tshrink_by = Math.sqrt( v_trans_lensq / 2 );\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t} else {\t\t// handle special case of colinear edges\r\n\t\r\n\t\t\t\tvar direction_eq = false;\t\t// assumes: opposite\r\n\t\t\t\tif ( v_prev_x > EPSILON ) {\r\n\t\t\t\t\tif ( v_next_x > EPSILON ) { direction_eq = true; }\r\n\t\t\t\t} else {\r\n\t\t\t\t\tif ( v_prev_x < - EPSILON ) {\r\n\t\t\t\t\t\tif ( v_next_x < - EPSILON ) { direction_eq = true; }\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tif ( Math.sign(v_prev_y) == Math.sign(v_next_y) ) { direction_eq = true; }\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( direction_eq ) {\r\n\t\t\t\t\t// console.log(\"Warning: lines are a straight sequence\");\r\n\t\t\t\t\tv_trans_x = - v_prev_y;\r\n\t\t\t\t\tv_trans_y =  v_prev_x;\r\n\t\t\t\t\tshrink_by = Math.sqrt( v_prev_lensq );\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// console.log(\"Warning: lines are a straight spike\");\r\n\t\t\t\t\tv_trans_x = v_prev_x;\r\n\t\t\t\t\tv_trans_y = v_prev_y;\r\n\t\t\t\t\tshrink_by = Math.sqrt( v_prev_lensq / 2 );\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn\tnew THREE.Vector2( v_trans_x / shrink_by, v_trans_y / shrink_by );\r\n\t\r\n\t\t}\r\n\t\r\n\t\r\n\t\tvar contourMovements = [];\r\n\t\r\n\t\tfor ( var i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {\r\n\t\r\n\t\t\tif ( j === il ) j = 0;\r\n\t\t\tif ( k === il ) k = 0;\r\n\t\r\n\t\t\t//  (j)---(i)---(k)\r\n\t\t\t// console.log('i,j,k', i, j , k)\r\n\t\r\n\t\t\tcontourMovements[ i ] = getBevelVec( contour[ i ], contour[ j ], contour[ k ] );\r\n\t\r\n\t\t}\r\n\t\r\n\t\tvar holesMovements = [], oneHoleMovements, verticesMovements = contourMovements.concat();\r\n\t\r\n\t\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\r\n\t\r\n\t\t\tahole = holes[ h ];\r\n\t\r\n\t\t\toneHoleMovements = [];\r\n\t\r\n\t\t\tfor ( i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {\r\n\t\r\n\t\t\t\tif ( j === il ) j = 0;\r\n\t\t\t\tif ( k === il ) k = 0;\r\n\t\r\n\t\t\t\t//  (j)---(i)---(k)\r\n\t\t\t\toneHoleMovements[ i ] = getBevelVec( ahole[ i ], ahole[ j ], ahole[ k ] );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tholesMovements.push( oneHoleMovements );\r\n\t\t\tverticesMovements = verticesMovements.concat( oneHoleMovements );\r\n\t\r\n\t\t}\r\n\t\r\n\t\r\n\t\t// Loop bevelSegments, 1 for the front, 1 for the back\r\n\t\r\n\t\tfor ( b = 0; b < bevelSegments; b ++ ) {\r\n\t\t//for ( b = bevelSegments; b > 0; b -- ) {\r\n\t\r\n\t\t\tt = b / bevelSegments;\r\n\t\t\tz = bevelThickness * ( 1 - t );\r\n\t\r\n\t\t\t//z = bevelThickness * t;\r\n\t\t\tbs = bevelSize * ( Math.sin ( t * Math.PI / 2 ) ) ; // curved\r\n\t\t\t//bs = bevelSize * t ; // linear\r\n\t\r\n\t\t\t// contract shape\r\n\t\r\n\t\t\tfor ( i = 0, il = contour.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\tvert = scalePt2( contour[ i ], contourMovements[ i ], bs );\r\n\t\r\n\t\t\t\tv( vert.x, vert.y,  - z );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// expand holes\r\n\t\r\n\t\t\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\r\n\t\r\n\t\t\t\tahole = holes[ h ];\r\n\t\t\t\toneHoleMovements = holesMovements[ h ];\r\n\t\r\n\t\t\t\tfor ( i = 0, il = ahole.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\t\tvert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );\r\n\t\r\n\t\t\t\t\tv( vert.x, vert.y,  - z );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\tbs = bevelSize;\r\n\t\r\n\t\t// Back facing vertices\r\n\t\r\n\t\tfor ( i = 0; i < vlen; i ++ ) {\r\n\t\r\n\t\t\tvert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];\r\n\t\r\n\t\t\tif ( ! extrudeByPath ) {\r\n\t\r\n\t\t\t\tv( vert.x, vert.y, 0 );\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\t// v( vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x );\r\n\t\r\n\t\t\t\tnormal.copy( splineTube.normals[0] ).multiplyScalar(vert.x);\r\n\t\t\t\tbinormal.copy( splineTube.binormals[0] ).multiplyScalar(vert.y);\r\n\t\r\n\t\t\t\tposition2.copy( extrudePts[0] ).add(normal).add(binormal);\r\n\t\r\n\t\t\t\tv( position2.x, position2.y, position2.z );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\t// Add stepped vertices...\r\n\t\t// Including front facing vertices\r\n\t\r\n\t\tvar s;\r\n\t\r\n\t\tfor ( s = 1; s <= steps; s ++ ) {\r\n\t\r\n\t\t\tfor ( i = 0; i < vlen; i ++ ) {\r\n\t\r\n\t\t\t\tvert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];\r\n\t\r\n\t\t\t\tif ( ! extrudeByPath ) {\r\n\t\r\n\t\t\t\t\tv( vert.x, vert.y, amount / steps * s );\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t// v( vert.x, vert.y + extrudePts[ s - 1 ].y, extrudePts[ s - 1 ].x );\r\n\t\r\n\t\t\t\t\tnormal.copy( splineTube.normals[s] ).multiplyScalar( vert.x );\r\n\t\t\t\t\tbinormal.copy( splineTube.binormals[s] ).multiplyScalar( vert.y );\r\n\t\r\n\t\t\t\t\tposition2.copy( extrudePts[s] ).add( normal ).add( binormal );\r\n\t\r\n\t\t\t\t\tv( position2.x, position2.y, position2.z );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\r\n\t\t// Add bevel segments planes\r\n\t\r\n\t\t//for ( b = 1; b <= bevelSegments; b ++ ) {\r\n\t\tfor ( b = bevelSegments - 1; b >= 0; b -- ) {\r\n\t\r\n\t\t\tt = b / bevelSegments;\r\n\t\t\tz = bevelThickness * ( 1 - t );\r\n\t\t\t//bs = bevelSize * ( 1-Math.sin ( ( 1 - t ) * Math.PI/2 ) );\r\n\t\t\tbs = bevelSize * Math.sin ( t * Math.PI / 2 ) ;\r\n\t\r\n\t\t\t// contract shape\r\n\t\r\n\t\t\tfor ( i = 0, il = contour.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\tvert = scalePt2( contour[ i ], contourMovements[ i ], bs );\r\n\t\t\t\tv( vert.x, vert.y,  amount + z );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// expand holes\r\n\t\r\n\t\t\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\r\n\t\r\n\t\t\t\tahole = holes[ h ];\r\n\t\t\t\toneHoleMovements = holesMovements[ h ];\r\n\t\r\n\t\t\t\tfor ( i = 0, il = ahole.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\t\tvert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );\r\n\t\r\n\t\t\t\t\tif ( ! extrudeByPath ) {\r\n\t\r\n\t\t\t\t\t\tv( vert.x, vert.y,  amount + z );\r\n\t\r\n\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\tv( vert.x, vert.y + extrudePts[ steps - 1 ].y, extrudePts[ steps - 1 ].x + z );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\t/* Faces */\r\n\t\r\n\t\t// Top and bottom faces\r\n\t\r\n\t\tbuildLidFaces();\r\n\t\r\n\t\t// Sides faces\r\n\t\r\n\t\tbuildSideFaces();\r\n\t\r\n\t\r\n\t\t/////  Internal functions\r\n\t\r\n\t\tfunction buildLidFaces() {\r\n\t\r\n\t\t\tif ( bevelEnabled ) {\r\n\t\r\n\t\t\t\tvar layer = 0 ; // steps + 1\r\n\t\t\t\tvar offset = vlen * layer;\r\n\t\r\n\t\t\t\t// Bottom faces\r\n\t\r\n\t\t\t\tfor ( i = 0; i < flen; i ++ ) {\r\n\t\r\n\t\t\t\t\tface = faces[ i ];\r\n\t\t\t\t\tf3( face[ 2 ] + offset, face[ 1 ] + offset, face[ 0 ] + offset );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tlayer = steps + bevelSegments * 2;\r\n\t\t\t\toffset = vlen * layer;\r\n\t\r\n\t\t\t\t// Top faces\r\n\t\r\n\t\t\t\tfor ( i = 0; i < flen; i ++ ) {\r\n\t\r\n\t\t\t\t\tface = faces[ i ];\r\n\t\t\t\t\tf3( face[ 0 ] + offset, face[ 1 ] + offset, face[ 2 ] + offset );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\t// Bottom faces\r\n\t\r\n\t\t\t\tfor ( i = 0; i < flen; i ++ ) {\r\n\t\r\n\t\t\t\t\tface = faces[ i ];\r\n\t\t\t\t\tf3( face[ 2 ], face[ 1 ], face[ 0 ] );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\t// Top faces\r\n\t\r\n\t\t\t\tfor ( i = 0; i < flen; i ++ ) {\r\n\t\r\n\t\t\t\t\tface = faces[ i ];\r\n\t\t\t\t\tf3( face[ 0 ] + vlen * steps, face[ 1 ] + vlen * steps, face[ 2 ] + vlen * steps );\r\n\t\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\t// Create faces for the z-sides of the shape\r\n\t\r\n\t\tfunction buildSideFaces() {\r\n\t\r\n\t\t\tvar layeroffset = 0;\r\n\t\t\tsidewalls( contour, layeroffset );\r\n\t\t\tlayeroffset += contour.length;\r\n\t\r\n\t\t\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\r\n\t\r\n\t\t\t\tahole = holes[ h ];\r\n\t\t\t\tsidewalls( ahole, layeroffset );\r\n\t\r\n\t\t\t\t//, true\r\n\t\t\t\tlayeroffset += ahole.length;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction sidewalls( contour, layeroffset ) {\r\n\t\r\n\t\t\tvar j, k;\r\n\t\t\ti = contour.length;\r\n\t\r\n\t\t\twhile ( -- i >= 0 ) {\r\n\t\r\n\t\t\t\tj = i;\r\n\t\t\t\tk = i - 1;\r\n\t\t\t\tif ( k < 0 ) k = contour.length - 1;\r\n\t\r\n\t\t\t\t//console.log('b', i,j, i-1, k,vertices.length);\r\n\t\r\n\t\t\t\tvar s = 0, sl = steps  + bevelSegments * 2;\r\n\t\r\n\t\t\t\tfor ( s = 0; s < sl; s ++ ) {\r\n\t\r\n\t\t\t\t\tvar slen1 = vlen * s;\r\n\t\t\t\t\tvar slen2 = vlen * ( s + 1 );\r\n\t\r\n\t\t\t\t\tvar a = layeroffset + j + slen1,\r\n\t\t\t\t\t\tb = layeroffset + k + slen1,\r\n\t\t\t\t\t\tc = layeroffset + k + slen2,\r\n\t\t\t\t\t\td = layeroffset + j + slen2;\r\n\t\r\n\t\t\t\t\tf4( a, b, c, d, contour, s, sl, j, k );\r\n\t\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\r\n\t\tfunction v( x, y, z ) {\r\n\t\r\n\t\t\tscope.vertices.push( new THREE.Vector3( x, y, z ) );\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction f3( a, b, c ) {\r\n\t\r\n\t\t\ta += shapesOffset;\r\n\t\t\tb += shapesOffset;\r\n\t\t\tc += shapesOffset;\r\n\t\r\n\t\t\t// normal, color, material\r\n\t\t\tscope.faces.push( new THREE.Face3( a, b, c, null, null, material ) );\r\n\t\r\n\t\t\tvar uvs = uvgen.generateTopUV( scope, a, b, c );\r\n\t\r\n\t\t\tscope.faceVertexUvs[ 0 ].push( uvs );\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction f4( a, b, c, d, wallContour, stepIndex, stepsLength, contourIndex1, contourIndex2 ) {\r\n\t\r\n\t\t\ta += shapesOffset;\r\n\t\t\tb += shapesOffset;\r\n\t\t\tc += shapesOffset;\r\n\t\t\td += shapesOffset;\r\n\t\r\n\t\t\tscope.faces.push( new THREE.Face3( a, b, d, null, null, extrudeMaterial ) );\r\n\t\t\tscope.faces.push( new THREE.Face3( b, c, d, null, null, extrudeMaterial ) );\r\n\t\r\n\t\t\tvar uvs = uvgen.generateSideWallUV( scope, a, b, c, d );\r\n\t\r\n\t\t\tscope.faceVertexUvs[ 0 ].push( [ uvs[ 0 ], uvs[ 1 ], uvs[ 3 ] ] );\r\n\t\t\tscope.faceVertexUvs[ 0 ].push( [ uvs[ 1 ], uvs[ 2 ], uvs[ 3 ] ] );\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.ExtrudeGeometry.WorldUVGenerator = {\r\n\t\r\n\t\tgenerateTopUV: function ( geometry, indexA, indexB, indexC ) {\r\n\t\r\n\t\t\tvar vertices = geometry.vertices;\r\n\t\r\n\t\t\tvar a = vertices[ indexA ];\r\n\t\t\tvar b = vertices[ indexB ];\r\n\t\t\tvar c = vertices[ indexC ];\r\n\t\r\n\t\t\treturn [\r\n\t\t\t\tnew THREE.Vector2( a.x, a.y ),\r\n\t\t\t\tnew THREE.Vector2( b.x, b.y ),\r\n\t\t\t\tnew THREE.Vector2( c.x, c.y )\r\n\t\t\t];\r\n\t\r\n\t\t},\r\n\t\r\n\t\tgenerateSideWallUV: function ( geometry, indexA, indexB, indexC, indexD ) {\r\n\t\r\n\t\t\tvar vertices = geometry.vertices;\r\n\t\r\n\t\t\tvar a = vertices[ indexA ];\r\n\t\t\tvar b = vertices[ indexB ];\r\n\t\t\tvar c = vertices[ indexC ];\r\n\t\t\tvar d = vertices[ indexD ];\r\n\t\r\n\t\t\tif ( Math.abs( a.y - b.y ) < 0.01 ) {\r\n\t\t\t\treturn [\r\n\t\t\t\t\tnew THREE.Vector2( a.x, 1 - a.z ),\r\n\t\t\t\t\tnew THREE.Vector2( b.x, 1 - b.z ),\r\n\t\t\t\t\tnew THREE.Vector2( c.x, 1 - c.z ),\r\n\t\t\t\t\tnew THREE.Vector2( d.x, 1 - d.z )\r\n\t\t\t\t];\r\n\t\t\t} else {\r\n\t\t\t\treturn [\r\n\t\t\t\t\tnew THREE.Vector2( a.y, 1 - a.z ),\r\n\t\t\t\t\tnew THREE.Vector2( b.y, 1 - b.z ),\r\n\t\t\t\t\tnew THREE.Vector2( c.y, 1 - c.z ),\r\n\t\t\t\t\tnew THREE.Vector2( d.y, 1 - d.z )\r\n\t\t\t\t];\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\t\r\n\t// File:src/extras/geometries/ShapeGeometry.js\r\n\t\r\n\t/**\r\n\t * @author jonobr1 / http://jonobr1.com\r\n\t *\r\n\t * Creates a one-sided polygonal geometry from a path shape. Similar to\r\n\t * ExtrudeGeometry.\r\n\t *\r\n\t * parameters = {\r\n\t *\r\n\t *\tcurveSegments: <int>, // number of points on the curves. NOT USED AT THE MOMENT.\r\n\t *\r\n\t *\tmaterial: <int> // material index for front and back faces\r\n\t *\tuvGenerator: <Object> // object that provides UV generator functions\r\n\t *\r\n\t * }\r\n\t **/\r\n\t\r\n\tTHREE.ShapeGeometry = function ( shapes, options ) {\r\n\t\r\n\t\tTHREE.Geometry.call( this );\r\n\t\r\n\t\tthis.type = 'ShapeGeometry';\r\n\t\r\n\t\tif ( shapes instanceof Array === false ) shapes = [ shapes ];\r\n\t\r\n\t\tthis.addShapeList( shapes, options );\r\n\t\r\n\t\tthis.computeFaceNormals();\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.ShapeGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\n\tTHREE.ShapeGeometry.prototype.constructor = THREE.ShapeGeometry;\r\n\t\r\n\t/**\r\n\t * Add an array of shapes to THREE.ShapeGeometry.\r\n\t */\r\n\tTHREE.ShapeGeometry.prototype.addShapeList = function ( shapes, options ) {\r\n\t\r\n\t\tfor ( var i = 0, l = shapes.length; i < l; i ++ ) {\r\n\t\r\n\t\t\tthis.addShape( shapes[ i ], options );\r\n\t\r\n\t\t}\r\n\t\r\n\t\treturn this;\r\n\t\r\n\t};\r\n\t\r\n\t/**\r\n\t * Adds a shape to THREE.ShapeGeometry, based on THREE.ExtrudeGeometry.\r\n\t */\r\n\tTHREE.ShapeGeometry.prototype.addShape = function ( shape, options ) {\r\n\t\r\n\t\tif ( options === undefined ) options = {};\r\n\t\tvar curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;\r\n\t\r\n\t\tvar material = options.material;\r\n\t\tvar uvgen = options.UVGenerator === undefined ? THREE.ExtrudeGeometry.WorldUVGenerator : options.UVGenerator;\r\n\t\r\n\t\t//\r\n\t\r\n\t\tvar i, l, hole;\r\n\t\r\n\t\tvar shapesOffset = this.vertices.length;\r\n\t\tvar shapePoints = shape.extractPoints( curveSegments );\r\n\t\r\n\t\tvar vertices = shapePoints.shape;\r\n\t\tvar holes = shapePoints.holes;\r\n\t\r\n\t\tvar reverse = ! THREE.Shape.Utils.isClockWise( vertices );\r\n\t\r\n\t\tif ( reverse ) {\r\n\t\r\n\t\t\tvertices = vertices.reverse();\r\n\t\r\n\t\t\t// Maybe we should also check if holes are in the opposite direction, just to be safe...\r\n\t\r\n\t\t\tfor ( i = 0, l = holes.length; i < l; i ++ ) {\r\n\t\r\n\t\t\t\thole = holes[ i ];\r\n\t\r\n\t\t\t\tif ( THREE.Shape.Utils.isClockWise( hole ) ) {\r\n\t\r\n\t\t\t\t\tholes[ i ] = hole.reverse();\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treverse = false;\r\n\t\r\n\t\t}\r\n\t\r\n\t\tvar faces = THREE.Shape.Utils.triangulateShape( vertices, holes );\r\n\t\r\n\t\t// Vertices\r\n\t\r\n\t\tvar contour = vertices;\r\n\t\r\n\t\tfor ( i = 0, l = holes.length; i < l; i ++ ) {\r\n\t\r\n\t\t\thole = holes[ i ];\r\n\t\t\tvertices = vertices.concat( hole );\r\n\t\r\n\t\t}\r\n\t\r\n\t\t//\r\n\t\r\n\t\tvar vert, vlen = vertices.length;\r\n\t\tvar face, flen = faces.length;\r\n\t\r\n\t\tfor ( i = 0; i < vlen; i ++ ) {\r\n\t\r\n\t\t\tvert = vertices[ i ];\r\n\t\r\n\t\t\tthis.vertices.push( new THREE.Vector3( vert.x, vert.y, 0 ) );\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfor ( i = 0; i < flen; i ++ ) {\r\n\t\r\n\t\t\tface = faces[ i ];\r\n\t\r\n\t\t\tvar a = face[ 0 ] + shapesOffset;\r\n\t\t\tvar b = face[ 1 ] + shapesOffset;\r\n\t\t\tvar c = face[ 2 ] + shapesOffset;\r\n\t\r\n\t\t\tthis.faces.push( new THREE.Face3( a, b, c, null, null, material ) );\r\n\t\t\tthis.faceVertexUvs[ 0 ].push( uvgen.generateTopUV( this, a, b, c ) );\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/extras/geometries/LatheGeometry.js\r\n\t\r\n\t/**\r\n\t * @author astrodud / http://astrodud.isgreat.org/\r\n\t * @author zz85 / https://github.com/zz85\r\n\t * @author bhouston / http://exocortex.com\r\n\t */\r\n\t\r\n\t// points - to create a closed torus, one must use a set of points \r\n\t//    like so: [ a, b, c, d, a ], see first is the same as last.\r\n\t// segments - the number of circumference segments to create\r\n\t// phiStart - the starting radian\r\n\t// phiLength - the radian (0 to 2*PI) range of the lathed section\r\n\t//    2*pi is a closed lathe, less than 2PI is a portion.\r\n\t\r\n\tTHREE.LatheGeometry = function ( points, segments, phiStart, phiLength ) {\r\n\t\r\n\t\tTHREE.Geometry.call( this );\r\n\t\r\n\t\tthis.type = 'LatheGeometry';\r\n\t\r\n\t\tthis.parameters = {\r\n\t\t\tpoints: points,\r\n\t\t\tsegments: segments,\r\n\t\t\tphiStart: phiStart,\r\n\t\t\tphiLength: phiLength\r\n\t\t};\r\n\t\r\n\t\tsegments = segments || 12;\r\n\t\tphiStart = phiStart || 0;\r\n\t\tphiLength = phiLength || 2 * Math.PI;\r\n\t\r\n\t\tvar inversePointLength = 1.0 / ( points.length - 1 );\r\n\t\tvar inverseSegments = 1.0 / segments;\r\n\t\r\n\t\tfor ( var i = 0, il = segments; i <= il; i ++ ) {\r\n\t\r\n\t\t\tvar phi = phiStart + i * inverseSegments * phiLength;\r\n\t\r\n\t\t\tvar c = Math.cos( phi ),\r\n\t\t\t\ts = Math.sin( phi );\r\n\t\r\n\t\t\tfor ( var j = 0, jl = points.length; j < jl; j ++ ) {\r\n\t\r\n\t\t\t\tvar pt = points[ j ];\r\n\t\r\n\t\t\t\tvar vertex = new THREE.Vector3();\r\n\t\r\n\t\t\t\tvertex.x = c * pt.x - s * pt.y;\r\n\t\t\t\tvertex.y = s * pt.x + c * pt.y;\r\n\t\t\t\tvertex.z = pt.z;\r\n\t\r\n\t\t\t\tthis.vertices.push( vertex );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\tvar np = points.length;\r\n\t\r\n\t\tfor ( var i = 0, il = segments; i < il; i ++ ) {\r\n\t\r\n\t\t\tfor ( var j = 0, jl = points.length - 1; j < jl; j ++ ) {\r\n\t\r\n\t\t\t\tvar base = j + np * i;\r\n\t\t\t\tvar a = base;\r\n\t\t\t\tvar b = base + np;\r\n\t\t\t\tvar c = base + 1 + np;\r\n\t\t\t\tvar d = base + 1;\r\n\t\r\n\t\t\t\tvar u0 = i * inverseSegments;\r\n\t\t\t\tvar v0 = j * inversePointLength;\r\n\t\t\t\tvar u1 = u0 + inverseSegments;\r\n\t\t\t\tvar v1 = v0 + inversePointLength;\r\n\t\r\n\t\t\t\tthis.faces.push( new THREE.Face3( a, b, d ) );\r\n\t\r\n\t\t\t\tthis.faceVertexUvs[ 0 ].push( [\r\n\t\r\n\t\t\t\t\tnew THREE.Vector2( u0, v0 ),\r\n\t\t\t\t\tnew THREE.Vector2( u1, v0 ),\r\n\t\t\t\t\tnew THREE.Vector2( u0, v1 )\r\n\t\r\n\t\t\t\t] );\r\n\t\r\n\t\t\t\tthis.faces.push( new THREE.Face3( b, c, d ) );\r\n\t\r\n\t\t\t\tthis.faceVertexUvs[ 0 ].push( [\r\n\t\r\n\t\t\t\t\tnew THREE.Vector2( u1, v0 ),\r\n\t\t\t\t\tnew THREE.Vector2( u1, v1 ),\r\n\t\t\t\t\tnew THREE.Vector2( u0, v1 )\r\n\t\r\n\t\t\t\t] );\r\n\t\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\tthis.mergeVertices();\r\n\t\tthis.computeFaceNormals();\r\n\t\tthis.computeVertexNormals();\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.LatheGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\n\tTHREE.LatheGeometry.prototype.constructor = THREE.LatheGeometry;\r\n\t\r\n\t// File:src/extras/geometries/PlaneGeometry.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Plane.as\r\n\t */\r\n\t\r\n\tTHREE.PlaneGeometry = function ( width, height, widthSegments, heightSegments ) {\r\n\t\r\n\t\tconsole.info( 'THREE.PlaneGeometry: Consider using THREE.PlaneBufferGeometry for lower memory footprint.' );\r\n\t\r\n\t\tTHREE.Geometry.call( this );\r\n\t\r\n\t\tthis.type = 'PlaneGeometry';\r\n\t\r\n\t\tthis.parameters = {\r\n\t\t\twidth: width,\r\n\t\t\theight: height,\r\n\t\t\twidthSegments: widthSegments,\r\n\t\t\theightSegments: heightSegments\r\n\t\t};\r\n\t\r\n\t\tthis.fromBufferGeometry( new THREE.PlaneBufferGeometry( width, height, widthSegments, heightSegments ) );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.PlaneGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\n\tTHREE.PlaneGeometry.prototype.constructor = THREE.PlaneGeometry;\r\n\t\r\n\t// File:src/extras/geometries/PlaneBufferGeometry.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Plane.as\r\n\t */\r\n\t\r\n\tTHREE.PlaneBufferGeometry = function ( width, height, widthSegments, heightSegments ) {\r\n\t\r\n\t\tTHREE.BufferGeometry.call( this );\r\n\t\r\n\t\tthis.type = 'PlaneBufferGeometry';\r\n\t\r\n\t\tthis.parameters = {\r\n\t\t\twidth: width,\r\n\t\t\theight: height,\r\n\t\t\twidthSegments: widthSegments,\r\n\t\t\theightSegments: heightSegments\r\n\t\t};\r\n\t\r\n\t\tvar width_half = width / 2;\r\n\t\tvar height_half = height / 2;\r\n\t\r\n\t\tvar gridX = widthSegments || 1;\r\n\t\tvar gridY = heightSegments || 1;\r\n\t\r\n\t\tvar gridX1 = gridX + 1;\r\n\t\tvar gridY1 = gridY + 1;\r\n\t\r\n\t\tvar segment_width = width / gridX;\r\n\t\tvar segment_height = height / gridY;\r\n\t\r\n\t\tvar vertices = new Float32Array( gridX1 * gridY1 * 3 );\r\n\t\tvar normals = new Float32Array( gridX1 * gridY1 * 3 );\r\n\t\tvar uvs = new Float32Array( gridX1 * gridY1 * 2 );\r\n\t\r\n\t\tvar offset = 0;\r\n\t\tvar offset2 = 0;\r\n\t\r\n\t\tfor ( var iy = 0; iy < gridY1; iy ++ ) {\r\n\t\r\n\t\t\tvar y = iy * segment_height - height_half;\r\n\t\r\n\t\t\tfor ( var ix = 0; ix < gridX1; ix ++ ) {\r\n\t\r\n\t\t\t\tvar x = ix * segment_width - width_half;\r\n\t\r\n\t\t\t\tvertices[ offset     ] = x;\r\n\t\t\t\tvertices[ offset + 1 ] = - y;\r\n\t\r\n\t\t\t\tnormals[ offset + 2 ] = 1;\r\n\t\r\n\t\t\t\tuvs[ offset2     ] = ix / gridX;\r\n\t\t\t\tuvs[ offset2 + 1 ] = 1 - ( iy / gridY );\r\n\t\r\n\t\t\t\toffset += 3;\r\n\t\t\t\toffset2 += 2;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\toffset = 0;\r\n\t\r\n\t\tvar indices = new ( ( vertices.length / 3 ) > 65535 ? Uint32Array : Uint16Array )( gridX * gridY * 6 );\r\n\t\r\n\t\tfor ( var iy = 0; iy < gridY; iy ++ ) {\r\n\t\r\n\t\t\tfor ( var ix = 0; ix < gridX; ix ++ ) {\r\n\t\r\n\t\t\t\tvar a = ix + gridX1 * iy;\r\n\t\t\t\tvar b = ix + gridX1 * ( iy + 1 );\r\n\t\t\t\tvar c = ( ix + 1 ) + gridX1 * ( iy + 1 );\r\n\t\t\t\tvar d = ( ix + 1 ) + gridX1 * iy;\r\n\t\r\n\t\t\t\tindices[ offset     ] = a;\r\n\t\t\t\tindices[ offset + 1 ] = b;\r\n\t\t\t\tindices[ offset + 2 ] = d;\r\n\t\r\n\t\t\t\tindices[ offset + 3 ] = b;\r\n\t\t\t\tindices[ offset + 4 ] = c;\r\n\t\t\t\tindices[ offset + 5 ] = d;\r\n\t\r\n\t\t\t\toffset += 6;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\tthis.addAttribute( 'index', new THREE.BufferAttribute( indices, 1 ) );\r\n\t\tthis.addAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );\r\n\t\tthis.addAttribute( 'normal', new THREE.BufferAttribute( normals, 3 ) );\r\n\t\tthis.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ) );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.PlaneBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );\r\n\tTHREE.PlaneBufferGeometry.prototype.constructor = THREE.PlaneBufferGeometry;\r\n\t\r\n\t// File:src/extras/geometries/RingGeometry.js\r\n\t\r\n\t/**\r\n\t * @author Kaleb Murphy\r\n\t */\r\n\t\r\n\tTHREE.RingGeometry = function ( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) {\r\n\t\r\n\t\tTHREE.Geometry.call( this );\r\n\t\r\n\t\tthis.type = 'RingGeometry';\r\n\t\r\n\t\tthis.parameters = {\r\n\t\t\tinnerRadius: innerRadius,\r\n\t\t\touterRadius: outerRadius,\r\n\t\t\tthetaSegments: thetaSegments,\r\n\t\t\tphiSegments: phiSegments,\r\n\t\t\tthetaStart: thetaStart,\r\n\t\t\tthetaLength: thetaLength\r\n\t\t};\r\n\t\r\n\t\tinnerRadius = innerRadius || 0;\r\n\t\touterRadius = outerRadius || 50;\r\n\t\r\n\t\tthetaStart = thetaStart !== undefined ? thetaStart : 0;\r\n\t\tthetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;\r\n\t\r\n\t\tthetaSegments = thetaSegments !== undefined ? Math.max( 3, thetaSegments ) : 8;\r\n\t\tphiSegments = phiSegments !== undefined ? Math.max( 1, phiSegments ) : 8;\r\n\t\r\n\t\tvar i, o, uvs = [], radius = innerRadius, radiusStep = ( ( outerRadius - innerRadius ) / phiSegments );\r\n\t\r\n\t\tfor ( i = 0; i < phiSegments + 1; i ++ ) { // concentric circles inside ring\r\n\t\r\n\t\t\tfor ( o = 0; o < thetaSegments + 1; o ++ ) { // number of segments per circle\r\n\t\r\n\t\t\t\tvar vertex = new THREE.Vector3();\r\n\t\t\t\tvar segment = thetaStart + o / thetaSegments * thetaLength;\r\n\t\t\t\tvertex.x = radius * Math.cos( segment );\r\n\t\t\t\tvertex.y = radius * Math.sin( segment );\r\n\t\r\n\t\t\t\tthis.vertices.push( vertex );\r\n\t\t\t\tuvs.push( new THREE.Vector2( ( vertex.x / outerRadius + 1 ) / 2, ( vertex.y / outerRadius + 1 ) / 2 ) );\r\n\t\t\t}\r\n\t\r\n\t\t\tradius += radiusStep;\r\n\t\r\n\t\t}\r\n\t\r\n\t\tvar n = new THREE.Vector3( 0, 0, 1 );\r\n\t\r\n\t\tfor ( i = 0; i < phiSegments; i ++ ) { // concentric circles inside ring\r\n\t\r\n\t\t\tvar thetaSegment = i * (thetaSegments + 1);\r\n\t\r\n\t\t\tfor ( o = 0; o < thetaSegments ; o ++ ) { // number of segments per circle\r\n\t\r\n\t\t\t\tvar segment = o + thetaSegment;\r\n\t\r\n\t\t\t\tvar v1 = segment;\r\n\t\t\t\tvar v2 = segment + thetaSegments + 1;\r\n\t\t\t\tvar v3 = segment + thetaSegments + 2;\r\n\t\r\n\t\t\t\tthis.faces.push( new THREE.Face3( v1, v2, v3, [ n.clone(), n.clone(), n.clone() ] ) );\r\n\t\t\t\tthis.faceVertexUvs[ 0 ].push( [ uvs[ v1 ].clone(), uvs[ v2 ].clone(), uvs[ v3 ].clone() ]);\r\n\t\r\n\t\t\t\tv1 = segment;\r\n\t\t\t\tv2 = segment + thetaSegments + 2;\r\n\t\t\t\tv3 = segment + 1;\r\n\t\r\n\t\t\t\tthis.faces.push( new THREE.Face3( v1, v2, v3, [ n.clone(), n.clone(), n.clone() ] ) );\r\n\t\t\t\tthis.faceVertexUvs[ 0 ].push( [ uvs[ v1 ].clone(), uvs[ v2 ].clone(), uvs[ v3 ].clone() ]);\r\n\t\r\n\t\t\t}\r\n\t\t}\r\n\t\r\n\t\tthis.computeFaceNormals();\r\n\t\r\n\t\tthis.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.RingGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\n\tTHREE.RingGeometry.prototype.constructor = THREE.RingGeometry;\r\n\t\r\n\t\r\n\t// File:src/extras/geometries/SphereGeometry.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tTHREE.SphereGeometry = function ( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) {\r\n\t\r\n\t\tTHREE.Geometry.call( this );\r\n\t\r\n\t\tthis.type = 'SphereGeometry';\r\n\t\r\n\t\tthis.parameters = {\r\n\t\t\tradius: radius,\r\n\t\t\twidthSegments: widthSegments,\r\n\t\t\theightSegments: heightSegments,\r\n\t\t\tphiStart: phiStart,\r\n\t\t\tphiLength: phiLength,\r\n\t\t\tthetaStart: thetaStart,\r\n\t\t\tthetaLength: thetaLength \r\n\t\t};\r\n\t\r\n\t\tradius = radius || 50;\r\n\t\r\n\t\twidthSegments = Math.max( 3, Math.floor( widthSegments ) || 8 );\r\n\t\theightSegments = Math.max( 2, Math.floor( heightSegments ) || 6 );\r\n\t\r\n\t\tphiStart = phiStart !== undefined ? phiStart : 0;\r\n\t\tphiLength = phiLength !== undefined ? phiLength : Math.PI * 2;\r\n\t\r\n\t\tthetaStart = thetaStart !== undefined ? thetaStart : 0;\r\n\t\tthetaLength = thetaLength !== undefined ? thetaLength : Math.PI;\r\n\t\r\n\t\tvar x, y, vertices = [], uvs = [];\r\n\t\r\n\t\tfor ( y = 0; y <= heightSegments; y ++ ) {\r\n\t\r\n\t\t\tvar verticesRow = [];\r\n\t\t\tvar uvsRow = [];\r\n\t\r\n\t\t\tfor ( x = 0; x <= widthSegments; x ++ ) {\r\n\t\r\n\t\t\t\tvar u = x / widthSegments;\r\n\t\t\t\tvar v = y / heightSegments;\r\n\t\r\n\t\t\t\tvar vertex = new THREE.Vector3();\r\n\t\t\t\tvertex.x = - radius * Math.cos( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );\r\n\t\t\t\tvertex.y = radius * Math.cos( thetaStart + v * thetaLength );\r\n\t\t\t\tvertex.z = radius * Math.sin( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );\r\n\t\r\n\t\t\t\tthis.vertices.push( vertex );\r\n\t\r\n\t\t\t\tverticesRow.push( this.vertices.length - 1 );\r\n\t\t\t\tuvsRow.push( new THREE.Vector2( u, 1 - v ) );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvertices.push( verticesRow );\r\n\t\t\tuvs.push( uvsRow );\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfor ( y = 0; y < heightSegments; y ++ ) {\r\n\t\r\n\t\t\tfor ( x = 0; x < widthSegments; x ++ ) {\r\n\t\r\n\t\t\t\tvar v1 = vertices[ y ][ x + 1 ];\r\n\t\t\t\tvar v2 = vertices[ y ][ x ];\r\n\t\t\t\tvar v3 = vertices[ y + 1 ][ x ];\r\n\t\t\t\tvar v4 = vertices[ y + 1 ][ x + 1 ];\r\n\t\r\n\t\t\t\tvar n1 = this.vertices[ v1 ].clone().normalize();\r\n\t\t\t\tvar n2 = this.vertices[ v2 ].clone().normalize();\r\n\t\t\t\tvar n3 = this.vertices[ v3 ].clone().normalize();\r\n\t\t\t\tvar n4 = this.vertices[ v4 ].clone().normalize();\r\n\t\r\n\t\t\t\tvar uv1 = uvs[ y ][ x + 1 ].clone();\r\n\t\t\t\tvar uv2 = uvs[ y ][ x ].clone();\r\n\t\t\t\tvar uv3 = uvs[ y + 1 ][ x ].clone();\r\n\t\t\t\tvar uv4 = uvs[ y + 1 ][ x + 1 ].clone();\r\n\t\r\n\t\t\t\tif ( Math.abs( this.vertices[ v1 ].y ) === radius ) {\r\n\t\r\n\t\t\t\t\tuv1.x = ( uv1.x + uv2.x ) / 2;\r\n\t\t\t\t\tthis.faces.push( new THREE.Face3( v1, v3, v4, [ n1, n3, n4 ] ) );\r\n\t\t\t\t\tthis.faceVertexUvs[ 0 ].push( [ uv1, uv3, uv4 ] );\r\n\t\r\n\t\t\t\t} else if ( Math.abs( this.vertices[ v3 ].y ) === radius ) {\r\n\t\r\n\t\t\t\t\tuv3.x = ( uv3.x + uv4.x ) / 2;\r\n\t\t\t\t\tthis.faces.push( new THREE.Face3( v1, v2, v3, [ n1, n2, n3 ] ) );\r\n\t\t\t\t\tthis.faceVertexUvs[ 0 ].push( [ uv1, uv2, uv3 ] );\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tthis.faces.push( new THREE.Face3( v1, v2, v4, [ n1, n2, n4 ] ) );\r\n\t\t\t\t\tthis.faceVertexUvs[ 0 ].push( [ uv1, uv2, uv4 ] );\r\n\t\r\n\t\t\t\t\tthis.faces.push( new THREE.Face3( v2, v3, v4, [ n2.clone(), n3, n4.clone() ] ) );\r\n\t\t\t\t\tthis.faceVertexUvs[ 0 ].push( [ uv2.clone(), uv3, uv4.clone() ] );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\tthis.computeFaceNormals();\r\n\t\r\n\t\tthis.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.SphereGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\n\tTHREE.SphereGeometry.prototype.constructor = THREE.SphereGeometry;\r\n\t\r\n\t// File:src/extras/geometries/TextGeometry.js\r\n\t\r\n\t/**\r\n\t * @author zz85 / http://www.lab4games.net/zz85/blog\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t *\r\n\t * For creating 3D text geometry in three.js\r\n\t *\r\n\t * Text = 3D Text\r\n\t *\r\n\t * parameters = {\r\n\t *  size: \t\t\t<float>, \t// size of the text\r\n\t *  height: \t\t<float>, \t// thickness to extrude text\r\n\t *  curveSegments: \t<int>,\t\t// number of points on the curves\r\n\t *\r\n\t *  font: \t\t\t<string>,\t\t// font name\r\n\t *  weight: \t\t<string>,\t\t// font weight (normal, bold)\r\n\t *  style: \t\t\t<string>,\t\t// font style  (normal, italics)\r\n\t *\r\n\t *  bevelEnabled:\t<bool>,\t\t\t// turn on bevel\r\n\t *  bevelThickness: <float>, \t\t// how deep into text bevel goes\r\n\t *  bevelSize:\t\t<float>, \t\t// how far from text outline is bevel\r\n\t *  }\r\n\t *\r\n\t */\r\n\t\r\n\t/*\tUsage Examples\r\n\t\r\n\t\t// TextGeometry wrapper\r\n\t\r\n\t\tvar text3d = new TextGeometry( text, options );\r\n\t\r\n\t\t// Complete manner\r\n\t\r\n\t\tvar textShapes = THREE.FontUtils.generateShapes( text, options );\r\n\t\tvar text3d = new ExtrudeGeometry( textShapes, options );\r\n\t\r\n\t*/\r\n\t\r\n\t\r\n\tTHREE.TextGeometry = function ( text, parameters ) {\r\n\t\r\n\t\tparameters = parameters || {};\r\n\t\r\n\t\tvar textShapes = THREE.FontUtils.generateShapes( text, parameters );\r\n\t\r\n\t\t// translate parameters to ExtrudeGeometry API\r\n\t\r\n\t\tparameters.amount = parameters.height !== undefined ? parameters.height : 50;\r\n\t\r\n\t\t// defaults\r\n\t\r\n\t\tif ( parameters.bevelThickness === undefined ) parameters.bevelThickness = 10;\r\n\t\tif ( parameters.bevelSize === undefined ) parameters.bevelSize = 8;\r\n\t\tif ( parameters.bevelEnabled === undefined ) parameters.bevelEnabled = false;\r\n\t\r\n\t\tTHREE.ExtrudeGeometry.call( this, textShapes, parameters );\r\n\t\r\n\t\tthis.type = 'TextGeometry';\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.TextGeometry.prototype = Object.create( THREE.ExtrudeGeometry.prototype );\r\n\tTHREE.TextGeometry.prototype.constructor = THREE.TextGeometry;\r\n\t\r\n\t// File:src/extras/geometries/TorusGeometry.js\r\n\t\r\n\t/**\r\n\t * @author oosmoxiecode\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t * based on http://code.google.com/p/away3d/source/browse/trunk/fp10/Away3DLite/src/away3dlite/primitives/Torus.as?r=2888\r\n\t */\r\n\t\r\n\tTHREE.TorusGeometry = function ( radius, tube, radialSegments, tubularSegments, arc ) {\r\n\t\r\n\t\tTHREE.Geometry.call( this );\r\n\t\r\n\t\tthis.type = 'TorusGeometry';\r\n\t\r\n\t\tthis.parameters = {\r\n\t\t\tradius: radius,\r\n\t\t\ttube: tube,\r\n\t\t\tradialSegments: radialSegments,\r\n\t\t\ttubularSegments: tubularSegments,\r\n\t\t\tarc: arc\r\n\t\t};\r\n\t\r\n\t\tradius = radius || 100;\r\n\t\ttube = tube || 40;\r\n\t\tradialSegments = radialSegments || 8;\r\n\t\ttubularSegments = tubularSegments || 6;\r\n\t\tarc = arc || Math.PI * 2;\r\n\t\r\n\t\tvar center = new THREE.Vector3(), uvs = [], normals = [];\r\n\t\r\n\t\tfor ( var j = 0; j <= radialSegments; j ++ ) {\r\n\t\r\n\t\t\tfor ( var i = 0; i <= tubularSegments; i ++ ) {\r\n\t\r\n\t\t\t\tvar u = i / tubularSegments * arc;\r\n\t\t\t\tvar v = j / radialSegments * Math.PI * 2;\r\n\t\r\n\t\t\t\tcenter.x = radius * Math.cos( u );\r\n\t\t\t\tcenter.y = radius * Math.sin( u );\r\n\t\r\n\t\t\t\tvar vertex = new THREE.Vector3();\r\n\t\t\t\tvertex.x = ( radius + tube * Math.cos( v ) ) * Math.cos( u );\r\n\t\t\t\tvertex.y = ( radius + tube * Math.cos( v ) ) * Math.sin( u );\r\n\t\t\t\tvertex.z = tube * Math.sin( v );\r\n\t\r\n\t\t\t\tthis.vertices.push( vertex );\r\n\t\r\n\t\t\t\tuvs.push( new THREE.Vector2( i / tubularSegments, j / radialSegments ) );\r\n\t\t\t\tnormals.push( vertex.clone().sub( center ).normalize() );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfor ( var j = 1; j <= radialSegments; j ++ ) {\r\n\t\r\n\t\t\tfor ( var i = 1; i <= tubularSegments; i ++ ) {\r\n\t\r\n\t\t\t\tvar a = ( tubularSegments + 1 ) * j + i - 1;\r\n\t\t\t\tvar b = ( tubularSegments + 1 ) * ( j - 1 ) + i - 1;\r\n\t\t\t\tvar c = ( tubularSegments + 1 ) * ( j - 1 ) + i;\r\n\t\t\t\tvar d = ( tubularSegments + 1 ) * j + i;\r\n\t\r\n\t\t\t\tvar face = new THREE.Face3( a, b, d, [ normals[ a ].clone(), normals[ b ].clone(), normals[ d ].clone() ] );\r\n\t\t\t\tthis.faces.push( face );\r\n\t\t\t\tthis.faceVertexUvs[ 0 ].push( [ uvs[ a ].clone(), uvs[ b ].clone(), uvs[ d ].clone() ] );\r\n\t\r\n\t\t\t\tface = new THREE.Face3( b, c, d, [ normals[ b ].clone(), normals[ c ].clone(), normals[ d ].clone() ] );\r\n\t\t\t\tthis.faces.push( face );\r\n\t\t\t\tthis.faceVertexUvs[ 0 ].push( [ uvs[ b ].clone(), uvs[ c ].clone(), uvs[ d ].clone() ] );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\tthis.computeFaceNormals();\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.TorusGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\n\tTHREE.TorusGeometry.prototype.constructor = THREE.TorusGeometry;\r\n\t\r\n\t// File:src/extras/geometries/TorusKnotGeometry.js\r\n\t\r\n\t/**\r\n\t * @author oosmoxiecode\r\n\t * based on http://code.google.com/p/away3d/source/browse/trunk/fp10/Away3D/src/away3d/primitives/TorusKnot.as?spec=svn2473&r=2473\r\n\t */\r\n\t\r\n\tTHREE.TorusKnotGeometry = function ( radius, tube, radialSegments, tubularSegments, p, q, heightScale ) {\r\n\t\r\n\t\tTHREE.Geometry.call( this );\r\n\t\r\n\t\tthis.type = 'TorusKnotGeometry';\r\n\t\r\n\t\tthis.parameters = {\r\n\t\t\tradius: radius,\r\n\t\t\ttube: tube,\r\n\t\t\tradialSegments: radialSegments,\r\n\t\t\ttubularSegments: tubularSegments,\r\n\t\t\tp: p,\r\n\t\t\tq: q,\r\n\t\t\theightScale: heightScale\r\n\t\t};\r\n\t\r\n\t\tradius = radius || 100;\r\n\t\ttube = tube || 40;\r\n\t\tradialSegments = radialSegments || 64;\r\n\t\ttubularSegments = tubularSegments || 8;\r\n\t\tp = p || 2;\r\n\t\tq = q || 3;\r\n\t\theightScale = heightScale || 1;\r\n\t\t\r\n\t\tvar grid = new Array( radialSegments );\r\n\t\tvar tang = new THREE.Vector3();\r\n\t\tvar n = new THREE.Vector3();\r\n\t\tvar bitan = new THREE.Vector3();\r\n\t\r\n\t\tfor ( var i = 0; i < radialSegments; ++ i ) {\r\n\t\r\n\t\t\tgrid[ i ] = new Array( tubularSegments );\r\n\t\t\tvar u = i / radialSegments * 2 * p * Math.PI;\r\n\t\t\tvar p1 = getPos( u, q, p, radius, heightScale );\r\n\t\t\tvar p2 = getPos( u + 0.01, q, p, radius, heightScale );\r\n\t\t\ttang.subVectors( p2, p1 );\r\n\t\t\tn.addVectors( p2, p1 );\r\n\t\r\n\t\t\tbitan.crossVectors( tang, n );\r\n\t\t\tn.crossVectors( bitan, tang );\r\n\t\t\tbitan.normalize();\r\n\t\t\tn.normalize();\r\n\t\r\n\t\t\tfor ( var j = 0; j < tubularSegments; ++ j ) {\r\n\t\r\n\t\t\t\tvar v = j / tubularSegments * 2 * Math.PI;\r\n\t\t\t\tvar cx = - tube * Math.cos( v ); // TODO: Hack: Negating it so it faces outside.\r\n\t\t\t\tvar cy = tube * Math.sin( v );\r\n\t\r\n\t\t\t\tvar pos = new THREE.Vector3();\r\n\t\t\t\tpos.x = p1.x + cx * n.x + cy * bitan.x;\r\n\t\t\t\tpos.y = p1.y + cx * n.y + cy * bitan.y;\r\n\t\t\t\tpos.z = p1.z + cx * n.z + cy * bitan.z;\r\n\t\r\n\t\t\t\tgrid[ i ][ j ] = this.vertices.push( pos ) - 1;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfor ( var i = 0; i < radialSegments; ++ i ) {\r\n\t\r\n\t\t\tfor ( var j = 0; j < tubularSegments; ++ j ) {\r\n\t\r\n\t\t\t\tvar ip = ( i + 1 ) % radialSegments;\r\n\t\t\t\tvar jp = ( j + 1 ) % tubularSegments;\r\n\t\r\n\t\t\t\tvar a = grid[ i ][ j ];\r\n\t\t\t\tvar b = grid[ ip ][ j ];\r\n\t\t\t\tvar c = grid[ ip ][ jp ];\r\n\t\t\t\tvar d = grid[ i ][ jp ];\r\n\t\r\n\t\t\t\tvar uva = new THREE.Vector2( i / radialSegments, j / tubularSegments );\r\n\t\t\t\tvar uvb = new THREE.Vector2( ( i + 1 ) / radialSegments, j / tubularSegments );\r\n\t\t\t\tvar uvc = new THREE.Vector2( ( i + 1 ) / radialSegments, ( j + 1 ) / tubularSegments );\r\n\t\t\t\tvar uvd = new THREE.Vector2( i / radialSegments, ( j + 1 ) / tubularSegments );\r\n\t\r\n\t\t\t\tthis.faces.push( new THREE.Face3( a, b, d ) );\r\n\t\t\t\tthis.faceVertexUvs[ 0 ].push( [ uva, uvb, uvd ] );\r\n\t\r\n\t\t\t\tthis.faces.push( new THREE.Face3( b, c, d ) );\r\n\t\t\t\tthis.faceVertexUvs[ 0 ].push( [ uvb.clone(), uvc, uvd.clone() ] );\r\n\t\r\n\t\t\t}\r\n\t\t}\r\n\t\r\n\t\tthis.computeFaceNormals();\r\n\t\tthis.computeVertexNormals();\r\n\t\r\n\t\tfunction getPos( u, in_q, in_p, radius, heightScale ) {\r\n\t\r\n\t\t\tvar cu = Math.cos( u );\r\n\t\t\tvar su = Math.sin( u );\r\n\t\t\tvar quOverP = in_q / in_p * u;\r\n\t\t\tvar cs = Math.cos( quOverP );\r\n\t\r\n\t\t\tvar tx = radius * ( 2 + cs ) * 0.5 * cu;\r\n\t\t\tvar ty = radius * ( 2 + cs ) * su * 0.5;\r\n\t\t\tvar tz = heightScale * radius * Math.sin( quOverP ) * 0.5;\r\n\t\r\n\t\t\treturn new THREE.Vector3( tx, ty, tz );\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.TorusKnotGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\n\tTHREE.TorusKnotGeometry.prototype.constructor = THREE.TorusKnotGeometry;\r\n\t\r\n\t// File:src/extras/geometries/TubeGeometry.js\r\n\t\r\n\t/**\r\n\t * @author WestLangley / https://github.com/WestLangley\r\n\t * @author zz85 / https://github.com/zz85\r\n\t * @author miningold / https://github.com/miningold\r\n\t * @author jonobr1 / https://github.com/jonobr1\r\n\t *\r\n\t * Modified from the TorusKnotGeometry by @oosmoxiecode\r\n\t *\r\n\t * Creates a tube which extrudes along a 3d spline\r\n\t *\r\n\t * Uses parallel transport frames as described in\r\n\t * http://www.cs.indiana.edu/pub/techreports/TR425.pdf\r\n\t */\r\n\t\r\n\tTHREE.TubeGeometry = function ( path, segments, radius, radialSegments, closed, taper ) {\r\n\t\r\n\t\tTHREE.Geometry.call( this );\r\n\t\r\n\t\tthis.type = 'TubeGeometry';\r\n\t\r\n\t\tthis.parameters = {\r\n\t\t\tpath: path,\r\n\t\t\tsegments: segments,\r\n\t\t\tradius: radius,\r\n\t\t\tradialSegments: radialSegments,\r\n\t\t\tclosed: closed\r\n\t\t};\r\n\t\r\n\t\tsegments = segments || 64;\r\n\t\tradius = radius || 1;\r\n\t\tradialSegments = radialSegments || 8;\r\n\t\tclosed = closed || false;\r\n\t\ttaper = taper || THREE.TubeGeometry.NoTaper;\r\n\t\r\n\t\tvar grid = [];\r\n\t\r\n\t\tvar scope = this,\r\n\t\r\n\t\t\ttangent,\r\n\t\t\tnormal,\r\n\t\t\tbinormal,\r\n\t\r\n\t\t\tnumpoints = segments + 1,\r\n\t\r\n\t\t\tu, v, r,\r\n\t\r\n\t\t\tcx, cy,\r\n\t\t\tpos, pos2 = new THREE.Vector3(),\r\n\t\t\ti, j,\r\n\t\t\tip, jp,\r\n\t\t\ta, b, c, d,\r\n\t\t\tuva, uvb, uvc, uvd;\r\n\t\r\n\t\tvar frames = new THREE.TubeGeometry.FrenetFrames( path, segments, closed ),\r\n\t\t\ttangents = frames.tangents,\r\n\t\t\tnormals = frames.normals,\r\n\t\t\tbinormals = frames.binormals;\r\n\t\r\n\t\t// proxy internals\r\n\t\tthis.tangents = tangents;\r\n\t\tthis.normals = normals;\r\n\t\tthis.binormals = binormals;\r\n\t\r\n\t\tfunction vert( x, y, z ) {\r\n\t\r\n\t\t\treturn scope.vertices.push( new THREE.Vector3( x, y, z ) ) - 1;\r\n\t\r\n\t\t}\r\n\t\r\n\t\t// consruct the grid\r\n\t\r\n\t\tfor ( i = 0; i < numpoints; i ++ ) {\r\n\t\r\n\t\t\tgrid[ i ] = [];\r\n\t\r\n\t\t\tu = i / ( numpoints - 1 );\r\n\t\r\n\t\t\tpos = path.getPointAt( u );\r\n\t\r\n\t\t\ttangent = tangents[ i ];\r\n\t\t\tnormal = normals[ i ];\r\n\t\t\tbinormal = binormals[ i ];\r\n\t\r\n\t\t\tr = radius * taper( u );\r\n\t\r\n\t\t\tfor ( j = 0; j < radialSegments; j ++ ) {\r\n\t\r\n\t\t\t\tv = j / radialSegments * 2 * Math.PI;\r\n\t\r\n\t\t\t\tcx = - r * Math.cos( v ); // TODO: Hack: Negating it so it faces outside.\r\n\t\t\t\tcy = r * Math.sin( v );\r\n\t\r\n\t\t\t\tpos2.copy( pos );\r\n\t\t\t\tpos2.x += cx * normal.x + cy * binormal.x;\r\n\t\t\t\tpos2.y += cx * normal.y + cy * binormal.y;\r\n\t\t\t\tpos2.z += cx * normal.z + cy * binormal.z;\r\n\t\r\n\t\t\t\tgrid[ i ][ j ] = vert( pos2.x, pos2.y, pos2.z );\r\n\t\r\n\t\t\t}\r\n\t\t}\r\n\t\r\n\t\r\n\t\t// construct the mesh\r\n\t\r\n\t\tfor ( i = 0; i < segments; i ++ ) {\r\n\t\r\n\t\t\tfor ( j = 0; j < radialSegments; j ++ ) {\r\n\t\r\n\t\t\t\tip = ( closed ) ? (i + 1) % segments : i + 1;\r\n\t\t\t\tjp = (j + 1) % radialSegments;\r\n\t\r\n\t\t\t\ta = grid[ i ][ j ];\t\t// *** NOT NECESSARILY PLANAR ! ***\r\n\t\t\t\tb = grid[ ip ][ j ];\r\n\t\t\t\tc = grid[ ip ][ jp ];\r\n\t\t\t\td = grid[ i ][ jp ];\r\n\t\r\n\t\t\t\tuva = new THREE.Vector2( i / segments, j / radialSegments );\r\n\t\t\t\tuvb = new THREE.Vector2( ( i + 1 ) / segments, j / radialSegments );\r\n\t\t\t\tuvc = new THREE.Vector2( ( i + 1 ) / segments, ( j + 1 ) / radialSegments );\r\n\t\t\t\tuvd = new THREE.Vector2( i / segments, ( j + 1 ) / radialSegments );\r\n\t\r\n\t\t\t\tthis.faces.push( new THREE.Face3( a, b, d ) );\r\n\t\t\t\tthis.faceVertexUvs[ 0 ].push( [ uva, uvb, uvd ] );\r\n\t\r\n\t\t\t\tthis.faces.push( new THREE.Face3( b, c, d ) );\r\n\t\t\t\tthis.faceVertexUvs[ 0 ].push( [ uvb.clone(), uvc, uvd.clone() ] );\r\n\t\r\n\t\t\t}\r\n\t\t}\r\n\t\r\n\t\tthis.computeFaceNormals();\r\n\t\tthis.computeVertexNormals();\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.TubeGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\n\tTHREE.TubeGeometry.prototype.constructor = THREE.TubeGeometry;\r\n\t\r\n\tTHREE.TubeGeometry.NoTaper = function ( u ) {\r\n\t\r\n\t\treturn 1;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.TubeGeometry.SinusoidalTaper = function ( u ) {\r\n\t\r\n\t\treturn Math.sin( Math.PI * u );\r\n\t\r\n\t};\r\n\t\r\n\t// For computing of Frenet frames, exposing the tangents, normals and binormals the spline\r\n\tTHREE.TubeGeometry.FrenetFrames = function ( path, segments, closed ) {\r\n\t\r\n\t\tvar\tnormal = new THREE.Vector3(),\r\n\t\r\n\t\t\ttangents = [],\r\n\t\t\tnormals = [],\r\n\t\t\tbinormals = [],\r\n\t\r\n\t\t\tvec = new THREE.Vector3(),\r\n\t\t\tmat = new THREE.Matrix4(),\r\n\t\r\n\t\t\tnumpoints = segments + 1,\r\n\t\t\ttheta,\r\n\t\t\tepsilon = 0.0001,\r\n\t\t\tsmallest,\r\n\t\r\n\t\t\ttx, ty, tz,\r\n\t\t\ti, u;\r\n\t\r\n\t\r\n\t\t// expose internals\r\n\t\tthis.tangents = tangents;\r\n\t\tthis.normals = normals;\r\n\t\tthis.binormals = binormals;\r\n\t\r\n\t\t// compute the tangent vectors for each segment on the path\r\n\t\r\n\t\tfor ( i = 0; i < numpoints; i ++ ) {\r\n\t\r\n\t\t\tu = i / ( numpoints - 1 );\r\n\t\r\n\t\t\ttangents[ i ] = path.getTangentAt( u );\r\n\t\t\ttangents[ i ].normalize();\r\n\t\r\n\t\t}\r\n\t\r\n\t\tinitialNormal3();\r\n\t\r\n\t\t/*\r\n\t\tfunction initialNormal1(lastBinormal) {\r\n\t\t\t// fixed start binormal. Has dangers of 0 vectors\r\n\t\t\tnormals[ 0 ] = new THREE.Vector3();\r\n\t\t\tbinormals[ 0 ] = new THREE.Vector3();\r\n\t\t\tif (lastBinormal===undefined) lastBinormal = new THREE.Vector3( 0, 0, 1 );\r\n\t\t\tnormals[ 0 ].crossVectors( lastBinormal, tangents[ 0 ] ).normalize();\r\n\t\t\tbinormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] ).normalize();\r\n\t\t}\r\n\t\r\n\t\tfunction initialNormal2() {\r\n\t\r\n\t\t\t// This uses the Frenet-Serret formula for deriving binormal\r\n\t\t\tvar t2 = path.getTangentAt( epsilon );\r\n\t\r\n\t\t\tnormals[ 0 ] = new THREE.Vector3().subVectors( t2, tangents[ 0 ] ).normalize();\r\n\t\t\tbinormals[ 0 ] = new THREE.Vector3().crossVectors( tangents[ 0 ], normals[ 0 ] );\r\n\t\r\n\t\t\tnormals[ 0 ].crossVectors( binormals[ 0 ], tangents[ 0 ] ).normalize(); // last binormal x tangent\r\n\t\t\tbinormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] ).normalize();\r\n\t\r\n\t\t}\r\n\t\t*/\r\n\t\r\n\t\tfunction initialNormal3() {\r\n\t\t\t// select an initial normal vector perpenicular to the first tangent vector,\r\n\t\t\t// and in the direction of the smallest tangent xyz component\r\n\t\r\n\t\t\tnormals[ 0 ] = new THREE.Vector3();\r\n\t\t\tbinormals[ 0 ] = new THREE.Vector3();\r\n\t\t\tsmallest = Number.MAX_VALUE;\r\n\t\t\ttx = Math.abs( tangents[ 0 ].x );\r\n\t\t\tty = Math.abs( tangents[ 0 ].y );\r\n\t\t\ttz = Math.abs( tangents[ 0 ].z );\r\n\t\r\n\t\t\tif ( tx <= smallest ) {\r\n\t\t\t\tsmallest = tx;\r\n\t\t\t\tnormal.set( 1, 0, 0 );\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( ty <= smallest ) {\r\n\t\t\t\tsmallest = ty;\r\n\t\t\t\tnormal.set( 0, 1, 0 );\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( tz <= smallest ) {\r\n\t\t\t\tnormal.set( 0, 0, 1 );\r\n\t\t\t}\r\n\t\r\n\t\t\tvec.crossVectors( tangents[ 0 ], normal ).normalize();\r\n\t\r\n\t\t\tnormals[ 0 ].crossVectors( tangents[ 0 ], vec );\r\n\t\t\tbinormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] );\r\n\t\t}\r\n\t\r\n\t\r\n\t\t// compute the slowly-varying normal and binormal vectors for each segment on the path\r\n\t\r\n\t\tfor ( i = 1; i < numpoints; i ++ ) {\r\n\t\r\n\t\t\tnormals[ i ] = normals[ i - 1 ].clone();\r\n\t\r\n\t\t\tbinormals[ i ] = binormals[ i - 1 ].clone();\r\n\t\r\n\t\t\tvec.crossVectors( tangents[ i - 1 ], tangents[ i ] );\r\n\t\r\n\t\t\tif ( vec.length() > epsilon ) {\r\n\t\r\n\t\t\t\tvec.normalize();\r\n\t\r\n\t\t\t\ttheta = Math.acos( THREE.Math.clamp( tangents[ i - 1 ].dot( tangents[ i ] ), - 1, 1 ) ); // clamp for floating pt errors\r\n\t\r\n\t\t\t\tnormals[ i ].applyMatrix4( mat.makeRotationAxis( vec, theta ) );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tbinormals[ i ].crossVectors( tangents[ i ], normals[ i ] );\r\n\t\r\n\t\t}\r\n\t\r\n\t\r\n\t\t// if the curve is closed, postprocess the vectors so the first and last normal vectors are the same\r\n\t\r\n\t\tif ( closed ) {\r\n\t\r\n\t\t\ttheta = Math.acos( THREE.Math.clamp( normals[ 0 ].dot( normals[ numpoints - 1 ] ), - 1, 1 ) );\r\n\t\t\ttheta /= ( numpoints - 1 );\r\n\t\r\n\t\t\tif ( tangents[ 0 ].dot( vec.crossVectors( normals[ 0 ], normals[ numpoints - 1 ] ) ) > 0 ) {\r\n\t\r\n\t\t\t\ttheta = - theta;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tfor ( i = 1; i < numpoints; i ++ ) {\r\n\t\r\n\t\t\t\t// twist a little...\r\n\t\t\t\tnormals[ i ].applyMatrix4( mat.makeRotationAxis( tangents[ i ], theta * i ) );\r\n\t\t\t\tbinormals[ i ].crossVectors( tangents[ i ], normals[ i ] );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t};\r\n\t\r\n\t// File:src/extras/geometries/PolyhedronGeometry.js\r\n\t\r\n\t/**\r\n\t * @author clockworkgeek / https://github.com/clockworkgeek\r\n\t * @author timothypratley / https://github.com/timothypratley\r\n\t * @author WestLangley / http://github.com/WestLangley\r\n\t*/\r\n\t\r\n\tTHREE.PolyhedronGeometry = function ( vertices, indices, radius, detail ) {\r\n\t\r\n\t\tTHREE.Geometry.call( this );\r\n\t\r\n\t\tthis.type = 'PolyhedronGeometry';\r\n\t\r\n\t\tthis.parameters = {\r\n\t\t\tvertices: vertices,\r\n\t\t\tindices: indices,\r\n\t\t\tradius: radius,\r\n\t\t\tdetail: detail\r\n\t\t};\r\n\t\r\n\t\tradius = radius || 1;\r\n\t\tdetail = detail || 0;\r\n\t\r\n\t\tvar that = this;\r\n\t\r\n\t\tfor ( var i = 0, l = vertices.length; i < l; i += 3 ) {\r\n\t\r\n\t\t\tprepare( new THREE.Vector3( vertices[ i ], vertices[ i + 1 ], vertices[ i + 2 ] ) );\r\n\t\r\n\t\t}\r\n\t\r\n\t\tvar p = this.vertices;\r\n\t\r\n\t\tvar faces = [];\r\n\t\r\n\t\tfor ( var i = 0, j = 0, l = indices.length; i < l; i += 3, j ++ ) {\r\n\t\r\n\t\t\tvar v1 = p[ indices[ i     ] ];\r\n\t\t\tvar v2 = p[ indices[ i + 1 ] ];\r\n\t\t\tvar v3 = p[ indices[ i + 2 ] ];\r\n\t\r\n\t\t\tfaces[ j ] = new THREE.Face3( v1.index, v2.index, v3.index, [ v1.clone(), v2.clone(), v3.clone() ] );\r\n\t\r\n\t\t}\r\n\t\r\n\t\tvar centroid = new THREE.Vector3();\r\n\t\r\n\t\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\r\n\t\r\n\t\t\tsubdivide( faces[ i ], detail );\r\n\t\r\n\t\t}\r\n\t\r\n\t\r\n\t\t// Handle case when face straddles the seam\r\n\t\r\n\t\tfor ( var i = 0, l = this.faceVertexUvs[ 0 ].length; i < l; i ++ ) {\r\n\t\r\n\t\t\tvar uvs = this.faceVertexUvs[ 0 ][ i ];\r\n\t\r\n\t\t\tvar x0 = uvs[ 0 ].x;\r\n\t\t\tvar x1 = uvs[ 1 ].x;\r\n\t\t\tvar x2 = uvs[ 2 ].x;\r\n\t\r\n\t\t\tvar max = Math.max( x0, Math.max( x1, x2 ) );\r\n\t\t\tvar min = Math.min( x0, Math.min( x1, x2 ) );\r\n\t\r\n\t\t\tif ( max > 0.9 && min < 0.1 ) { // 0.9 is somewhat arbitrary\r\n\t\r\n\t\t\t\tif ( x0 < 0.2 ) uvs[ 0 ].x += 1;\r\n\t\t\t\tif ( x1 < 0.2 ) uvs[ 1 ].x += 1;\r\n\t\t\t\tif ( x2 < 0.2 ) uvs[ 2 ].x += 1;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\r\n\t\t// Apply radius\r\n\t\r\n\t\tfor ( var i = 0, l = this.vertices.length; i < l; i ++ ) {\r\n\t\r\n\t\t\tthis.vertices[ i ].multiplyScalar( radius );\r\n\t\r\n\t\t}\r\n\t\r\n\t\r\n\t\t// Merge vertices\r\n\t\r\n\t\tthis.mergeVertices();\r\n\t\r\n\t\tthis.computeFaceNormals();\r\n\t\r\n\t\tthis.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );\r\n\t\r\n\t\r\n\t\t// Project vector onto sphere's surface\r\n\t\r\n\t\tfunction prepare( vector ) {\r\n\t\r\n\t\t\tvar vertex = vector.normalize().clone();\r\n\t\t\tvertex.index = that.vertices.push( vertex ) - 1;\r\n\t\r\n\t\t\t// Texture coords are equivalent to map coords, calculate angle and convert to fraction of a circle.\r\n\t\r\n\t\t\tvar u = azimuth( vector ) / 2 / Math.PI + 0.5;\r\n\t\t\tvar v = inclination( vector ) / Math.PI + 0.5;\r\n\t\t\tvertex.uv = new THREE.Vector2( u, 1 - v );\r\n\t\r\n\t\t\treturn vertex;\r\n\t\r\n\t\t}\r\n\t\r\n\t\r\n\t\t// Approximate a curved face with recursively sub-divided triangles.\r\n\t\r\n\t\tfunction make( v1, v2, v3 ) {\r\n\t\r\n\t\t\tvar face = new THREE.Face3( v1.index, v2.index, v3.index, [ v1.clone(), v2.clone(), v3.clone() ] );\r\n\t\t\tthat.faces.push( face );\r\n\t\r\n\t\t\tcentroid.copy( v1 ).add( v2 ).add( v3 ).divideScalar( 3 );\r\n\t\r\n\t\t\tvar azi = azimuth( centroid );\r\n\t\r\n\t\t\tthat.faceVertexUvs[ 0 ].push( [\r\n\t\t\t\tcorrectUV( v1.uv, v1, azi ),\r\n\t\t\t\tcorrectUV( v2.uv, v2, azi ),\r\n\t\t\t\tcorrectUV( v3.uv, v3, azi )\r\n\t\t\t] );\r\n\t\r\n\t\t}\r\n\t\r\n\t\r\n\t\t// Analytically subdivide a face to the required detail level.\r\n\t\r\n\t\tfunction subdivide( face, detail ) {\r\n\t\r\n\t\t\tvar cols = Math.pow(2, detail);\r\n\t\t\tvar a = prepare( that.vertices[ face.a ] );\r\n\t\t\tvar b = prepare( that.vertices[ face.b ] );\r\n\t\t\tvar c = prepare( that.vertices[ face.c ] );\r\n\t\t\tvar v = [];\r\n\t\r\n\t\t\t// Construct all of the vertices for this subdivision.\r\n\t\r\n\t\t\tfor ( var i = 0 ; i <= cols; i ++ ) {\r\n\t\r\n\t\t\t\tv[ i ] = [];\r\n\t\r\n\t\t\t\tvar aj = prepare( a.clone().lerp( c, i / cols ) );\r\n\t\t\t\tvar bj = prepare( b.clone().lerp( c, i / cols ) );\r\n\t\t\t\tvar rows = cols - i;\r\n\t\r\n\t\t\t\tfor ( var j = 0; j <= rows; j ++) {\r\n\t\r\n\t\t\t\t\tif ( j == 0 && i == cols ) {\r\n\t\r\n\t\t\t\t\t\tv[ i ][ j ] = aj;\r\n\t\r\n\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\tv[ i ][ j ] = prepare( aj.clone().lerp( bj, j / rows ) );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// Construct all of the faces.\r\n\t\r\n\t\t\tfor ( var i = 0; i < cols ; i ++ ) {\r\n\t\r\n\t\t\t\tfor ( var j = 0; j < 2 * (cols - i) - 1; j ++ ) {\r\n\t\r\n\t\t\t\t\tvar k = Math.floor( j / 2 );\r\n\t\r\n\t\t\t\t\tif ( j % 2 == 0 ) {\r\n\t\r\n\t\t\t\t\t\tmake(\r\n\t\t\t\t\t\t\tv[ i ][ k + 1],\r\n\t\t\t\t\t\t\tv[ i + 1 ][ k ],\r\n\t\t\t\t\t\t\tv[ i ][ k ]\r\n\t\t\t\t\t\t);\r\n\t\r\n\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\tmake(\r\n\t\t\t\t\t\t\tv[ i ][ k + 1 ],\r\n\t\t\t\t\t\t\tv[ i + 1][ k + 1],\r\n\t\t\t\t\t\t\tv[ i + 1 ][ k ]\r\n\t\t\t\t\t\t);\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\r\n\t\t// Angle around the Y axis, counter-clockwise when looking from above.\r\n\t\r\n\t\tfunction azimuth( vector ) {\r\n\t\r\n\t\t\treturn Math.atan2( vector.z, - vector.x );\r\n\t\r\n\t\t}\r\n\t\r\n\t\r\n\t\t// Angle above the XZ plane.\r\n\t\r\n\t\tfunction inclination( vector ) {\r\n\t\r\n\t\t\treturn Math.atan2( - vector.y, Math.sqrt( ( vector.x * vector.x ) + ( vector.z * vector.z ) ) );\r\n\t\r\n\t\t}\r\n\t\r\n\t\r\n\t\t// Texture fixing helper. Spheres have some odd behaviours.\r\n\t\r\n\t\tfunction correctUV( uv, vector, azimuth ) {\r\n\t\r\n\t\t\tif ( ( azimuth < 0 ) && ( uv.x === 1 ) ) uv = new THREE.Vector2( uv.x - 1, uv.y );\r\n\t\t\tif ( ( vector.x === 0 ) && ( vector.z === 0 ) ) uv = new THREE.Vector2( azimuth / 2 / Math.PI + 0.5, uv.y );\r\n\t\t\treturn uv.clone();\r\n\t\r\n\t\t}\r\n\t\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.PolyhedronGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\n\tTHREE.PolyhedronGeometry.prototype.constructor = THREE.PolyhedronGeometry;\r\n\t\r\n\t// File:src/extras/geometries/DodecahedronGeometry.js\r\n\t\r\n\t/**\r\n\t * @author Abe Pazos / https://hamoid.com\r\n\t */\r\n\t\r\n\tTHREE.DodecahedronGeometry = function ( radius, detail ) {\r\n\t\r\n\t\tthis.parameters = {\r\n\t\t\tradius: radius,\r\n\t\t\tdetail: detail\r\n\t\t};\r\n\t\r\n\t\tvar t = ( 1 + Math.sqrt( 5 ) ) / 2;\r\n\t\tvar r = 1 / t;\r\n\t\r\n\t\tvar vertices = [\r\n\t\r\n\t\t\t// (±1, ±1, ±1)\r\n\t\t\t-1, -1, -1,    -1, -1,  1,\r\n\t\t\t-1,  1, -1,    -1,  1,  1,\r\n\t\t\t 1, -1, -1,     1, -1,  1,\r\n\t\t\t 1,  1, -1,     1,  1,  1,\r\n\t\r\n\t\t\t// (0, ±1/φ, ±φ)\r\n\t\t\t 0, -r, -t,     0, -r,  t,\r\n\t\t\t 0,  r, -t,     0,  r,  t,\r\n\t\r\n\t\t\t// (±1/φ, ±φ, 0)\r\n\t\t\t-r, -t,  0,    -r,  t,  0,\r\n\t\t\t r, -t,  0,     r,  t,  0,\r\n\t\r\n\t\t\t// (±φ, 0, ±1/φ)\r\n\t\t\t-t,  0, -r,     t,  0, -r,\r\n\t\t\t-t,  0,  r,     t,  0,  r\r\n\t\t];\r\n\t\r\n\t\tvar indices = [\r\n\t\t\t 3, 11,  7,      3,  7, 15,      3, 15, 13,\r\n\t\t\t 7, 19, 17,      7, 17,  6,      7,  6, 15,\r\n\t\t\t17,  4,  8,     17,  8, 10,     17, 10,  6,\r\n\t\t\t 8,  0, 16,      8, 16,  2,      8,  2, 10,\r\n\t\t\t 0, 12,  1,      0,  1, 18,      0, 18, 16,\r\n\t\t\t 6, 10,  2,      6,  2, 13,      6, 13, 15,\r\n\t\t\t 2, 16, 18,      2, 18,  3,      2,  3, 13,\r\n\t\t\t18,  1,  9,     18,  9, 11,     18, 11,  3,\r\n\t\t\t 4, 14, 12,      4, 12,  0,      4,  0,  8,\r\n\t\t\t11,  9,  5,     11,  5, 19,     11, 19,  7,\r\n\t\t\t19,  5, 14,     19, 14,  4,     19,  4, 17,\r\n\t\t\t 1, 12, 14,      1, 14,  5,      1,  5,  9\r\n\t\t];\r\n\t\r\n\t\tTHREE.PolyhedronGeometry.call( this, vertices, indices, radius, detail );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.DodecahedronGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\n\tTHREE.DodecahedronGeometry.prototype.constructor = THREE.DodecahedronGeometry;\r\n\t\r\n\t// File:src/extras/geometries/IcosahedronGeometry.js\r\n\t\r\n\t/**\r\n\t * @author timothypratley / https://github.com/timothypratley\r\n\t */\r\n\t\r\n\tTHREE.IcosahedronGeometry = function ( radius, detail ) {\r\n\t\r\n\t\tvar t = ( 1 + Math.sqrt( 5 ) ) / 2;\r\n\t\r\n\t\tvar vertices = [\r\n\t\t\t- 1,  t,  0,    1,  t,  0,   - 1, - t,  0,    1, - t,  0,\r\n\t\t\t 0, - 1,  t,    0,  1,  t,    0, - 1, - t,    0,  1, - t,\r\n\t\t\t t,  0, - 1,    t,  0,  1,   - t,  0, - 1,   - t,  0,  1\r\n\t\t];\r\n\t\r\n\t\tvar indices = [\r\n\t\t\t 0, 11,  5,    0,  5,  1,    0,  1,  7,    0,  7, 10,    0, 10, 11,\r\n\t\t\t 1,  5,  9,    5, 11,  4,   11, 10,  2,   10,  7,  6,    7,  1,  8,\r\n\t\t\t 3,  9,  4,    3,  4,  2,    3,  2,  6,    3,  6,  8,    3,  8,  9,\r\n\t\t\t 4,  9,  5,    2,  4, 11,    6,  2, 10,    8,  6,  7,    9,  8,  1\r\n\t\t];\r\n\t\r\n\t\tTHREE.PolyhedronGeometry.call( this, vertices, indices, radius, detail );\r\n\t\r\n\t\tthis.type = 'IcosahedronGeometry';\r\n\t\r\n\t\tthis.parameters = {\r\n\t\t\tradius: radius,\r\n\t\t\tdetail: detail\r\n\t\t};\r\n\t};\r\n\t\r\n\tTHREE.IcosahedronGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\n\tTHREE.IcosahedronGeometry.prototype.constructor = THREE.IcosahedronGeometry;\r\n\t\r\n\t// File:src/extras/geometries/OctahedronGeometry.js\r\n\t\r\n\t/**\r\n\t * @author timothypratley / https://github.com/timothypratley\r\n\t */\r\n\t\r\n\tTHREE.OctahedronGeometry = function ( radius, detail ) {\r\n\t\r\n\t\tthis.parameters = {\r\n\t\t\tradius: radius,\r\n\t\t\tdetail: detail\r\n\t\t};\r\n\t\r\n\t\tvar vertices = [\r\n\t\t\t1, 0, 0,   - 1, 0, 0,    0, 1, 0,    0,- 1, 0,    0, 0, 1,    0, 0,- 1\r\n\t\t];\r\n\t\r\n\t\tvar indices = [\r\n\t\t\t0, 2, 4,    0, 4, 3,    0, 3, 5,    0, 5, 2,    1, 2, 5,    1, 5, 3,    1, 3, 4,    1, 4, 2\r\n\t\t];\r\n\t\r\n\t\tTHREE.PolyhedronGeometry.call( this, vertices, indices, radius, detail );\r\n\t\r\n\t\tthis.type = 'OctahedronGeometry';\r\n\t\r\n\t\tthis.parameters = {\r\n\t\t\tradius: radius,\r\n\t\t\tdetail: detail\r\n\t\t};\r\n\t};\r\n\t\r\n\tTHREE.OctahedronGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\n\tTHREE.OctahedronGeometry.prototype.constructor = THREE.OctahedronGeometry;\r\n\t\r\n\t// File:src/extras/geometries/TetrahedronGeometry.js\r\n\t\r\n\t/**\r\n\t * @author timothypratley / https://github.com/timothypratley\r\n\t */\r\n\t\r\n\tTHREE.TetrahedronGeometry = function ( radius, detail ) {\r\n\t\r\n\t\tvar vertices = [\r\n\t\t\t 1,  1,  1,   - 1, - 1,  1,   - 1,  1, - 1,    1, - 1, - 1\r\n\t\t];\r\n\t\r\n\t\tvar indices = [\r\n\t\t\t 2,  1,  0,    0,  3,  2,    1,  3,  0,    2,  3,  1\r\n\t\t];\r\n\t\r\n\t\tTHREE.PolyhedronGeometry.call( this, vertices, indices, radius, detail );\r\n\t\r\n\t\tthis.type = 'TetrahedronGeometry';\r\n\t\r\n\t\tthis.parameters = {\r\n\t\t\tradius: radius,\r\n\t\t\tdetail: detail\r\n\t\t};\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.TetrahedronGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\n\tTHREE.TetrahedronGeometry.prototype.constructor = THREE.TetrahedronGeometry;\r\n\t\r\n\t// File:src/extras/geometries/ParametricGeometry.js\r\n\t\r\n\t/**\r\n\t * @author zz85 / https://github.com/zz85\r\n\t * Parametric Surfaces Geometry\r\n\t * based on the brilliant article by @prideout http://prideout.net/blog/?p=44\r\n\t *\r\n\t * new THREE.ParametricGeometry( parametricFunction, uSegments, ySegements );\r\n\t *\r\n\t */\r\n\t\r\n\tTHREE.ParametricGeometry = function ( func, slices, stacks ) {\r\n\t\r\n\t\tTHREE.Geometry.call( this );\r\n\t\r\n\t\tthis.type = 'ParametricGeometry';\r\n\t\r\n\t\tthis.parameters = {\r\n\t\t\tfunc: func,\r\n\t\t\tslices: slices,\r\n\t\t\tstacks: stacks\r\n\t\t};\r\n\t\r\n\t\tvar verts = this.vertices;\r\n\t\tvar faces = this.faces;\r\n\t\tvar uvs = this.faceVertexUvs[ 0 ];\r\n\t\r\n\t\tvar i, j, p;\r\n\t\tvar u, v;\r\n\t\r\n\t\tvar sliceCount = slices + 1;\r\n\t\r\n\t\tfor ( i = 0; i <= stacks; i ++ ) {\r\n\t\r\n\t\t\tv = i / stacks;\r\n\t\r\n\t\t\tfor ( j = 0; j <= slices; j ++ ) {\r\n\t\r\n\t\t\t\tu = j / slices;\r\n\t\r\n\t\t\t\tp = func( u, v );\r\n\t\t\t\tverts.push( p );\r\n\t\r\n\t\t\t}\r\n\t\t}\r\n\t\r\n\t\tvar a, b, c, d;\r\n\t\tvar uva, uvb, uvc, uvd;\r\n\t\r\n\t\tfor ( i = 0; i < stacks; i ++ ) {\r\n\t\r\n\t\t\tfor ( j = 0; j < slices; j ++ ) {\r\n\t\r\n\t\t\t\ta = i * sliceCount + j;\r\n\t\t\t\tb = i * sliceCount + j + 1;\r\n\t\t\t\tc = (i + 1) * sliceCount + j + 1;\r\n\t\t\t\td = (i + 1) * sliceCount + j;\r\n\t\r\n\t\t\t\tuva = new THREE.Vector2( j / slices, i / stacks );\r\n\t\t\t\tuvb = new THREE.Vector2( ( j + 1 ) / slices, i / stacks );\r\n\t\t\t\tuvc = new THREE.Vector2( ( j + 1 ) / slices, ( i + 1 ) / stacks );\r\n\t\t\t\tuvd = new THREE.Vector2( j / slices, ( i + 1 ) / stacks );\r\n\t\r\n\t\t\t\tfaces.push( new THREE.Face3( a, b, d ) );\r\n\t\t\t\tuvs.push( [ uva, uvb, uvd ] );\r\n\t\r\n\t\t\t\tfaces.push( new THREE.Face3( b, c, d ) );\r\n\t\t\t\tuvs.push( [ uvb.clone(), uvc, uvd.clone() ] );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\t// console.log(this);\r\n\t\r\n\t\t// magic bullet\r\n\t\t// var diff = this.mergeVertices();\r\n\t\t// console.log('removed ', diff, ' vertices by merging');\r\n\t\r\n\t\tthis.computeFaceNormals();\r\n\t\tthis.computeVertexNormals();\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.ParametricGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\n\tTHREE.ParametricGeometry.prototype.constructor = THREE.ParametricGeometry;\r\n\t\r\n\t// File:src/extras/helpers/AxisHelper.js\r\n\t\r\n\t/**\r\n\t * @author sroucheray / http://sroucheray.org/\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tTHREE.AxisHelper = function ( size ) {\r\n\t\r\n\t\tsize = size || 1;\r\n\t\r\n\t\tvar vertices = new Float32Array( [\r\n\t\t\t0, 0, 0,  size, 0, 0,\r\n\t\t\t0, 0, 0,  0, size, 0,\r\n\t\t\t0, 0, 0,  0, 0, size\r\n\t\t] );\r\n\t\r\n\t\tvar colors = new Float32Array( [\r\n\t\t\t1, 0, 0,  1, 0.6, 0,\r\n\t\t\t0, 1, 0,  0.6, 1, 0,\r\n\t\t\t0, 0, 1,  0, 0.6, 1\r\n\t\t] );\r\n\t\r\n\t\tvar geometry = new THREE.BufferGeometry();\r\n\t\tgeometry.addAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );\r\n\t\tgeometry.addAttribute( 'color', new THREE.BufferAttribute( colors, 3 ) );\r\n\t\r\n\t\tvar material = new THREE.LineBasicMaterial( { vertexColors: THREE.VertexColors } );\r\n\t\r\n\t\tTHREE.Line.call( this, geometry, material, THREE.LinePieces );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.AxisHelper.prototype = Object.create( THREE.Line.prototype );\r\n\tTHREE.AxisHelper.prototype.constructor = THREE.AxisHelper;\r\n\t\r\n\t// File:src/extras/helpers/ArrowHelper.js\r\n\t\r\n\t/**\r\n\t * @author WestLangley / http://github.com/WestLangley\r\n\t * @author zz85 / http://github.com/zz85\r\n\t * @author bhouston / http://exocortex.com\r\n\t *\r\n\t * Creates an arrow for visualizing directions\r\n\t *\r\n\t * Parameters:\r\n\t *  dir - Vector3\r\n\t *  origin - Vector3\r\n\t *  length - Number\r\n\t *  color - color in hex value\r\n\t *  headLength - Number\r\n\t *  headWidth - Number\r\n\t */\r\n\t\r\n\tTHREE.ArrowHelper = ( function () {\r\n\t\r\n\t\tvar lineGeometry = new THREE.Geometry();\r\n\t\tlineGeometry.vertices.push( new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( 0, 1, 0 ) );\r\n\t\r\n\t\tvar coneGeometry = new THREE.CylinderGeometry( 0, 0.5, 1, 5, 1 );\r\n\t\tconeGeometry.applyMatrix( new THREE.Matrix4().makeTranslation( 0, - 0.5, 0 ) );\r\n\t\r\n\t\treturn function ( dir, origin, length, color, headLength, headWidth ) {\r\n\t\r\n\t\t\t// dir is assumed to be normalized\r\n\t\r\n\t\t\tTHREE.Object3D.call( this );\r\n\t\r\n\t\t\tif ( color === undefined ) color = 0xffff00;\r\n\t\t\tif ( length === undefined ) length = 1;\r\n\t\t\tif ( headLength === undefined ) headLength = 0.2 * length;\r\n\t\t\tif ( headWidth === undefined ) headWidth = 0.2 * headLength;\r\n\t\r\n\t\t\tthis.position.copy( origin );\r\n\t\r\n\t\t\tthis.line = new THREE.Line( lineGeometry, new THREE.LineBasicMaterial( { color: color } ) );\r\n\t\t\tthis.line.matrixAutoUpdate = false;\r\n\t\t\tthis.add( this.line );\r\n\t\r\n\t\t\tthis.cone = new THREE.Mesh( coneGeometry, new THREE.MeshBasicMaterial( { color: color } ) );\r\n\t\t\tthis.cone.matrixAutoUpdate = false;\r\n\t\t\tthis.add( this.cone );\r\n\t\r\n\t\t\tthis.setDirection( dir );\r\n\t\t\tthis.setLength( length, headLength, headWidth );\r\n\t\r\n\t\t}\r\n\t\r\n\t}() );\r\n\t\r\n\tTHREE.ArrowHelper.prototype = Object.create( THREE.Object3D.prototype );\r\n\tTHREE.ArrowHelper.prototype.constructor = THREE.ArrowHelper;\r\n\t\r\n\tTHREE.ArrowHelper.prototype.setDirection = ( function () {\r\n\t\r\n\t\tvar axis = new THREE.Vector3();\r\n\t\tvar radians;\r\n\t\r\n\t\treturn function ( dir ) {\r\n\t\r\n\t\t\t// dir is assumed to be normalized\r\n\t\r\n\t\t\tif ( dir.y > 0.99999 ) {\r\n\t\r\n\t\t\t\tthis.quaternion.set( 0, 0, 0, 1 );\r\n\t\r\n\t\t\t} else if ( dir.y < - 0.99999 ) {\r\n\t\r\n\t\t\t\tthis.quaternion.set( 1, 0, 0, 0 );\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\taxis.set( dir.z, 0, - dir.x ).normalize();\r\n\t\r\n\t\t\t\tradians = Math.acos( dir.y );\r\n\t\r\n\t\t\t\tthis.quaternion.setFromAxisAngle( axis, radians );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t}() );\r\n\t\r\n\tTHREE.ArrowHelper.prototype.setLength = function ( length, headLength, headWidth ) {\r\n\t\r\n\t\tif ( headLength === undefined ) headLength = 0.2 * length;\r\n\t\tif ( headWidth === undefined ) headWidth = 0.2 * headLength;\r\n\t\r\n\t\tthis.line.scale.set( 1, length - headLength, 1 );\r\n\t\tthis.line.updateMatrix();\r\n\t\r\n\t\tthis.cone.scale.set( headWidth, headLength, headWidth );\r\n\t\tthis.cone.position.y = length;\r\n\t\tthis.cone.updateMatrix();\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.ArrowHelper.prototype.setColor = function ( color ) {\r\n\t\r\n\t\tthis.line.material.color.set( color );\r\n\t\tthis.cone.material.color.set( color );\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/extras/helpers/BoxHelper.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tTHREE.BoxHelper = function ( object ) {\r\n\t\r\n\t\tvar geometry = new THREE.BufferGeometry();\r\n\t\tgeometry.addAttribute( 'position', new THREE.BufferAttribute( new Float32Array( 72 ), 3 ) );\r\n\t\r\n\t\tTHREE.Line.call( this, geometry, new THREE.LineBasicMaterial( { color: 0xffff00 } ), THREE.LinePieces );\r\n\t\r\n\t\tif ( object !== undefined ) {\r\n\t\r\n\t\t\tthis.update( object );\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.BoxHelper.prototype = Object.create( THREE.Line.prototype );\r\n\tTHREE.BoxHelper.prototype.constructor = THREE.BoxHelper;\r\n\t\r\n\tTHREE.BoxHelper.prototype.update = function ( object ) {\r\n\t\r\n\t\tvar geometry = object.geometry;\r\n\t\r\n\t\tif ( geometry.boundingBox === null ) {\r\n\t\r\n\t\t\tgeometry.computeBoundingBox();\r\n\t\r\n\t\t}\r\n\t\r\n\t\tvar min = geometry.boundingBox.min;\r\n\t\tvar max = geometry.boundingBox.max;\r\n\t\r\n\t\t/*\r\n\t\t  5____4\r\n\t\t1/___0/|\r\n\t\t| 6__|_7\r\n\t\t2/___3/\r\n\t\r\n\t\t0: max.x, max.y, max.z\r\n\t\t1: min.x, max.y, max.z\r\n\t\t2: min.x, min.y, max.z\r\n\t\t3: max.x, min.y, max.z\r\n\t\t4: max.x, max.y, min.z\r\n\t\t5: min.x, max.y, min.z\r\n\t\t6: min.x, min.y, min.z\r\n\t\t7: max.x, min.y, min.z\r\n\t\t*/\r\n\t\r\n\t\tvar vertices = this.geometry.attributes.position.array;\r\n\t\r\n\t\tvertices[  0 ] = max.x; vertices[  1 ] = max.y; vertices[  2 ] = max.z;\r\n\t\tvertices[  3 ] = min.x; vertices[  4 ] = max.y; vertices[  5 ] = max.z;\r\n\t\r\n\t\tvertices[  6 ] = min.x; vertices[  7 ] = max.y; vertices[  8 ] = max.z;\r\n\t\tvertices[  9 ] = min.x; vertices[ 10 ] = min.y; vertices[ 11 ] = max.z;\r\n\t\r\n\t\tvertices[ 12 ] = min.x; vertices[ 13 ] = min.y; vertices[ 14 ] = max.z;\r\n\t\tvertices[ 15 ] = max.x; vertices[ 16 ] = min.y; vertices[ 17 ] = max.z;\r\n\t\r\n\t\tvertices[ 18 ] = max.x; vertices[ 19 ] = min.y; vertices[ 20 ] = max.z;\r\n\t\tvertices[ 21 ] = max.x; vertices[ 22 ] = max.y; vertices[ 23 ] = max.z;\r\n\t\r\n\t\t//\r\n\t\r\n\t\tvertices[ 24 ] = max.x; vertices[ 25 ] = max.y; vertices[ 26 ] = min.z;\r\n\t\tvertices[ 27 ] = min.x; vertices[ 28 ] = max.y; vertices[ 29 ] = min.z;\r\n\t\r\n\t\tvertices[ 30 ] = min.x; vertices[ 31 ] = max.y; vertices[ 32 ] = min.z;\r\n\t\tvertices[ 33 ] = min.x; vertices[ 34 ] = min.y; vertices[ 35 ] = min.z;\r\n\t\r\n\t\tvertices[ 36 ] = min.x; vertices[ 37 ] = min.y; vertices[ 38 ] = min.z;\r\n\t\tvertices[ 39 ] = max.x; vertices[ 40 ] = min.y; vertices[ 41 ] = min.z;\r\n\t\r\n\t\tvertices[ 42 ] = max.x; vertices[ 43 ] = min.y; vertices[ 44 ] = min.z;\r\n\t\tvertices[ 45 ] = max.x; vertices[ 46 ] = max.y; vertices[ 47 ] = min.z;\r\n\t\r\n\t\t//\r\n\t\r\n\t\tvertices[ 48 ] = max.x; vertices[ 49 ] = max.y; vertices[ 50 ] = max.z;\r\n\t\tvertices[ 51 ] = max.x; vertices[ 52 ] = max.y; vertices[ 53 ] = min.z;\r\n\t\r\n\t\tvertices[ 54 ] = min.x; vertices[ 55 ] = max.y; vertices[ 56 ] = max.z;\r\n\t\tvertices[ 57 ] = min.x; vertices[ 58 ] = max.y; vertices[ 59 ] = min.z;\r\n\t\r\n\t\tvertices[ 60 ] = min.x; vertices[ 61 ] = min.y; vertices[ 62 ] = max.z;\r\n\t\tvertices[ 63 ] = min.x; vertices[ 64 ] = min.y; vertices[ 65 ] = min.z;\r\n\t\r\n\t\tvertices[ 66 ] = max.x; vertices[ 67 ] = min.y; vertices[ 68 ] = max.z;\r\n\t\tvertices[ 69 ] = max.x; vertices[ 70 ] = min.y; vertices[ 71 ] = min.z;\r\n\t\r\n\t\tthis.geometry.attributes.position.needsUpdate = true;\r\n\t\r\n\t\tthis.geometry.computeBoundingSphere();\r\n\t\r\n\t\tthis.matrix = object.matrixWorld;\r\n\t\tthis.matrixAutoUpdate = false;\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/extras/helpers/BoundingBoxHelper.js\r\n\t\r\n\t/**\r\n\t * @author WestLangley / http://github.com/WestLangley\r\n\t */\r\n\t\r\n\t// a helper to show the world-axis-aligned bounding box for an object\r\n\t\r\n\tTHREE.BoundingBoxHelper = function ( object, hex ) {\r\n\t\r\n\t\tvar color = ( hex !== undefined ) ? hex : 0x888888;\r\n\t\r\n\t\tthis.object = object;\r\n\t\r\n\t\tthis.box = new THREE.Box3();\r\n\t\r\n\t\tTHREE.Mesh.call( this, new THREE.BoxGeometry( 1, 1, 1 ), new THREE.MeshBasicMaterial( { color: color, wireframe: true } ) );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.BoundingBoxHelper.prototype = Object.create( THREE.Mesh.prototype );\r\n\tTHREE.BoundingBoxHelper.prototype.constructor = THREE.BoundingBoxHelper;\r\n\t\r\n\tTHREE.BoundingBoxHelper.prototype.update = function () {\r\n\t\r\n\t\tthis.box.setFromObject( this.object );\r\n\t\r\n\t\tthis.box.size( this.scale );\r\n\t\r\n\t\tthis.box.center( this.position );\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/extras/helpers/CameraHelper.js\r\n\t\r\n\t/**\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t *\r\n\t *\t- shows frustum, line of sight and up of the camera\r\n\t *\t- suitable for fast updates\r\n\t * \t- based on frustum visualization in lightgl.js shadowmap example\r\n\t *\t\thttp://evanw.github.com/lightgl.js/tests/shadowmap.html\r\n\t */\r\n\t\r\n\tTHREE.CameraHelper = function ( camera ) {\r\n\t\r\n\t\tvar geometry = new THREE.Geometry();\r\n\t\tvar material = new THREE.LineBasicMaterial( { color: 0xffffff, vertexColors: THREE.FaceColors } );\r\n\t\r\n\t\tvar pointMap = {};\r\n\t\r\n\t\t// colors\r\n\t\r\n\t\tvar hexFrustum = 0xffaa00;\r\n\t\tvar hexCone = 0xff0000;\r\n\t\tvar hexUp = 0x00aaff;\r\n\t\tvar hexTarget = 0xffffff;\r\n\t\tvar hexCross = 0x333333;\r\n\t\r\n\t\t// near\r\n\t\r\n\t\taddLine( \"n1\", \"n2\", hexFrustum );\r\n\t\taddLine( \"n2\", \"n4\", hexFrustum );\r\n\t\taddLine( \"n4\", \"n3\", hexFrustum );\r\n\t\taddLine( \"n3\", \"n1\", hexFrustum );\r\n\t\r\n\t\t// far\r\n\t\r\n\t\taddLine( \"f1\", \"f2\", hexFrustum );\r\n\t\taddLine( \"f2\", \"f4\", hexFrustum );\r\n\t\taddLine( \"f4\", \"f3\", hexFrustum );\r\n\t\taddLine( \"f3\", \"f1\", hexFrustum );\r\n\t\r\n\t\t// sides\r\n\t\r\n\t\taddLine( \"n1\", \"f1\", hexFrustum );\r\n\t\taddLine( \"n2\", \"f2\", hexFrustum );\r\n\t\taddLine( \"n3\", \"f3\", hexFrustum );\r\n\t\taddLine( \"n4\", \"f4\", hexFrustum );\r\n\t\r\n\t\t// cone\r\n\t\r\n\t\taddLine( \"p\", \"n1\", hexCone );\r\n\t\taddLine( \"p\", \"n2\", hexCone );\r\n\t\taddLine( \"p\", \"n3\", hexCone );\r\n\t\taddLine( \"p\", \"n4\", hexCone );\r\n\t\r\n\t\t// up\r\n\t\r\n\t\taddLine( \"u1\", \"u2\", hexUp );\r\n\t\taddLine( \"u2\", \"u3\", hexUp );\r\n\t\taddLine( \"u3\", \"u1\", hexUp );\r\n\t\r\n\t\t// target\r\n\t\r\n\t\taddLine( \"c\", \"t\", hexTarget );\r\n\t\taddLine( \"p\", \"c\", hexCross );\r\n\t\r\n\t\t// cross\r\n\t\r\n\t\taddLine( \"cn1\", \"cn2\", hexCross );\r\n\t\taddLine( \"cn3\", \"cn4\", hexCross );\r\n\t\r\n\t\taddLine( \"cf1\", \"cf2\", hexCross );\r\n\t\taddLine( \"cf3\", \"cf4\", hexCross );\r\n\t\r\n\t\tfunction addLine( a, b, hex ) {\r\n\t\r\n\t\t\taddPoint( a, hex );\r\n\t\t\taddPoint( b, hex );\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction addPoint( id, hex ) {\r\n\t\r\n\t\t\tgeometry.vertices.push( new THREE.Vector3() );\r\n\t\t\tgeometry.colors.push( new THREE.Color( hex ) );\r\n\t\r\n\t\t\tif ( pointMap[ id ] === undefined ) {\r\n\t\r\n\t\t\t\tpointMap[ id ] = [];\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tpointMap[ id ].push( geometry.vertices.length - 1 );\r\n\t\r\n\t\t}\r\n\t\r\n\t\tTHREE.Line.call( this, geometry, material, THREE.LinePieces );\r\n\t\r\n\t\tthis.camera = camera;\r\n\t\tthis.matrix = camera.matrixWorld;\r\n\t\tthis.matrixAutoUpdate = false;\r\n\t\r\n\t\tthis.pointMap = pointMap;\r\n\t\r\n\t\tthis.update();\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.CameraHelper.prototype = Object.create( THREE.Line.prototype );\r\n\tTHREE.CameraHelper.prototype.constructor = THREE.CameraHelper;\r\n\t\r\n\tTHREE.CameraHelper.prototype.update = function () {\r\n\t\r\n\t\tvar geometry, pointMap;\r\n\t\t\r\n\t\tvar vector = new THREE.Vector3();\r\n\t\tvar camera = new THREE.Camera();\r\n\t\r\n\t\tvar setPoint = function ( point, x, y, z ) {\r\n\t\r\n\t\t\tvector.set( x, y, z ).unproject( camera );\r\n\t\r\n\t\t\tvar points = pointMap[ point ];\r\n\t\r\n\t\t\tif ( points !== undefined ) {\r\n\t\r\n\t\t\t\tfor ( var i = 0, il = points.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\t\tgeometry.vertices[ points[ i ] ].copy( vector );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t\treturn function () {\r\n\t\r\n\t\t\tgeometry = this.geometry;\r\n\t\t\tpointMap = this.pointMap;\r\n\t\r\n\t\t\tvar w = 1, h = 1;\r\n\t\r\n\t\t\t// we need just camera projection matrix\r\n\t\t\t// world matrix must be identity\r\n\t\r\n\t\t\tcamera.projectionMatrix.copy( this.camera.projectionMatrix );\r\n\t\r\n\t\t\t// center / target\r\n\t\r\n\t\t\tsetPoint( \"c\", 0, 0, - 1 );\r\n\t\t\tsetPoint( \"t\", 0, 0,  1 );\r\n\t\r\n\t\t\t// near\r\n\t\r\n\t\t\tsetPoint( \"n1\", - w, - h, - 1 );\r\n\t\t\tsetPoint( \"n2\",   w, - h, - 1 );\r\n\t\t\tsetPoint( \"n3\", - w,   h, - 1 );\r\n\t\t\tsetPoint( \"n4\",   w,   h, - 1 );\r\n\t\r\n\t\t\t// far\r\n\t\r\n\t\t\tsetPoint( \"f1\", - w, - h, 1 );\r\n\t\t\tsetPoint( \"f2\",   w, - h, 1 );\r\n\t\t\tsetPoint( \"f3\", - w,   h, 1 );\r\n\t\t\tsetPoint( \"f4\",   w,   h, 1 );\r\n\t\r\n\t\t\t// up\r\n\t\r\n\t\t\tsetPoint( \"u1\",   w * 0.7, h * 1.1, - 1 );\r\n\t\t\tsetPoint( \"u2\", - w * 0.7, h * 1.1, - 1 );\r\n\t\t\tsetPoint( \"u3\",         0, h * 2,   - 1 );\r\n\t\r\n\t\t\t// cross\r\n\t\r\n\t\t\tsetPoint( \"cf1\", - w,   0, 1 );\r\n\t\t\tsetPoint( \"cf2\",   w,   0, 1 );\r\n\t\t\tsetPoint( \"cf3\",   0, - h, 1 );\r\n\t\t\tsetPoint( \"cf4\",   0,   h, 1 );\r\n\t\r\n\t\t\tsetPoint( \"cn1\", - w,   0, - 1 );\r\n\t\t\tsetPoint( \"cn2\",   w,   0, - 1 );\r\n\t\t\tsetPoint( \"cn3\",   0, - h, - 1 );\r\n\t\t\tsetPoint( \"cn4\",   0,   h, - 1 );\r\n\t\r\n\t\t\tgeometry.verticesNeedUpdate = true;\r\n\t\r\n\t\t};\r\n\t\r\n\t}();\r\n\t\r\n\t// File:src/extras/helpers/DirectionalLightHelper.js\r\n\t\r\n\t/**\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t * @author WestLangley / http://github.com/WestLangley\r\n\t */\r\n\t\r\n\tTHREE.DirectionalLightHelper = function ( light, size ) {\r\n\t\r\n\t\tTHREE.Object3D.call( this );\r\n\t\r\n\t\tthis.light = light;\r\n\t\tthis.light.updateMatrixWorld();\r\n\t\r\n\t\tthis.matrix = light.matrixWorld;\r\n\t\tthis.matrixAutoUpdate = false;\r\n\t\r\n\t\tsize = size || 1;\r\n\t\r\n\t\tvar geometry = new THREE.Geometry();\r\n\t\tgeometry.vertices.push(\r\n\t\t\tnew THREE.Vector3( - size,   size, 0 ),\r\n\t\t\tnew THREE.Vector3(   size,   size, 0 ),\r\n\t\t\tnew THREE.Vector3(   size, - size, 0 ),\r\n\t\t\tnew THREE.Vector3( - size, - size, 0 ),\r\n\t\t\tnew THREE.Vector3( - size,   size, 0 )\r\n\t\t);\r\n\t\r\n\t\tvar material = new THREE.LineBasicMaterial( { fog: false } );\r\n\t\tmaterial.color.copy( this.light.color ).multiplyScalar( this.light.intensity );\r\n\t\r\n\t\tthis.lightPlane = new THREE.Line( geometry, material );\r\n\t\tthis.add( this.lightPlane );\r\n\t\r\n\t\tgeometry = new THREE.Geometry();\r\n\t\tgeometry.vertices.push(\r\n\t\t\tnew THREE.Vector3(),\r\n\t\t\tnew THREE.Vector3()\r\n\t\t);\r\n\t\r\n\t\tmaterial = new THREE.LineBasicMaterial( { fog: false } );\r\n\t\tmaterial.color.copy( this.light.color ).multiplyScalar( this.light.intensity );\r\n\t\r\n\t\tthis.targetLine = new THREE.Line( geometry, material );\r\n\t\tthis.add( this.targetLine );\r\n\t\r\n\t\tthis.update();\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.DirectionalLightHelper.prototype = Object.create( THREE.Object3D.prototype );\r\n\tTHREE.DirectionalLightHelper.prototype.constructor = THREE.DirectionalLightHelper;\r\n\t\r\n\tTHREE.DirectionalLightHelper.prototype.dispose = function () {\r\n\t\r\n\t\tthis.lightPlane.geometry.dispose();\r\n\t\tthis.lightPlane.material.dispose();\r\n\t\tthis.targetLine.geometry.dispose();\r\n\t\tthis.targetLine.material.dispose();\r\n\t};\r\n\t\r\n\tTHREE.DirectionalLightHelper.prototype.update = function () {\r\n\t\r\n\t\tvar v1 = new THREE.Vector3();\r\n\t\tvar v2 = new THREE.Vector3();\r\n\t\tvar v3 = new THREE.Vector3();\r\n\t\r\n\t\treturn function () {\r\n\t\r\n\t\t\tv1.setFromMatrixPosition( this.light.matrixWorld );\r\n\t\t\tv2.setFromMatrixPosition( this.light.target.matrixWorld );\r\n\t\t\tv3.subVectors( v2, v1 );\r\n\t\r\n\t\t\tthis.lightPlane.lookAt( v3 );\r\n\t\t\tthis.lightPlane.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );\r\n\t\r\n\t\t\tthis.targetLine.geometry.vertices[ 1 ].copy( v3 );\r\n\t\t\tthis.targetLine.geometry.verticesNeedUpdate = true;\r\n\t\t\tthis.targetLine.material.color.copy( this.lightPlane.material.color );\r\n\t\r\n\t\t};\r\n\t\r\n\t}();\r\n\t\r\n\t// File:src/extras/helpers/EdgesHelper.js\r\n\t\r\n\t/**\r\n\t * @author WestLangley / http://github.com/WestLangley\r\n\t * @param object THREE.Mesh whose geometry will be used\r\n\t * @param hex line color\r\n\t * @param thresholdAngle the minimim angle (in degrees),\r\n\t * between the face normals of adjacent faces,\r\n\t * that is required to render an edge. A value of 10 means\r\n\t * an edge is only rendered if the angle is at least 10 degrees.\r\n\t */\r\n\t\r\n\tTHREE.EdgesHelper = function ( object, hex, thresholdAngle ) {\r\n\t\r\n\t\tvar color = ( hex !== undefined ) ? hex : 0xffffff;\r\n\t\tthresholdAngle = ( thresholdAngle !== undefined ) ? thresholdAngle : 1;\r\n\t\r\n\t\tvar thresholdDot = Math.cos( THREE.Math.degToRad( thresholdAngle ) );\r\n\t\r\n\t\tvar edge = [ 0, 0 ], hash = {};\r\n\t\tvar sortFunction = function ( a, b ) { return a - b };\r\n\t\r\n\t\tvar keys = [ 'a', 'b', 'c' ];\r\n\t\tvar geometry = new THREE.BufferGeometry();\r\n\t\r\n\t\tvar geometry2;\r\n\t\r\n\t\tif ( object.geometry instanceof THREE.BufferGeometry ) {\r\n\t\r\n\t\t\tgeometry2 = new THREE.Geometry();\r\n\t\t\tgeometry2.fromBufferGeometry( object.geometry );\r\n\t\r\n\t\t} else {\r\n\t\r\n\t\t\tgeometry2 = object.geometry.clone();\r\n\t\r\n\t\t}\r\n\t\r\n\t\tgeometry2.mergeVertices();\r\n\t\tgeometry2.computeFaceNormals();\r\n\t\r\n\t\tvar vertices = geometry2.vertices;\r\n\t\tvar faces = geometry2.faces;\r\n\t\tvar numEdges = 0;\r\n\t\r\n\t\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\r\n\t\r\n\t\t\tvar face = faces[ i ];\r\n\t\r\n\t\t\tfor ( var j = 0; j < 3; j ++ ) {\r\n\t\r\n\t\t\t\tedge[ 0 ] = face[ keys[ j ] ];\r\n\t\t\t\tedge[ 1 ] = face[ keys[ ( j + 1 ) % 3 ] ];\r\n\t\t\t\tedge.sort( sortFunction );\r\n\t\r\n\t\t\t\tvar key = edge.toString();\r\n\t\r\n\t\t\t\tif ( hash[ key ] === undefined ) {\r\n\t\r\n\t\t\t\t\thash[ key ] = { vert1: edge[ 0 ], vert2: edge[ 1 ], face1: i, face2: undefined };\r\n\t\t\t\t\tnumEdges ++;\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\thash[ key ].face2 = i;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\tvar coords = new Float32Array( numEdges * 2 * 3 );\r\n\t\r\n\t\tvar index = 0;\r\n\t\r\n\t\tfor ( var key in hash ) {\r\n\t\r\n\t\t\tvar h = hash[ key ];\r\n\t\r\n\t\t\tif ( h.face2 === undefined || faces[ h.face1 ].normal.dot( faces[ h.face2 ].normal ) <= thresholdDot ) {\r\n\t\r\n\t\t\t\tvar vertex = vertices[ h.vert1 ];\r\n\t\t\t\tcoords[ index ++ ] = vertex.x;\r\n\t\t\t\tcoords[ index ++ ] = vertex.y;\r\n\t\t\t\tcoords[ index ++ ] = vertex.z;\r\n\t\r\n\t\t\t\tvertex = vertices[ h.vert2 ];\r\n\t\t\t\tcoords[ index ++ ] = vertex.x;\r\n\t\t\t\tcoords[ index ++ ] = vertex.y;\r\n\t\t\t\tcoords[ index ++ ] = vertex.z;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\tgeometry.addAttribute( 'position', new THREE.BufferAttribute( coords, 3 ) );\r\n\t\r\n\t\tTHREE.Line.call( this, geometry, new THREE.LineBasicMaterial( { color: color } ), THREE.LinePieces );\r\n\t\r\n\t\tthis.matrix = object.matrixWorld;\r\n\t\tthis.matrixAutoUpdate = false;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.EdgesHelper.prototype = Object.create( THREE.Line.prototype );\r\n\tTHREE.EdgesHelper.prototype.constructor = THREE.EdgesHelper;\r\n\t\r\n\t// File:src/extras/helpers/FaceNormalsHelper.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t * @author WestLangley / http://github.com/WestLangley\r\n\t*/\r\n\t\r\n\tTHREE.FaceNormalsHelper = function ( object, size, hex, linewidth ) {\r\n\t\r\n\t\tthis.object = object;\r\n\t\r\n\t\tthis.size = ( size !== undefined ) ? size : 1;\r\n\t\r\n\t\tvar color = ( hex !== undefined ) ? hex : 0xffff00;\r\n\t\r\n\t\tvar width = ( linewidth !== undefined ) ? linewidth : 1;\r\n\t\r\n\t\tvar geometry = new THREE.Geometry();\r\n\t\r\n\t\tvar faces = this.object.geometry.faces;\r\n\t\r\n\t\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\r\n\t\r\n\t\t\tgeometry.vertices.push( new THREE.Vector3(), new THREE.Vector3() );\r\n\t\r\n\t\t}\r\n\t\r\n\t\tTHREE.Line.call( this, geometry, new THREE.LineBasicMaterial( { color: color, linewidth: width } ), THREE.LinePieces );\r\n\t\r\n\t\tthis.matrixAutoUpdate = false;\r\n\t\r\n\t\tthis.normalMatrix = new THREE.Matrix3();\r\n\t\r\n\t\tthis.update();\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.FaceNormalsHelper.prototype = Object.create( THREE.Line.prototype );\r\n\tTHREE.FaceNormalsHelper.prototype.constructor = THREE.FaceNormalsHelper;\r\n\t\r\n\tTHREE.FaceNormalsHelper.prototype.update = function () {\r\n\t\r\n\t\tvar vertices = this.geometry.vertices;\r\n\t\r\n\t\tvar object = this.object;\r\n\t\tvar objectVertices = object.geometry.vertices;\r\n\t\tvar objectFaces = object.geometry.faces;\r\n\t\tvar objectWorldMatrix = object.matrixWorld;\r\n\t\r\n\t\tobject.updateMatrixWorld( true );\r\n\t\r\n\t\tthis.normalMatrix.getNormalMatrix( objectWorldMatrix );\r\n\t\r\n\t\tfor ( var i = 0, i2 = 0, l = objectFaces.length; i < l; i ++, i2 += 2 ) {\r\n\t\r\n\t\t\tvar face = objectFaces[ i ];\r\n\t\r\n\t\t\tvertices[ i2 ].copy( objectVertices[ face.a ] )\r\n\t\t\t\t.add( objectVertices[ face.b ] )\r\n\t\t\t\t.add( objectVertices[ face.c ] )\r\n\t\t\t\t.divideScalar( 3 )\r\n\t\t\t\t.applyMatrix4( objectWorldMatrix );\r\n\t\r\n\t\t\tvertices[ i2 + 1 ].copy( face.normal )\r\n\t\t\t\t.applyMatrix3( this.normalMatrix )\r\n\t\t\t\t.normalize()\r\n\t\t\t\t.multiplyScalar( this.size )\r\n\t\t\t\t.add( vertices[ i2 ] );\r\n\t\r\n\t\t}\r\n\t\r\n\t\tthis.geometry.verticesNeedUpdate = true;\r\n\t\r\n\t\treturn this;\r\n\t\r\n\t};\r\n\t\r\n\t\r\n\t// File:src/extras/helpers/GridHelper.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tTHREE.GridHelper = function ( size, step ) {\r\n\t\r\n\t\tvar geometry = new THREE.Geometry();\r\n\t\tvar material = new THREE.LineBasicMaterial( { vertexColors: THREE.VertexColors } );\r\n\t\r\n\t\tthis.color1 = new THREE.Color( 0x444444 );\r\n\t\tthis.color2 = new THREE.Color( 0x888888 );\r\n\t\r\n\t\tfor ( var i = - size; i <= size; i += step ) {\r\n\t\r\n\t\t\tgeometry.vertices.push(\r\n\t\t\t\tnew THREE.Vector3( - size, 0, i ), new THREE.Vector3( size, 0, i ),\r\n\t\t\t\tnew THREE.Vector3( i, 0, - size ), new THREE.Vector3( i, 0, size )\r\n\t\t\t);\r\n\t\r\n\t\t\tvar color = i === 0 ? this.color1 : this.color2;\r\n\t\r\n\t\t\tgeometry.colors.push( color, color, color, color );\r\n\t\r\n\t\t}\r\n\t\r\n\t\tTHREE.Line.call( this, geometry, material, THREE.LinePieces );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.GridHelper.prototype = Object.create( THREE.Line.prototype );\r\n\tTHREE.GridHelper.prototype.constructor = THREE.GridHelper;\r\n\t\r\n\tTHREE.GridHelper.prototype.setColors = function( colorCenterLine, colorGrid ) {\r\n\t\r\n\t\tthis.color1.set( colorCenterLine );\r\n\t\tthis.color2.set( colorGrid );\r\n\t\r\n\t\tthis.geometry.colorsNeedUpdate = true;\r\n\t\r\n\t}\r\n\t\r\n\t// File:src/extras/helpers/HemisphereLightHelper.js\r\n\t\r\n\t/**\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tTHREE.HemisphereLightHelper = function ( light, sphereSize ) {\r\n\t\r\n\t\tTHREE.Object3D.call( this );\r\n\t\r\n\t\tthis.light = light;\r\n\t\tthis.light.updateMatrixWorld();\r\n\t\r\n\t\tthis.matrix = light.matrixWorld;\r\n\t\tthis.matrixAutoUpdate = false;\r\n\t\r\n\t\tthis.colors = [ new THREE.Color(), new THREE.Color() ];\r\n\t\r\n\t\tvar geometry = new THREE.SphereGeometry( sphereSize, 4, 2 );\r\n\t\tgeometry.applyMatrix( new THREE.Matrix4().makeRotationX( - Math.PI / 2 ) );\r\n\t\r\n\t\tfor ( var i = 0, il = 8; i < il; i ++ ) {\r\n\t\r\n\t\t\tgeometry.faces[ i ].color = this.colors[ i < 4 ? 0 : 1 ];\r\n\t\r\n\t\t}\r\n\t\r\n\t\tvar material = new THREE.MeshBasicMaterial( { vertexColors: THREE.FaceColors, wireframe: true } );\r\n\t\r\n\t\tthis.lightSphere = new THREE.Mesh( geometry, material );\r\n\t\tthis.add( this.lightSphere );\r\n\t\r\n\t\tthis.update();\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.HemisphereLightHelper.prototype = Object.create( THREE.Object3D.prototype );\r\n\tTHREE.HemisphereLightHelper.prototype.constructor = THREE.HemisphereLightHelper;\r\n\t\r\n\tTHREE.HemisphereLightHelper.prototype.dispose = function () {\r\n\t\tthis.lightSphere.geometry.dispose();\r\n\t\tthis.lightSphere.material.dispose();\r\n\t};\r\n\t\r\n\tTHREE.HemisphereLightHelper.prototype.update = function () {\r\n\t\r\n\t\tvar vector = new THREE.Vector3();\r\n\t\r\n\t\treturn function () {\r\n\t\r\n\t\t\tthis.colors[ 0 ].copy( this.light.color ).multiplyScalar( this.light.intensity );\r\n\t\t\tthis.colors[ 1 ].copy( this.light.groundColor ).multiplyScalar( this.light.intensity );\r\n\t\r\n\t\t\tthis.lightSphere.lookAt( vector.setFromMatrixPosition( this.light.matrixWorld ).negate() );\r\n\t\t\tthis.lightSphere.geometry.colorsNeedUpdate = true;\r\n\t\r\n\t\t}\r\n\t\r\n\t}();\r\n\t\r\n\t// File:src/extras/helpers/PointLightHelper.js\r\n\t\r\n\t/**\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tTHREE.PointLightHelper = function ( light, sphereSize ) {\r\n\t\r\n\t\tthis.light = light;\r\n\t\tthis.light.updateMatrixWorld();\r\n\t\r\n\t\tvar geometry = new THREE.SphereGeometry( sphereSize, 4, 2 );\r\n\t\tvar material = new THREE.MeshBasicMaterial( { wireframe: true, fog: false } );\r\n\t\tmaterial.color.copy( this.light.color ).multiplyScalar( this.light.intensity );\r\n\t\r\n\t\tTHREE.Mesh.call( this, geometry, material );\r\n\t\r\n\t\tthis.matrix = this.light.matrixWorld;\r\n\t\tthis.matrixAutoUpdate = false;\r\n\t\r\n\t\t/*\r\n\t\tvar distanceGeometry = new THREE.IcosahedronGeometry( 1, 2 );\r\n\t\tvar distanceMaterial = new THREE.MeshBasicMaterial( { color: hexColor, fog: false, wireframe: true, opacity: 0.1, transparent: true } );\r\n\t\r\n\t\tthis.lightSphere = new THREE.Mesh( bulbGeometry, bulbMaterial );\r\n\t\tthis.lightDistance = new THREE.Mesh( distanceGeometry, distanceMaterial );\r\n\t\r\n\t\tvar d = light.distance;\r\n\t\r\n\t\tif ( d === 0.0 ) {\r\n\t\r\n\t\t\tthis.lightDistance.visible = false;\r\n\t\r\n\t\t} else {\r\n\t\r\n\t\t\tthis.lightDistance.scale.set( d, d, d );\r\n\t\r\n\t\t}\r\n\t\r\n\t\tthis.add( this.lightDistance );\r\n\t\t*/\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.PointLightHelper.prototype = Object.create( THREE.Mesh.prototype );\r\n\tTHREE.PointLightHelper.prototype.constructor = THREE.PointLightHelper;\r\n\t\r\n\tTHREE.PointLightHelper.prototype.dispose = function () {\r\n\t\r\n\t\tthis.geometry.dispose();\r\n\t\tthis.material.dispose();\r\n\t};\r\n\t\r\n\tTHREE.PointLightHelper.prototype.update = function () {\r\n\t\r\n\t\tthis.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );\r\n\t\r\n\t\t/*\r\n\t\tvar d = this.light.distance;\r\n\t\r\n\t\tif ( d === 0.0 ) {\r\n\t\r\n\t\t\tthis.lightDistance.visible = false;\r\n\t\r\n\t\t} else {\r\n\t\r\n\t\t\tthis.lightDistance.visible = true;\r\n\t\t\tthis.lightDistance.scale.set( d, d, d );\r\n\t\r\n\t\t}\r\n\t\t*/\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/extras/helpers/SkeletonHelper.js\r\n\t\r\n\t/**\r\n\t * @author Sean Griffin / http://twitter.com/sgrif\r\n\t * @author Michael Guerrero / http://realitymeltdown.com\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t * @author ikerr / http://verold.com\r\n\t */\r\n\t\r\n\tTHREE.SkeletonHelper = function ( object ) {\r\n\t\r\n\t\tthis.bones = this.getBoneList( object );\r\n\t\r\n\t\tvar geometry = new THREE.Geometry();\r\n\t\r\n\t\tfor ( var i = 0; i < this.bones.length; i ++ ) {\r\n\t\r\n\t\t\tvar bone = this.bones[ i ];\r\n\t\r\n\t\t\tif ( bone.parent instanceof THREE.Bone ) {\r\n\t\r\n\t\t\t\tgeometry.vertices.push( new THREE.Vector3() );\r\n\t\t\t\tgeometry.vertices.push( new THREE.Vector3() );\r\n\t\t\t\tgeometry.colors.push( new THREE.Color( 0, 0, 1 ) );\r\n\t\t\t\tgeometry.colors.push( new THREE.Color( 0, 1, 0 ) );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\tvar material = new THREE.LineBasicMaterial( { vertexColors: THREE.VertexColors, depthTest: false, depthWrite: false, transparent: true } );\r\n\t\r\n\t\tTHREE.Line.call( this, geometry, material, THREE.LinePieces );\r\n\t\r\n\t\tthis.root = object;\r\n\t\r\n\t\tthis.matrix = object.matrixWorld;\r\n\t\tthis.matrixAutoUpdate = false;\r\n\t\r\n\t\tthis.update();\r\n\t\r\n\t};\r\n\t\r\n\t\r\n\tTHREE.SkeletonHelper.prototype = Object.create( THREE.Line.prototype );\r\n\tTHREE.SkeletonHelper.prototype.constructor = THREE.SkeletonHelper;\r\n\t\r\n\tTHREE.SkeletonHelper.prototype.getBoneList = function( object ) {\r\n\t\r\n\t\tvar boneList = [];\r\n\t\r\n\t\tif ( object instanceof THREE.Bone ) {\r\n\t\r\n\t\t\tboneList.push( object );\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfor ( var i = 0; i < object.children.length; i ++ ) {\r\n\t\r\n\t\t\tboneList.push.apply( boneList, this.getBoneList( object.children[ i ] ) );\r\n\t\r\n\t\t}\r\n\t\r\n\t\treturn boneList;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.SkeletonHelper.prototype.update = function () {\r\n\t\r\n\t\tvar geometry = this.geometry;\r\n\t\r\n\t\tvar matrixWorldInv = new THREE.Matrix4().getInverse( this.root.matrixWorld );\r\n\t\r\n\t\tvar boneMatrix = new THREE.Matrix4();\r\n\t\r\n\t\tvar j = 0;\r\n\t\r\n\t\tfor ( var i = 0; i < this.bones.length; i ++ ) {\r\n\t\r\n\t\t\tvar bone = this.bones[ i ];\r\n\t\r\n\t\t\tif ( bone.parent instanceof THREE.Bone ) {\r\n\t\r\n\t\t\t\tboneMatrix.multiplyMatrices( matrixWorldInv, bone.matrixWorld );\r\n\t\t\t\tgeometry.vertices[ j ].setFromMatrixPosition( boneMatrix );\r\n\t\r\n\t\t\t\tboneMatrix.multiplyMatrices( matrixWorldInv, bone.parent.matrixWorld );\r\n\t\t\t\tgeometry.vertices[ j + 1 ].setFromMatrixPosition( boneMatrix );\r\n\t\r\n\t\t\t\tj += 2;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\tgeometry.verticesNeedUpdate = true;\r\n\t\r\n\t\tgeometry.computeBoundingSphere();\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/extras/helpers/SpotLightHelper.js\r\n\t\r\n\t/**\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t * @author WestLangley / http://github.com/WestLangley\r\n\t*/\r\n\t\r\n\tTHREE.SpotLightHelper = function ( light ) {\r\n\t\r\n\t\tTHREE.Object3D.call( this );\r\n\t\r\n\t\tthis.light = light;\r\n\t\tthis.light.updateMatrixWorld();\r\n\t\r\n\t\tthis.matrix = light.matrixWorld;\r\n\t\tthis.matrixAutoUpdate = false;\r\n\t\r\n\t\tvar geometry = new THREE.CylinderGeometry( 0, 1, 1, 8, 1, true );\r\n\t\r\n\t\tgeometry.applyMatrix( new THREE.Matrix4().makeTranslation( 0, - 0.5, 0 ) );\r\n\t\tgeometry.applyMatrix( new THREE.Matrix4().makeRotationX( - Math.PI / 2 ) );\r\n\t\r\n\t\tvar material = new THREE.MeshBasicMaterial( { wireframe: true, fog: false } );\r\n\t\r\n\t\tthis.cone = new THREE.Mesh( geometry, material );\r\n\t\tthis.add( this.cone );\r\n\t\r\n\t\tthis.update();\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.SpotLightHelper.prototype = Object.create( THREE.Object3D.prototype );\r\n\tTHREE.SpotLightHelper.prototype.constructor = THREE.SpotLightHelper;\r\n\t\r\n\tTHREE.SpotLightHelper.prototype.dispose = function () {\r\n\t\tthis.cone.geometry.dispose();\r\n\t\tthis.cone.material.dispose();\r\n\t};\r\n\t\r\n\tTHREE.SpotLightHelper.prototype.update = function () {\r\n\t\r\n\t\tvar vector = new THREE.Vector3();\r\n\t\tvar vector2 = new THREE.Vector3();\r\n\t\r\n\t\treturn function () {\r\n\t\r\n\t\t\tvar coneLength = this.light.distance ? this.light.distance : 10000;\r\n\t\t\tvar coneWidth = coneLength * Math.tan( this.light.angle );\r\n\t\r\n\t\t\tthis.cone.scale.set( coneWidth, coneWidth, coneLength );\r\n\t\r\n\t\t\tvector.setFromMatrixPosition( this.light.matrixWorld );\r\n\t\t\tvector2.setFromMatrixPosition( this.light.target.matrixWorld );\r\n\t\r\n\t\t\tthis.cone.lookAt( vector2.sub( vector ) );\r\n\t\r\n\t\t\tthis.cone.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );\r\n\t\r\n\t\t};\r\n\t\r\n\t}();\r\n\t\r\n\t// File:src/extras/helpers/VertexNormalsHelper.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t * @author WestLangley / http://github.com/WestLangley\r\n\t*/\r\n\t\r\n\tTHREE.VertexNormalsHelper = function ( object, size, hex, linewidth ) {\r\n\t\r\n\t\tthis.object = object;\r\n\t\r\n\t\tthis.size = ( size !== undefined ) ? size : 1;\r\n\t\r\n\t\tvar color = ( hex !== undefined ) ? hex : 0xff0000;\r\n\t\r\n\t\tvar width = ( linewidth !== undefined ) ? linewidth : 1;\r\n\t\r\n\t\tvar geometry = new THREE.Geometry();\r\n\t\r\n\t\tvar faces = object.geometry.faces;\r\n\t\r\n\t\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\r\n\t\r\n\t\t\tvar face = faces[ i ];\r\n\t\r\n\t\t\tfor ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {\r\n\t\r\n\t\t\t\tgeometry.vertices.push( new THREE.Vector3(), new THREE.Vector3() );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\tTHREE.Line.call( this, geometry, new THREE.LineBasicMaterial( { color: color, linewidth: width } ), THREE.LinePieces );\r\n\t\r\n\t\tthis.matrixAutoUpdate = false;\r\n\t\r\n\t\tthis.normalMatrix = new THREE.Matrix3();\r\n\t\r\n\t\tthis.update();\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.VertexNormalsHelper.prototype = Object.create( THREE.Line.prototype );\r\n\tTHREE.VertexNormalsHelper.prototype.constructor = THREE.VertexNormalsHelper;\r\n\t\r\n\tTHREE.VertexNormalsHelper.prototype.update = ( function ( object ) {\r\n\t\r\n\t\tvar v1 = new THREE.Vector3();\r\n\t\r\n\t\treturn function( object ) {\r\n\t\r\n\t\t\tvar keys = [ 'a', 'b', 'c', 'd' ];\r\n\t\r\n\t\t\tthis.object.updateMatrixWorld( true );\r\n\t\r\n\t\t\tthis.normalMatrix.getNormalMatrix( this.object.matrixWorld );\r\n\t\r\n\t\t\tvar vertices = this.geometry.vertices;\r\n\t\r\n\t\t\tvar verts = this.object.geometry.vertices;\r\n\t\r\n\t\t\tvar faces = this.object.geometry.faces;\r\n\t\r\n\t\t\tvar worldMatrix = this.object.matrixWorld;\r\n\t\r\n\t\t\tvar idx = 0;\r\n\t\r\n\t\t\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\r\n\t\r\n\t\t\t\tvar face = faces[ i ];\r\n\t\r\n\t\t\t\tfor ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {\r\n\t\r\n\t\t\t\t\tvar vertexId = face[ keys[ j ] ];\r\n\t\t\t\t\tvar vertex = verts[ vertexId ];\r\n\t\r\n\t\t\t\t\tvar normal = face.vertexNormals[ j ];\r\n\t\r\n\t\t\t\t\tvertices[ idx ].copy( vertex ).applyMatrix4( worldMatrix );\r\n\t\r\n\t\t\t\t\tv1.copy( normal ).applyMatrix3( this.normalMatrix ).normalize().multiplyScalar( this.size );\r\n\t\r\n\t\t\t\t\tv1.add( vertices[ idx ] );\r\n\t\t\t\t\tidx = idx + 1;\r\n\t\r\n\t\t\t\t\tvertices[ idx ].copy( v1 );\r\n\t\t\t\t\tidx = idx + 1;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tthis.geometry.verticesNeedUpdate = true;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t}\r\n\t\r\n\t}());\r\n\t\r\n\t// File:src/extras/helpers/VertexTangentsHelper.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t * @author WestLangley / http://github.com/WestLangley\r\n\t*/\r\n\t\r\n\tTHREE.VertexTangentsHelper = function ( object, size, hex, linewidth ) {\r\n\t\r\n\t\tthis.object = object;\r\n\t\r\n\t\tthis.size = ( size !== undefined ) ? size : 1;\r\n\t\r\n\t\tvar color = ( hex !== undefined ) ? hex : 0x0000ff;\r\n\t\r\n\t\tvar width = ( linewidth !== undefined ) ? linewidth : 1;\r\n\t\r\n\t\tvar geometry = new THREE.Geometry();\r\n\t\r\n\t\tvar faces = object.geometry.faces;\r\n\t\r\n\t\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\r\n\t\r\n\t\t\tvar face = faces[ i ];\r\n\t\r\n\t\t\tfor ( var j = 0, jl = face.vertexTangents.length; j < jl; j ++ ) {\r\n\t\r\n\t\t\t\tgeometry.vertices.push( new THREE.Vector3() );\r\n\t\t\t\tgeometry.vertices.push( new THREE.Vector3() );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\tTHREE.Line.call( this, geometry, new THREE.LineBasicMaterial( { color: color, linewidth: width } ), THREE.LinePieces );\r\n\t\r\n\t\tthis.matrixAutoUpdate = false;\r\n\t\r\n\t\tthis.update();\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.VertexTangentsHelper.prototype = Object.create( THREE.Line.prototype );\r\n\tTHREE.VertexTangentsHelper.prototype.constructor = THREE.VertexTangentsHelper;\r\n\t\r\n\tTHREE.VertexTangentsHelper.prototype.update = ( function ( object ) {\r\n\t\r\n\t\tvar v1 = new THREE.Vector3();\r\n\t\r\n\t\treturn function( object ) {\r\n\t\r\n\t\t\tvar keys = [ 'a', 'b', 'c', 'd' ];\r\n\t\r\n\t\t\tthis.object.updateMatrixWorld( true );\r\n\t\r\n\t\t\tvar vertices = this.geometry.vertices;\r\n\t\r\n\t\t\tvar verts = this.object.geometry.vertices;\r\n\t\r\n\t\t\tvar faces = this.object.geometry.faces;\r\n\t\r\n\t\t\tvar worldMatrix = this.object.matrixWorld;\r\n\t\r\n\t\t\tvar idx = 0;\r\n\t\r\n\t\t\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\r\n\t\r\n\t\t\t\tvar face = faces[ i ];\r\n\t\r\n\t\t\t\tfor ( var j = 0, jl = face.vertexTangents.length; j < jl; j ++ ) {\r\n\t\r\n\t\t\t\t\tvar vertexId = face[ keys[ j ] ];\r\n\t\t\t\t\tvar vertex = verts[ vertexId ];\r\n\t\r\n\t\t\t\t\tvar tangent = face.vertexTangents[ j ];\r\n\t\r\n\t\t\t\t\tvertices[ idx ].copy( vertex ).applyMatrix4( worldMatrix );\r\n\t\r\n\t\t\t\t\tv1.copy( tangent ).transformDirection( worldMatrix ).multiplyScalar( this.size );\r\n\t\r\n\t\t\t\t\tv1.add( vertices[ idx ] );\r\n\t\t\t\t\tidx = idx + 1;\r\n\t\r\n\t\t\t\t\tvertices[ idx ].copy( v1 );\r\n\t\t\t\t\tidx = idx + 1;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tthis.geometry.verticesNeedUpdate = true;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t}\r\n\t\r\n\t}());\r\n\t\r\n\t// File:src/extras/helpers/WireframeHelper.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tTHREE.WireframeHelper = function ( object, hex ) {\r\n\t\r\n\t\tvar color = ( hex !== undefined ) ? hex : 0xffffff;\r\n\t\r\n\t\tvar edge = [ 0, 0 ], hash = {};\r\n\t\tvar sortFunction = function ( a, b ) { return a - b };\r\n\t\r\n\t\tvar keys = [ 'a', 'b', 'c' ];\r\n\t\tvar geometry = new THREE.BufferGeometry();\r\n\t\r\n\t\tif ( object.geometry instanceof THREE.Geometry ) {\r\n\t\r\n\t\t\tvar vertices = object.geometry.vertices;\r\n\t\t\tvar faces = object.geometry.faces;\r\n\t\t\tvar numEdges = 0;\r\n\t\r\n\t\t\t// allocate maximal size\r\n\t\t\tvar edges = new Uint32Array( 6 * faces.length );\r\n\t\r\n\t\t\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\r\n\t\r\n\t\t\t\tvar face = faces[ i ];\r\n\t\r\n\t\t\t\tfor ( var j = 0; j < 3; j ++ ) {\r\n\t\r\n\t\t\t\t\tedge[ 0 ] = face[ keys[ j ] ];\r\n\t\t\t\t\tedge[ 1 ] = face[ keys[ ( j + 1 ) % 3 ] ];\r\n\t\t\t\t\tedge.sort( sortFunction );\r\n\t\r\n\t\t\t\t\tvar key = edge.toString();\r\n\t\r\n\t\t\t\t\tif ( hash[ key ] === undefined ) {\r\n\t\r\n\t\t\t\t\t\tedges[ 2 * numEdges ] = edge[ 0 ];\r\n\t\t\t\t\t\tedges[ 2 * numEdges + 1 ] = edge[ 1 ];\r\n\t\t\t\t\t\thash[ key ] = true;\r\n\t\t\t\t\t\tnumEdges ++;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar coords = new Float32Array( numEdges * 2 * 3 );\r\n\t\r\n\t\t\tfor ( var i = 0, l = numEdges; i < l; i ++ ) {\r\n\t\r\n\t\t\t\tfor ( var j = 0; j < 2; j ++ ) {\r\n\t\r\n\t\t\t\t\tvar vertex = vertices[ edges [ 2 * i + j] ];\r\n\t\r\n\t\t\t\t\tvar index = 6 * i + 3 * j;\r\n\t\t\t\t\tcoords[ index + 0 ] = vertex.x;\r\n\t\t\t\t\tcoords[ index + 1 ] = vertex.y;\r\n\t\t\t\t\tcoords[ index + 2 ] = vertex.z;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tgeometry.addAttribute( 'position', new THREE.BufferAttribute( coords, 3 ) );\r\n\t\r\n\t\t} else if ( object.geometry instanceof THREE.BufferGeometry ) {\r\n\t\r\n\t\t\tif ( object.geometry.attributes.index !== undefined ) { // Indexed BufferGeometry\r\n\t\r\n\t\t\t\tvar vertices = object.geometry.attributes.position.array;\r\n\t\t\t\tvar indices = object.geometry.attributes.index.array;\r\n\t\t\t\tvar drawcalls = object.geometry.drawcalls;\r\n\t\t\t\tvar numEdges = 0;\r\n\t\r\n\t\t\t\tif ( drawcalls.length === 0 ) {\r\n\t\r\n\t\t\t\t\tdrawcalls = [ { count : indices.length, index : 0, start : 0 } ];\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\t// allocate maximal size\r\n\t\t\t\tvar edges = new Uint32Array( 2 * indices.length );\r\n\t\r\n\t\t\t\tfor ( var o = 0, ol = drawcalls.length; o < ol; ++ o ) {\r\n\t\r\n\t\t\t\t\tvar start = drawcalls[ o ].start;\r\n\t\t\t\t\tvar count = drawcalls[ o ].count;\r\n\t\t\t\t\tvar index = drawcalls[ o ].index;\r\n\t\r\n\t\t\t\t\tfor ( var i = start, il = start + count; i < il; i += 3 ) {\r\n\t\r\n\t\t\t\t\t\tfor ( var j = 0; j < 3; j ++ ) {\r\n\t\r\n\t\t\t\t\t\t\tedge[ 0 ] = index + indices[ i + j ];\r\n\t\t\t\t\t\t\tedge[ 1 ] = index + indices[ i + ( j + 1 ) % 3 ];\r\n\t\t\t\t\t\t\tedge.sort( sortFunction );\r\n\t\r\n\t\t\t\t\t\t\tvar key = edge.toString();\r\n\t\r\n\t\t\t\t\t\t\tif ( hash[ key ] === undefined ) {\r\n\t\r\n\t\t\t\t\t\t\t\tedges[ 2 * numEdges ] = edge[ 0 ];\r\n\t\t\t\t\t\t\t\tedges[ 2 * numEdges + 1 ] = edge[ 1 ];\r\n\t\t\t\t\t\t\t\thash[ key ] = true;\r\n\t\t\t\t\t\t\t\tnumEdges ++;\r\n\t\r\n\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tvar coords = new Float32Array( numEdges * 2 * 3 );\r\n\t\r\n\t\t\t\tfor ( var i = 0, l = numEdges; i < l; i ++ ) {\r\n\t\r\n\t\t\t\t\tfor ( var j = 0; j < 2; j ++ ) {\r\n\t\r\n\t\t\t\t\t\tvar index = 6 * i + 3 * j;\r\n\t\t\t\t\t\tvar index2 = 3 * edges[ 2 * i + j];\r\n\t\t\t\t\t\tcoords[ index + 0 ] = vertices[ index2 ];\r\n\t\t\t\t\t\tcoords[ index + 1 ] = vertices[ index2 + 1 ];\r\n\t\t\t\t\t\tcoords[ index + 2 ] = vertices[ index2 + 2 ];\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tgeometry.addAttribute( 'position', new THREE.BufferAttribute( coords, 3 ) );\r\n\t\r\n\t\t\t} else { // non-indexed BufferGeometry\r\n\t\r\n\t\t\t\tvar vertices = object.geometry.attributes.position.array;\r\n\t\t\t\tvar numEdges = vertices.length / 3;\r\n\t\t\t\tvar numTris = numEdges / 3;\r\n\t\r\n\t\t\t\tvar coords = new Float32Array( numEdges * 2 * 3 );\r\n\t\r\n\t\t\t\tfor ( var i = 0, l = numTris; i < l; i ++ ) {\r\n\t\r\n\t\t\t\t\tfor ( var j = 0; j < 3; j ++ ) {\r\n\t\r\n\t\t\t\t\t\tvar index = 18 * i + 6 * j;\r\n\t\r\n\t\t\t\t\t\tvar index1 = 9 * i + 3 * j;\r\n\t\t\t\t\t\tcoords[ index + 0 ] = vertices[ index1 ];\r\n\t\t\t\t\t\tcoords[ index + 1 ] = vertices[ index1 + 1 ];\r\n\t\t\t\t\t\tcoords[ index + 2 ] = vertices[ index1 + 2 ];\r\n\t\r\n\t\t\t\t\t\tvar index2 = 9 * i + 3 * ( ( j + 1 ) % 3 );\r\n\t\t\t\t\t\tcoords[ index + 3 ] = vertices[ index2 ];\r\n\t\t\t\t\t\tcoords[ index + 4 ] = vertices[ index2 + 1 ];\r\n\t\t\t\t\t\tcoords[ index + 5 ] = vertices[ index2 + 2 ];\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tgeometry.addAttribute( 'position', new THREE.BufferAttribute( coords, 3 ) );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\tTHREE.Line.call( this, geometry, new THREE.LineBasicMaterial( { color: color } ), THREE.LinePieces );\r\n\t\r\n\t\tthis.matrix = object.matrixWorld;\r\n\t\tthis.matrixAutoUpdate = false;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.WireframeHelper.prototype = Object.create( THREE.Line.prototype );\r\n\tTHREE.WireframeHelper.prototype.constructor = THREE.WireframeHelper;\r\n\t\r\n\t// File:src/extras/objects/ImmediateRenderObject.js\r\n\t\r\n\t/**\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t */\r\n\t\r\n\tTHREE.ImmediateRenderObject = function () {\r\n\t\r\n\t\tTHREE.Object3D.call( this );\r\n\t\r\n\t\tthis.render = function ( renderCallback ) {};\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.ImmediateRenderObject.prototype = Object.create( THREE.Object3D.prototype );\r\n\tTHREE.ImmediateRenderObject.prototype.constructor = THREE.ImmediateRenderObject;\r\n\t\r\n\t// File:src/extras/objects/MorphBlendMesh.js\r\n\t\r\n\t/**\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t */\r\n\t\r\n\tTHREE.MorphBlendMesh = function( geometry, material ) {\r\n\t\r\n\t\tTHREE.Mesh.call( this, geometry, material );\r\n\t\r\n\t\tthis.animationsMap = {};\r\n\t\tthis.animationsList = [];\r\n\t\r\n\t\t// prepare default animation\r\n\t\t// (all frames played together in 1 second)\r\n\t\r\n\t\tvar numFrames = this.geometry.morphTargets.length;\r\n\t\r\n\t\tvar name = \"__default\";\r\n\t\r\n\t\tvar startFrame = 0;\r\n\t\tvar endFrame = numFrames - 1;\r\n\t\r\n\t\tvar fps = numFrames / 1;\r\n\t\r\n\t\tthis.createAnimation( name, startFrame, endFrame, fps );\r\n\t\tthis.setAnimationWeight( name, 1 );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.MorphBlendMesh.prototype = Object.create( THREE.Mesh.prototype );\r\n\tTHREE.MorphBlendMesh.prototype.constructor = THREE.MorphBlendMesh;\r\n\t\r\n\tTHREE.MorphBlendMesh.prototype.createAnimation = function ( name, start, end, fps ) {\r\n\t\r\n\t\tvar animation = {\r\n\t\r\n\t\t\tstartFrame: start,\r\n\t\t\tendFrame: end,\r\n\t\r\n\t\t\tlength: end - start + 1,\r\n\t\r\n\t\t\tfps: fps,\r\n\t\t\tduration: ( end - start ) / fps,\r\n\t\r\n\t\t\tlastFrame: 0,\r\n\t\t\tcurrentFrame: 0,\r\n\t\r\n\t\t\tactive: false,\r\n\t\r\n\t\t\ttime: 0,\r\n\t\t\tdirection: 1,\r\n\t\t\tweight: 1,\r\n\t\r\n\t\t\tdirectionBackwards: false,\r\n\t\t\tmirroredLoop: false\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.animationsMap[ name ] = animation;\r\n\t\tthis.animationsList.push( animation );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.MorphBlendMesh.prototype.autoCreateAnimations = function ( fps ) {\r\n\t\r\n\t\tvar pattern = /([a-z]+)_?(\\d+)/;\r\n\t\r\n\t\tvar firstAnimation, frameRanges = {};\r\n\t\r\n\t\tvar geometry = this.geometry;\r\n\t\r\n\t\tfor ( var i = 0, il = geometry.morphTargets.length; i < il; i ++ ) {\r\n\t\r\n\t\t\tvar morph = geometry.morphTargets[ i ];\r\n\t\t\tvar chunks = morph.name.match( pattern );\r\n\t\r\n\t\t\tif ( chunks && chunks.length > 1 ) {\r\n\t\r\n\t\t\t\tvar name = chunks[ 1 ];\r\n\t\r\n\t\t\t\tif ( ! frameRanges[ name ] ) frameRanges[ name ] = { start: Infinity, end: - Infinity };\r\n\t\r\n\t\t\t\tvar range = frameRanges[ name ];\r\n\t\r\n\t\t\t\tif ( i < range.start ) range.start = i;\r\n\t\t\t\tif ( i > range.end ) range.end = i;\r\n\t\r\n\t\t\t\tif ( ! firstAnimation ) firstAnimation = name;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfor ( var name in frameRanges ) {\r\n\t\r\n\t\t\tvar range = frameRanges[ name ];\r\n\t\t\tthis.createAnimation( name, range.start, range.end, fps );\r\n\t\r\n\t\t}\r\n\t\r\n\t\tthis.firstAnimation = firstAnimation;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.MorphBlendMesh.prototype.setAnimationDirectionForward = function ( name ) {\r\n\t\r\n\t\tvar animation = this.animationsMap[ name ];\r\n\t\r\n\t\tif ( animation ) {\r\n\t\r\n\t\t\tanimation.direction = 1;\r\n\t\t\tanimation.directionBackwards = false;\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.MorphBlendMesh.prototype.setAnimationDirectionBackward = function ( name ) {\r\n\t\r\n\t\tvar animation = this.animationsMap[ name ];\r\n\t\r\n\t\tif ( animation ) {\r\n\t\r\n\t\t\tanimation.direction = - 1;\r\n\t\t\tanimation.directionBackwards = true;\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.MorphBlendMesh.prototype.setAnimationFPS = function ( name, fps ) {\r\n\t\r\n\t\tvar animation = this.animationsMap[ name ];\r\n\t\r\n\t\tif ( animation ) {\r\n\t\r\n\t\t\tanimation.fps = fps;\r\n\t\t\tanimation.duration = ( animation.end - animation.start ) / animation.fps;\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.MorphBlendMesh.prototype.setAnimationDuration = function ( name, duration ) {\r\n\t\r\n\t\tvar animation = this.animationsMap[ name ];\r\n\t\r\n\t\tif ( animation ) {\r\n\t\r\n\t\t\tanimation.duration = duration;\r\n\t\t\tanimation.fps = ( animation.end - animation.start ) / animation.duration;\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.MorphBlendMesh.prototype.setAnimationWeight = function ( name, weight ) {\r\n\t\r\n\t\tvar animation = this.animationsMap[ name ];\r\n\t\r\n\t\tif ( animation ) {\r\n\t\r\n\t\t\tanimation.weight = weight;\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.MorphBlendMesh.prototype.setAnimationTime = function ( name, time ) {\r\n\t\r\n\t\tvar animation = this.animationsMap[ name ];\r\n\t\r\n\t\tif ( animation ) {\r\n\t\r\n\t\t\tanimation.time = time;\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.MorphBlendMesh.prototype.getAnimationTime = function ( name ) {\r\n\t\r\n\t\tvar time = 0;\r\n\t\r\n\t\tvar animation = this.animationsMap[ name ];\r\n\t\r\n\t\tif ( animation ) {\r\n\t\r\n\t\t\ttime = animation.time;\r\n\t\r\n\t\t}\r\n\t\r\n\t\treturn time;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.MorphBlendMesh.prototype.getAnimationDuration = function ( name ) {\r\n\t\r\n\t\tvar duration = - 1;\r\n\t\r\n\t\tvar animation = this.animationsMap[ name ];\r\n\t\r\n\t\tif ( animation ) {\r\n\t\r\n\t\t\tduration = animation.duration;\r\n\t\r\n\t\t}\r\n\t\r\n\t\treturn duration;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.MorphBlendMesh.prototype.playAnimation = function ( name ) {\r\n\t\r\n\t\tvar animation = this.animationsMap[ name ];\r\n\t\r\n\t\tif ( animation ) {\r\n\t\r\n\t\t\tanimation.time = 0;\r\n\t\t\tanimation.active = true;\r\n\t\r\n\t\t} else {\r\n\t\r\n\t\t\tTHREE.warn( \"THREE.MorphBlendMesh: animation[\" + name + \"] undefined in .playAnimation()\" );\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.MorphBlendMesh.prototype.stopAnimation = function ( name ) {\r\n\t\r\n\t\tvar animation = this.animationsMap[ name ];\r\n\t\r\n\t\tif ( animation ) {\r\n\t\r\n\t\t\tanimation.active = false;\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.MorphBlendMesh.prototype.update = function ( delta ) {\r\n\t\r\n\t\tfor ( var i = 0, il = this.animationsList.length; i < il; i ++ ) {\r\n\t\r\n\t\t\tvar animation = this.animationsList[ i ];\r\n\t\r\n\t\t\tif ( ! animation.active ) continue;\r\n\t\r\n\t\t\tvar frameTime = animation.duration / animation.length;\r\n\t\r\n\t\t\tanimation.time += animation.direction * delta;\r\n\t\r\n\t\t\tif ( animation.mirroredLoop ) {\r\n\t\r\n\t\t\t\tif ( animation.time > animation.duration || animation.time < 0 ) {\r\n\t\r\n\t\t\t\t\tanimation.direction *= - 1;\r\n\t\r\n\t\t\t\t\tif ( animation.time > animation.duration ) {\r\n\t\r\n\t\t\t\t\t\tanimation.time = animation.duration;\r\n\t\t\t\t\t\tanimation.directionBackwards = true;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tif ( animation.time < 0 ) {\r\n\t\r\n\t\t\t\t\t\tanimation.time = 0;\r\n\t\t\t\t\t\tanimation.directionBackwards = false;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\tanimation.time = animation.time % animation.duration;\r\n\t\r\n\t\t\t\tif ( animation.time < 0 ) animation.time += animation.duration;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar keyframe = animation.startFrame + THREE.Math.clamp( Math.floor( animation.time / frameTime ), 0, animation.length - 1 );\r\n\t\t\tvar weight = animation.weight;\r\n\t\r\n\t\t\tif ( keyframe !== animation.currentFrame ) {\r\n\t\r\n\t\t\t\tthis.morphTargetInfluences[ animation.lastFrame ] = 0;\r\n\t\t\t\tthis.morphTargetInfluences[ animation.currentFrame ] = 1 * weight;\r\n\t\r\n\t\t\t\tthis.morphTargetInfluences[ keyframe ] = 0;\r\n\t\r\n\t\t\t\tanimation.lastFrame = animation.currentFrame;\r\n\t\t\t\tanimation.currentFrame = keyframe;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar mix = ( animation.time % frameTime ) / frameTime;\r\n\t\r\n\t\t\tif ( animation.directionBackwards ) mix = 1 - mix;\r\n\t\r\n\t\t\tthis.morphTargetInfluences[ animation.currentFrame ] = mix * weight;\r\n\t\t\tthis.morphTargetInfluences[ animation.lastFrame ] = ( 1 - mix ) * weight;\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t\r\n\t// Export the THREE object for **Node.js**, with\r\n\t// backwards-compatibility for the old `require()` API. If we're in\r\n\t// the browser, add `_` as a global object via a string identifier,\r\n\t// for Closure Compiler \"advanced\" mode.\r\n\tif (true) {\r\n\t  if (typeof module !== 'undefined' && module.exports) {\r\n\t    exports = module.exports = THREE;\r\n\t  }\r\n\t  exports.THREE = THREE;\r\n\t} else {\r\n\t  this['THREE'] = THREE;\r\n\t}\r\n\n\n/***/ },\n/* 11 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar EventEmitter, Entity, out$ = typeof exports != 'undefined' && exports || this;\n\tEventEmitter = __webpack_require__(12).EventEmitter;\n\tout$.Entity = Entity = (function(superclass){\n\t  var prototype = extend$((import$(Entity, superclass).displayName = 'Entity', Entity), superclass).prototype, constructor = Entity;\n\t  function Entity(parent){\n\t    this.parent = parent;\n\t    this.children = [];\n\t  }\n\t  prototype.addChild = function(it){\n\t    this.children.push(it);\n\t    this.emit('childadded', it);\n\t    return it;\n\t  };\n\t  prototype.removeChild = function(it){\n\t    var i$, ref$, len$, index, child;\n\t    for (i$ = 0, len$ = (ref$ = this.children).length; i$ < len$; ++i$) {\n\t      index = i$;\n\t      child = ref$[i$];\n\t      if (child === it) {\n\t        this.children.splice(index, 1);\n\t        this.emit('childremoved', it);\n\t        return it;\n\t      }\n\t    }\n\t  };\n\t  return Entity;\n\t}(EventEmitter));\n\tfunction extend$(sub, sup){\n\t  function fun(){} fun.prototype = (sub.superclass = sup).prototype;\n\t  (sub.prototype = new fun).constructor = sub;\n\t  if (typeof sup.extended == 'function') sup.extended(sub);\n\t  return sub;\n\t}\n\tfunction import$(obj, src){\n\t  var own = {}.hasOwnProperty;\n\t  for (var key in src) if (own.call(src, key)) obj[key] = src[key];\n\t  return obj;\n\t}\n\t//# sourceMappingURL=/home/amar/misc/Dropbox/projects/home/proto/node_modules/livescript-loader/index.js!/home/amar/misc/Dropbox/projects/home/proto/src/core/entity.ls.map\n\n\n/***/ },\n/* 12 */\n/***/ function(module, exports) {\n\n\t// Copyright Joyent, Inc. and other Node contributors.\n\t//\n\t// Permission is hereby granted, free of charge, to any person obtaining a\n\t// copy of this software and associated documentation files (the\n\t// \"Software\"), to deal in the Software without restriction, including\n\t// without limitation the rights to use, copy, modify, merge, publish,\n\t// distribute, sublicense, and/or sell copies of the Software, and to permit\n\t// persons to whom the Software is furnished to do so, subject to the\n\t// following conditions:\n\t//\n\t// The above copyright notice and this permission notice shall be included\n\t// in all copies or substantial portions of the Software.\n\t//\n\t// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n\t// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n\t// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n\t// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n\t// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n\t// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n\t// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\t\n\tfunction EventEmitter() {\n\t  this._events = this._events || {};\n\t  this._maxListeners = this._maxListeners || undefined;\n\t}\n\tmodule.exports = EventEmitter;\n\t\n\t// Backwards-compat with node 0.10.x\n\tEventEmitter.EventEmitter = EventEmitter;\n\t\n\tEventEmitter.prototype._events = undefined;\n\tEventEmitter.prototype._maxListeners = undefined;\n\t\n\t// By default EventEmitters will print a warning if more than 10 listeners are\n\t// added to it. This is a useful default which helps finding memory leaks.\n\tEventEmitter.defaultMaxListeners = 10;\n\t\n\t// Obviously not all Emitters should be limited to 10. This function allows\n\t// that to be increased. Set to zero for unlimited.\n\tEventEmitter.prototype.setMaxListeners = function(n) {\n\t  if (!isNumber(n) || n < 0 || isNaN(n))\n\t    throw TypeError('n must be a positive number');\n\t  this._maxListeners = n;\n\t  return this;\n\t};\n\t\n\tEventEmitter.prototype.emit = function(type) {\n\t  var er, handler, len, args, i, listeners;\n\t\n\t  if (!this._events)\n\t    this._events = {};\n\t\n\t  // If there is no 'error' event listener then throw.\n\t  if (type === 'error') {\n\t    if (!this._events.error ||\n\t        (isObject(this._events.error) && !this._events.error.length)) {\n\t      er = arguments[1];\n\t      if (er instanceof Error) {\n\t        throw er; // Unhandled 'error' event\n\t      }\n\t      throw TypeError('Uncaught, unspecified \"error\" event.');\n\t    }\n\t  }\n\t\n\t  handler = this._events[type];\n\t\n\t  if (isUndefined(handler))\n\t    return false;\n\t\n\t  if (isFunction(handler)) {\n\t    switch (arguments.length) {\n\t      // fast cases\n\t      case 1:\n\t        handler.call(this);\n\t        break;\n\t      case 2:\n\t        handler.call(this, arguments[1]);\n\t        break;\n\t      case 3:\n\t        handler.call(this, arguments[1], arguments[2]);\n\t        break;\n\t      // slower\n\t      default:\n\t        len = arguments.length;\n\t        args = new Array(len - 1);\n\t        for (i = 1; i < len; i++)\n\t          args[i - 1] = arguments[i];\n\t        handler.apply(this, args);\n\t    }\n\t  } else if (isObject(handler)) {\n\t    len = arguments.length;\n\t    args = new Array(len - 1);\n\t    for (i = 1; i < len; i++)\n\t      args[i - 1] = arguments[i];\n\t\n\t    listeners = handler.slice();\n\t    len = listeners.length;\n\t    for (i = 0; i < len; i++)\n\t      listeners[i].apply(this, args);\n\t  }\n\t\n\t  return true;\n\t};\n\t\n\tEventEmitter.prototype.addListener = function(type, listener) {\n\t  var m;\n\t\n\t  if (!isFunction(listener))\n\t    throw TypeError('listener must be a function');\n\t\n\t  if (!this._events)\n\t    this._events = {};\n\t\n\t  // To avoid recursion in the case that type === \"newListener\"! Before\n\t  // adding it to the listeners, first emit \"newListener\".\n\t  if (this._events.newListener)\n\t    this.emit('newListener', type,\n\t              isFunction(listener.listener) ?\n\t              listener.listener : listener);\n\t\n\t  if (!this._events[type])\n\t    // Optimize the case of one listener. Don't need the extra array object.\n\t    this._events[type] = listener;\n\t  else if (isObject(this._events[type]))\n\t    // If we've already got an array, just append.\n\t    this._events[type].push(listener);\n\t  else\n\t    // Adding the second element, need to change to array.\n\t    this._events[type] = [this._events[type], listener];\n\t\n\t  // Check for listener leak\n\t  if (isObject(this._events[type]) && !this._events[type].warned) {\n\t    var m;\n\t    if (!isUndefined(this._maxListeners)) {\n\t      m = this._maxListeners;\n\t    } else {\n\t      m = EventEmitter.defaultMaxListeners;\n\t    }\n\t\n\t    if (m && m > 0 && this._events[type].length > m) {\n\t      this._events[type].warned = true;\n\t      console.error('(node) warning: possible EventEmitter memory ' +\n\t                    'leak detected. %d listeners added. ' +\n\t                    'Use emitter.setMaxListeners() to increase limit.',\n\t                    this._events[type].length);\n\t      if (typeof console.trace === 'function') {\n\t        // not supported in IE 10\n\t        console.trace();\n\t      }\n\t    }\n\t  }\n\t\n\t  return this;\n\t};\n\t\n\tEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\t\n\tEventEmitter.prototype.once = function(type, listener) {\n\t  if (!isFunction(listener))\n\t    throw TypeError('listener must be a function');\n\t\n\t  var fired = false;\n\t\n\t  function g() {\n\t    this.removeListener(type, g);\n\t\n\t    if (!fired) {\n\t      fired = true;\n\t      listener.apply(this, arguments);\n\t    }\n\t  }\n\t\n\t  g.listener = listener;\n\t  this.on(type, g);\n\t\n\t  return this;\n\t};\n\t\n\t// emits a 'removeListener' event iff the listener was removed\n\tEventEmitter.prototype.removeListener = function(type, listener) {\n\t  var list, position, length, i;\n\t\n\t  if (!isFunction(listener))\n\t    throw TypeError('listener must be a function');\n\t\n\t  if (!this._events || !this._events[type])\n\t    return this;\n\t\n\t  list = this._events[type];\n\t  length = list.length;\n\t  position = -1;\n\t\n\t  if (list === listener ||\n\t      (isFunction(list.listener) && list.listener === listener)) {\n\t    delete this._events[type];\n\t    if (this._events.removeListener)\n\t      this.emit('removeListener', type, listener);\n\t\n\t  } else if (isObject(list)) {\n\t    for (i = length; i-- > 0;) {\n\t      if (list[i] === listener ||\n\t          (list[i].listener && list[i].listener === listener)) {\n\t        position = i;\n\t        break;\n\t      }\n\t    }\n\t\n\t    if (position < 0)\n\t      return this;\n\t\n\t    if (list.length === 1) {\n\t      list.length = 0;\n\t      delete this._events[type];\n\t    } else {\n\t      list.splice(position, 1);\n\t    }\n\t\n\t    if (this._events.removeListener)\n\t      this.emit('removeListener', type, listener);\n\t  }\n\t\n\t  return this;\n\t};\n\t\n\tEventEmitter.prototype.removeAllListeners = function(type) {\n\t  var key, listeners;\n\t\n\t  if (!this._events)\n\t    return this;\n\t\n\t  // not listening for removeListener, no need to emit\n\t  if (!this._events.removeListener) {\n\t    if (arguments.length === 0)\n\t      this._events = {};\n\t    else if (this._events[type])\n\t      delete this._events[type];\n\t    return this;\n\t  }\n\t\n\t  // emit removeListener for all listeners on all events\n\t  if (arguments.length === 0) {\n\t    for (key in this._events) {\n\t      if (key === 'removeListener') continue;\n\t      this.removeAllListeners(key);\n\t    }\n\t    this.removeAllListeners('removeListener');\n\t    this._events = {};\n\t    return this;\n\t  }\n\t\n\t  listeners = this._events[type];\n\t\n\t  if (isFunction(listeners)) {\n\t    this.removeListener(type, listeners);\n\t  } else {\n\t    // LIFO order\n\t    while (listeners.length)\n\t      this.removeListener(type, listeners[listeners.length - 1]);\n\t  }\n\t  delete this._events[type];\n\t\n\t  return this;\n\t};\n\t\n\tEventEmitter.prototype.listeners = function(type) {\n\t  var ret;\n\t  if (!this._events || !this._events[type])\n\t    ret = [];\n\t  else if (isFunction(this._events[type]))\n\t    ret = [this._events[type]];\n\t  else\n\t    ret = this._events[type].slice();\n\t  return ret;\n\t};\n\t\n\tEventEmitter.listenerCount = function(emitter, type) {\n\t  var ret;\n\t  if (!emitter._events || !emitter._events[type])\n\t    ret = 0;\n\t  else if (isFunction(emitter._events[type]))\n\t    ret = 1;\n\t  else\n\t    ret = emitter._events[type].length;\n\t  return ret;\n\t};\n\t\n\tfunction isFunction(arg) {\n\t  return typeof arg === 'function';\n\t}\n\t\n\tfunction isNumber(arg) {\n\t  return typeof arg === 'number';\n\t}\n\t\n\tfunction isObject(arg) {\n\t  return typeof arg === 'object' && arg !== null;\n\t}\n\t\n\tfunction isUndefined(arg) {\n\t  return arg === void 0;\n\t}\n\n\n/***/ }\n/******/ ]);\n\n\n/** WEBPACK FOOTER **\n ** proto.min.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 6e07bdf12b4c2ae4d8f6\n **/","require! {\n  \"../../src/core/game.ls\" : { Game }\n  \"../../src/gfx/renderer.ls\" : { Renderer }\n}\n\ngame = new Game!\n\nrenderer = new Renderer game\n\n\n\n/** WEBPACK FOOTER **\n ** ./proto.ls\n **/","require! {\n  './scene.ls': { Scene }\n}\n\nexport class Game\n  (config = {}) ->\n\n    scene = new Scene!\n\n    console.log 'game'\n\n\n\n/** WEBPACK FOOTER **\n ** /home/amar/misc/Dropbox/projects/home/proto/src/core/game.ls\n **/","require! {\n  './entity.ls': { Entity }\n}\n\nexport class Scene extends Entity\n  ->\n    super null\n\n  add-child: ->\n    it = super ...\n    if it? then @emit \\entityspawned it\n    it\n\n  remove-child: ->\n    it = super ...\n    if it? then @emit \\entitydespawned it\n    it\n\n\n\n/** WEBPACK FOOTER **\n ** /home/amar/misc/Dropbox/projects/home/proto/src/core/scene.ls\n **/","require! {\n  './style/clear.styl'\n  './style/standard.styl'\n}\n\nrequire! three\n\nexport class Renderer\n  (config = {}) ->\n\n    @three-renderer = new three.WebGLRenderer antialias: true\n      ..set-size window.inner-width, window.inner-height\n      ..shadow-map-enabled = true\n      ..shadow-map-soft    = true\n      ..sort-objects       = false\n\n    self = @\n\n    window.add-event-listener \\resize !->\n      if self.camera\n        self.camera.aspect = window.inner-width / window.inner-height\n        self.camera.update-projection-matrix!\n      self.three-renderer.set-size window.inner-width, window.inner-height\n\n\n    @scene = new three.Scene!\n\n    @camera = new three.PerspectiveCamera 75, window.inner-width / window.inner-height, 1, 10000\n    @camera.position.z = 1000\n\n    @geometry = new three.BoxGeometry 200, 200, 200\n    @material = new three.MeshBasicMaterial color: 0xff0000 wireframe: true\n\n    @mesh = new three.Mesh @geometry, @material\n    @scene.add @mesh\n\n    @three-renderer.domElement\n      ..id = \\wgl-canvas\n      .. |> document.body.append-child\n\n    window.request-animation-frame render = !->\n      window.request-animation-frame render\n      self.render!\n\n  render: !->\n    @mesh.rotation.x += 0.01;\n    @mesh.rotation.y += 0.02;\n\n    @three-renderer.render @scene, @camera\n\n\n\n/** WEBPACK FOOTER **\n ** /home/amar/misc/Dropbox/projects/home/proto/src/gfx/renderer.ls\n **/","// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = require(\"!!./../../../node_modules/css-loader/index.js!./../../../node_modules/stylus-loader/index.js!./clear.styl\");\nif(typeof content === 'string') content = [[module.id, content, '']];\n// add the styles to the DOM\nvar update = require(\"!./../../../node_modules/style-loader/addStyles.js\")(content, {});\nif(content.locals) module.exports = content.locals;\n// Hot Module Replacement\nif(module.hot) {\n\t// When the styles change, update the <style> tags\n\tif(!content.locals) {\n\t\tmodule.hot.accept(\"!!./../../../node_modules/css-loader/index.js!./../../../node_modules/stylus-loader/index.js!./clear.styl\", function() {\n\t\t\tvar newContent = require(\"!!./../../../node_modules/css-loader/index.js!./../../../node_modules/stylus-loader/index.js!./clear.styl\");\n\t\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\t\t\tupdate(newContent);\n\t\t});\n\t}\n\t// When the module is disposed, remove the <style> tags\n\tmodule.hot.dispose(function() { update(); });\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** /home/amar/misc/Dropbox/projects/home/proto/src/gfx/style/clear.styl\n ** module id = 4\n ** module chunks = 0\n **/","exports = module.exports = require(\"./../../../node_modules/css-loader/lib/css-base.js\")();\n// imports\n\n\n// module\nexports.push([module.id, \"*{margin:0;padding:0;height:100%}\", \"\"]);\n\n// exports\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** /home/amar/misc/Dropbox/projects/home/proto/~/css-loader!/home/amar/misc/Dropbox/projects/home/proto/~/stylus-loader!/home/amar/misc/Dropbox/projects/home/proto/src/gfx/style/clear.styl\n ** module id = 5\n ** module chunks = 0\n **/","/*\r\n\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\tAuthor Tobias Koppers @sokra\r\n*/\r\n// css base code, injected by the css-loader\r\nmodule.exports = function() {\r\n\tvar list = [];\r\n\r\n\t// return the list of modules as css string\r\n\tlist.toString = function toString() {\r\n\t\tvar result = [];\r\n\t\tfor(var i = 0; i < this.length; i++) {\r\n\t\t\tvar item = this[i];\r\n\t\t\tif(item[2]) {\r\n\t\t\t\tresult.push(\"@media \" + item[2] + \"{\" + item[1] + \"}\");\r\n\t\t\t} else {\r\n\t\t\t\tresult.push(item[1]);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn result.join(\"\");\r\n\t};\r\n\r\n\t// import a list of modules into the list\r\n\tlist.i = function(modules, mediaQuery) {\r\n\t\tif(typeof modules === \"string\")\r\n\t\t\tmodules = [[null, modules, \"\"]];\r\n\t\tvar alreadyImportedModules = {};\r\n\t\tfor(var i = 0; i < this.length; i++) {\r\n\t\t\tvar id = this[i][0];\r\n\t\t\tif(typeof id === \"number\")\r\n\t\t\t\talreadyImportedModules[id] = true;\r\n\t\t}\r\n\t\tfor(i = 0; i < modules.length; i++) {\r\n\t\t\tvar item = modules[i];\r\n\t\t\t// skip already imported module\r\n\t\t\t// this implementation is not 100% perfect for weird media query combinations\r\n\t\t\t//  when a module is imported multiple times with different media queries.\r\n\t\t\t//  I hope this will never occur (Hey this way we have smaller bundles)\r\n\t\t\tif(typeof item[0] !== \"number\" || !alreadyImportedModules[item[0]]) {\r\n\t\t\t\tif(mediaQuery && !item[2]) {\r\n\t\t\t\t\titem[2] = mediaQuery;\r\n\t\t\t\t} else if(mediaQuery) {\r\n\t\t\t\t\titem[2] = \"(\" + item[2] + \") and (\" + mediaQuery + \")\";\r\n\t\t\t\t}\r\n\t\t\t\tlist.push(item);\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\treturn list;\r\n};\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** /home/amar/misc/Dropbox/projects/home/proto/~/css-loader/lib/css-base.js\n ** module id = 6\n ** module chunks = 0\n **/","/*\r\n\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\tAuthor Tobias Koppers @sokra\r\n*/\r\nvar stylesInDom = {},\r\n\tmemoize = function(fn) {\r\n\t\tvar memo;\r\n\t\treturn function () {\r\n\t\t\tif (typeof memo === \"undefined\") memo = fn.apply(this, arguments);\r\n\t\t\treturn memo;\r\n\t\t};\r\n\t},\r\n\tisOldIE = memoize(function() {\r\n\t\treturn /msie [6-9]\\b/.test(window.navigator.userAgent.toLowerCase());\r\n\t}),\r\n\tgetHeadElement = memoize(function () {\r\n\t\treturn document.head || document.getElementsByTagName(\"head\")[0];\r\n\t}),\r\n\tsingletonElement = null,\r\n\tsingletonCounter = 0;\r\n\r\nmodule.exports = function(list, options) {\r\n\tif(typeof DEBUG !== \"undefined\" && DEBUG) {\r\n\t\tif(typeof document !== \"object\") throw new Error(\"The style-loader cannot be used in a non-browser environment\");\r\n\t}\r\n\r\n\toptions = options || {};\r\n\t// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\r\n\t// tags it will allow on a page\r\n\tif (typeof options.singleton === \"undefined\") options.singleton = isOldIE();\r\n\r\n\tvar styles = listToStyles(list);\r\n\taddStylesToDom(styles, options);\r\n\r\n\treturn function update(newList) {\r\n\t\tvar mayRemove = [];\r\n\t\tfor(var i = 0; i < styles.length; i++) {\r\n\t\t\tvar item = styles[i];\r\n\t\t\tvar domStyle = stylesInDom[item.id];\r\n\t\t\tdomStyle.refs--;\r\n\t\t\tmayRemove.push(domStyle);\r\n\t\t}\r\n\t\tif(newList) {\r\n\t\t\tvar newStyles = listToStyles(newList);\r\n\t\t\taddStylesToDom(newStyles, options);\r\n\t\t}\r\n\t\tfor(var i = 0; i < mayRemove.length; i++) {\r\n\t\t\tvar domStyle = mayRemove[i];\r\n\t\t\tif(domStyle.refs === 0) {\r\n\t\t\t\tfor(var j = 0; j < domStyle.parts.length; j++)\r\n\t\t\t\t\tdomStyle.parts[j]();\r\n\t\t\t\tdelete stylesInDom[domStyle.id];\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n}\r\n\r\nfunction addStylesToDom(styles, options) {\r\n\tfor(var i = 0; i < styles.length; i++) {\r\n\t\tvar item = styles[i];\r\n\t\tvar domStyle = stylesInDom[item.id];\r\n\t\tif(domStyle) {\r\n\t\t\tdomStyle.refs++;\r\n\t\t\tfor(var j = 0; j < domStyle.parts.length; j++) {\r\n\t\t\t\tdomStyle.parts[j](item.parts[j]);\r\n\t\t\t}\r\n\t\t\tfor(; j < item.parts.length; j++) {\r\n\t\t\t\tdomStyle.parts.push(addStyle(item.parts[j], options));\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tvar parts = [];\r\n\t\t\tfor(var j = 0; j < item.parts.length; j++) {\r\n\t\t\t\tparts.push(addStyle(item.parts[j], options));\r\n\t\t\t}\r\n\t\t\tstylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};\r\n\t\t}\r\n\t}\r\n}\r\n\r\nfunction listToStyles(list) {\r\n\tvar styles = [];\r\n\tvar newStyles = {};\r\n\tfor(var i = 0; i < list.length; i++) {\r\n\t\tvar item = list[i];\r\n\t\tvar id = item[0];\r\n\t\tvar css = item[1];\r\n\t\tvar media = item[2];\r\n\t\tvar sourceMap = item[3];\r\n\t\tvar part = {css: css, media: media, sourceMap: sourceMap};\r\n\t\tif(!newStyles[id])\r\n\t\t\tstyles.push(newStyles[id] = {id: id, parts: [part]});\r\n\t\telse\r\n\t\t\tnewStyles[id].parts.push(part);\r\n\t}\r\n\treturn styles;\r\n}\r\n\r\nfunction createStyleElement() {\r\n\tvar styleElement = document.createElement(\"style\");\r\n\tvar head = getHeadElement();\r\n\tstyleElement.type = \"text/css\";\r\n\thead.appendChild(styleElement);\r\n\treturn styleElement;\r\n}\r\n\r\nfunction createLinkElement() {\r\n\tvar linkElement = document.createElement(\"link\");\r\n\tvar head = getHeadElement();\r\n\tlinkElement.rel = \"stylesheet\";\r\n\thead.appendChild(linkElement);\r\n\treturn linkElement;\r\n}\r\n\r\nfunction addStyle(obj, options) {\r\n\tvar styleElement, update, remove;\r\n\r\n\tif (options.singleton) {\r\n\t\tvar styleIndex = singletonCounter++;\r\n\t\tstyleElement = singletonElement || (singletonElement = createStyleElement());\r\n\t\tupdate = applyToSingletonTag.bind(null, styleElement, styleIndex, false);\r\n\t\tremove = applyToSingletonTag.bind(null, styleElement, styleIndex, true);\r\n\t} else if(obj.sourceMap &&\r\n\t\ttypeof URL === \"function\" &&\r\n\t\ttypeof URL.createObjectURL === \"function\" &&\r\n\t\ttypeof URL.revokeObjectURL === \"function\" &&\r\n\t\ttypeof Blob === \"function\" &&\r\n\t\ttypeof btoa === \"function\") {\r\n\t\tstyleElement = createLinkElement();\r\n\t\tupdate = updateLink.bind(null, styleElement);\r\n\t\tremove = function() {\r\n\t\t\tstyleElement.parentNode.removeChild(styleElement);\r\n\t\t\tif(styleElement.href)\r\n\t\t\t\tURL.revokeObjectURL(styleElement.href);\r\n\t\t};\r\n\t} else {\r\n\t\tstyleElement = createStyleElement();\r\n\t\tupdate = applyToTag.bind(null, styleElement);\r\n\t\tremove = function() {\r\n\t\t\tstyleElement.parentNode.removeChild(styleElement);\r\n\t\t};\r\n\t}\r\n\r\n\tupdate(obj);\r\n\r\n\treturn function updateStyle(newObj) {\r\n\t\tif(newObj) {\r\n\t\t\tif(newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap)\r\n\t\t\t\treturn;\r\n\t\t\tupdate(obj = newObj);\r\n\t\t} else {\r\n\t\t\tremove();\r\n\t\t}\r\n\t};\r\n}\r\n\r\nvar replaceText = (function () {\r\n\tvar textStore = [];\r\n\r\n\treturn function (index, replacement) {\r\n\t\ttextStore[index] = replacement;\r\n\t\treturn textStore.filter(Boolean).join('\\n');\r\n\t};\r\n})();\r\n\r\nfunction applyToSingletonTag(styleElement, index, remove, obj) {\r\n\tvar css = remove ? \"\" : obj.css;\r\n\r\n\tif (styleElement.styleSheet) {\r\n\t\tstyleElement.styleSheet.cssText = replaceText(index, css);\r\n\t} else {\r\n\t\tvar cssNode = document.createTextNode(css);\r\n\t\tvar childNodes = styleElement.childNodes;\r\n\t\tif (childNodes[index]) styleElement.removeChild(childNodes[index]);\r\n\t\tif (childNodes.length) {\r\n\t\t\tstyleElement.insertBefore(cssNode, childNodes[index]);\r\n\t\t} else {\r\n\t\t\tstyleElement.appendChild(cssNode);\r\n\t\t}\r\n\t}\r\n}\r\n\r\nfunction applyToTag(styleElement, obj) {\r\n\tvar css = obj.css;\r\n\tvar media = obj.media;\r\n\tvar sourceMap = obj.sourceMap;\r\n\r\n\tif(media) {\r\n\t\tstyleElement.setAttribute(\"media\", media)\r\n\t}\r\n\r\n\tif(styleElement.styleSheet) {\r\n\t\tstyleElement.styleSheet.cssText = css;\r\n\t} else {\r\n\t\twhile(styleElement.firstChild) {\r\n\t\t\tstyleElement.removeChild(styleElement.firstChild);\r\n\t\t}\r\n\t\tstyleElement.appendChild(document.createTextNode(css));\r\n\t}\r\n}\r\n\r\nfunction updateLink(linkElement, obj) {\r\n\tvar css = obj.css;\r\n\tvar media = obj.media;\r\n\tvar sourceMap = obj.sourceMap;\r\n\r\n\tif(sourceMap) {\r\n\t\t// http://stackoverflow.com/a/26603875\r\n\t\tcss += \"\\n/*# sourceMappingURL=data:application/json;base64,\" + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + \" */\";\r\n\t}\r\n\r\n\tvar blob = new Blob([css], { type: \"text/css\" });\r\n\r\n\tvar oldSrc = linkElement.href;\r\n\r\n\tlinkElement.href = URL.createObjectURL(blob);\r\n\r\n\tif(oldSrc)\r\n\t\tURL.revokeObjectURL(oldSrc);\r\n}\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** /home/amar/misc/Dropbox/projects/home/proto/~/style-loader/addStyles.js\n ** module id = 7\n ** module chunks = 0\n **/","// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = require(\"!!./../../../node_modules/css-loader/index.js!./../../../node_modules/stylus-loader/index.js!./standard.styl\");\nif(typeof content === 'string') content = [[module.id, content, '']];\n// add the styles to the DOM\nvar update = require(\"!./../../../node_modules/style-loader/addStyles.js\")(content, {});\nif(content.locals) module.exports = content.locals;\n// Hot Module Replacement\nif(module.hot) {\n\t// When the styles change, update the <style> tags\n\tif(!content.locals) {\n\t\tmodule.hot.accept(\"!!./../../../node_modules/css-loader/index.js!./../../../node_modules/stylus-loader/index.js!./standard.styl\", function() {\n\t\t\tvar newContent = require(\"!!./../../../node_modules/css-loader/index.js!./../../../node_modules/stylus-loader/index.js!./standard.styl\");\n\t\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\t\t\tupdate(newContent);\n\t\t});\n\t}\n\t// When the module is disposed, remove the <style> tags\n\tmodule.hot.dispose(function() { update(); });\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** /home/amar/misc/Dropbox/projects/home/proto/src/gfx/style/standard.styl\n ** module id = 8\n ** module chunks = 0\n **/","exports = module.exports = require(\"./../../../node_modules/css-loader/lib/css-base.js\")();\n// imports\n\n\n// module\nexports.push([module.id, \"\", \"\"]);\n\n// exports\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** /home/amar/misc/Dropbox/projects/home/proto/~/css-loader!/home/amar/misc/Dropbox/projects/home/proto/~/stylus-loader!/home/amar/misc/Dropbox/projects/home/proto/src/gfx/style/standard.styl\n ** module id = 9\n ** module chunks = 0\n **/","var self = self || {};// File:src/Three.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nvar THREE = { REVISION: '71' };\r\n\r\n// browserify support\r\n\r\nif ( typeof module === 'object' ) {\r\n\r\n\tmodule.exports = THREE;\r\n\r\n}\r\n\r\n// polyfills\r\n\r\nif ( Math.sign === undefined ) {\r\n\r\n\t// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/sign\r\n\r\n\tMath.sign = function ( x ) {\r\n\r\n\t\treturn ( x < 0 ) ? - 1 : ( x > 0 ) ? 1 : +x;\r\n\r\n\t};\r\n\r\n}\r\n\r\n\r\n// set the default log handlers\r\nTHREE.log = function() { console.log.apply( console, arguments ); }\r\nTHREE.warn = function() { console.warn.apply( console, arguments ); }\r\nTHREE.error = function() { console.error.apply( console, arguments ); }\r\n\r\n\r\n// https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent.button\r\n\r\nTHREE.MOUSE = { LEFT: 0, MIDDLE: 1, RIGHT: 2 };\r\n\r\n// GL STATE CONSTANTS\r\n\r\nTHREE.CullFaceNone = 0;\r\nTHREE.CullFaceBack = 1;\r\nTHREE.CullFaceFront = 2;\r\nTHREE.CullFaceFrontBack = 3;\r\n\r\nTHREE.FrontFaceDirectionCW = 0;\r\nTHREE.FrontFaceDirectionCCW = 1;\r\n\r\n// SHADOWING TYPES\r\n\r\nTHREE.BasicShadowMap = 0;\r\nTHREE.PCFShadowMap = 1;\r\nTHREE.PCFSoftShadowMap = 2;\r\n\r\n// MATERIAL CONSTANTS\r\n\r\n// side\r\n\r\nTHREE.FrontSide = 0;\r\nTHREE.BackSide = 1;\r\nTHREE.DoubleSide = 2;\r\n\r\n// shading\r\n\r\nTHREE.NoShading = 0;\r\nTHREE.FlatShading = 1;\r\nTHREE.SmoothShading = 2;\r\n\r\n// colors\r\n\r\nTHREE.NoColors = 0;\r\nTHREE.FaceColors = 1;\r\nTHREE.VertexColors = 2;\r\n\r\n// blending modes\r\n\r\nTHREE.NoBlending = 0;\r\nTHREE.NormalBlending = 1;\r\nTHREE.AdditiveBlending = 2;\r\nTHREE.SubtractiveBlending = 3;\r\nTHREE.MultiplyBlending = 4;\r\nTHREE.CustomBlending = 5;\r\n\r\n// custom blending equations\r\n// (numbers start from 100 not to clash with other\r\n//  mappings to OpenGL constants defined in Texture.js)\r\n\r\nTHREE.AddEquation = 100;\r\nTHREE.SubtractEquation = 101;\r\nTHREE.ReverseSubtractEquation = 102;\r\nTHREE.MinEquation = 103;\r\nTHREE.MaxEquation = 104;\r\n\r\n// custom blending destination factors\r\n\r\nTHREE.ZeroFactor = 200;\r\nTHREE.OneFactor = 201;\r\nTHREE.SrcColorFactor = 202;\r\nTHREE.OneMinusSrcColorFactor = 203;\r\nTHREE.SrcAlphaFactor = 204;\r\nTHREE.OneMinusSrcAlphaFactor = 205;\r\nTHREE.DstAlphaFactor = 206;\r\nTHREE.OneMinusDstAlphaFactor = 207;\r\n\r\n// custom blending source factors\r\n\r\n//THREE.ZeroFactor = 200;\r\n//THREE.OneFactor = 201;\r\n//THREE.SrcAlphaFactor = 204;\r\n//THREE.OneMinusSrcAlphaFactor = 205;\r\n//THREE.DstAlphaFactor = 206;\r\n//THREE.OneMinusDstAlphaFactor = 207;\r\nTHREE.DstColorFactor = 208;\r\nTHREE.OneMinusDstColorFactor = 209;\r\nTHREE.SrcAlphaSaturateFactor = 210;\r\n\r\n\r\n// TEXTURE CONSTANTS\r\n\r\nTHREE.MultiplyOperation = 0;\r\nTHREE.MixOperation = 1;\r\nTHREE.AddOperation = 2;\r\n\r\n// Mapping modes\r\n\r\nTHREE.UVMapping = 300;\r\n\r\nTHREE.CubeReflectionMapping = 301;\r\nTHREE.CubeRefractionMapping = 302;\r\n\r\nTHREE.EquirectangularReflectionMapping = 303;\r\nTHREE.EquirectangularRefractionMapping = 304;\r\n\r\nTHREE.SphericalReflectionMapping = 305;\r\n\r\n// Wrapping modes\r\n\r\nTHREE.RepeatWrapping = 1000;\r\nTHREE.ClampToEdgeWrapping = 1001;\r\nTHREE.MirroredRepeatWrapping = 1002;\r\n\r\n// Filters\r\n\r\nTHREE.NearestFilter = 1003;\r\nTHREE.NearestMipMapNearestFilter = 1004;\r\nTHREE.NearestMipMapLinearFilter = 1005;\r\nTHREE.LinearFilter = 1006;\r\nTHREE.LinearMipMapNearestFilter = 1007;\r\nTHREE.LinearMipMapLinearFilter = 1008;\r\n\r\n// Data types\r\n\r\nTHREE.UnsignedByteType = 1009;\r\nTHREE.ByteType = 1010;\r\nTHREE.ShortType = 1011;\r\nTHREE.UnsignedShortType = 1012;\r\nTHREE.IntType = 1013;\r\nTHREE.UnsignedIntType = 1014;\r\nTHREE.FloatType = 1015;\r\nTHREE.HalfFloatType = 1025;\r\n\r\n// Pixel types\r\n\r\n//THREE.UnsignedByteType = 1009;\r\nTHREE.UnsignedShort4444Type = 1016;\r\nTHREE.UnsignedShort5551Type = 1017;\r\nTHREE.UnsignedShort565Type = 1018;\r\n\r\n// Pixel formats\r\n\r\nTHREE.AlphaFormat = 1019;\r\nTHREE.RGBFormat = 1020;\r\nTHREE.RGBAFormat = 1021;\r\nTHREE.LuminanceFormat = 1022;\r\nTHREE.LuminanceAlphaFormat = 1023;\r\n// THREE.RGBEFormat handled as THREE.RGBAFormat in shaders\r\nTHREE.RGBEFormat = THREE.RGBAFormat; //1024;\r\n\r\n// DDS / ST3C Compressed texture formats\r\n\r\nTHREE.RGB_S3TC_DXT1_Format = 2001;\r\nTHREE.RGBA_S3TC_DXT1_Format = 2002;\r\nTHREE.RGBA_S3TC_DXT3_Format = 2003;\r\nTHREE.RGBA_S3TC_DXT5_Format = 2004;\r\n\r\n\r\n// PVRTC compressed texture formats\r\n\r\nTHREE.RGB_PVRTC_4BPPV1_Format = 2100;\r\nTHREE.RGB_PVRTC_2BPPV1_Format = 2101;\r\nTHREE.RGBA_PVRTC_4BPPV1_Format = 2102;\r\nTHREE.RGBA_PVRTC_2BPPV1_Format = 2103;\r\n\r\n\r\n// DEPRECATED\r\n\r\nTHREE.Projector = function () {\r\n\r\n\tTHREE.error( 'THREE.Projector has been moved to /examples/js/renderers/Projector.js.' );\r\n\r\n\tthis.projectVector = function ( vector, camera ) {\r\n\r\n\t\tTHREE.warn( 'THREE.Projector: .projectVector() is now vector.project().' );\r\n\t\tvector.project( camera );\r\n\r\n\t};\r\n\r\n\tthis.unprojectVector = function ( vector, camera ) {\r\n\r\n\t\tTHREE.warn( 'THREE.Projector: .unprojectVector() is now vector.unproject().' );\r\n\t\tvector.unproject( camera );\r\n\r\n\t};\r\n\r\n\tthis.pickingRay = function ( vector, camera ) {\r\n\r\n\t\tTHREE.error( 'THREE.Projector: .pickingRay() is now raycaster.setFromCamera().' );\r\n\r\n\t};\r\n\r\n};\r\n\r\nTHREE.CanvasRenderer = function () {\r\n\r\n\tTHREE.error( 'THREE.CanvasRenderer has been moved to /examples/js/renderers/CanvasRenderer.js' );\r\n\r\n\tthis.domElement = document.createElement( 'canvas' );\r\n\tthis.clear = function () {};\r\n\tthis.render = function () {};\r\n\tthis.setClearColor = function () {};\r\n\tthis.setSize = function () {};\r\n\r\n};\r\n\r\n// File:src/math/Color.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.Color = function ( color ) {\r\n\r\n\tif ( arguments.length === 3 ) {\r\n\r\n\t\treturn this.setRGB( arguments[ 0 ], arguments[ 1 ], arguments[ 2 ] );\r\n\r\n\t}\r\n\r\n\treturn this.set( color )\r\n\r\n};\r\n\r\nTHREE.Color.prototype = {\r\n\r\n\tconstructor: THREE.Color,\r\n\r\n\tr: 1, g: 1, b: 1,\r\n\r\n\tset: function ( value ) {\r\n\r\n\t\tif ( value instanceof THREE.Color ) {\r\n\r\n\t\t\tthis.copy( value );\r\n\r\n\t\t} else if ( typeof value === 'number' ) {\r\n\r\n\t\t\tthis.setHex( value );\r\n\r\n\t\t} else if ( typeof value === 'string' ) {\r\n\r\n\t\t\tthis.setStyle( value );\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetHex: function ( hex ) {\r\n\r\n\t\thex = Math.floor( hex );\r\n\r\n\t\tthis.r = ( hex >> 16 & 255 ) / 255;\r\n\t\tthis.g = ( hex >> 8 & 255 ) / 255;\r\n\t\tthis.b = ( hex & 255 ) / 255;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetRGB: function ( r, g, b ) {\r\n\r\n\t\tthis.r = r;\r\n\t\tthis.g = g;\r\n\t\tthis.b = b;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetHSL: function ( h, s, l ) {\r\n\r\n\t\t// h,s,l ranges are in 0.0 - 1.0\r\n\r\n\t\tif ( s === 0 ) {\r\n\r\n\t\t\tthis.r = this.g = this.b = l;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tvar hue2rgb = function ( p, q, t ) {\r\n\r\n\t\t\t\tif ( t < 0 ) t += 1;\r\n\t\t\t\tif ( t > 1 ) t -= 1;\r\n\t\t\t\tif ( t < 1 / 6 ) return p + ( q - p ) * 6 * t;\r\n\t\t\t\tif ( t < 1 / 2 ) return q;\r\n\t\t\t\tif ( t < 2 / 3 ) return p + ( q - p ) * 6 * ( 2 / 3 - t );\r\n\t\t\t\treturn p;\r\n\r\n\t\t\t};\r\n\r\n\t\t\tvar p = l <= 0.5 ? l * ( 1 + s ) : l + s - ( l * s );\r\n\t\t\tvar q = ( 2 * l ) - p;\r\n\r\n\t\t\tthis.r = hue2rgb( q, p, h + 1 / 3 );\r\n\t\t\tthis.g = hue2rgb( q, p, h );\r\n\t\t\tthis.b = hue2rgb( q, p, h - 1 / 3 );\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetStyle: function ( style ) {\r\n\r\n\t\t// rgb(255,0,0)\r\n\r\n\t\tif ( /^rgb\\((\\d+), ?(\\d+), ?(\\d+)\\)$/i.test( style ) ) {\r\n\r\n\t\t\tvar color = /^rgb\\((\\d+), ?(\\d+), ?(\\d+)\\)$/i.exec( style );\r\n\r\n\t\t\tthis.r = Math.min( 255, parseInt( color[ 1 ], 10 ) ) / 255;\r\n\t\t\tthis.g = Math.min( 255, parseInt( color[ 2 ], 10 ) ) / 255;\r\n\t\t\tthis.b = Math.min( 255, parseInt( color[ 3 ], 10 ) ) / 255;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t// rgb(100%,0%,0%)\r\n\r\n\t\tif ( /^rgb\\((\\d+)\\%, ?(\\d+)\\%, ?(\\d+)\\%\\)$/i.test( style ) ) {\r\n\r\n\t\t\tvar color = /^rgb\\((\\d+)\\%, ?(\\d+)\\%, ?(\\d+)\\%\\)$/i.exec( style );\r\n\r\n\t\t\tthis.r = Math.min( 100, parseInt( color[ 1 ], 10 ) ) / 100;\r\n\t\t\tthis.g = Math.min( 100, parseInt( color[ 2 ], 10 ) ) / 100;\r\n\t\t\tthis.b = Math.min( 100, parseInt( color[ 3 ], 10 ) ) / 100;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t// #ff0000\r\n\r\n\t\tif ( /^\\#([0-9a-f]{6})$/i.test( style ) ) {\r\n\r\n\t\t\tvar color = /^\\#([0-9a-f]{6})$/i.exec( style );\r\n\r\n\t\t\tthis.setHex( parseInt( color[ 1 ], 16 ) );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t// #f00\r\n\r\n\t\tif ( /^\\#([0-9a-f])([0-9a-f])([0-9a-f])$/i.test( style ) ) {\r\n\r\n\t\t\tvar color = /^\\#([0-9a-f])([0-9a-f])([0-9a-f])$/i.exec( style );\r\n\r\n\t\t\tthis.setHex( parseInt( color[ 1 ] + color[ 1 ] + color[ 2 ] + color[ 2 ] + color[ 3 ] + color[ 3 ], 16 ) );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\t// red\r\n\r\n\t\tif ( /^(\\w+)$/i.test( style ) ) {\r\n\r\n\t\t\tthis.setHex( THREE.ColorKeywords[ style ] );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\r\n\t},\r\n\r\n\tcopy: function ( color ) {\r\n\r\n\t\tthis.r = color.r;\r\n\t\tthis.g = color.g;\r\n\t\tthis.b = color.b;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tcopyGammaToLinear: function ( color, gammaFactor ) {\r\n\r\n\t\tif ( gammaFactor === undefined ) gammaFactor = 2.0;\r\n\r\n\t\tthis.r = Math.pow( color.r, gammaFactor );\r\n\t\tthis.g = Math.pow( color.g, gammaFactor );\r\n\t\tthis.b = Math.pow( color.b, gammaFactor );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tcopyLinearToGamma: function ( color, gammaFactor ) {\r\n\r\n\t\tif ( gammaFactor === undefined ) gammaFactor = 2.0;\r\n\r\n\t\tvar safeInverse = ( gammaFactor > 0 ) ? ( 1.0 / gammaFactor ) : 1.0;\r\n\r\n\t\tthis.r = Math.pow( color.r, safeInverse );\r\n\t\tthis.g = Math.pow( color.g, safeInverse );\r\n\t\tthis.b = Math.pow( color.b, safeInverse );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tconvertGammaToLinear: function () {\r\n\r\n\t\tvar r = this.r, g = this.g, b = this.b;\r\n\r\n\t\tthis.r = r * r;\r\n\t\tthis.g = g * g;\r\n\t\tthis.b = b * b;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tconvertLinearToGamma: function () {\r\n\r\n\t\tthis.r = Math.sqrt( this.r );\r\n\t\tthis.g = Math.sqrt( this.g );\r\n\t\tthis.b = Math.sqrt( this.b );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tgetHex: function () {\r\n\r\n\t\treturn ( this.r * 255 ) << 16 ^ ( this.g * 255 ) << 8 ^ ( this.b * 255 ) << 0;\r\n\r\n\t},\r\n\r\n\tgetHexString: function () {\r\n\r\n\t\treturn ( '000000' + this.getHex().toString( 16 ) ).slice( - 6 );\r\n\r\n\t},\r\n\r\n\tgetHSL: function ( optionalTarget ) {\r\n\r\n\t\t// h,s,l ranges are in 0.0 - 1.0\r\n\r\n\t\tvar hsl = optionalTarget || { h: 0, s: 0, l: 0 };\r\n\r\n\t\tvar r = this.r, g = this.g, b = this.b;\r\n\r\n\t\tvar max = Math.max( r, g, b );\r\n\t\tvar min = Math.min( r, g, b );\r\n\r\n\t\tvar hue, saturation;\r\n\t\tvar lightness = ( min + max ) / 2.0;\r\n\r\n\t\tif ( min === max ) {\r\n\r\n\t\t\thue = 0;\r\n\t\t\tsaturation = 0;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tvar delta = max - min;\r\n\r\n\t\t\tsaturation = lightness <= 0.5 ? delta / ( max + min ) : delta / ( 2 - max - min );\r\n\r\n\t\t\tswitch ( max ) {\r\n\r\n\t\t\t\tcase r: hue = ( g - b ) / delta + ( g < b ? 6 : 0 ); break;\r\n\t\t\t\tcase g: hue = ( b - r ) / delta + 2; break;\r\n\t\t\t\tcase b: hue = ( r - g ) / delta + 4; break;\r\n\r\n\t\t\t}\r\n\r\n\t\t\thue /= 6;\r\n\r\n\t\t}\r\n\r\n\t\thsl.h = hue;\r\n\t\thsl.s = saturation;\r\n\t\thsl.l = lightness;\r\n\r\n\t\treturn hsl;\r\n\r\n\t},\r\n\r\n\tgetStyle: function () {\r\n\r\n\t\treturn 'rgb(' + ( ( this.r * 255 ) | 0 ) + ',' + ( ( this.g * 255 ) | 0 ) + ',' + ( ( this.b * 255 ) | 0 ) + ')';\r\n\r\n\t},\r\n\r\n\toffsetHSL: function ( h, s, l ) {\r\n\r\n\t\tvar hsl = this.getHSL();\r\n\r\n\t\thsl.h += h; hsl.s += s; hsl.l += l;\r\n\r\n\t\tthis.setHSL( hsl.h, hsl.s, hsl.l );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tadd: function ( color ) {\r\n\r\n\t\tthis.r += color.r;\r\n\t\tthis.g += color.g;\r\n\t\tthis.b += color.b;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\taddColors: function ( color1, color2 ) {\r\n\r\n\t\tthis.r = color1.r + color2.r;\r\n\t\tthis.g = color1.g + color2.g;\r\n\t\tthis.b = color1.b + color2.b;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\taddScalar: function ( s ) {\r\n\r\n\t\tthis.r += s;\r\n\t\tthis.g += s;\r\n\t\tthis.b += s;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmultiply: function ( color ) {\r\n\r\n\t\tthis.r *= color.r;\r\n\t\tthis.g *= color.g;\r\n\t\tthis.b *= color.b;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmultiplyScalar: function ( s ) {\r\n\r\n\t\tthis.r *= s;\r\n\t\tthis.g *= s;\r\n\t\tthis.b *= s;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tlerp: function ( color, alpha ) {\r\n\r\n\t\tthis.r += ( color.r - this.r ) * alpha;\r\n\t\tthis.g += ( color.g - this.g ) * alpha;\r\n\t\tthis.b += ( color.b - this.b ) * alpha;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tequals: function ( c ) {\r\n\r\n\t\treturn ( c.r === this.r ) && ( c.g === this.g ) && ( c.b === this.b );\r\n\r\n\t},\r\n\r\n\tfromArray: function ( array ) {\r\n\r\n\t\tthis.r = array[ 0 ];\r\n\t\tthis.g = array[ 1 ];\r\n\t\tthis.b = array[ 2 ];\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\ttoArray: function ( array, offset ) {\r\n\r\n\t\tif ( array === undefined ) array = [];\r\n\t\tif ( offset === undefined ) offset = 0;\r\n\r\n\t\tarray[ offset ] = this.r;\r\n\t\tarray[ offset + 1 ] = this.g;\r\n\t\tarray[ offset + 2 ] = this.b;\r\n\r\n\t\treturn array;\r\n\t},\r\n\r\n\tclone: function () {\r\n\r\n\t\treturn new THREE.Color().setRGB( this.r, this.g, this.b );\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.ColorKeywords = { 'aliceblue': 0xF0F8FF, 'antiquewhite': 0xFAEBD7, 'aqua': 0x00FFFF, 'aquamarine': 0x7FFFD4, 'azure': 0xF0FFFF,\r\n'beige': 0xF5F5DC, 'bisque': 0xFFE4C4, 'black': 0x000000, 'blanchedalmond': 0xFFEBCD, 'blue': 0x0000FF, 'blueviolet': 0x8A2BE2,\r\n'brown': 0xA52A2A, 'burlywood': 0xDEB887, 'cadetblue': 0x5F9EA0, 'chartreuse': 0x7FFF00, 'chocolate': 0xD2691E, 'coral': 0xFF7F50,\r\n'cornflowerblue': 0x6495ED, 'cornsilk': 0xFFF8DC, 'crimson': 0xDC143C, 'cyan': 0x00FFFF, 'darkblue': 0x00008B, 'darkcyan': 0x008B8B,\r\n'darkgoldenrod': 0xB8860B, 'darkgray': 0xA9A9A9, 'darkgreen': 0x006400, 'darkgrey': 0xA9A9A9, 'darkkhaki': 0xBDB76B, 'darkmagenta': 0x8B008B,\r\n'darkolivegreen': 0x556B2F, 'darkorange': 0xFF8C00, 'darkorchid': 0x9932CC, 'darkred': 0x8B0000, 'darksalmon': 0xE9967A, 'darkseagreen': 0x8FBC8F,\r\n'darkslateblue': 0x483D8B, 'darkslategray': 0x2F4F4F, 'darkslategrey': 0x2F4F4F, 'darkturquoise': 0x00CED1, 'darkviolet': 0x9400D3,\r\n'deeppink': 0xFF1493, 'deepskyblue': 0x00BFFF, 'dimgray': 0x696969, 'dimgrey': 0x696969, 'dodgerblue': 0x1E90FF, 'firebrick': 0xB22222,\r\n'floralwhite': 0xFFFAF0, 'forestgreen': 0x228B22, 'fuchsia': 0xFF00FF, 'gainsboro': 0xDCDCDC, 'ghostwhite': 0xF8F8FF, 'gold': 0xFFD700,\r\n'goldenrod': 0xDAA520, 'gray': 0x808080, 'green': 0x008000, 'greenyellow': 0xADFF2F, 'grey': 0x808080, 'honeydew': 0xF0FFF0, 'hotpink': 0xFF69B4,\r\n'indianred': 0xCD5C5C, 'indigo': 0x4B0082, 'ivory': 0xFFFFF0, 'khaki': 0xF0E68C, 'lavender': 0xE6E6FA, 'lavenderblush': 0xFFF0F5, 'lawngreen': 0x7CFC00,\r\n'lemonchiffon': 0xFFFACD, 'lightblue': 0xADD8E6, 'lightcoral': 0xF08080, 'lightcyan': 0xE0FFFF, 'lightgoldenrodyellow': 0xFAFAD2, 'lightgray': 0xD3D3D3,\r\n'lightgreen': 0x90EE90, 'lightgrey': 0xD3D3D3, 'lightpink': 0xFFB6C1, 'lightsalmon': 0xFFA07A, 'lightseagreen': 0x20B2AA, 'lightskyblue': 0x87CEFA,\r\n'lightslategray': 0x778899, 'lightslategrey': 0x778899, 'lightsteelblue': 0xB0C4DE, 'lightyellow': 0xFFFFE0, 'lime': 0x00FF00, 'limegreen': 0x32CD32,\r\n'linen': 0xFAF0E6, 'magenta': 0xFF00FF, 'maroon': 0x800000, 'mediumaquamarine': 0x66CDAA, 'mediumblue': 0x0000CD, 'mediumorchid': 0xBA55D3,\r\n'mediumpurple': 0x9370DB, 'mediumseagreen': 0x3CB371, 'mediumslateblue': 0x7B68EE, 'mediumspringgreen': 0x00FA9A, 'mediumturquoise': 0x48D1CC,\r\n'mediumvioletred': 0xC71585, 'midnightblue': 0x191970, 'mintcream': 0xF5FFFA, 'mistyrose': 0xFFE4E1, 'moccasin': 0xFFE4B5, 'navajowhite': 0xFFDEAD,\r\n'navy': 0x000080, 'oldlace': 0xFDF5E6, 'olive': 0x808000, 'olivedrab': 0x6B8E23, 'orange': 0xFFA500, 'orangered': 0xFF4500, 'orchid': 0xDA70D6,\r\n'palegoldenrod': 0xEEE8AA, 'palegreen': 0x98FB98, 'paleturquoise': 0xAFEEEE, 'palevioletred': 0xDB7093, 'papayawhip': 0xFFEFD5, 'peachpuff': 0xFFDAB9,\r\n'peru': 0xCD853F, 'pink': 0xFFC0CB, 'plum': 0xDDA0DD, 'powderblue': 0xB0E0E6, 'purple': 0x800080, 'red': 0xFF0000, 'rosybrown': 0xBC8F8F,\r\n'royalblue': 0x4169E1, 'saddlebrown': 0x8B4513, 'salmon': 0xFA8072, 'sandybrown': 0xF4A460, 'seagreen': 0x2E8B57, 'seashell': 0xFFF5EE,\r\n'sienna': 0xA0522D, 'silver': 0xC0C0C0, 'skyblue': 0x87CEEB, 'slateblue': 0x6A5ACD, 'slategray': 0x708090, 'slategrey': 0x708090, 'snow': 0xFFFAFA,\r\n'springgreen': 0x00FF7F, 'steelblue': 0x4682B4, 'tan': 0xD2B48C, 'teal': 0x008080, 'thistle': 0xD8BFD8, 'tomato': 0xFF6347, 'turquoise': 0x40E0D0,\r\n'violet': 0xEE82EE, 'wheat': 0xF5DEB3, 'white': 0xFFFFFF, 'whitesmoke': 0xF5F5F5, 'yellow': 0xFFFF00, 'yellowgreen': 0x9ACD32 };\r\n\r\n// File:src/math/Quaternion.js\r\n\r\n/**\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author WestLangley / http://github.com/WestLangley\r\n * @author bhouston / http://exocortex.com\r\n */\r\n\r\nTHREE.Quaternion = function ( x, y, z, w ) {\r\n\r\n\tthis._x = x || 0;\r\n\tthis._y = y || 0;\r\n\tthis._z = z || 0;\r\n\tthis._w = ( w !== undefined ) ? w : 1;\r\n\r\n};\r\n\r\nTHREE.Quaternion.prototype = {\r\n\r\n\tconstructor: THREE.Quaternion,\r\n\r\n\t_x: 0,_y: 0, _z: 0, _w: 0,\r\n\r\n\tget x () {\r\n\r\n\t\treturn this._x;\r\n\r\n\t},\r\n\r\n\tset x ( value ) {\r\n\r\n\t\tthis._x = value;\r\n\t\tthis.onChangeCallback();\r\n\r\n\t},\r\n\r\n\tget y () {\r\n\r\n\t\treturn this._y;\r\n\r\n\t},\r\n\r\n\tset y ( value ) {\r\n\r\n\t\tthis._y = value;\r\n\t\tthis.onChangeCallback();\r\n\r\n\t},\r\n\r\n\tget z () {\r\n\r\n\t\treturn this._z;\r\n\r\n\t},\r\n\r\n\tset z ( value ) {\r\n\r\n\t\tthis._z = value;\r\n\t\tthis.onChangeCallback();\r\n\r\n\t},\r\n\r\n\tget w () {\r\n\r\n\t\treturn this._w;\r\n\r\n\t},\r\n\r\n\tset w ( value ) {\r\n\r\n\t\tthis._w = value;\r\n\t\tthis.onChangeCallback();\r\n\r\n\t},\r\n\r\n\tset: function ( x, y, z, w ) {\r\n\r\n\t\tthis._x = x;\r\n\t\tthis._y = y;\r\n\t\tthis._z = z;\r\n\t\tthis._w = w;\r\n\r\n\t\tthis.onChangeCallback();\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tcopy: function ( quaternion ) {\r\n\r\n\t\tthis._x = quaternion.x;\r\n\t\tthis._y = quaternion.y;\r\n\t\tthis._z = quaternion.z;\r\n\t\tthis._w = quaternion.w;\r\n\r\n\t\tthis.onChangeCallback();\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetFromEuler: function ( euler, update ) {\r\n\r\n\t\tif ( euler instanceof THREE.Euler === false ) {\r\n\r\n\t\t\tthrow new Error( 'THREE.Quaternion: .setFromEuler() now expects a Euler rotation rather than a Vector3 and order.' );\r\n\t\t}\r\n\r\n\t\t// http://www.mathworks.com/matlabcentral/fileexchange/\r\n\t\t// \t20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/\r\n\t\t//\tcontent/SpinCalc.m\r\n\r\n\t\tvar c1 = Math.cos( euler._x / 2 );\r\n\t\tvar c2 = Math.cos( euler._y / 2 );\r\n\t\tvar c3 = Math.cos( euler._z / 2 );\r\n\t\tvar s1 = Math.sin( euler._x / 2 );\r\n\t\tvar s2 = Math.sin( euler._y / 2 );\r\n\t\tvar s3 = Math.sin( euler._z / 2 );\r\n\r\n\t\tif ( euler.order === 'XYZ' ) {\r\n\r\n\t\t\tthis._x = s1 * c2 * c3 + c1 * s2 * s3;\r\n\t\t\tthis._y = c1 * s2 * c3 - s1 * c2 * s3;\r\n\t\t\tthis._z = c1 * c2 * s3 + s1 * s2 * c3;\r\n\t\t\tthis._w = c1 * c2 * c3 - s1 * s2 * s3;\r\n\r\n\t\t} else if ( euler.order === 'YXZ' ) {\r\n\r\n\t\t\tthis._x = s1 * c2 * c3 + c1 * s2 * s3;\r\n\t\t\tthis._y = c1 * s2 * c3 - s1 * c2 * s3;\r\n\t\t\tthis._z = c1 * c2 * s3 - s1 * s2 * c3;\r\n\t\t\tthis._w = c1 * c2 * c3 + s1 * s2 * s3;\r\n\r\n\t\t} else if ( euler.order === 'ZXY' ) {\r\n\r\n\t\t\tthis._x = s1 * c2 * c3 - c1 * s2 * s3;\r\n\t\t\tthis._y = c1 * s2 * c3 + s1 * c2 * s3;\r\n\t\t\tthis._z = c1 * c2 * s3 + s1 * s2 * c3;\r\n\t\t\tthis._w = c1 * c2 * c3 - s1 * s2 * s3;\r\n\r\n\t\t} else if ( euler.order === 'ZYX' ) {\r\n\r\n\t\t\tthis._x = s1 * c2 * c3 - c1 * s2 * s3;\r\n\t\t\tthis._y = c1 * s2 * c3 + s1 * c2 * s3;\r\n\t\t\tthis._z = c1 * c2 * s3 - s1 * s2 * c3;\r\n\t\t\tthis._w = c1 * c2 * c3 + s1 * s2 * s3;\r\n\r\n\t\t} else if ( euler.order === 'YZX' ) {\r\n\r\n\t\t\tthis._x = s1 * c2 * c3 + c1 * s2 * s3;\r\n\t\t\tthis._y = c1 * s2 * c3 + s1 * c2 * s3;\r\n\t\t\tthis._z = c1 * c2 * s3 - s1 * s2 * c3;\r\n\t\t\tthis._w = c1 * c2 * c3 - s1 * s2 * s3;\r\n\r\n\t\t} else if ( euler.order === 'XZY' ) {\r\n\r\n\t\t\tthis._x = s1 * c2 * c3 - c1 * s2 * s3;\r\n\t\t\tthis._y = c1 * s2 * c3 - s1 * c2 * s3;\r\n\t\t\tthis._z = c1 * c2 * s3 + s1 * s2 * c3;\r\n\t\t\tthis._w = c1 * c2 * c3 + s1 * s2 * s3;\r\n\r\n\t\t}\r\n\r\n\t\tif ( update !== false ) this.onChangeCallback();\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetFromAxisAngle: function ( axis, angle ) {\r\n\r\n\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm\r\n\r\n\t\t// assumes axis is normalized\r\n\r\n\t\tvar halfAngle = angle / 2, s = Math.sin( halfAngle );\r\n\r\n\t\tthis._x = axis.x * s;\r\n\t\tthis._y = axis.y * s;\r\n\t\tthis._z = axis.z * s;\r\n\t\tthis._w = Math.cos( halfAngle );\r\n\r\n\t\tthis.onChangeCallback();\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetFromRotationMatrix: function ( m ) {\r\n\r\n\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm\r\n\r\n\t\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\r\n\r\n\t\tvar te = m.elements,\r\n\r\n\t\t\tm11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],\r\n\t\t\tm21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],\r\n\t\t\tm31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ],\r\n\r\n\t\t\ttrace = m11 + m22 + m33,\r\n\t\t\ts;\r\n\r\n\t\tif ( trace > 0 ) {\r\n\r\n\t\t\ts = 0.5 / Math.sqrt( trace + 1.0 );\r\n\r\n\t\t\tthis._w = 0.25 / s;\r\n\t\t\tthis._x = ( m32 - m23 ) * s;\r\n\t\t\tthis._y = ( m13 - m31 ) * s;\r\n\t\t\tthis._z = ( m21 - m12 ) * s;\r\n\r\n\t\t} else if ( m11 > m22 && m11 > m33 ) {\r\n\r\n\t\t\ts = 2.0 * Math.sqrt( 1.0 + m11 - m22 - m33 );\r\n\r\n\t\t\tthis._w = ( m32 - m23 ) / s;\r\n\t\t\tthis._x = 0.25 * s;\r\n\t\t\tthis._y = ( m12 + m21 ) / s;\r\n\t\t\tthis._z = ( m13 + m31 ) / s;\r\n\r\n\t\t} else if ( m22 > m33 ) {\r\n\r\n\t\t\ts = 2.0 * Math.sqrt( 1.0 + m22 - m11 - m33 );\r\n\r\n\t\t\tthis._w = ( m13 - m31 ) / s;\r\n\t\t\tthis._x = ( m12 + m21 ) / s;\r\n\t\t\tthis._y = 0.25 * s;\r\n\t\t\tthis._z = ( m23 + m32 ) / s;\r\n\r\n\t\t} else {\r\n\r\n\t\t\ts = 2.0 * Math.sqrt( 1.0 + m33 - m11 - m22 );\r\n\r\n\t\t\tthis._w = ( m21 - m12 ) / s;\r\n\t\t\tthis._x = ( m13 + m31 ) / s;\r\n\t\t\tthis._y = ( m23 + m32 ) / s;\r\n\t\t\tthis._z = 0.25 * s;\r\n\r\n\t\t}\r\n\r\n\t\tthis.onChangeCallback();\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetFromUnitVectors: function () {\r\n\r\n\t\t// http://lolengine.net/blog/2014/02/24/quaternion-from-two-vectors-final\r\n\r\n\t\t// assumes direction vectors vFrom and vTo are normalized\r\n\r\n\t\tvar v1, r;\r\n\r\n\t\tvar EPS = 0.000001;\r\n\r\n\t\treturn function ( vFrom, vTo ) {\r\n\r\n\t\t\tif ( v1 === undefined ) v1 = new THREE.Vector3();\r\n\r\n\t\t\tr = vFrom.dot( vTo ) + 1;\r\n\r\n\t\t\tif ( r < EPS ) {\r\n\r\n\t\t\t\tr = 0;\r\n\r\n\t\t\t\tif ( Math.abs( vFrom.x ) > Math.abs( vFrom.z ) ) {\r\n\r\n\t\t\t\t\tv1.set( - vFrom.y, vFrom.x, 0 );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tv1.set( 0, - vFrom.z, vFrom.y );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tv1.crossVectors( vFrom, vTo );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis._x = v1.x;\r\n\t\t\tthis._y = v1.y;\r\n\t\t\tthis._z = v1.z;\r\n\t\t\tthis._w = r;\r\n\r\n\t\t\tthis.normalize();\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t}(),\r\n\r\n\tinverse: function () {\r\n\r\n\t\tthis.conjugate().normalize();\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tconjugate: function () {\r\n\r\n\t\tthis._x *= - 1;\r\n\t\tthis._y *= - 1;\r\n\t\tthis._z *= - 1;\r\n\r\n\t\tthis.onChangeCallback();\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tdot: function ( v ) {\r\n\r\n\t\treturn this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;\r\n\r\n\t},\r\n\r\n\tlengthSq: function () {\r\n\r\n\t\treturn this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;\r\n\r\n\t},\r\n\r\n\tlength: function () {\r\n\r\n\t\treturn Math.sqrt( this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w );\r\n\r\n\t},\r\n\r\n\tnormalize: function () {\r\n\r\n\t\tvar l = this.length();\r\n\r\n\t\tif ( l === 0 ) {\r\n\r\n\t\t\tthis._x = 0;\r\n\t\t\tthis._y = 0;\r\n\t\t\tthis._z = 0;\r\n\t\t\tthis._w = 1;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tl = 1 / l;\r\n\r\n\t\t\tthis._x = this._x * l;\r\n\t\t\tthis._y = this._y * l;\r\n\t\t\tthis._z = this._z * l;\r\n\t\t\tthis._w = this._w * l;\r\n\r\n\t\t}\r\n\r\n\t\tthis.onChangeCallback();\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmultiply: function ( q, p ) {\r\n\r\n\t\tif ( p !== undefined ) {\r\n\r\n\t\t\tTHREE.warn( 'THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.' );\r\n\t\t\treturn this.multiplyQuaternions( q, p );\r\n\r\n\t\t}\r\n\r\n\t\treturn this.multiplyQuaternions( this, q );\r\n\r\n\t},\r\n\r\n\tmultiplyQuaternions: function ( a, b ) {\r\n\r\n\t\t// from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm\r\n\r\n\t\tvar qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;\r\n\t\tvar qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;\r\n\r\n\t\tthis._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;\r\n\t\tthis._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;\r\n\t\tthis._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;\r\n\t\tthis._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;\r\n\r\n\t\tthis.onChangeCallback();\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmultiplyVector3: function ( vector ) {\r\n\r\n\t\tTHREE.warn( 'THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.' );\r\n\t\treturn vector.applyQuaternion( this );\r\n\r\n\t},\r\n\r\n\tslerp: function ( qb, t ) {\r\n\r\n\t\tif ( t === 0 ) return this;\r\n\t\tif ( t === 1 ) return this.copy( qb );\r\n\r\n\t\tvar x = this._x, y = this._y, z = this._z, w = this._w;\r\n\r\n\t\t// http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/\r\n\r\n\t\tvar cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;\r\n\r\n\t\tif ( cosHalfTheta < 0 ) {\r\n\r\n\t\t\tthis._w = - qb._w;\r\n\t\t\tthis._x = - qb._x;\r\n\t\t\tthis._y = - qb._y;\r\n\t\t\tthis._z = - qb._z;\r\n\r\n\t\t\tcosHalfTheta = - cosHalfTheta;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tthis.copy( qb );\r\n\r\n\t\t}\r\n\r\n\t\tif ( cosHalfTheta >= 1.0 ) {\r\n\r\n\t\t\tthis._w = w;\r\n\t\t\tthis._x = x;\r\n\t\t\tthis._y = y;\r\n\t\t\tthis._z = z;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\tvar halfTheta = Math.acos( cosHalfTheta );\r\n\t\tvar sinHalfTheta = Math.sqrt( 1.0 - cosHalfTheta * cosHalfTheta );\r\n\r\n\t\tif ( Math.abs( sinHalfTheta ) < 0.001 ) {\r\n\r\n\t\t\tthis._w = 0.5 * ( w + this._w );\r\n\t\t\tthis._x = 0.5 * ( x + this._x );\r\n\t\t\tthis._y = 0.5 * ( y + this._y );\r\n\t\t\tthis._z = 0.5 * ( z + this._z );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\tvar ratioA = Math.sin( ( 1 - t ) * halfTheta ) / sinHalfTheta,\r\n\t\tratioB = Math.sin( t * halfTheta ) / sinHalfTheta;\r\n\r\n\t\tthis._w = ( w * ratioA + this._w * ratioB );\r\n\t\tthis._x = ( x * ratioA + this._x * ratioB );\r\n\t\tthis._y = ( y * ratioA + this._y * ratioB );\r\n\t\tthis._z = ( z * ratioA + this._z * ratioB );\r\n\r\n\t\tthis.onChangeCallback();\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tequals: function ( quaternion ) {\r\n\r\n\t\treturn ( quaternion._x === this._x ) && ( quaternion._y === this._y ) && ( quaternion._z === this._z ) && ( quaternion._w === this._w );\r\n\r\n\t},\r\n\r\n\tfromArray: function ( array, offset ) {\r\n\r\n\t\tif ( offset === undefined ) offset = 0;\r\n\r\n\t\tthis._x = array[ offset ];\r\n\t\tthis._y = array[ offset + 1 ];\r\n\t\tthis._z = array[ offset + 2 ];\r\n\t\tthis._w = array[ offset + 3 ];\r\n\r\n\t\tthis.onChangeCallback();\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\ttoArray: function ( array, offset ) {\r\n\r\n\t\tif ( array === undefined ) array = [];\r\n\t\tif ( offset === undefined ) offset = 0;\r\n\r\n\t\tarray[ offset ] = this._x;\r\n\t\tarray[ offset + 1 ] = this._y;\r\n\t\tarray[ offset + 2 ] = this._z;\r\n\t\tarray[ offset + 3 ] = this._w;\r\n\r\n\t\treturn array;\r\n\r\n\t},\r\n\r\n\tonChange: function ( callback ) {\r\n\r\n\t\tthis.onChangeCallback = callback;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tonChangeCallback: function () {},\r\n\r\n\tclone: function () {\r\n\r\n\t\treturn new THREE.Quaternion( this._x, this._y, this._z, this._w );\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.Quaternion.slerp = function ( qa, qb, qm, t ) {\r\n\r\n\treturn qm.copy( qa ).slerp( qb, t );\r\n\r\n}\r\n\r\n// File:src/math/Vector2.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author philogb / http://blog.thejit.org/\r\n * @author egraether / http://egraether.com/\r\n * @author zz85 / http://www.lab4games.net/zz85/blog\r\n */\r\n\r\nTHREE.Vector2 = function ( x, y ) {\r\n\r\n\tthis.x = x || 0;\r\n\tthis.y = y || 0;\r\n\r\n};\r\n\r\nTHREE.Vector2.prototype = {\r\n\r\n\tconstructor: THREE.Vector2,\r\n\r\n\tset: function ( x, y ) {\r\n\r\n\t\tthis.x = x;\r\n\t\tthis.y = y;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetX: function ( x ) {\r\n\r\n\t\tthis.x = x;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetY: function ( y ) {\r\n\r\n\t\tthis.y = y;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetComponent: function ( index, value ) {\r\n\r\n\t\tswitch ( index ) {\r\n\r\n\t\t\tcase 0: this.x = value; break;\r\n\t\t\tcase 1: this.y = value; break;\r\n\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tgetComponent: function ( index ) {\r\n\r\n\t\tswitch ( index ) {\r\n\r\n\t\t\tcase 0: return this.x;\r\n\t\t\tcase 1: return this.y;\r\n\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tcopy: function ( v ) {\r\n\r\n\t\tthis.x = v.x;\r\n\t\tthis.y = v.y;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tadd: function ( v, w ) {\r\n\r\n\t\tif ( w !== undefined ) {\r\n\r\n\t\t\tTHREE.warn( 'THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );\r\n\t\t\treturn this.addVectors( v, w );\r\n\r\n\t\t}\r\n\r\n\t\tthis.x += v.x;\r\n\t\tthis.y += v.y;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\taddScalar: function ( s ) {\r\n\r\n\t\tthis.x += s;\r\n\t\tthis.y += s;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\taddVectors: function ( a, b ) {\r\n\r\n\t\tthis.x = a.x + b.x;\r\n\t\tthis.y = a.y + b.y;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsub: function ( v, w ) {\r\n\r\n\t\tif ( w !== undefined ) {\r\n\r\n\t\t\tTHREE.warn( 'THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );\r\n\t\t\treturn this.subVectors( v, w );\r\n\r\n\t\t}\r\n\r\n\t\tthis.x -= v.x;\r\n\t\tthis.y -= v.y;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsubScalar: function ( s ) {\r\n\r\n\t\tthis.x -= s;\r\n\t\tthis.y -= s;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsubVectors: function ( a, b ) {\r\n\r\n\t\tthis.x = a.x - b.x;\r\n\t\tthis.y = a.y - b.y;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmultiply: function ( v ) {\r\n\r\n\t\tthis.x *= v.x;\r\n\t\tthis.y *= v.y;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmultiplyScalar: function ( s ) {\r\n\r\n\t\tthis.x *= s;\r\n\t\tthis.y *= s;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tdivide: function ( v ) {\r\n\r\n\t\tthis.x /= v.x;\r\n\t\tthis.y /= v.y;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tdivideScalar: function ( scalar ) {\r\n\r\n\t\tif ( scalar !== 0 ) {\r\n\r\n\t\t\tvar invScalar = 1 / scalar;\r\n\r\n\t\t\tthis.x *= invScalar;\r\n\t\t\tthis.y *= invScalar;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tthis.x = 0;\r\n\t\t\tthis.y = 0;\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmin: function ( v ) {\r\n\r\n\t\tif ( this.x > v.x ) {\r\n\r\n\t\t\tthis.x = v.x;\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.y > v.y ) {\r\n\r\n\t\t\tthis.y = v.y;\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmax: function ( v ) {\r\n\r\n\t\tif ( this.x < v.x ) {\r\n\r\n\t\t\tthis.x = v.x;\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.y < v.y ) {\r\n\r\n\t\t\tthis.y = v.y;\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tclamp: function ( min, max ) {\r\n\r\n\t\t// This function assumes min < max, if this assumption isn't true it will not operate correctly\r\n\r\n\t\tif ( this.x < min.x ) {\r\n\r\n\t\t\tthis.x = min.x;\r\n\r\n\t\t} else if ( this.x > max.x ) {\r\n\r\n\t\t\tthis.x = max.x;\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.y < min.y ) {\r\n\r\n\t\t\tthis.y = min.y;\r\n\r\n\t\t} else if ( this.y > max.y ) {\r\n\r\n\t\t\tthis.y = max.y;\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tclampScalar: ( function () {\r\n\r\n\t\tvar min, max;\r\n\r\n\t\treturn function ( minVal, maxVal ) {\r\n\r\n\t\t\tif ( min === undefined ) {\r\n\r\n\t\t\t\tmin = new THREE.Vector2();\r\n\t\t\t\tmax = new THREE.Vector2();\r\n\r\n\t\t\t}\r\n\r\n\t\t\tmin.set( minVal, minVal );\r\n\t\t\tmax.set( maxVal, maxVal );\r\n\r\n\t\t\treturn this.clamp( min, max );\r\n\r\n\t\t};\r\n\r\n\t} )(),\r\n\r\n\tfloor: function () {\r\n\r\n\t\tthis.x = Math.floor( this.x );\r\n\t\tthis.y = Math.floor( this.y );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tceil: function () {\r\n\r\n\t\tthis.x = Math.ceil( this.x );\r\n\t\tthis.y = Math.ceil( this.y );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tround: function () {\r\n\r\n\t\tthis.x = Math.round( this.x );\r\n\t\tthis.y = Math.round( this.y );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\troundToZero: function () {\r\n\r\n\t\tthis.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );\r\n\t\tthis.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tnegate: function () {\r\n\r\n\t\tthis.x = - this.x;\r\n\t\tthis.y = - this.y;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tdot: function ( v ) {\r\n\r\n\t\treturn this.x * v.x + this.y * v.y;\r\n\r\n\t},\r\n\r\n\tlengthSq: function () {\r\n\r\n\t\treturn this.x * this.x + this.y * this.y;\r\n\r\n\t},\r\n\r\n\tlength: function () {\r\n\r\n\t\treturn Math.sqrt( this.x * this.x + this.y * this.y );\r\n\r\n\t},\r\n\r\n\tnormalize: function () {\r\n\r\n\t\treturn this.divideScalar( this.length() );\r\n\r\n\t},\r\n\r\n\tdistanceTo: function ( v ) {\r\n\r\n\t\treturn Math.sqrt( this.distanceToSquared( v ) );\r\n\r\n\t},\r\n\r\n\tdistanceToSquared: function ( v ) {\r\n\r\n\t\tvar dx = this.x - v.x, dy = this.y - v.y;\r\n\t\treturn dx * dx + dy * dy;\r\n\r\n\t},\r\n\r\n\tsetLength: function ( l ) {\r\n\r\n\t\tvar oldLength = this.length();\r\n\r\n\t\tif ( oldLength !== 0 && l !== oldLength ) {\r\n\r\n\t\t\tthis.multiplyScalar( l / oldLength );\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tlerp: function ( v, alpha ) {\r\n\r\n\t\tthis.x += ( v.x - this.x ) * alpha;\r\n\t\tthis.y += ( v.y - this.y ) * alpha;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tlerpVectors: function ( v1, v2, alpha ) {\r\n\r\n\t\tthis.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tequals: function ( v ) {\r\n\r\n\t\treturn ( ( v.x === this.x ) && ( v.y === this.y ) );\r\n\r\n\t},\r\n\r\n\tfromArray: function ( array, offset ) {\r\n\r\n\t\tif ( offset === undefined ) offset = 0;\r\n\r\n\t\tthis.x = array[ offset ];\r\n\t\tthis.y = array[ offset + 1 ];\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\ttoArray: function ( array, offset ) {\r\n\r\n\t\tif ( array === undefined ) array = [];\r\n\t\tif ( offset === undefined ) offset = 0;\r\n\r\n\t\tarray[ offset ] = this.x;\r\n\t\tarray[ offset + 1 ] = this.y;\r\n\r\n\t\treturn array;\r\n\r\n\t},\r\n\r\n\tfromAttribute: function ( attribute, index, offset ) {\r\n\r\n\t\tif ( offset === undefined ) offset = 0;\r\n\r\n\t\tindex = index * attribute.itemSize + offset;\r\n\r\n\t\tthis.x = attribute.array[ index ];\r\n\t\tthis.y = attribute.array[ index + 1 ];\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tclone: function () {\r\n\r\n\t\treturn new THREE.Vector2( this.x, this.y );\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/math/Vector3.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author *kile / http://kile.stravaganza.org/\r\n * @author philogb / http://blog.thejit.org/\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author egraether / http://egraether.com/\r\n * @author WestLangley / http://github.com/WestLangley\r\n */\r\n\r\nTHREE.Vector3 = function ( x, y, z ) {\r\n\r\n\tthis.x = x || 0;\r\n\tthis.y = y || 0;\r\n\tthis.z = z || 0;\r\n\r\n};\r\n\r\nTHREE.Vector3.prototype = {\r\n\r\n\tconstructor: THREE.Vector3,\r\n\r\n\tset: function ( x, y, z ) {\r\n\r\n\t\tthis.x = x;\r\n\t\tthis.y = y;\r\n\t\tthis.z = z;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetX: function ( x ) {\r\n\r\n\t\tthis.x = x;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetY: function ( y ) {\r\n\r\n\t\tthis.y = y;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetZ: function ( z ) {\r\n\r\n\t\tthis.z = z;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetComponent: function ( index, value ) {\r\n\r\n\t\tswitch ( index ) {\r\n\r\n\t\t\tcase 0: this.x = value; break;\r\n\t\t\tcase 1: this.y = value; break;\r\n\t\t\tcase 2: this.z = value; break;\r\n\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tgetComponent: function ( index ) {\r\n\r\n\t\tswitch ( index ) {\r\n\r\n\t\t\tcase 0: return this.x;\r\n\t\t\tcase 1: return this.y;\r\n\t\t\tcase 2: return this.z;\r\n\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tcopy: function ( v ) {\r\n\r\n\t\tthis.x = v.x;\r\n\t\tthis.y = v.y;\r\n\t\tthis.z = v.z;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tadd: function ( v, w ) {\r\n\r\n\t\tif ( w !== undefined ) {\r\n\r\n\t\t\tTHREE.warn( 'THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );\r\n\t\t\treturn this.addVectors( v, w );\r\n\r\n\t\t}\r\n\r\n\t\tthis.x += v.x;\r\n\t\tthis.y += v.y;\r\n\t\tthis.z += v.z;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\taddScalar: function ( s ) {\r\n\r\n\t\tthis.x += s;\r\n\t\tthis.y += s;\r\n\t\tthis.z += s;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\taddVectors: function ( a, b ) {\r\n\r\n\t\tthis.x = a.x + b.x;\r\n\t\tthis.y = a.y + b.y;\r\n\t\tthis.z = a.z + b.z;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsub: function ( v, w ) {\r\n\r\n\t\tif ( w !== undefined ) {\r\n\r\n\t\t\tTHREE.warn( 'THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );\r\n\t\t\treturn this.subVectors( v, w );\r\n\r\n\t\t}\r\n\r\n\t\tthis.x -= v.x;\r\n\t\tthis.y -= v.y;\r\n\t\tthis.z -= v.z;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\t\r\n\tsubScalar: function ( s ) {\r\n\r\n\t\tthis.x -= s;\r\n\t\tthis.y -= s;\r\n\t\tthis.z -= s;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsubVectors: function ( a, b ) {\r\n\r\n\t\tthis.x = a.x - b.x;\r\n\t\tthis.y = a.y - b.y;\r\n\t\tthis.z = a.z - b.z;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmultiply: function ( v, w ) {\r\n\r\n\t\tif ( w !== undefined ) {\r\n\r\n\t\t\tTHREE.warn( 'THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.' );\r\n\t\t\treturn this.multiplyVectors( v, w );\r\n\r\n\t\t}\r\n\r\n\t\tthis.x *= v.x;\r\n\t\tthis.y *= v.y;\r\n\t\tthis.z *= v.z;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmultiplyScalar: function ( scalar ) {\r\n\r\n\t\tthis.x *= scalar;\r\n\t\tthis.y *= scalar;\r\n\t\tthis.z *= scalar;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmultiplyVectors: function ( a, b ) {\r\n\r\n\t\tthis.x = a.x * b.x;\r\n\t\tthis.y = a.y * b.y;\r\n\t\tthis.z = a.z * b.z;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tapplyEuler: function () {\r\n\r\n\t\tvar quaternion;\r\n\r\n\t\treturn function ( euler ) {\r\n\r\n\t\t\tif ( euler instanceof THREE.Euler === false ) {\r\n\r\n\t\t\t\tTHREE.error( 'THREE.Vector3: .applyEuler() now expects a Euler rotation rather than a Vector3 and order.' );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( quaternion === undefined ) quaternion = new THREE.Quaternion();\r\n\r\n\t\t\tthis.applyQuaternion( quaternion.setFromEuler( euler ) );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tapplyAxisAngle: function () {\r\n\r\n\t\tvar quaternion;\r\n\r\n\t\treturn function ( axis, angle ) {\r\n\r\n\t\t\tif ( quaternion === undefined ) quaternion = new THREE.Quaternion();\r\n\r\n\t\t\tthis.applyQuaternion( quaternion.setFromAxisAngle( axis, angle ) );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tapplyMatrix3: function ( m ) {\r\n\r\n\t\tvar x = this.x;\r\n\t\tvar y = this.y;\r\n\t\tvar z = this.z;\r\n\r\n\t\tvar e = m.elements;\r\n\r\n\t\tthis.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ] * z;\r\n\t\tthis.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ] * z;\r\n\t\tthis.z = e[ 2 ] * x + e[ 5 ] * y + e[ 8 ] * z;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tapplyMatrix4: function ( m ) {\r\n\r\n\t\t// input: THREE.Matrix4 affine matrix\r\n\r\n\t\tvar x = this.x, y = this.y, z = this.z;\r\n\r\n\t\tvar e = m.elements;\r\n\r\n\t\tthis.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ]  * z + e[ 12 ];\r\n\t\tthis.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ]  * z + e[ 13 ];\r\n\t\tthis.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ];\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tapplyProjection: function ( m ) {\r\n\r\n\t\t// input: THREE.Matrix4 projection matrix\r\n\r\n\t\tvar x = this.x, y = this.y, z = this.z;\r\n\r\n\t\tvar e = m.elements;\r\n\t\tvar d = 1 / ( e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] ); // perspective divide\r\n\r\n\t\tthis.x = ( e[ 0 ] * x + e[ 4 ] * y + e[ 8 ]  * z + e[ 12 ] ) * d;\r\n\t\tthis.y = ( e[ 1 ] * x + e[ 5 ] * y + e[ 9 ]  * z + e[ 13 ] ) * d;\r\n\t\tthis.z = ( e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] ) * d;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tapplyQuaternion: function ( q ) {\r\n\r\n\t\tvar x = this.x;\r\n\t\tvar y = this.y;\r\n\t\tvar z = this.z;\r\n\r\n\t\tvar qx = q.x;\r\n\t\tvar qy = q.y;\r\n\t\tvar qz = q.z;\r\n\t\tvar qw = q.w;\r\n\r\n\t\t// calculate quat * vector\r\n\r\n\t\tvar ix =  qw * x + qy * z - qz * y;\r\n\t\tvar iy =  qw * y + qz * x - qx * z;\r\n\t\tvar iz =  qw * z + qx * y - qy * x;\r\n\t\tvar iw = - qx * x - qy * y - qz * z;\r\n\r\n\t\t// calculate result * inverse quat\r\n\r\n\t\tthis.x = ix * qw + iw * - qx + iy * - qz - iz * - qy;\r\n\t\tthis.y = iy * qw + iw * - qy + iz * - qx - ix * - qz;\r\n\t\tthis.z = iz * qw + iw * - qz + ix * - qy - iy * - qx;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tproject: function () {\r\n\r\n\t\tvar matrix;\r\n\r\n\t\treturn function ( camera ) {\r\n\r\n\t\t\tif ( matrix === undefined ) matrix = new THREE.Matrix4();\r\n\r\n\t\t\tmatrix.multiplyMatrices( camera.projectionMatrix, matrix.getInverse( camera.matrixWorld ) );\r\n\t\t\treturn this.applyProjection( matrix );\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tunproject: function () {\r\n\r\n\t\tvar matrix;\r\n\r\n\t\treturn function ( camera ) {\r\n\r\n\t\t\tif ( matrix === undefined ) matrix = new THREE.Matrix4();\r\n\r\n\t\t\tmatrix.multiplyMatrices( camera.matrixWorld, matrix.getInverse( camera.projectionMatrix ) );\r\n\t\t\treturn this.applyProjection( matrix );\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\ttransformDirection: function ( m ) {\r\n\r\n\t\t// input: THREE.Matrix4 affine matrix\r\n\t\t// vector interpreted as a direction\r\n\r\n\t\tvar x = this.x, y = this.y, z = this.z;\r\n\r\n\t\tvar e = m.elements;\r\n\r\n\t\tthis.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ]  * z;\r\n\t\tthis.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ]  * z;\r\n\t\tthis.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z;\r\n\r\n\t\tthis.normalize();\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tdivide: function ( v ) {\r\n\r\n\t\tthis.x /= v.x;\r\n\t\tthis.y /= v.y;\r\n\t\tthis.z /= v.z;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tdivideScalar: function ( scalar ) {\r\n\r\n\t\tif ( scalar !== 0 ) {\r\n\r\n\t\t\tvar invScalar = 1 / scalar;\r\n\r\n\t\t\tthis.x *= invScalar;\r\n\t\t\tthis.y *= invScalar;\r\n\t\t\tthis.z *= invScalar;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tthis.x = 0;\r\n\t\t\tthis.y = 0;\r\n\t\t\tthis.z = 0;\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmin: function ( v ) {\r\n\r\n\t\tif ( this.x > v.x ) {\r\n\r\n\t\t\tthis.x = v.x;\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.y > v.y ) {\r\n\r\n\t\t\tthis.y = v.y;\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.z > v.z ) {\r\n\r\n\t\t\tthis.z = v.z;\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmax: function ( v ) {\r\n\r\n\t\tif ( this.x < v.x ) {\r\n\r\n\t\t\tthis.x = v.x;\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.y < v.y ) {\r\n\r\n\t\t\tthis.y = v.y;\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.z < v.z ) {\r\n\r\n\t\t\tthis.z = v.z;\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tclamp: function ( min, max ) {\r\n\r\n\t\t// This function assumes min < max, if this assumption isn't true it will not operate correctly\r\n\r\n\t\tif ( this.x < min.x ) {\r\n\r\n\t\t\tthis.x = min.x;\r\n\r\n\t\t} else if ( this.x > max.x ) {\r\n\r\n\t\t\tthis.x = max.x;\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.y < min.y ) {\r\n\r\n\t\t\tthis.y = min.y;\r\n\r\n\t\t} else if ( this.y > max.y ) {\r\n\r\n\t\t\tthis.y = max.y;\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.z < min.z ) {\r\n\r\n\t\t\tthis.z = min.z;\r\n\r\n\t\t} else if ( this.z > max.z ) {\r\n\r\n\t\t\tthis.z = max.z;\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tclampScalar: ( function () {\r\n\r\n\t\tvar min, max;\r\n\r\n\t\treturn function ( minVal, maxVal ) {\r\n\r\n\t\t\tif ( min === undefined ) {\r\n\r\n\t\t\t\tmin = new THREE.Vector3();\r\n\t\t\t\tmax = new THREE.Vector3();\r\n\r\n\t\t\t}\r\n\r\n\t\t\tmin.set( minVal, minVal, minVal );\r\n\t\t\tmax.set( maxVal, maxVal, maxVal );\r\n\r\n\t\t\treturn this.clamp( min, max );\r\n\r\n\t\t};\r\n\r\n\t} )(),\r\n\r\n\tfloor: function () {\r\n\r\n\t\tthis.x = Math.floor( this.x );\r\n\t\tthis.y = Math.floor( this.y );\r\n\t\tthis.z = Math.floor( this.z );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tceil: function () {\r\n\r\n\t\tthis.x = Math.ceil( this.x );\r\n\t\tthis.y = Math.ceil( this.y );\r\n\t\tthis.z = Math.ceil( this.z );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tround: function () {\r\n\r\n\t\tthis.x = Math.round( this.x );\r\n\t\tthis.y = Math.round( this.y );\r\n\t\tthis.z = Math.round( this.z );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\troundToZero: function () {\r\n\r\n\t\tthis.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );\r\n\t\tthis.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );\r\n\t\tthis.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tnegate: function () {\r\n\r\n\t\tthis.x = - this.x;\r\n\t\tthis.y = - this.y;\r\n\t\tthis.z = - this.z;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tdot: function ( v ) {\r\n\r\n\t\treturn this.x * v.x + this.y * v.y + this.z * v.z;\r\n\r\n\t},\r\n\r\n\tlengthSq: function () {\r\n\r\n\t\treturn this.x * this.x + this.y * this.y + this.z * this.z;\r\n\r\n\t},\r\n\r\n\tlength: function () {\r\n\r\n\t\treturn Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z );\r\n\r\n\t},\r\n\r\n\tlengthManhattan: function () {\r\n\r\n\t\treturn Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z );\r\n\r\n\t},\r\n\r\n\tnormalize: function () {\r\n\r\n\t\treturn this.divideScalar( this.length() );\r\n\r\n\t},\r\n\r\n\tsetLength: function ( l ) {\r\n\r\n\t\tvar oldLength = this.length();\r\n\r\n\t\tif ( oldLength !== 0 && l !== oldLength  ) {\r\n\r\n\t\t\tthis.multiplyScalar( l / oldLength );\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tlerp: function ( v, alpha ) {\r\n\r\n\t\tthis.x += ( v.x - this.x ) * alpha;\r\n\t\tthis.y += ( v.y - this.y ) * alpha;\r\n\t\tthis.z += ( v.z - this.z ) * alpha;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tlerpVectors: function ( v1, v2, alpha ) {\r\n\r\n\t\tthis.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tcross: function ( v, w ) {\r\n\r\n\t\tif ( w !== undefined ) {\r\n\r\n\t\t\tTHREE.warn( 'THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.' );\r\n\t\t\treturn this.crossVectors( v, w );\r\n\r\n\t\t}\r\n\r\n\t\tvar x = this.x, y = this.y, z = this.z;\r\n\r\n\t\tthis.x = y * v.z - z * v.y;\r\n\t\tthis.y = z * v.x - x * v.z;\r\n\t\tthis.z = x * v.y - y * v.x;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tcrossVectors: function ( a, b ) {\r\n\r\n\t\tvar ax = a.x, ay = a.y, az = a.z;\r\n\t\tvar bx = b.x, by = b.y, bz = b.z;\r\n\r\n\t\tthis.x = ay * bz - az * by;\r\n\t\tthis.y = az * bx - ax * bz;\r\n\t\tthis.z = ax * by - ay * bx;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tprojectOnVector: function () {\r\n\r\n\t\tvar v1, dot;\r\n\r\n\t\treturn function ( vector ) {\r\n\r\n\t\t\tif ( v1 === undefined ) v1 = new THREE.Vector3();\r\n\r\n\t\t\tv1.copy( vector ).normalize();\r\n\r\n\t\t\tdot = this.dot( v1 );\r\n\r\n\t\t\treturn this.copy( v1 ).multiplyScalar( dot );\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tprojectOnPlane: function () {\r\n\r\n\t\tvar v1;\r\n\r\n\t\treturn function ( planeNormal ) {\r\n\r\n\t\t\tif ( v1 === undefined ) v1 = new THREE.Vector3();\r\n\r\n\t\t\tv1.copy( this ).projectOnVector( planeNormal );\r\n\r\n\t\t\treturn this.sub( v1 );\r\n\r\n\t\t}\r\n\r\n\t}(),\r\n\r\n\treflect: function () {\r\n\r\n\t\t// reflect incident vector off plane orthogonal to normal\r\n\t\t// normal is assumed to have unit length\r\n\r\n\t\tvar v1;\r\n\r\n\t\treturn function ( normal ) {\r\n\r\n\t\t\tif ( v1 === undefined ) v1 = new THREE.Vector3();\r\n\r\n\t\t\treturn this.sub( v1.copy( normal ).multiplyScalar( 2 * this.dot( normal ) ) );\r\n\r\n\t\t}\r\n\r\n\t}(),\r\n\r\n\tangleTo: function ( v ) {\r\n\r\n\t\tvar theta = this.dot( v ) / ( this.length() * v.length() );\r\n\r\n\t\t// clamp, to handle numerical problems\r\n\r\n\t\treturn Math.acos( THREE.Math.clamp( theta, - 1, 1 ) );\r\n\r\n\t},\r\n\r\n\tdistanceTo: function ( v ) {\r\n\r\n\t\treturn Math.sqrt( this.distanceToSquared( v ) );\r\n\r\n\t},\r\n\r\n\tdistanceToSquared: function ( v ) {\r\n\r\n\t\tvar dx = this.x - v.x;\r\n\t\tvar dy = this.y - v.y;\r\n\t\tvar dz = this.z - v.z;\r\n\r\n\t\treturn dx * dx + dy * dy + dz * dz;\r\n\r\n\t},\r\n\r\n\tsetEulerFromRotationMatrix: function ( m, order ) {\r\n\r\n\t\tTHREE.error( 'THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.' );\r\n\r\n\t},\r\n\r\n\tsetEulerFromQuaternion: function ( q, order ) {\r\n\r\n\t\tTHREE.error( 'THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.' );\r\n\r\n\t},\r\n\r\n\tgetPositionFromMatrix: function ( m ) {\r\n\r\n\t\tTHREE.warn( 'THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().' );\r\n\r\n\t\treturn this.setFromMatrixPosition( m );\r\n\r\n\t},\r\n\r\n\tgetScaleFromMatrix: function ( m ) {\r\n\r\n\t\tTHREE.warn( 'THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().' );\r\n\r\n\t\treturn this.setFromMatrixScale( m );\r\n\t},\r\n\r\n\tgetColumnFromMatrix: function ( index, matrix ) {\r\n\r\n\t\tTHREE.warn( 'THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().' );\r\n\r\n\t\treturn this.setFromMatrixColumn( index, matrix );\r\n\r\n\t},\r\n\r\n\tsetFromMatrixPosition: function ( m ) {\r\n\r\n\t\tthis.x = m.elements[ 12 ];\r\n\t\tthis.y = m.elements[ 13 ];\r\n\t\tthis.z = m.elements[ 14 ];\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetFromMatrixScale: function ( m ) {\r\n\r\n\t\tvar sx = this.set( m.elements[ 0 ], m.elements[ 1 ], m.elements[  2 ] ).length();\r\n\t\tvar sy = this.set( m.elements[ 4 ], m.elements[ 5 ], m.elements[  6 ] ).length();\r\n\t\tvar sz = this.set( m.elements[ 8 ], m.elements[ 9 ], m.elements[ 10 ] ).length();\r\n\r\n\t\tthis.x = sx;\r\n\t\tthis.y = sy;\r\n\t\tthis.z = sz;\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tsetFromMatrixColumn: function ( index, matrix ) {\r\n\t\t\r\n\t\tvar offset = index * 4;\r\n\r\n\t\tvar me = matrix.elements;\r\n\r\n\t\tthis.x = me[ offset ];\r\n\t\tthis.y = me[ offset + 1 ];\r\n\t\tthis.z = me[ offset + 2 ];\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tequals: function ( v ) {\r\n\r\n\t\treturn ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) );\r\n\r\n\t},\r\n\r\n\tfromArray: function ( array, offset ) {\r\n\r\n\t\tif ( offset === undefined ) offset = 0;\r\n\r\n\t\tthis.x = array[ offset ];\r\n\t\tthis.y = array[ offset + 1 ];\r\n\t\tthis.z = array[ offset + 2 ];\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\ttoArray: function ( array, offset ) {\r\n\r\n\t\tif ( array === undefined ) array = [];\r\n\t\tif ( offset === undefined ) offset = 0;\r\n\r\n\t\tarray[ offset ] = this.x;\r\n\t\tarray[ offset + 1 ] = this.y;\r\n\t\tarray[ offset + 2 ] = this.z;\r\n\r\n\t\treturn array;\r\n\r\n\t},\r\n\r\n\tfromAttribute: function ( attribute, index, offset ) {\r\n\r\n\t\tif ( offset === undefined ) offset = 0;\r\n\r\n\t\tindex = index * attribute.itemSize + offset;\r\n\r\n\t\tthis.x = attribute.array[ index ];\r\n\t\tthis.y = attribute.array[ index + 1 ];\r\n\t\tthis.z = attribute.array[ index + 2 ];\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tclone: function () {\r\n\r\n\t\treturn new THREE.Vector3( this.x, this.y, this.z );\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/math/Vector4.js\r\n\r\n/**\r\n * @author supereggbert / http://www.paulbrunt.co.uk/\r\n * @author philogb / http://blog.thejit.org/\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author egraether / http://egraether.com/\r\n * @author WestLangley / http://github.com/WestLangley\r\n */\r\n\r\nTHREE.Vector4 = function ( x, y, z, w ) {\r\n\r\n\tthis.x = x || 0;\r\n\tthis.y = y || 0;\r\n\tthis.z = z || 0;\r\n\tthis.w = ( w !== undefined ) ? w : 1;\r\n\r\n};\r\n\r\nTHREE.Vector4.prototype = {\r\n\r\n\tconstructor: THREE.Vector4,\r\n\r\n\tset: function ( x, y, z, w ) {\r\n\r\n\t\tthis.x = x;\r\n\t\tthis.y = y;\r\n\t\tthis.z = z;\r\n\t\tthis.w = w;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetX: function ( x ) {\r\n\r\n\t\tthis.x = x;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetY: function ( y ) {\r\n\r\n\t\tthis.y = y;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetZ: function ( z ) {\r\n\r\n\t\tthis.z = z;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetW: function ( w ) {\r\n\r\n\t\tthis.w = w;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetComponent: function ( index, value ) {\r\n\r\n\t\tswitch ( index ) {\r\n\r\n\t\t\tcase 0: this.x = value; break;\r\n\t\t\tcase 1: this.y = value; break;\r\n\t\t\tcase 2: this.z = value; break;\r\n\t\t\tcase 3: this.w = value; break;\r\n\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tgetComponent: function ( index ) {\r\n\r\n\t\tswitch ( index ) {\r\n\r\n\t\t\tcase 0: return this.x;\r\n\t\t\tcase 1: return this.y;\r\n\t\t\tcase 2: return this.z;\r\n\t\t\tcase 3: return this.w;\r\n\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tcopy: function ( v ) {\r\n\r\n\t\tthis.x = v.x;\r\n\t\tthis.y = v.y;\r\n\t\tthis.z = v.z;\r\n\t\tthis.w = ( v.w !== undefined ) ? v.w : 1;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tadd: function ( v, w ) {\r\n\r\n\t\tif ( w !== undefined ) {\r\n\r\n\t\t\tTHREE.warn( 'THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );\r\n\t\t\treturn this.addVectors( v, w );\r\n\r\n\t\t}\r\n\r\n\t\tthis.x += v.x;\r\n\t\tthis.y += v.y;\r\n\t\tthis.z += v.z;\r\n\t\tthis.w += v.w;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\taddScalar: function ( s ) {\r\n\r\n\t\tthis.x += s;\r\n\t\tthis.y += s;\r\n\t\tthis.z += s;\r\n\t\tthis.w += s;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\taddVectors: function ( a, b ) {\r\n\r\n\t\tthis.x = a.x + b.x;\r\n\t\tthis.y = a.y + b.y;\r\n\t\tthis.z = a.z + b.z;\r\n\t\tthis.w = a.w + b.w;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsub: function ( v, w ) {\r\n\r\n\t\tif ( w !== undefined ) {\r\n\r\n\t\t\tTHREE.warn( 'THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );\r\n\t\t\treturn this.subVectors( v, w );\r\n\r\n\t\t}\r\n\r\n\t\tthis.x -= v.x;\r\n\t\tthis.y -= v.y;\r\n\t\tthis.z -= v.z;\r\n\t\tthis.w -= v.w;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsubScalar: function ( s ) {\r\n\r\n\t\tthis.x -= s;\r\n\t\tthis.y -= s;\r\n\t\tthis.z -= s;\r\n\t\tthis.w -= s;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsubVectors: function ( a, b ) {\r\n\r\n\t\tthis.x = a.x - b.x;\r\n\t\tthis.y = a.y - b.y;\r\n\t\tthis.z = a.z - b.z;\r\n\t\tthis.w = a.w - b.w;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmultiplyScalar: function ( scalar ) {\r\n\r\n\t\tthis.x *= scalar;\r\n\t\tthis.y *= scalar;\r\n\t\tthis.z *= scalar;\r\n\t\tthis.w *= scalar;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tapplyMatrix4: function ( m ) {\r\n\r\n\t\tvar x = this.x;\r\n\t\tvar y = this.y;\r\n\t\tvar z = this.z;\r\n\t\tvar w = this.w;\r\n\r\n\t\tvar e = m.elements;\r\n\r\n\t\tthis.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] * w;\r\n\t\tthis.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] * w;\r\n\t\tthis.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] * w;\r\n\t\tthis.w = e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] * w;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tdivideScalar: function ( scalar ) {\r\n\r\n\t\tif ( scalar !== 0 ) {\r\n\r\n\t\t\tvar invScalar = 1 / scalar;\r\n\r\n\t\t\tthis.x *= invScalar;\r\n\t\t\tthis.y *= invScalar;\r\n\t\t\tthis.z *= invScalar;\r\n\t\t\tthis.w *= invScalar;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tthis.x = 0;\r\n\t\t\tthis.y = 0;\r\n\t\t\tthis.z = 0;\r\n\t\t\tthis.w = 1;\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetAxisAngleFromQuaternion: function ( q ) {\r\n\r\n\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm\r\n\r\n\t\t// q is assumed to be normalized\r\n\r\n\t\tthis.w = 2 * Math.acos( q.w );\r\n\r\n\t\tvar s = Math.sqrt( 1 - q.w * q.w );\r\n\r\n\t\tif ( s < 0.0001 ) {\r\n\r\n\t\t\t this.x = 1;\r\n\t\t\t this.y = 0;\r\n\t\t\t this.z = 0;\r\n\r\n\t\t} else {\r\n\r\n\t\t\t this.x = q.x / s;\r\n\t\t\t this.y = q.y / s;\r\n\t\t\t this.z = q.z / s;\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetAxisAngleFromRotationMatrix: function ( m ) {\r\n\r\n\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm\r\n\r\n\t\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\r\n\r\n\t\tvar angle, x, y, z,\t\t// variables for result\r\n\t\t\tepsilon = 0.01,\t\t// margin to allow for rounding errors\r\n\t\t\tepsilon2 = 0.1,\t\t// margin to distinguish between 0 and 180 degrees\r\n\r\n\t\t\tte = m.elements,\r\n\r\n\t\t\tm11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],\r\n\t\t\tm21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],\r\n\t\t\tm31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];\r\n\r\n\t\tif ( ( Math.abs( m12 - m21 ) < epsilon )\r\n\t\t   && ( Math.abs( m13 - m31 ) < epsilon )\r\n\t\t   && ( Math.abs( m23 - m32 ) < epsilon ) ) {\r\n\r\n\t\t\t// singularity found\r\n\t\t\t// first check for identity matrix which must have +1 for all terms\r\n\t\t\t// in leading diagonal and zero in other terms\r\n\r\n\t\t\tif ( ( Math.abs( m12 + m21 ) < epsilon2 )\r\n\t\t\t   && ( Math.abs( m13 + m31 ) < epsilon2 )\r\n\t\t\t   && ( Math.abs( m23 + m32 ) < epsilon2 )\r\n\t\t\t   && ( Math.abs( m11 + m22 + m33 - 3 ) < epsilon2 ) ) {\r\n\r\n\t\t\t\t// this singularity is identity matrix so angle = 0\r\n\r\n\t\t\t\tthis.set( 1, 0, 0, 0 );\r\n\r\n\t\t\t\treturn this; // zero angle, arbitrary axis\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// otherwise this singularity is angle = 180\r\n\r\n\t\t\tangle = Math.PI;\r\n\r\n\t\t\tvar xx = ( m11 + 1 ) / 2;\r\n\t\t\tvar yy = ( m22 + 1 ) / 2;\r\n\t\t\tvar zz = ( m33 + 1 ) / 2;\r\n\t\t\tvar xy = ( m12 + m21 ) / 4;\r\n\t\t\tvar xz = ( m13 + m31 ) / 4;\r\n\t\t\tvar yz = ( m23 + m32 ) / 4;\r\n\r\n\t\t\tif ( ( xx > yy ) && ( xx > zz ) ) { // m11 is the largest diagonal term\r\n\r\n\t\t\t\tif ( xx < epsilon ) {\r\n\r\n\t\t\t\t\tx = 0;\r\n\t\t\t\t\ty = 0.707106781;\r\n\t\t\t\t\tz = 0.707106781;\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tx = Math.sqrt( xx );\r\n\t\t\t\t\ty = xy / x;\r\n\t\t\t\t\tz = xz / x;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else if ( yy > zz ) { // m22 is the largest diagonal term\r\n\r\n\t\t\t\tif ( yy < epsilon ) {\r\n\r\n\t\t\t\t\tx = 0.707106781;\r\n\t\t\t\t\ty = 0;\r\n\t\t\t\t\tz = 0.707106781;\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\ty = Math.sqrt( yy );\r\n\t\t\t\t\tx = xy / y;\r\n\t\t\t\t\tz = yz / y;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else { // m33 is the largest diagonal term so base result on this\r\n\r\n\t\t\t\tif ( zz < epsilon ) {\r\n\r\n\t\t\t\t\tx = 0.707106781;\r\n\t\t\t\t\ty = 0.707106781;\r\n\t\t\t\t\tz = 0;\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tz = Math.sqrt( zz );\r\n\t\t\t\t\tx = xz / z;\r\n\t\t\t\t\ty = yz / z;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis.set( x, y, z, angle );\r\n\r\n\t\t\treturn this; // return 180 deg rotation\r\n\r\n\t\t}\r\n\r\n\t\t// as we have reached here there are no singularities so we can handle normally\r\n\r\n\t\tvar s = Math.sqrt( ( m32 - m23 ) * ( m32 - m23 )\r\n\t\t\t\t\t\t  + ( m13 - m31 ) * ( m13 - m31 )\r\n\t\t\t\t\t\t  + ( m21 - m12 ) * ( m21 - m12 ) ); // used to normalize\r\n\r\n\t\tif ( Math.abs( s ) < 0.001 ) s = 1;\r\n\r\n\t\t// prevent divide by zero, should not happen if matrix is orthogonal and should be\r\n\t\t// caught by singularity test above, but I've left it in just in case\r\n\r\n\t\tthis.x = ( m32 - m23 ) / s;\r\n\t\tthis.y = ( m13 - m31 ) / s;\r\n\t\tthis.z = ( m21 - m12 ) / s;\r\n\t\tthis.w = Math.acos( ( m11 + m22 + m33 - 1 ) / 2 );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmin: function ( v ) {\r\n\r\n\t\tif ( this.x > v.x ) {\r\n\r\n\t\t\tthis.x = v.x;\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.y > v.y ) {\r\n\r\n\t\t\tthis.y = v.y;\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.z > v.z ) {\r\n\r\n\t\t\tthis.z = v.z;\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.w > v.w ) {\r\n\r\n\t\t\tthis.w = v.w;\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmax: function ( v ) {\r\n\r\n\t\tif ( this.x < v.x ) {\r\n\r\n\t\t\tthis.x = v.x;\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.y < v.y ) {\r\n\r\n\t\t\tthis.y = v.y;\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.z < v.z ) {\r\n\r\n\t\t\tthis.z = v.z;\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.w < v.w ) {\r\n\r\n\t\t\tthis.w = v.w;\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tclamp: function ( min, max ) {\r\n\r\n\t\t// This function assumes min < max, if this assumption isn't true it will not operate correctly\r\n\r\n\t\tif ( this.x < min.x ) {\r\n\r\n\t\t\tthis.x = min.x;\r\n\r\n\t\t} else if ( this.x > max.x ) {\r\n\r\n\t\t\tthis.x = max.x;\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.y < min.y ) {\r\n\r\n\t\t\tthis.y = min.y;\r\n\r\n\t\t} else if ( this.y > max.y ) {\r\n\r\n\t\t\tthis.y = max.y;\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.z < min.z ) {\r\n\r\n\t\t\tthis.z = min.z;\r\n\r\n\t\t} else if ( this.z > max.z ) {\r\n\r\n\t\t\tthis.z = max.z;\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.w < min.w ) {\r\n\r\n\t\t\tthis.w = min.w;\r\n\r\n\t\t} else if ( this.w > max.w ) {\r\n\r\n\t\t\tthis.w = max.w;\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tclampScalar: ( function () {\r\n\r\n\t\tvar min, max;\r\n\r\n\t\treturn function ( minVal, maxVal ) {\r\n\r\n\t\t\tif ( min === undefined ) {\r\n\r\n\t\t\t\tmin = new THREE.Vector4();\r\n\t\t\t\tmax = new THREE.Vector4();\r\n\r\n\t\t\t}\r\n\r\n\t\t\tmin.set( minVal, minVal, minVal, minVal );\r\n\t\t\tmax.set( maxVal, maxVal, maxVal, maxVal );\r\n\r\n\t\t\treturn this.clamp( min, max );\r\n\r\n\t\t};\r\n\r\n\t} )(),\r\n\r\n  floor: function () {\r\n\r\n\t\tthis.x = Math.floor( this.x );\r\n\t\tthis.y = Math.floor( this.y );\r\n\t\tthis.z = Math.floor( this.z );\r\n\t\tthis.w = Math.floor( this.w );\r\n\r\n\t\treturn this;\r\n\r\n  },\r\n\r\n  ceil: function () {\r\n\r\n\t\tthis.x = Math.ceil( this.x );\r\n\t\tthis.y = Math.ceil( this.y );\r\n\t\tthis.z = Math.ceil( this.z );\r\n\t\tthis.w = Math.ceil( this.w );\r\n\r\n\t\treturn this;\r\n\r\n  },\r\n\r\n  round: function () {\r\n\r\n\t\tthis.x = Math.round( this.x );\r\n\t\tthis.y = Math.round( this.y );\r\n\t\tthis.z = Math.round( this.z );\r\n\t\tthis.w = Math.round( this.w );\r\n\r\n\t\treturn this;\r\n\r\n  },\r\n\r\n  roundToZero: function () {\r\n\r\n\t\tthis.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );\r\n\t\tthis.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );\r\n\t\tthis.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );\r\n\t\tthis.w = ( this.w < 0 ) ? Math.ceil( this.w ) : Math.floor( this.w );\r\n\r\n\t\treturn this;\r\n\r\n  },\r\n\r\n\tnegate: function () {\r\n\r\n\t\tthis.x = - this.x;\r\n\t\tthis.y = - this.y;\r\n\t\tthis.z = - this.z;\r\n\t\tthis.w = - this.w;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tdot: function ( v ) {\r\n\r\n\t\treturn this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;\r\n\r\n\t},\r\n\r\n\tlengthSq: function () {\r\n\r\n\t\treturn this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;\r\n\r\n\t},\r\n\r\n\tlength: function () {\r\n\r\n\t\treturn Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w );\r\n\r\n\t},\r\n\r\n\tlengthManhattan: function () {\r\n\r\n\t\treturn Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z ) + Math.abs( this.w );\r\n\r\n\t},\r\n\r\n\tnormalize: function () {\r\n\r\n\t\treturn this.divideScalar( this.length() );\r\n\r\n\t},\r\n\r\n\tsetLength: function ( l ) {\r\n\r\n\t\tvar oldLength = this.length();\r\n\r\n\t\tif ( oldLength !== 0 && l !== oldLength ) {\r\n\r\n\t\t\tthis.multiplyScalar( l / oldLength );\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tlerp: function ( v, alpha ) {\r\n\r\n\t\tthis.x += ( v.x - this.x ) * alpha;\r\n\t\tthis.y += ( v.y - this.y ) * alpha;\r\n\t\tthis.z += ( v.z - this.z ) * alpha;\r\n\t\tthis.w += ( v.w - this.w ) * alpha;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tlerpVectors: function ( v1, v2, alpha ) {\r\n\r\n\t\tthis.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tequals: function ( v ) {\r\n\r\n\t\treturn ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) && ( v.w === this.w ) );\r\n\r\n\t},\r\n\r\n\tfromArray: function ( array, offset ) {\r\n\r\n\t\tif ( offset === undefined ) offset = 0;\r\n\r\n\t\tthis.x = array[ offset ];\r\n\t\tthis.y = array[ offset + 1 ];\r\n\t\tthis.z = array[ offset + 2 ];\r\n\t\tthis.w = array[ offset + 3 ];\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\ttoArray: function ( array, offset ) {\r\n\r\n\t\tif ( array === undefined ) array = [];\r\n\t\tif ( offset === undefined ) offset = 0;\r\n\r\n\t\tarray[ offset ] = this.x;\r\n\t\tarray[ offset + 1 ] = this.y;\r\n\t\tarray[ offset + 2 ] = this.z;\r\n\t\tarray[ offset + 3 ] = this.w;\r\n\r\n\t\treturn array;\r\n\r\n\t},\r\n\r\n\tfromAttribute: function ( attribute, index, offset ) {\r\n\r\n\t\tif ( offset === undefined ) offset = 0;\r\n\r\n\t\tindex = index * attribute.itemSize + offset;\r\n\r\n\t\tthis.x = attribute.array[ index ];\r\n\t\tthis.y = attribute.array[ index + 1 ];\r\n\t\tthis.z = attribute.array[ index + 2 ];\r\n\t\tthis.w = attribute.array[ index + 3 ];\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tclone: function () {\r\n\r\n\t\treturn new THREE.Vector4( this.x, this.y, this.z, this.w );\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/math/Euler.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author WestLangley / http://github.com/WestLangley\r\n * @author bhouston / http://exocortex.com\r\n */\r\n\r\nTHREE.Euler = function ( x, y, z, order ) {\r\n\r\n\tthis._x = x || 0;\r\n\tthis._y = y || 0;\r\n\tthis._z = z || 0;\r\n\tthis._order = order || THREE.Euler.DefaultOrder;\r\n\r\n};\r\n\r\nTHREE.Euler.RotationOrders = [ 'XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX' ];\r\n\r\nTHREE.Euler.DefaultOrder = 'XYZ';\r\n\r\nTHREE.Euler.prototype = {\r\n\r\n\tconstructor: THREE.Euler,\r\n\r\n\t_x: 0, _y: 0, _z: 0, _order: THREE.Euler.DefaultOrder,\r\n\r\n\tget x () {\r\n\r\n\t\treturn this._x;\r\n\r\n\t},\r\n\r\n\tset x ( value ) {\r\n\r\n\t\tthis._x = value;\r\n\t\tthis.onChangeCallback();\r\n\r\n\t},\r\n\r\n\tget y () {\r\n\r\n\t\treturn this._y;\r\n\r\n\t},\r\n\r\n\tset y ( value ) {\r\n\r\n\t\tthis._y = value;\r\n\t\tthis.onChangeCallback();\r\n\r\n\t},\r\n\r\n\tget z () {\r\n\r\n\t\treturn this._z;\r\n\r\n\t},\r\n\r\n\tset z ( value ) {\r\n\r\n\t\tthis._z = value;\r\n\t\tthis.onChangeCallback();\r\n\r\n\t},\r\n\r\n\tget order () {\r\n\r\n\t\treturn this._order;\r\n\r\n\t},\r\n\r\n\tset order ( value ) {\r\n\r\n\t\tthis._order = value;\r\n\t\tthis.onChangeCallback();\r\n\r\n\t},\r\n\r\n\tset: function ( x, y, z, order ) {\r\n\r\n\t\tthis._x = x;\r\n\t\tthis._y = y;\r\n\t\tthis._z = z;\r\n\t\tthis._order = order || this._order;\r\n\r\n\t\tthis.onChangeCallback();\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tcopy: function ( euler ) {\r\n\r\n\t\tthis._x = euler._x;\r\n\t\tthis._y = euler._y;\r\n\t\tthis._z = euler._z;\r\n\t\tthis._order = euler._order;\r\n\r\n\t\tthis.onChangeCallback();\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetFromRotationMatrix: function ( m, order, update ) {\r\n\r\n\t\tvar clamp = THREE.Math.clamp;\r\n\r\n\t\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\r\n\r\n\t\tvar te = m.elements;\r\n\t\tvar m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ];\r\n\t\tvar m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ];\r\n\t\tvar m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];\r\n\r\n\t\torder = order || this._order;\r\n\r\n\t\tif ( order === 'XYZ' ) {\r\n\r\n\t\t\tthis._y = Math.asin( clamp( m13, - 1, 1 ) );\r\n\r\n\t\t\tif ( Math.abs( m13 ) < 0.99999 ) {\r\n\r\n\t\t\t\tthis._x = Math.atan2( - m23, m33 );\r\n\t\t\t\tthis._z = Math.atan2( - m12, m11 );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tthis._x = Math.atan2( m32, m22 );\r\n\t\t\t\tthis._z = 0;\r\n\r\n\t\t\t}\r\n\r\n\t\t} else if ( order === 'YXZ' ) {\r\n\r\n\t\t\tthis._x = Math.asin( - clamp( m23, - 1, 1 ) );\r\n\r\n\t\t\tif ( Math.abs( m23 ) < 0.99999 ) {\r\n\r\n\t\t\t\tthis._y = Math.atan2( m13, m33 );\r\n\t\t\t\tthis._z = Math.atan2( m21, m22 );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tthis._y = Math.atan2( - m31, m11 );\r\n\t\t\t\tthis._z = 0;\r\n\r\n\t\t\t}\r\n\r\n\t\t} else if ( order === 'ZXY' ) {\r\n\r\n\t\t\tthis._x = Math.asin( clamp( m32, - 1, 1 ) );\r\n\r\n\t\t\tif ( Math.abs( m32 ) < 0.99999 ) {\r\n\r\n\t\t\t\tthis._y = Math.atan2( - m31, m33 );\r\n\t\t\t\tthis._z = Math.atan2( - m12, m22 );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tthis._y = 0;\r\n\t\t\t\tthis._z = Math.atan2( m21, m11 );\r\n\r\n\t\t\t}\r\n\r\n\t\t} else if ( order === 'ZYX' ) {\r\n\r\n\t\t\tthis._y = Math.asin( - clamp( m31, - 1, 1 ) );\r\n\r\n\t\t\tif ( Math.abs( m31 ) < 0.99999 ) {\r\n\r\n\t\t\t\tthis._x = Math.atan2( m32, m33 );\r\n\t\t\t\tthis._z = Math.atan2( m21, m11 );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tthis._x = 0;\r\n\t\t\t\tthis._z = Math.atan2( - m12, m22 );\r\n\r\n\t\t\t}\r\n\r\n\t\t} else if ( order === 'YZX' ) {\r\n\r\n\t\t\tthis._z = Math.asin( clamp( m21, - 1, 1 ) );\r\n\r\n\t\t\tif ( Math.abs( m21 ) < 0.99999 ) {\r\n\r\n\t\t\t\tthis._x = Math.atan2( - m23, m22 );\r\n\t\t\t\tthis._y = Math.atan2( - m31, m11 );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tthis._x = 0;\r\n\t\t\t\tthis._y = Math.atan2( m13, m33 );\r\n\r\n\t\t\t}\r\n\r\n\t\t} else if ( order === 'XZY' ) {\r\n\r\n\t\t\tthis._z = Math.asin( - clamp( m12, - 1, 1 ) );\r\n\r\n\t\t\tif ( Math.abs( m12 ) < 0.99999 ) {\r\n\r\n\t\t\t\tthis._x = Math.atan2( m32, m22 );\r\n\t\t\t\tthis._y = Math.atan2( m13, m11 );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tthis._x = Math.atan2( - m23, m33 );\r\n\t\t\t\tthis._y = 0;\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\tTHREE.warn( 'THREE.Euler: .setFromRotationMatrix() given unsupported order: ' + order )\r\n\r\n\t\t}\r\n\r\n\t\tthis._order = order;\r\n\r\n\t\tif ( update !== false ) this.onChangeCallback();\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetFromQuaternion: function () {\r\n\r\n\t\tvar matrix;\r\n\r\n\t\treturn function ( q, order, update ) {\r\n\r\n\t\t\tif ( matrix === undefined ) matrix = new THREE.Matrix4();\r\n\t\t\tmatrix.makeRotationFromQuaternion( q );\r\n\t\t\tthis.setFromRotationMatrix( matrix, order, update );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tsetFromVector3: function ( v, order ) {\r\n\r\n\t\treturn this.set( v.x, v.y, v.z, order || this._order );\r\n\r\n\t},\r\n\r\n\treorder: function () {\r\n\r\n\t\t// WARNING: this discards revolution information -bhouston\r\n\r\n\t\tvar q = new THREE.Quaternion();\r\n\r\n\t\treturn function ( newOrder ) {\r\n\r\n\t\t\tq.setFromEuler( this );\r\n\t\t\tthis.setFromQuaternion( q, newOrder );\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tequals: function ( euler ) {\r\n\r\n\t\treturn ( euler._x === this._x ) && ( euler._y === this._y ) && ( euler._z === this._z ) && ( euler._order === this._order );\r\n\r\n\t},\r\n\r\n\tfromArray: function ( array ) {\r\n\r\n\t\tthis._x = array[ 0 ];\r\n\t\tthis._y = array[ 1 ];\r\n\t\tthis._z = array[ 2 ];\r\n\t\tif ( array[ 3 ] !== undefined ) this._order = array[ 3 ];\r\n\r\n\t\tthis.onChangeCallback();\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\ttoArray: function ( array, offset ) {\r\n\r\n\t\tif ( array === undefined ) array = [];\r\n\t\tif ( offset === undefined ) offset = 0;\r\n\r\n\t\tarray[ offset ] = this._x;\r\n\t\tarray[ offset + 1 ] = this._y;\r\n\t\tarray[ offset + 2 ] = this._z;\r\n\t\tarray[ offset + 3 ] = this._order;\r\n\r\n\t\treturn array;\r\n\t},\r\n\r\n\ttoVector3: function ( optionalResult ) {\r\n\r\n\t\tif ( optionalResult ) {\r\n\r\n\t\t\treturn optionalResult.set( this._x, this._y, this._z );\r\n\r\n\t\t} else {\r\n\r\n\t\t\treturn new THREE.Vector3( this._x, this._y, this._z );\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tonChange: function ( callback ) {\r\n\r\n\t\tthis.onChangeCallback = callback;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tonChangeCallback: function () {},\r\n\r\n\tclone: function () {\r\n\r\n\t\treturn new THREE.Euler( this._x, this._y, this._z, this._order );\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/math/Line3.js\r\n\r\n/**\r\n * @author bhouston / http://exocortex.com\r\n */\r\n\r\nTHREE.Line3 = function ( start, end ) {\r\n\r\n\tthis.start = ( start !== undefined ) ? start : new THREE.Vector3();\r\n\tthis.end = ( end !== undefined ) ? end : new THREE.Vector3();\r\n\r\n};\r\n\r\nTHREE.Line3.prototype = {\r\n\r\n\tconstructor: THREE.Line3,\r\n\r\n\tset: function ( start, end ) {\r\n\r\n\t\tthis.start.copy( start );\r\n\t\tthis.end.copy( end );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tcopy: function ( line ) {\r\n\r\n\t\tthis.start.copy( line.start );\r\n\t\tthis.end.copy( line.end );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tcenter: function ( optionalTarget ) {\r\n\r\n\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\t\treturn result.addVectors( this.start, this.end ).multiplyScalar( 0.5 );\r\n\r\n\t},\r\n\r\n\tdelta: function ( optionalTarget ) {\r\n\r\n\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\t\treturn result.subVectors( this.end, this.start );\r\n\r\n\t},\r\n\r\n\tdistanceSq: function () {\r\n\r\n\t\treturn this.start.distanceToSquared( this.end );\r\n\r\n\t},\r\n\r\n\tdistance: function () {\r\n\r\n\t\treturn this.start.distanceTo( this.end );\r\n\r\n\t},\r\n\r\n\tat: function ( t, optionalTarget ) {\r\n\r\n\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\r\n\t\treturn this.delta( result ).multiplyScalar( t ).add( this.start );\r\n\r\n\t},\r\n\r\n\tclosestPointToPointParameter: function () {\r\n\r\n\t\tvar startP = new THREE.Vector3();\r\n\t\tvar startEnd = new THREE.Vector3();\r\n\r\n\t\treturn function ( point, clampToLine ) {\r\n\r\n\t\t\tstartP.subVectors( point, this.start );\r\n\t\t\tstartEnd.subVectors( this.end, this.start );\r\n\r\n\t\t\tvar startEnd2 = startEnd.dot( startEnd );\r\n\t\t\tvar startEnd_startP = startEnd.dot( startP );\r\n\r\n\t\t\tvar t = startEnd_startP / startEnd2;\r\n\r\n\t\t\tif ( clampToLine ) {\r\n\r\n\t\t\t\tt = THREE.Math.clamp( t, 0, 1 );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn t;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tclosestPointToPoint: function ( point, clampToLine, optionalTarget ) {\r\n\r\n\t\tvar t = this.closestPointToPointParameter( point, clampToLine );\r\n\r\n\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\r\n\t\treturn this.delta( result ).multiplyScalar( t ).add( this.start );\r\n\r\n\t},\r\n\r\n\tapplyMatrix4: function ( matrix ) {\r\n\r\n\t\tthis.start.applyMatrix4( matrix );\r\n\t\tthis.end.applyMatrix4( matrix );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tequals: function ( line ) {\r\n\r\n\t\treturn line.start.equals( this.start ) && line.end.equals( this.end );\r\n\r\n\t},\r\n\r\n\tclone: function () {\r\n\r\n\t\treturn new THREE.Line3().copy( this );\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/math/Box2.js\r\n\r\n/**\r\n * @author bhouston / http://exocortex.com\r\n */\r\n\r\nTHREE.Box2 = function ( min, max ) {\r\n\r\n\tthis.min = ( min !== undefined ) ? min : new THREE.Vector2( Infinity, Infinity );\r\n\tthis.max = ( max !== undefined ) ? max : new THREE.Vector2( - Infinity, - Infinity );\r\n\r\n};\r\n\r\nTHREE.Box2.prototype = {\r\n\r\n\tconstructor: THREE.Box2,\r\n\r\n\tset: function ( min, max ) {\r\n\r\n\t\tthis.min.copy( min );\r\n\t\tthis.max.copy( max );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetFromPoints: function ( points ) {\r\n\r\n\t\tthis.makeEmpty();\r\n\r\n\t\tfor ( var i = 0, il = points.length; i < il; i ++ ) {\r\n\r\n\t\t\tthis.expandByPoint( points[ i ] )\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetFromCenterAndSize: function () {\r\n\r\n\t\tvar v1 = new THREE.Vector2();\r\n\r\n\t\treturn function ( center, size ) {\r\n\r\n\t\t\tvar halfSize = v1.copy( size ).multiplyScalar( 0.5 );\r\n\t\t\tthis.min.copy( center ).sub( halfSize );\r\n\t\t\tthis.max.copy( center ).add( halfSize );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tcopy: function ( box ) {\r\n\r\n\t\tthis.min.copy( box.min );\r\n\t\tthis.max.copy( box.max );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmakeEmpty: function () {\r\n\r\n\t\tthis.min.x = this.min.y = Infinity;\r\n\t\tthis.max.x = this.max.y = - Infinity;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tempty: function () {\r\n\r\n\t\t// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes\r\n\r\n\t\treturn ( this.max.x < this.min.x ) || ( this.max.y < this.min.y );\r\n\r\n\t},\r\n\r\n\tcenter: function ( optionalTarget ) {\r\n\r\n\t\tvar result = optionalTarget || new THREE.Vector2();\r\n\t\treturn result.addVectors( this.min, this.max ).multiplyScalar( 0.5 );\r\n\r\n\t},\r\n\r\n\tsize: function ( optionalTarget ) {\r\n\r\n\t\tvar result = optionalTarget || new THREE.Vector2();\r\n\t\treturn result.subVectors( this.max, this.min );\r\n\r\n\t},\r\n\r\n\texpandByPoint: function ( point ) {\r\n\r\n\t\tthis.min.min( point );\r\n\t\tthis.max.max( point );\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\texpandByVector: function ( vector ) {\r\n\r\n\t\tthis.min.sub( vector );\r\n\t\tthis.max.add( vector );\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\texpandByScalar: function ( scalar ) {\r\n\r\n\t\tthis.min.addScalar( - scalar );\r\n\t\tthis.max.addScalar( scalar );\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tcontainsPoint: function ( point ) {\r\n\r\n\t\tif ( point.x < this.min.x || point.x > this.max.x ||\r\n\t\t     point.y < this.min.y || point.y > this.max.y ) {\r\n\r\n\t\t\treturn false;\r\n\r\n\t\t}\r\n\r\n\t\treturn true;\r\n\r\n\t},\r\n\r\n\tcontainsBox: function ( box ) {\r\n\r\n\t\tif ( ( this.min.x <= box.min.x ) && ( box.max.x <= this.max.x ) &&\r\n\t\t     ( this.min.y <= box.min.y ) && ( box.max.y <= this.max.y ) ) {\r\n\r\n\t\t\treturn true;\r\n\r\n\t\t}\r\n\r\n\t\treturn false;\r\n\r\n\t},\r\n\r\n\tgetParameter: function ( point, optionalTarget ) {\r\n\r\n\t\t// This can potentially have a divide by zero if the box\r\n\t\t// has a size dimension of 0.\r\n\r\n\t\tvar result = optionalTarget || new THREE.Vector2();\r\n\r\n\t\treturn result.set(\r\n\t\t\t( point.x - this.min.x ) / ( this.max.x - this.min.x ),\r\n\t\t\t( point.y - this.min.y ) / ( this.max.y - this.min.y )\r\n\t\t);\r\n\r\n\t},\r\n\r\n\tisIntersectionBox: function ( box ) {\r\n\r\n\t\t// using 6 splitting planes to rule out intersections.\r\n\r\n\t\tif ( box.max.x < this.min.x || box.min.x > this.max.x ||\r\n\t\t     box.max.y < this.min.y || box.min.y > this.max.y ) {\r\n\r\n\t\t\treturn false;\r\n\r\n\t\t}\r\n\r\n\t\treturn true;\r\n\r\n\t},\r\n\r\n\tclampPoint: function ( point, optionalTarget ) {\r\n\r\n\t\tvar result = optionalTarget || new THREE.Vector2();\r\n\t\treturn result.copy( point ).clamp( this.min, this.max );\r\n\r\n\t},\r\n\r\n\tdistanceToPoint: function () {\r\n\r\n\t\tvar v1 = new THREE.Vector2();\r\n\r\n\t\treturn function ( point ) {\r\n\r\n\t\t\tvar clampedPoint = v1.copy( point ).clamp( this.min, this.max );\r\n\t\t\treturn clampedPoint.sub( point ).length();\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tintersect: function ( box ) {\r\n\r\n\t\tthis.min.max( box.min );\r\n\t\tthis.max.min( box.max );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tunion: function ( box ) {\r\n\r\n\t\tthis.min.min( box.min );\r\n\t\tthis.max.max( box.max );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\ttranslate: function ( offset ) {\r\n\r\n\t\tthis.min.add( offset );\r\n\t\tthis.max.add( offset );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tequals: function ( box ) {\r\n\r\n\t\treturn box.min.equals( this.min ) && box.max.equals( this.max );\r\n\r\n\t},\r\n\r\n\tclone: function () {\r\n\r\n\t\treturn new THREE.Box2().copy( this );\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/math/Box3.js\r\n\r\n/**\r\n * @author bhouston / http://exocortex.com\r\n * @author WestLangley / http://github.com/WestLangley\r\n */\r\n\r\nTHREE.Box3 = function ( min, max ) {\r\n\r\n\tthis.min = ( min !== undefined ) ? min : new THREE.Vector3( Infinity, Infinity, Infinity );\r\n\tthis.max = ( max !== undefined ) ? max : new THREE.Vector3( - Infinity, - Infinity, - Infinity );\r\n\r\n};\r\n\r\nTHREE.Box3.prototype = {\r\n\r\n\tconstructor: THREE.Box3,\r\n\r\n\tset: function ( min, max ) {\r\n\r\n\t\tthis.min.copy( min );\r\n\t\tthis.max.copy( max );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetFromPoints: function ( points ) {\r\n\r\n\t\tthis.makeEmpty();\r\n\r\n\t\tfor ( var i = 0, il = points.length; i < il; i ++ ) {\r\n\r\n\t\t\tthis.expandByPoint( points[ i ] )\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetFromCenterAndSize: function () {\r\n\r\n\t\tvar v1 = new THREE.Vector3();\r\n\r\n\t\treturn function ( center, size ) {\r\n\r\n\t\t\tvar halfSize = v1.copy( size ).multiplyScalar( 0.5 );\r\n\r\n\t\t\tthis.min.copy( center ).sub( halfSize );\r\n\t\t\tthis.max.copy( center ).add( halfSize );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tsetFromObject: function () {\r\n\r\n\t\t// Computes the world-axis-aligned bounding box of an object (including its children),\r\n\t\t// accounting for both the object's, and childrens', world transforms\r\n\r\n\t\tvar v1 = new THREE.Vector3();\r\n\r\n\t\treturn function ( object ) {\r\n\r\n\t\t\tvar scope = this;\r\n\r\n\t\t\tobject.updateMatrixWorld( true );\r\n\r\n\t\t\tthis.makeEmpty();\r\n\r\n\t\t\tobject.traverse( function ( node ) {\r\n\r\n\t\t\t\tvar geometry = node.geometry;\r\n\r\n\t\t\t\tif ( geometry !== undefined ) {\r\n\r\n\t\t\t\t\tif ( geometry instanceof THREE.Geometry ) {\r\n\r\n\t\t\t\t\t\tvar vertices = geometry.vertices;\r\n\r\n\t\t\t\t\t\tfor ( var i = 0, il = vertices.length; i < il; i ++ ) {\r\n\r\n\t\t\t\t\t\t\tv1.copy( vertices[ i ] );\r\n\r\n\t\t\t\t\t\t\tv1.applyMatrix4( node.matrixWorld );\r\n\r\n\t\t\t\t\t\t\tscope.expandByPoint( v1 );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t} else if ( geometry instanceof THREE.BufferGeometry && geometry.attributes[ 'position' ] !== undefined ) {\r\n\r\n\t\t\t\t\t\tvar positions = geometry.attributes[ 'position' ].array;\r\n\r\n\t\t\t\t\t\tfor ( var i = 0, il = positions.length; i < il; i += 3 ) {\r\n\r\n\t\t\t\t\t\t\tv1.set( positions[ i ], positions[ i + 1 ], positions[ i + 2 ] );\r\n\r\n\t\t\t\t\t\t\tv1.applyMatrix4( node.matrixWorld );\r\n\r\n\t\t\t\t\t\t\tscope.expandByPoint( v1 );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tcopy: function ( box ) {\r\n\r\n\t\tthis.min.copy( box.min );\r\n\t\tthis.max.copy( box.max );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmakeEmpty: function () {\r\n\r\n\t\tthis.min.x = this.min.y = this.min.z = Infinity;\r\n\t\tthis.max.x = this.max.y = this.max.z = - Infinity;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tempty: function () {\r\n\r\n\t\t// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes\r\n\r\n\t\treturn ( this.max.x < this.min.x ) || ( this.max.y < this.min.y ) || ( this.max.z < this.min.z );\r\n\r\n\t},\r\n\r\n\tcenter: function ( optionalTarget ) {\r\n\r\n\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\t\treturn result.addVectors( this.min, this.max ).multiplyScalar( 0.5 );\r\n\r\n\t},\r\n\r\n\tsize: function ( optionalTarget ) {\r\n\r\n\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\t\treturn result.subVectors( this.max, this.min );\r\n\r\n\t},\r\n\r\n\texpandByPoint: function ( point ) {\r\n\r\n\t\tthis.min.min( point );\r\n\t\tthis.max.max( point );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\texpandByVector: function ( vector ) {\r\n\r\n\t\tthis.min.sub( vector );\r\n\t\tthis.max.add( vector );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\texpandByScalar: function ( scalar ) {\r\n\r\n\t\tthis.min.addScalar( - scalar );\r\n\t\tthis.max.addScalar( scalar );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tcontainsPoint: function ( point ) {\r\n\r\n\t\tif ( point.x < this.min.x || point.x > this.max.x ||\r\n\t\t     point.y < this.min.y || point.y > this.max.y ||\r\n\t\t     point.z < this.min.z || point.z > this.max.z ) {\r\n\r\n\t\t\treturn false;\r\n\r\n\t\t}\r\n\r\n\t\treturn true;\r\n\r\n\t},\r\n\r\n\tcontainsBox: function ( box ) {\r\n\r\n\t\tif ( ( this.min.x <= box.min.x ) && ( box.max.x <= this.max.x ) &&\r\n\t\t\t ( this.min.y <= box.min.y ) && ( box.max.y <= this.max.y ) &&\r\n\t\t\t ( this.min.z <= box.min.z ) && ( box.max.z <= this.max.z ) ) {\r\n\r\n\t\t\treturn true;\r\n\r\n\t\t}\r\n\r\n\t\treturn false;\r\n\r\n\t},\r\n\r\n\tgetParameter: function ( point, optionalTarget ) {\r\n\r\n\t\t// This can potentially have a divide by zero if the box\r\n\t\t// has a size dimension of 0.\r\n\r\n\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\r\n\t\treturn result.set(\r\n\t\t\t( point.x - this.min.x ) / ( this.max.x - this.min.x ),\r\n\t\t\t( point.y - this.min.y ) / ( this.max.y - this.min.y ),\r\n\t\t\t( point.z - this.min.z ) / ( this.max.z - this.min.z )\r\n\t\t);\r\n\r\n\t},\r\n\r\n\tisIntersectionBox: function ( box ) {\r\n\r\n\t\t// using 6 splitting planes to rule out intersections.\r\n\r\n\t\tif ( box.max.x < this.min.x || box.min.x > this.max.x ||\r\n\t\t     box.max.y < this.min.y || box.min.y > this.max.y ||\r\n\t\t     box.max.z < this.min.z || box.min.z > this.max.z ) {\r\n\r\n\t\t\treturn false;\r\n\r\n\t\t}\r\n\r\n\t\treturn true;\r\n\r\n\t},\r\n\r\n\tclampPoint: function ( point, optionalTarget ) {\r\n\r\n\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\t\treturn result.copy( point ).clamp( this.min, this.max );\r\n\r\n\t},\r\n\r\n\tdistanceToPoint: function () {\r\n\r\n\t\tvar v1 = new THREE.Vector3();\r\n\r\n\t\treturn function ( point ) {\r\n\r\n\t\t\tvar clampedPoint = v1.copy( point ).clamp( this.min, this.max );\r\n\t\t\treturn clampedPoint.sub( point ).length();\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tgetBoundingSphere: function () {\r\n\r\n\t\tvar v1 = new THREE.Vector3();\r\n\r\n\t\treturn function ( optionalTarget ) {\r\n\r\n\t\t\tvar result = optionalTarget || new THREE.Sphere();\r\n\r\n\t\t\tresult.center = this.center();\r\n\t\t\tresult.radius = this.size( v1 ).length() * 0.5;\r\n\r\n\t\t\treturn result;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tintersect: function ( box ) {\r\n\r\n\t\tthis.min.max( box.min );\r\n\t\tthis.max.min( box.max );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tunion: function ( box ) {\r\n\r\n\t\tthis.min.min( box.min );\r\n\t\tthis.max.max( box.max );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tapplyMatrix4: function () {\r\n\r\n\t\tvar points = [\r\n\t\t\tnew THREE.Vector3(),\r\n\t\t\tnew THREE.Vector3(),\r\n\t\t\tnew THREE.Vector3(),\r\n\t\t\tnew THREE.Vector3(),\r\n\t\t\tnew THREE.Vector3(),\r\n\t\t\tnew THREE.Vector3(),\r\n\t\t\tnew THREE.Vector3(),\r\n\t\t\tnew THREE.Vector3()\r\n\t\t];\r\n\r\n\t\treturn function ( matrix ) {\r\n\r\n\t\t\t// NOTE: I am using a binary pattern to specify all 2^3 combinations below\r\n\t\t\tpoints[ 0 ].set( this.min.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 000\r\n\t\t\tpoints[ 1 ].set( this.min.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 001\r\n\t\t\tpoints[ 2 ].set( this.min.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 010\r\n\t\t\tpoints[ 3 ].set( this.min.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 011\r\n\t\t\tpoints[ 4 ].set( this.max.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 100\r\n\t\t\tpoints[ 5 ].set( this.max.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 101\r\n\t\t\tpoints[ 6 ].set( this.max.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 110\r\n\t\t\tpoints[ 7 ].set( this.max.x, this.max.y, this.max.z ).applyMatrix4( matrix );  // 111\r\n\r\n\t\t\tthis.makeEmpty();\r\n\t\t\tthis.setFromPoints( points );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\ttranslate: function ( offset ) {\r\n\r\n\t\tthis.min.add( offset );\r\n\t\tthis.max.add( offset );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tequals: function ( box ) {\r\n\r\n\t\treturn box.min.equals( this.min ) && box.max.equals( this.max );\r\n\r\n\t},\r\n\r\n\tclone: function () {\r\n\r\n\t\treturn new THREE.Box3().copy( this );\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/math/Matrix3.js\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author WestLangley / http://github.com/WestLangley\r\n * @author bhouston / http://exocortex.com\r\n */\r\n\r\nTHREE.Matrix3 = function () {\r\n\r\n\tthis.elements = new Float32Array( [\r\n\r\n\t\t1, 0, 0,\r\n\t\t0, 1, 0,\r\n\t\t0, 0, 1\r\n\r\n\t] );\r\n\r\n\tif ( arguments.length > 0 ) {\r\n\r\n\t\tTHREE.error( 'THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.' );\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.Matrix3.prototype = {\r\n\r\n\tconstructor: THREE.Matrix3,\r\n\r\n\tset: function ( n11, n12, n13, n21, n22, n23, n31, n32, n33 ) {\r\n\r\n\t\tvar te = this.elements;\r\n\r\n\t\tte[ 0 ] = n11; te[ 3 ] = n12; te[ 6 ] = n13;\r\n\t\tte[ 1 ] = n21; te[ 4 ] = n22; te[ 7 ] = n23;\r\n\t\tte[ 2 ] = n31; te[ 5 ] = n32; te[ 8 ] = n33;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tidentity: function () {\r\n\r\n\t\tthis.set(\r\n\r\n\t\t\t1, 0, 0,\r\n\t\t\t0, 1, 0,\r\n\t\t\t0, 0, 1\r\n\r\n\t\t);\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tcopy: function ( m ) {\r\n\r\n\t\tvar me = m.elements;\r\n\r\n\t\tthis.set(\r\n\r\n\t\t\tme[ 0 ], me[ 3 ], me[ 6 ],\r\n\t\t\tme[ 1 ], me[ 4 ], me[ 7 ],\r\n\t\t\tme[ 2 ], me[ 5 ], me[ 8 ]\r\n\r\n\t\t);\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmultiplyVector3: function ( vector ) {\r\n\r\n\t\tTHREE.warn( 'THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.' );\r\n\t\treturn vector.applyMatrix3( this );\r\n\r\n\t},\r\n\r\n\tmultiplyVector3Array: function ( a ) {\r\n\r\n\t\tTHREE.warn( 'THREE.Matrix3: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead.' );\r\n\t\treturn this.applyToVector3Array( a );\r\n\r\n\t},\r\n\r\n\tapplyToVector3Array: function () {\r\n\r\n\t\tvar v1 = new THREE.Vector3();\r\n\r\n\t\treturn function ( array, offset, length ) {\r\n\r\n\t\t\tif ( offset === undefined ) offset = 0;\r\n\t\t\tif ( length === undefined ) length = array.length;\r\n\r\n\t\t\tfor ( var i = 0, j = offset; i < length; i += 3, j += 3 ) {\r\n\r\n\t\t\t\tv1.x = array[ j ];\r\n\t\t\t\tv1.y = array[ j + 1 ];\r\n\t\t\t\tv1.z = array[ j + 2 ];\r\n\r\n\t\t\t\tv1.applyMatrix3( this );\r\n\r\n\t\t\t\tarray[ j ]     = v1.x;\r\n\t\t\t\tarray[ j + 1 ] = v1.y;\r\n\t\t\t\tarray[ j + 2 ] = v1.z;\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn array;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tmultiplyScalar: function ( s ) {\r\n\r\n\t\tvar te = this.elements;\r\n\r\n\t\tte[ 0 ] *= s; te[ 3 ] *= s; te[ 6 ] *= s;\r\n\t\tte[ 1 ] *= s; te[ 4 ] *= s; te[ 7 ] *= s;\r\n\t\tte[ 2 ] *= s; te[ 5 ] *= s; te[ 8 ] *= s;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tdeterminant: function () {\r\n\r\n\t\tvar te = this.elements;\r\n\r\n\t\tvar a = te[ 0 ], b = te[ 1 ], c = te[ 2 ],\r\n\t\t\td = te[ 3 ], e = te[ 4 ], f = te[ 5 ],\r\n\t\t\tg = te[ 6 ], h = te[ 7 ], i = te[ 8 ];\r\n\r\n\t\treturn a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;\r\n\r\n\t},\r\n\r\n\tgetInverse: function ( matrix, throwOnInvertible ) {\r\n\r\n\t\t// input: THREE.Matrix4\r\n\t\t// ( based on http://code.google.com/p/webgl-mjs/ )\r\n\r\n\t\tvar me = matrix.elements;\r\n\t\tvar te = this.elements;\r\n\r\n\t\tte[ 0 ] =   me[ 10 ] * me[ 5 ] - me[ 6 ] * me[ 9 ];\r\n\t\tte[ 1 ] = - me[ 10 ] * me[ 1 ] + me[ 2 ] * me[ 9 ];\r\n\t\tte[ 2 ] =   me[ 6 ] * me[ 1 ] - me[ 2 ] * me[ 5 ];\r\n\t\tte[ 3 ] = - me[ 10 ] * me[ 4 ] + me[ 6 ] * me[ 8 ];\r\n\t\tte[ 4 ] =   me[ 10 ] * me[ 0 ] - me[ 2 ] * me[ 8 ];\r\n\t\tte[ 5 ] = - me[ 6 ] * me[ 0 ] + me[ 2 ] * me[ 4 ];\r\n\t\tte[ 6 ] =   me[ 9 ] * me[ 4 ] - me[ 5 ] * me[ 8 ];\r\n\t\tte[ 7 ] = - me[ 9 ] * me[ 0 ] + me[ 1 ] * me[ 8 ];\r\n\t\tte[ 8 ] =   me[ 5 ] * me[ 0 ] - me[ 1 ] * me[ 4 ];\r\n\r\n\t\tvar det = me[ 0 ] * te[ 0 ] + me[ 1 ] * te[ 3 ] + me[ 2 ] * te[ 6 ];\r\n\r\n\t\t// no inverse\r\n\r\n\t\tif ( det === 0 ) {\r\n\r\n\t\t\tvar msg = \"Matrix3.getInverse(): can't invert matrix, determinant is 0\";\r\n\r\n\t\t\tif ( throwOnInvertible || false ) {\r\n\r\n\t\t\t\tthrow new Error( msg );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tTHREE.warn( msg );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis.identity();\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\tthis.multiplyScalar( 1.0 / det );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\ttranspose: function () {\r\n\r\n\t\tvar tmp, m = this.elements;\r\n\r\n\t\ttmp = m[ 1 ]; m[ 1 ] = m[ 3 ]; m[ 3 ] = tmp;\r\n\t\ttmp = m[ 2 ]; m[ 2 ] = m[ 6 ]; m[ 6 ] = tmp;\r\n\t\ttmp = m[ 5 ]; m[ 5 ] = m[ 7 ]; m[ 7 ] = tmp;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tflattenToArrayOffset: function ( array, offset ) {\r\n\r\n\t\tvar te = this.elements;\r\n\r\n\t\tarray[ offset     ] = te[ 0 ];\r\n\t\tarray[ offset + 1 ] = te[ 1 ];\r\n\t\tarray[ offset + 2 ] = te[ 2 ];\r\n\r\n\t\tarray[ offset + 3 ] = te[ 3 ];\r\n\t\tarray[ offset + 4 ] = te[ 4 ];\r\n\t\tarray[ offset + 5 ] = te[ 5 ];\r\n\r\n\t\tarray[ offset + 6 ] = te[ 6 ];\r\n\t\tarray[ offset + 7 ] = te[ 7 ];\r\n\t\tarray[ offset + 8 ]  = te[ 8 ];\r\n\r\n\t\treturn array;\r\n\r\n\t},\r\n\r\n\tgetNormalMatrix: function ( m ) {\r\n\r\n\t\t// input: THREE.Matrix4\r\n\r\n\t\tthis.getInverse( m ).transpose();\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\ttransposeIntoArray: function ( r ) {\r\n\r\n\t\tvar m = this.elements;\r\n\r\n\t\tr[ 0 ] = m[ 0 ];\r\n\t\tr[ 1 ] = m[ 3 ];\r\n\t\tr[ 2 ] = m[ 6 ];\r\n\t\tr[ 3 ] = m[ 1 ];\r\n\t\tr[ 4 ] = m[ 4 ];\r\n\t\tr[ 5 ] = m[ 7 ];\r\n\t\tr[ 6 ] = m[ 2 ];\r\n\t\tr[ 7 ] = m[ 5 ];\r\n\t\tr[ 8 ] = m[ 8 ];\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tfromArray: function ( array ) {\r\n\r\n\t\tthis.elements.set( array );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\ttoArray: function () {\r\n\r\n\t\tvar te = this.elements;\r\n\r\n\t\treturn [\r\n\t\t\tte[ 0 ], te[ 1 ], te[ 2 ],\r\n\t\t\tte[ 3 ], te[ 4 ], te[ 5 ],\r\n\t\t\tte[ 6 ], te[ 7 ], te[ 8 ]\r\n\t\t];\r\n\r\n\t},\r\n\r\n\tclone: function () {\r\n\r\n\t\treturn new THREE.Matrix3().fromArray( this.elements );\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/math/Matrix4.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author supereggbert / http://www.paulbrunt.co.uk/\r\n * @author philogb / http://blog.thejit.org/\r\n * @author jordi_ros / http://plattsoft.com\r\n * @author D1plo1d / http://github.com/D1plo1d\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author timknip / http://www.floorplanner.com/\r\n * @author bhouston / http://exocortex.com\r\n * @author WestLangley / http://github.com/WestLangley\r\n */\r\n\r\nTHREE.Matrix4 = function () {\r\n\r\n\tthis.elements = new Float32Array( [\r\n\r\n\t\t1, 0, 0, 0,\r\n\t\t0, 1, 0, 0,\r\n\t\t0, 0, 1, 0,\r\n\t\t0, 0, 0, 1\r\n\r\n\t] );\r\n\r\n\tif ( arguments.length > 0 ) {\r\n\r\n\t\tTHREE.error( 'THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.' );\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.Matrix4.prototype = {\r\n\r\n\tconstructor: THREE.Matrix4,\r\n\r\n\tset: function ( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 ) {\r\n\r\n\t\tvar te = this.elements;\r\n\r\n\t\tte[ 0 ] = n11; te[ 4 ] = n12; te[ 8 ] = n13; te[ 12 ] = n14;\r\n\t\tte[ 1 ] = n21; te[ 5 ] = n22; te[ 9 ] = n23; te[ 13 ] = n24;\r\n\t\tte[ 2 ] = n31; te[ 6 ] = n32; te[ 10 ] = n33; te[ 14 ] = n34;\r\n\t\tte[ 3 ] = n41; te[ 7 ] = n42; te[ 11 ] = n43; te[ 15 ] = n44;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tidentity: function () {\r\n\r\n\t\tthis.set(\r\n\r\n\t\t\t1, 0, 0, 0,\r\n\t\t\t0, 1, 0, 0,\r\n\t\t\t0, 0, 1, 0,\r\n\t\t\t0, 0, 0, 1\r\n\r\n\t\t);\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tcopy: function ( m ) {\r\n\r\n\t\tthis.elements.set( m.elements );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\textractPosition: function ( m ) {\r\n\r\n\t\tTHREE.warn( 'THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().' );\r\n\t\treturn this.copyPosition( m );\r\n\r\n\t},\r\n\r\n\tcopyPosition: function ( m ) {\r\n\r\n\t\tvar te = this.elements;\r\n\t\tvar me = m.elements;\r\n\r\n\t\tte[ 12 ] = me[ 12 ];\r\n\t\tte[ 13 ] = me[ 13 ];\r\n\t\tte[ 14 ] = me[ 14 ];\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\textractBasis: function ( xAxis, yAxis, zAxis ) {\r\n \r\n\t\tvar te = this.elements;\r\n \r\n\t\txAxis.set( te[ 0 ], te[ 1 ], te[ 2 ] );\r\n\t\tyAxis.set( te[ 4 ], te[ 5 ], te[ 6 ] );\r\n\t\tzAxis.set( te[ 8 ], te[ 9 ], te[ 10 ] );\r\n \r\n\t\treturn this;\r\n \t\t\r\n\t},\r\n \r\n\tmakeBasis: function ( xAxis, yAxis, zAxis ) {\r\n\r\n\t\tthis.set(\r\n\t\t\txAxis.x, yAxis.x, zAxis.x, 0,\r\n\t\t\txAxis.y, yAxis.y, zAxis.y, 0,\r\n\t\t\txAxis.z, yAxis.z, zAxis.z, 0,\r\n\t\t\t0,       0,       0,       1\r\n\t\t);\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\textractRotation: function () {\r\n\r\n\t\tvar v1 = new THREE.Vector3();\r\n\r\n\t\treturn function ( m ) {\r\n\r\n\t\t\tvar te = this.elements;\r\n\t\t\tvar me = m.elements;\r\n\r\n\t\t\tvar scaleX = 1 / v1.set( me[ 0 ], me[ 1 ], me[ 2 ] ).length();\r\n\t\t\tvar scaleY = 1 / v1.set( me[ 4 ], me[ 5 ], me[ 6 ] ).length();\r\n\t\t\tvar scaleZ = 1 / v1.set( me[ 8 ], me[ 9 ], me[ 10 ] ).length();\r\n\r\n\t\t\tte[ 0 ] = me[ 0 ] * scaleX;\r\n\t\t\tte[ 1 ] = me[ 1 ] * scaleX;\r\n\t\t\tte[ 2 ] = me[ 2 ] * scaleX;\r\n\r\n\t\t\tte[ 4 ] = me[ 4 ] * scaleY;\r\n\t\t\tte[ 5 ] = me[ 5 ] * scaleY;\r\n\t\t\tte[ 6 ] = me[ 6 ] * scaleY;\r\n\r\n\t\t\tte[ 8 ] = me[ 8 ] * scaleZ;\r\n\t\t\tte[ 9 ] = me[ 9 ] * scaleZ;\r\n\t\t\tte[ 10 ] = me[ 10 ] * scaleZ;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tmakeRotationFromEuler: function ( euler ) {\r\n\r\n\t\tif ( euler instanceof THREE.Euler === false ) {\r\n\r\n\t\t\tTHREE.error( 'THREE.Matrix: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.' );\r\n\r\n\t\t}\r\n\r\n\t\tvar te = this.elements;\r\n\r\n\t\tvar x = euler.x, y = euler.y, z = euler.z;\r\n\t\tvar a = Math.cos( x ), b = Math.sin( x );\r\n\t\tvar c = Math.cos( y ), d = Math.sin( y );\r\n\t\tvar e = Math.cos( z ), f = Math.sin( z );\r\n\r\n\t\tif ( euler.order === 'XYZ' ) {\r\n\r\n\t\t\tvar ae = a * e, af = a * f, be = b * e, bf = b * f;\r\n\r\n\t\t\tte[ 0 ] = c * e;\r\n\t\t\tte[ 4 ] = - c * f;\r\n\t\t\tte[ 8 ] = d;\r\n\r\n\t\t\tte[ 1 ] = af + be * d;\r\n\t\t\tte[ 5 ] = ae - bf * d;\r\n\t\t\tte[ 9 ] = - b * c;\r\n\r\n\t\t\tte[ 2 ] = bf - ae * d;\r\n\t\t\tte[ 6 ] = be + af * d;\r\n\t\t\tte[ 10 ] = a * c;\r\n\r\n\t\t} else if ( euler.order === 'YXZ' ) {\r\n\r\n\t\t\tvar ce = c * e, cf = c * f, de = d * e, df = d * f;\r\n\r\n\t\t\tte[ 0 ] = ce + df * b;\r\n\t\t\tte[ 4 ] = de * b - cf;\r\n\t\t\tte[ 8 ] = a * d;\r\n\r\n\t\t\tte[ 1 ] = a * f;\r\n\t\t\tte[ 5 ] = a * e;\r\n\t\t\tte[ 9 ] = - b;\r\n\r\n\t\t\tte[ 2 ] = cf * b - de;\r\n\t\t\tte[ 6 ] = df + ce * b;\r\n\t\t\tte[ 10 ] = a * c;\r\n\r\n\t\t} else if ( euler.order === 'ZXY' ) {\r\n\r\n\t\t\tvar ce = c * e, cf = c * f, de = d * e, df = d * f;\r\n\r\n\t\t\tte[ 0 ] = ce - df * b;\r\n\t\t\tte[ 4 ] = - a * f;\r\n\t\t\tte[ 8 ] = de + cf * b;\r\n\r\n\t\t\tte[ 1 ] = cf + de * b;\r\n\t\t\tte[ 5 ] = a * e;\r\n\t\t\tte[ 9 ] = df - ce * b;\r\n\r\n\t\t\tte[ 2 ] = - a * d;\r\n\t\t\tte[ 6 ] = b;\r\n\t\t\tte[ 10 ] = a * c;\r\n\r\n\t\t} else if ( euler.order === 'ZYX' ) {\r\n\r\n\t\t\tvar ae = a * e, af = a * f, be = b * e, bf = b * f;\r\n\r\n\t\t\tte[ 0 ] = c * e;\r\n\t\t\tte[ 4 ] = be * d - af;\r\n\t\t\tte[ 8 ] = ae * d + bf;\r\n\r\n\t\t\tte[ 1 ] = c * f;\r\n\t\t\tte[ 5 ] = bf * d + ae;\r\n\t\t\tte[ 9 ] = af * d - be;\r\n\r\n\t\t\tte[ 2 ] = - d;\r\n\t\t\tte[ 6 ] = b * c;\r\n\t\t\tte[ 10 ] = a * c;\r\n\r\n\t\t} else if ( euler.order === 'YZX' ) {\r\n\r\n\t\t\tvar ac = a * c, ad = a * d, bc = b * c, bd = b * d;\r\n\r\n\t\t\tte[ 0 ] = c * e;\r\n\t\t\tte[ 4 ] = bd - ac * f;\r\n\t\t\tte[ 8 ] = bc * f + ad;\r\n\r\n\t\t\tte[ 1 ] = f;\r\n\t\t\tte[ 5 ] = a * e;\r\n\t\t\tte[ 9 ] = - b * e;\r\n\r\n\t\t\tte[ 2 ] = - d * e;\r\n\t\t\tte[ 6 ] = ad * f + bc;\r\n\t\t\tte[ 10 ] = ac - bd * f;\r\n\r\n\t\t} else if ( euler.order === 'XZY' ) {\r\n\r\n\t\t\tvar ac = a * c, ad = a * d, bc = b * c, bd = b * d;\r\n\r\n\t\t\tte[ 0 ] = c * e;\r\n\t\t\tte[ 4 ] = - f;\r\n\t\t\tte[ 8 ] = d * e;\r\n\r\n\t\t\tte[ 1 ] = ac * f + bd;\r\n\t\t\tte[ 5 ] = a * e;\r\n\t\t\tte[ 9 ] = ad * f - bc;\r\n\r\n\t\t\tte[ 2 ] = bc * f - ad;\r\n\t\t\tte[ 6 ] = b * e;\r\n\t\t\tte[ 10 ] = bd * f + ac;\r\n\r\n\t\t}\r\n\r\n\t\t// last column\r\n\t\tte[ 3 ] = 0;\r\n\t\tte[ 7 ] = 0;\r\n\t\tte[ 11 ] = 0;\r\n\r\n\t\t// bottom row\r\n\t\tte[ 12 ] = 0;\r\n\t\tte[ 13 ] = 0;\r\n\t\tte[ 14 ] = 0;\r\n\t\tte[ 15 ] = 1;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetRotationFromQuaternion: function ( q ) {\r\n\r\n\t\tTHREE.warn( 'THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().' );\r\n\r\n\t\treturn this.makeRotationFromQuaternion( q );\r\n\r\n\t},\r\n\r\n\tmakeRotationFromQuaternion: function ( q ) {\r\n\r\n\t\tvar te = this.elements;\r\n\r\n\t\tvar x = q.x, y = q.y, z = q.z, w = q.w;\r\n\t\tvar x2 = x + x, y2 = y + y, z2 = z + z;\r\n\t\tvar xx = x * x2, xy = x * y2, xz = x * z2;\r\n\t\tvar yy = y * y2, yz = y * z2, zz = z * z2;\r\n\t\tvar wx = w * x2, wy = w * y2, wz = w * z2;\r\n\r\n\t\tte[ 0 ] = 1 - ( yy + zz );\r\n\t\tte[ 4 ] = xy - wz;\r\n\t\tte[ 8 ] = xz + wy;\r\n\r\n\t\tte[ 1 ] = xy + wz;\r\n\t\tte[ 5 ] = 1 - ( xx + zz );\r\n\t\tte[ 9 ] = yz - wx;\r\n\r\n\t\tte[ 2 ] = xz - wy;\r\n\t\tte[ 6 ] = yz + wx;\r\n\t\tte[ 10 ] = 1 - ( xx + yy );\r\n\r\n\t\t// last column\r\n\t\tte[ 3 ] = 0;\r\n\t\tte[ 7 ] = 0;\r\n\t\tte[ 11 ] = 0;\r\n\r\n\t\t// bottom row\r\n\t\tte[ 12 ] = 0;\r\n\t\tte[ 13 ] = 0;\r\n\t\tte[ 14 ] = 0;\r\n\t\tte[ 15 ] = 1;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tlookAt: function () {\r\n\r\n\t\tvar x = new THREE.Vector3();\r\n\t\tvar y = new THREE.Vector3();\r\n\t\tvar z = new THREE.Vector3();\r\n\r\n\t\treturn function ( eye, target, up ) {\r\n\r\n\t\t\tvar te = this.elements;\r\n\r\n\t\t\tz.subVectors( eye, target ).normalize();\r\n\r\n\t\t\tif ( z.length() === 0 ) {\r\n\r\n\t\t\t\tz.z = 1;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tx.crossVectors( up, z ).normalize();\r\n\r\n\t\t\tif ( x.length() === 0 ) {\r\n\r\n\t\t\t\tz.x += 0.0001;\r\n\t\t\t\tx.crossVectors( up, z ).normalize();\r\n\r\n\t\t\t}\r\n\r\n\t\t\ty.crossVectors( z, x );\r\n\r\n\r\n\t\t\tte[ 0 ] = x.x; te[ 4 ] = y.x; te[ 8 ] = z.x;\r\n\t\t\tte[ 1 ] = x.y; te[ 5 ] = y.y; te[ 9 ] = z.y;\r\n\t\t\tte[ 2 ] = x.z; te[ 6 ] = y.z; te[ 10 ] = z.z;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tmultiply: function ( m, n ) {\r\n\r\n\t\tif ( n !== undefined ) {\r\n\r\n\t\t\tTHREE.warn( 'THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.' );\r\n\t\t\treturn this.multiplyMatrices( m, n );\r\n\r\n\t\t}\r\n\r\n\t\treturn this.multiplyMatrices( this, m );\r\n\r\n\t},\r\n\r\n\tmultiplyMatrices: function ( a, b ) {\r\n\r\n\t\tvar ae = a.elements;\r\n\t\tvar be = b.elements;\r\n\t\tvar te = this.elements;\r\n\r\n\t\tvar a11 = ae[ 0 ], a12 = ae[ 4 ], a13 = ae[ 8 ], a14 = ae[ 12 ];\r\n\t\tvar a21 = ae[ 1 ], a22 = ae[ 5 ], a23 = ae[ 9 ], a24 = ae[ 13 ];\r\n\t\tvar a31 = ae[ 2 ], a32 = ae[ 6 ], a33 = ae[ 10 ], a34 = ae[ 14 ];\r\n\t\tvar a41 = ae[ 3 ], a42 = ae[ 7 ], a43 = ae[ 11 ], a44 = ae[ 15 ];\r\n\r\n\t\tvar b11 = be[ 0 ], b12 = be[ 4 ], b13 = be[ 8 ], b14 = be[ 12 ];\r\n\t\tvar b21 = be[ 1 ], b22 = be[ 5 ], b23 = be[ 9 ], b24 = be[ 13 ];\r\n\t\tvar b31 = be[ 2 ], b32 = be[ 6 ], b33 = be[ 10 ], b34 = be[ 14 ];\r\n\t\tvar b41 = be[ 3 ], b42 = be[ 7 ], b43 = be[ 11 ], b44 = be[ 15 ];\r\n\r\n\t\tte[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;\r\n\t\tte[ 4 ] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;\r\n\t\tte[ 8 ] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;\r\n\t\tte[ 12 ] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;\r\n\r\n\t\tte[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;\r\n\t\tte[ 5 ] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;\r\n\t\tte[ 9 ] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;\r\n\t\tte[ 13 ] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;\r\n\r\n\t\tte[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;\r\n\t\tte[ 6 ] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;\r\n\t\tte[ 10 ] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;\r\n\t\tte[ 14 ] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;\r\n\r\n\t\tte[ 3 ] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;\r\n\t\tte[ 7 ] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;\r\n\t\tte[ 11 ] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;\r\n\t\tte[ 15 ] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmultiplyToArray: function ( a, b, r ) {\r\n\r\n\t\tvar te = this.elements;\r\n\r\n\t\tthis.multiplyMatrices( a, b );\r\n\r\n\t\tr[ 0 ] = te[ 0 ]; r[ 1 ] = te[ 1 ]; r[ 2 ] = te[ 2 ]; r[ 3 ] = te[ 3 ];\r\n\t\tr[ 4 ] = te[ 4 ]; r[ 5 ] = te[ 5 ]; r[ 6 ] = te[ 6 ]; r[ 7 ] = te[ 7 ];\r\n\t\tr[ 8 ]  = te[ 8 ]; r[ 9 ]  = te[ 9 ]; r[ 10 ] = te[ 10 ]; r[ 11 ] = te[ 11 ];\r\n\t\tr[ 12 ] = te[ 12 ]; r[ 13 ] = te[ 13 ]; r[ 14 ] = te[ 14 ]; r[ 15 ] = te[ 15 ];\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmultiplyScalar: function ( s ) {\r\n\r\n\t\tvar te = this.elements;\r\n\r\n\t\tte[ 0 ] *= s; te[ 4 ] *= s; te[ 8 ] *= s; te[ 12 ] *= s;\r\n\t\tte[ 1 ] *= s; te[ 5 ] *= s; te[ 9 ] *= s; te[ 13 ] *= s;\r\n\t\tte[ 2 ] *= s; te[ 6 ] *= s; te[ 10 ] *= s; te[ 14 ] *= s;\r\n\t\tte[ 3 ] *= s; te[ 7 ] *= s; te[ 11 ] *= s; te[ 15 ] *= s;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmultiplyVector3: function ( vector ) {\r\n\r\n\t\tTHREE.warn( 'THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) or vector.applyProjection( matrix ) instead.' );\r\n\t\treturn vector.applyProjection( this );\r\n\r\n\t},\r\n\r\n\tmultiplyVector4: function ( vector ) {\r\n\r\n\t\tTHREE.warn( 'THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.' );\r\n\t\treturn vector.applyMatrix4( this );\r\n\r\n\t},\r\n\r\n\tmultiplyVector3Array: function ( a ) {\r\n\r\n\t\tTHREE.warn( 'THREE.Matrix4: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead.' );\r\n\t\treturn this.applyToVector3Array( a );\r\n\r\n\t},\r\n\r\n\tapplyToVector3Array: function () {\r\n\r\n\t\tvar v1 = new THREE.Vector3();\r\n\r\n\t\treturn function ( array, offset, length ) {\r\n\r\n\t\t\tif ( offset === undefined ) offset = 0;\r\n\t\t\tif ( length === undefined ) length = array.length;\r\n\r\n\t\t\tfor ( var i = 0, j = offset; i < length; i += 3, j += 3 ) {\r\n\r\n\t\t\t\tv1.x = array[ j ];\r\n\t\t\t\tv1.y = array[ j + 1 ];\r\n\t\t\t\tv1.z = array[ j + 2 ];\r\n\r\n\t\t\t\tv1.applyMatrix4( this );\r\n\r\n\t\t\t\tarray[ j ]     = v1.x;\r\n\t\t\t\tarray[ j + 1 ] = v1.y;\r\n\t\t\t\tarray[ j + 2 ] = v1.z;\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn array;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\trotateAxis: function ( v ) {\r\n\r\n\t\tTHREE.warn( 'THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.' );\r\n\r\n\t\tv.transformDirection( this );\r\n\r\n\t},\r\n\r\n\tcrossVector: function ( vector ) {\r\n\r\n\t\tTHREE.warn( 'THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.' );\r\n\t\treturn vector.applyMatrix4( this );\r\n\r\n\t},\r\n\r\n\tdeterminant: function () {\r\n\r\n\t\tvar te = this.elements;\r\n\r\n\t\tvar n11 = te[ 0 ], n12 = te[ 4 ], n13 = te[ 8 ], n14 = te[ 12 ];\r\n\t\tvar n21 = te[ 1 ], n22 = te[ 5 ], n23 = te[ 9 ], n24 = te[ 13 ];\r\n\t\tvar n31 = te[ 2 ], n32 = te[ 6 ], n33 = te[ 10 ], n34 = te[ 14 ];\r\n\t\tvar n41 = te[ 3 ], n42 = te[ 7 ], n43 = te[ 11 ], n44 = te[ 15 ];\r\n\r\n\t\t//TODO: make this more efficient\r\n\t\t//( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )\r\n\r\n\t\treturn (\r\n\t\t\tn41 * (\r\n\t\t\t\t+ n14 * n23 * n32\r\n\t\t\t\t - n13 * n24 * n32\r\n\t\t\t\t - n14 * n22 * n33\r\n\t\t\t\t + n12 * n24 * n33\r\n\t\t\t\t + n13 * n22 * n34\r\n\t\t\t\t - n12 * n23 * n34\r\n\t\t\t) +\r\n\t\t\tn42 * (\r\n\t\t\t\t+ n11 * n23 * n34\r\n\t\t\t\t - n11 * n24 * n33\r\n\t\t\t\t + n14 * n21 * n33\r\n\t\t\t\t - n13 * n21 * n34\r\n\t\t\t\t + n13 * n24 * n31\r\n\t\t\t\t - n14 * n23 * n31\r\n\t\t\t) +\r\n\t\t\tn43 * (\r\n\t\t\t\t+ n11 * n24 * n32\r\n\t\t\t\t - n11 * n22 * n34\r\n\t\t\t\t - n14 * n21 * n32\r\n\t\t\t\t + n12 * n21 * n34\r\n\t\t\t\t + n14 * n22 * n31\r\n\t\t\t\t - n12 * n24 * n31\r\n\t\t\t) +\r\n\t\t\tn44 * (\r\n\t\t\t\t- n13 * n22 * n31\r\n\t\t\t\t - n11 * n23 * n32\r\n\t\t\t\t + n11 * n22 * n33\r\n\t\t\t\t + n13 * n21 * n32\r\n\t\t\t\t - n12 * n21 * n33\r\n\t\t\t\t + n12 * n23 * n31\r\n\t\t\t)\r\n\r\n\t\t);\r\n\r\n\t},\r\n\r\n\ttranspose: function () {\r\n\r\n\t\tvar te = this.elements;\r\n\t\tvar tmp;\r\n\r\n\t\ttmp = te[ 1 ]; te[ 1 ] = te[ 4 ]; te[ 4 ] = tmp;\r\n\t\ttmp = te[ 2 ]; te[ 2 ] = te[ 8 ]; te[ 8 ] = tmp;\r\n\t\ttmp = te[ 6 ]; te[ 6 ] = te[ 9 ]; te[ 9 ] = tmp;\r\n\r\n\t\ttmp = te[ 3 ]; te[ 3 ] = te[ 12 ]; te[ 12 ] = tmp;\r\n\t\ttmp = te[ 7 ]; te[ 7 ] = te[ 13 ]; te[ 13 ] = tmp;\r\n\t\ttmp = te[ 11 ]; te[ 11 ] = te[ 14 ]; te[ 14 ] = tmp;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tflattenToArrayOffset: function ( array, offset ) {\r\n\r\n\t\tvar te = this.elements;\r\n\r\n\t\tarray[ offset     ] = te[ 0 ];\r\n\t\tarray[ offset + 1 ] = te[ 1 ];\r\n\t\tarray[ offset + 2 ] = te[ 2 ];\r\n\t\tarray[ offset + 3 ] = te[ 3 ];\r\n\r\n\t\tarray[ offset + 4 ] = te[ 4 ];\r\n\t\tarray[ offset + 5 ] = te[ 5 ];\r\n\t\tarray[ offset + 6 ] = te[ 6 ];\r\n\t\tarray[ offset + 7 ] = te[ 7 ];\r\n\r\n\t\tarray[ offset + 8 ]  = te[ 8 ];\r\n\t\tarray[ offset + 9 ]  = te[ 9 ];\r\n\t\tarray[ offset + 10 ] = te[ 10 ];\r\n\t\tarray[ offset + 11 ] = te[ 11 ];\r\n\r\n\t\tarray[ offset + 12 ] = te[ 12 ];\r\n\t\tarray[ offset + 13 ] = te[ 13 ];\r\n\t\tarray[ offset + 14 ] = te[ 14 ];\r\n\t\tarray[ offset + 15 ] = te[ 15 ];\r\n\r\n\t\treturn array;\r\n\r\n\t},\r\n\r\n\tgetPosition: function () {\r\n\r\n\t\tvar v1 = new THREE.Vector3();\r\n\r\n\t\treturn function () {\r\n\r\n\t\t\tTHREE.warn( 'THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.' );\r\n\r\n\t\t\tvar te = this.elements;\r\n\t\t\treturn v1.set( te[ 12 ], te[ 13 ], te[ 14 ] );\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tsetPosition: function ( v ) {\r\n\r\n\t\tvar te = this.elements;\r\n\r\n\t\tte[ 12 ] = v.x;\r\n\t\tte[ 13 ] = v.y;\r\n\t\tte[ 14 ] = v.z;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tgetInverse: function ( m, throwOnInvertible ) {\r\n\r\n\t\t// based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm\r\n\t\tvar te = this.elements;\r\n\t\tvar me = m.elements;\r\n\r\n\t\tvar n11 = me[ 0 ], n12 = me[ 4 ], n13 = me[ 8 ], n14 = me[ 12 ];\r\n\t\tvar n21 = me[ 1 ], n22 = me[ 5 ], n23 = me[ 9 ], n24 = me[ 13 ];\r\n\t\tvar n31 = me[ 2 ], n32 = me[ 6 ], n33 = me[ 10 ], n34 = me[ 14 ];\r\n\t\tvar n41 = me[ 3 ], n42 = me[ 7 ], n43 = me[ 11 ], n44 = me[ 15 ];\r\n\r\n\t\tte[ 0 ] = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44;\r\n\t\tte[ 4 ] = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44;\r\n\t\tte[ 8 ] = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44;\r\n\t\tte[ 12 ] = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;\r\n\t\tte[ 1 ] = n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44;\r\n\t\tte[ 5 ] = n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44;\r\n\t\tte[ 9 ] = n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44;\r\n\t\tte[ 13 ] = n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34;\r\n\t\tte[ 2 ] = n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44;\r\n\t\tte[ 6 ] = n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44;\r\n\t\tte[ 10 ] = n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44;\r\n\t\tte[ 14 ] = n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34;\r\n\t\tte[ 3 ] = n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43;\r\n\t\tte[ 7 ] = n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43;\r\n\t\tte[ 11 ] = n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43;\r\n\t\tte[ 15 ] = n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33;\r\n\r\n\t\tvar det = n11 * te[ 0 ] + n21 * te[ 4 ] + n31 * te[ 8 ] + n41 * te[ 12 ];\r\n\r\n\t\tif ( det == 0 ) {\r\n\r\n\t\t\tvar msg = \"THREE.Matrix4.getInverse(): can't invert matrix, determinant is 0\";\r\n\r\n\t\t\tif ( throwOnInvertible || false ) {\r\n\r\n\t\t\t\tthrow new Error( msg );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tTHREE.warn( msg );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis.identity();\r\n\r\n\t\t\treturn this;\r\n\t\t}\r\n\r\n\t\tthis.multiplyScalar( 1 / det );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\ttranslate: function ( v ) {\r\n\r\n\t\tTHREE.error( 'THREE.Matrix4: .translate() has been removed.' );\r\n\r\n\t},\r\n\r\n\trotateX: function ( angle ) {\r\n\r\n\t\tTHREE.error( 'THREE.Matrix4: .rotateX() has been removed.' );\r\n\r\n\t},\r\n\r\n\trotateY: function ( angle ) {\r\n\r\n\t\tTHREE.error( 'THREE.Matrix4: .rotateY() has been removed.' );\r\n\r\n\t},\r\n\r\n\trotateZ: function ( angle ) {\r\n\r\n\t\tTHREE.error( 'THREE.Matrix4: .rotateZ() has been removed.' );\r\n\r\n\t},\r\n\r\n\trotateByAxis: function ( axis, angle ) {\r\n\r\n\t\tTHREE.error( 'THREE.Matrix4: .rotateByAxis() has been removed.' );\r\n\r\n\t},\r\n\r\n\tscale: function ( v ) {\r\n\r\n\t\tvar te = this.elements;\r\n\t\tvar x = v.x, y = v.y, z = v.z;\r\n\r\n\t\tte[ 0 ] *= x; te[ 4 ] *= y; te[ 8 ] *= z;\r\n\t\tte[ 1 ] *= x; te[ 5 ] *= y; te[ 9 ] *= z;\r\n\t\tte[ 2 ] *= x; te[ 6 ] *= y; te[ 10 ] *= z;\r\n\t\tte[ 3 ] *= x; te[ 7 ] *= y; te[ 11 ] *= z;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tgetMaxScaleOnAxis: function () {\r\n\r\n\t\tvar te = this.elements;\r\n\r\n\t\tvar scaleXSq = te[ 0 ] * te[ 0 ] + te[ 1 ] * te[ 1 ] + te[ 2 ] * te[ 2 ];\r\n\t\tvar scaleYSq = te[ 4 ] * te[ 4 ] + te[ 5 ] * te[ 5 ] + te[ 6 ] * te[ 6 ];\r\n\t\tvar scaleZSq = te[ 8 ] * te[ 8 ] + te[ 9 ] * te[ 9 ] + te[ 10 ] * te[ 10 ];\r\n\r\n\t\treturn Math.sqrt( Math.max( scaleXSq, Math.max( scaleYSq, scaleZSq ) ) );\r\n\r\n\t},\r\n\r\n\tmakeTranslation: function ( x, y, z ) {\r\n\r\n\t\tthis.set(\r\n\r\n\t\t\t1, 0, 0, x,\r\n\t\t\t0, 1, 0, y,\r\n\t\t\t0, 0, 1, z,\r\n\t\t\t0, 0, 0, 1\r\n\r\n\t\t);\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmakeRotationX: function ( theta ) {\r\n\r\n\t\tvar c = Math.cos( theta ), s = Math.sin( theta );\r\n\r\n\t\tthis.set(\r\n\r\n\t\t\t1, 0,  0, 0,\r\n\t\t\t0, c, - s, 0,\r\n\t\t\t0, s,  c, 0,\r\n\t\t\t0, 0,  0, 1\r\n\r\n\t\t);\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmakeRotationY: function ( theta ) {\r\n\r\n\t\tvar c = Math.cos( theta ), s = Math.sin( theta );\r\n\r\n\t\tthis.set(\r\n\r\n\t\t\t c, 0, s, 0,\r\n\t\t\t 0, 1, 0, 0,\r\n\t\t\t- s, 0, c, 0,\r\n\t\t\t 0, 0, 0, 1\r\n\r\n\t\t);\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmakeRotationZ: function ( theta ) {\r\n\r\n\t\tvar c = Math.cos( theta ), s = Math.sin( theta );\r\n\r\n\t\tthis.set(\r\n\r\n\t\t\tc, - s, 0, 0,\r\n\t\t\ts,  c, 0, 0,\r\n\t\t\t0,  0, 1, 0,\r\n\t\t\t0,  0, 0, 1\r\n\r\n\t\t);\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmakeRotationAxis: function ( axis, angle ) {\r\n\r\n\t\t// Based on http://www.gamedev.net/reference/articles/article1199.asp\r\n\r\n\t\tvar c = Math.cos( angle );\r\n\t\tvar s = Math.sin( angle );\r\n\t\tvar t = 1 - c;\r\n\t\tvar x = axis.x, y = axis.y, z = axis.z;\r\n\t\tvar tx = t * x, ty = t * y;\r\n\r\n\t\tthis.set(\r\n\r\n\t\t\ttx * x + c, tx * y - s * z, tx * z + s * y, 0,\r\n\t\t\ttx * y + s * z, ty * y + c, ty * z - s * x, 0,\r\n\t\t\ttx * z - s * y, ty * z + s * x, t * z * z + c, 0,\r\n\t\t\t0, 0, 0, 1\r\n\r\n\t\t);\r\n\r\n\t\t return this;\r\n\r\n\t},\r\n\r\n\tmakeScale: function ( x, y, z ) {\r\n\r\n\t\tthis.set(\r\n\r\n\t\t\tx, 0, 0, 0,\r\n\t\t\t0, y, 0, 0,\r\n\t\t\t0, 0, z, 0,\r\n\t\t\t0, 0, 0, 1\r\n\r\n\t\t);\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tcompose: function ( position, quaternion, scale ) {\r\n\r\n\t\tthis.makeRotationFromQuaternion( quaternion );\r\n\t\tthis.scale( scale );\r\n\t\tthis.setPosition( position );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tdecompose: function () {\r\n\r\n\t\tvar vector = new THREE.Vector3();\r\n\t\tvar matrix = new THREE.Matrix4();\r\n\r\n\t\treturn function ( position, quaternion, scale ) {\r\n\r\n\t\t\tvar te = this.elements;\r\n\r\n\t\t\tvar sx = vector.set( te[ 0 ], te[ 1 ], te[ 2 ] ).length();\r\n\t\t\tvar sy = vector.set( te[ 4 ], te[ 5 ], te[ 6 ] ).length();\r\n\t\t\tvar sz = vector.set( te[ 8 ], te[ 9 ], te[ 10 ] ).length();\r\n\r\n\t\t\t// if determine is negative, we need to invert one scale\r\n\t\t\tvar det = this.determinant();\r\n\t\t\tif ( det < 0 ) {\r\n\t\t\t\tsx = - sx;\r\n\t\t\t}\r\n\r\n\t\t\tposition.x = te[ 12 ];\r\n\t\t\tposition.y = te[ 13 ];\r\n\t\t\tposition.z = te[ 14 ];\r\n\r\n\t\t\t// scale the rotation part\r\n\r\n\t\t\tmatrix.elements.set( this.elements ); // at this point matrix is incomplete so we can't use .copy()\r\n\r\n\t\t\tvar invSX = 1 / sx;\r\n\t\t\tvar invSY = 1 / sy;\r\n\t\t\tvar invSZ = 1 / sz;\r\n\r\n\t\t\tmatrix.elements[ 0 ] *= invSX;\r\n\t\t\tmatrix.elements[ 1 ] *= invSX;\r\n\t\t\tmatrix.elements[ 2 ] *= invSX;\r\n\r\n\t\t\tmatrix.elements[ 4 ] *= invSY;\r\n\t\t\tmatrix.elements[ 5 ] *= invSY;\r\n\t\t\tmatrix.elements[ 6 ] *= invSY;\r\n\r\n\t\t\tmatrix.elements[ 8 ] *= invSZ;\r\n\t\t\tmatrix.elements[ 9 ] *= invSZ;\r\n\t\t\tmatrix.elements[ 10 ] *= invSZ;\r\n\r\n\t\t\tquaternion.setFromRotationMatrix( matrix );\r\n\r\n\t\t\tscale.x = sx;\r\n\t\t\tscale.y = sy;\r\n\t\t\tscale.z = sz;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tmakeFrustum: function ( left, right, bottom, top, near, far ) {\r\n\r\n\t\tvar te = this.elements;\r\n\t\tvar x = 2 * near / ( right - left );\r\n\t\tvar y = 2 * near / ( top - bottom );\r\n\r\n\t\tvar a = ( right + left ) / ( right - left );\r\n\t\tvar b = ( top + bottom ) / ( top - bottom );\r\n\t\tvar c = - ( far + near ) / ( far - near );\r\n\t\tvar d = - 2 * far * near / ( far - near );\r\n\r\n\t\tte[ 0 ] = x;\tte[ 4 ] = 0;\tte[ 8 ] = a;\tte[ 12 ] = 0;\r\n\t\tte[ 1 ] = 0;\tte[ 5 ] = y;\tte[ 9 ] = b;\tte[ 13 ] = 0;\r\n\t\tte[ 2 ] = 0;\tte[ 6 ] = 0;\tte[ 10 ] = c;\tte[ 14 ] = d;\r\n\t\tte[ 3 ] = 0;\tte[ 7 ] = 0;\tte[ 11 ] = - 1;\tte[ 15 ] = 0;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmakePerspective: function ( fov, aspect, near, far ) {\r\n\r\n\t\tvar ymax = near * Math.tan( THREE.Math.degToRad( fov * 0.5 ) );\r\n\t\tvar ymin = - ymax;\r\n\t\tvar xmin = ymin * aspect;\r\n\t\tvar xmax = ymax * aspect;\r\n\r\n\t\treturn this.makeFrustum( xmin, xmax, ymin, ymax, near, far );\r\n\r\n\t},\r\n\r\n\tmakeOrthographic: function ( left, right, top, bottom, near, far ) {\r\n\r\n\t\tvar te = this.elements;\r\n\t\tvar w = right - left;\r\n\t\tvar h = top - bottom;\r\n\t\tvar p = far - near;\r\n\r\n\t\tvar x = ( right + left ) / w;\r\n\t\tvar y = ( top + bottom ) / h;\r\n\t\tvar z = ( far + near ) / p;\r\n\r\n\t\tte[ 0 ] = 2 / w;\tte[ 4 ] = 0;\tte[ 8 ] = 0;\tte[ 12 ] = - x;\r\n\t\tte[ 1 ] = 0;\tte[ 5 ] = 2 / h;\tte[ 9 ] = 0;\tte[ 13 ] = - y;\r\n\t\tte[ 2 ] = 0;\tte[ 6 ] = 0;\tte[ 10 ] = - 2 / p;\tte[ 14 ] = - z;\r\n\t\tte[ 3 ] = 0;\tte[ 7 ] = 0;\tte[ 11 ] = 0;\tte[ 15 ] = 1;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tfromArray: function ( array ) {\r\n\r\n\t\tthis.elements.set( array );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\ttoArray: function () {\r\n\r\n\t\tvar te = this.elements;\r\n\r\n\t\treturn [\r\n\t\t\tte[ 0 ], te[ 1 ], te[ 2 ], te[ 3 ],\r\n\t\t\tte[ 4 ], te[ 5 ], te[ 6 ], te[ 7 ],\r\n\t\t\tte[ 8 ], te[ 9 ], te[ 10 ], te[ 11 ],\r\n\t\t\tte[ 12 ], te[ 13 ], te[ 14 ], te[ 15 ]\r\n\t\t];\r\n\r\n\t},\r\n\r\n\tclone: function () {\r\n\r\n\t\treturn new THREE.Matrix4().fromArray( this.elements );\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/math/Ray.js\r\n\r\n/**\r\n * @author bhouston / http://exocortex.com\r\n */\r\n\r\nTHREE.Ray = function ( origin, direction ) {\r\n\r\n\tthis.origin = ( origin !== undefined ) ? origin : new THREE.Vector3();\r\n\tthis.direction = ( direction !== undefined ) ? direction : new THREE.Vector3();\r\n\r\n};\r\n\r\nTHREE.Ray.prototype = {\r\n\r\n\tconstructor: THREE.Ray,\r\n\r\n\tset: function ( origin, direction ) {\r\n\r\n\t\tthis.origin.copy( origin );\r\n\t\tthis.direction.copy( direction );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tcopy: function ( ray ) {\r\n\r\n\t\tthis.origin.copy( ray.origin );\r\n\t\tthis.direction.copy( ray.direction );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tat: function ( t, optionalTarget ) {\r\n\r\n\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\r\n\t\treturn result.copy( this.direction ).multiplyScalar( t ).add( this.origin );\r\n\r\n\t},\r\n\r\n\trecast: function () {\r\n\r\n\t\tvar v1 = new THREE.Vector3();\r\n\r\n\t\treturn function ( t ) {\r\n\r\n\t\t\tthis.origin.copy( this.at( t, v1 ) );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tclosestPointToPoint: function ( point, optionalTarget ) {\r\n\r\n\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\t\tresult.subVectors( point, this.origin );\r\n\t\tvar directionDistance = result.dot( this.direction );\r\n\r\n\t\tif ( directionDistance < 0 ) {\r\n\r\n\t\t\treturn result.copy( this.origin );\r\n\r\n\t\t}\r\n\r\n\t\treturn result.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );\r\n\r\n\t},\r\n\r\n\tdistanceToPoint: function () {\r\n\r\n\t\tvar v1 = new THREE.Vector3();\r\n\r\n\t\treturn function ( point ) {\r\n\r\n\t\t\tvar directionDistance = v1.subVectors( point, this.origin ).dot( this.direction );\r\n\r\n\t\t\t// point behind the ray\r\n\r\n\t\t\tif ( directionDistance < 0 ) {\r\n\r\n\t\t\t\treturn this.origin.distanceTo( point );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tv1.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );\r\n\r\n\t\t\treturn v1.distanceTo( point );\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tdistanceSqToSegment: function () {\r\n\r\n\t\tvar segCenter = new THREE.Vector3();\r\n\t\tvar segDir = new THREE.Vector3();\r\n\t\tvar diff = new THREE.Vector3();\r\n\r\n\t\treturn function ( v0, v1, optionalPointOnRay, optionalPointOnSegment ) {\r\n\r\n\t\t\t// from http://www.geometrictools.com/LibMathematics/Distance/Wm5DistRay3Segment3.cpp\r\n\t\t\t// It returns the min distance between the ray and the segment\r\n\t\t\t// defined by v0 and v1\r\n\t\t\t// It can also set two optional targets :\r\n\t\t\t// - The closest point on the ray\r\n\t\t\t// - The closest point on the segment\r\n\r\n\t\t\tsegCenter.copy( v0 ).add( v1 ).multiplyScalar( 0.5 );\r\n\t\t\tsegDir.copy( v1 ).sub( v0 ).normalize();\r\n\t\t\tdiff.copy( this.origin ).sub( segCenter );\r\n\r\n\t\t\tvar segExtent = v0.distanceTo( v1 ) * 0.5;\r\n\t\t\tvar a01 = - this.direction.dot( segDir );\r\n\t\t\tvar b0 = diff.dot( this.direction );\r\n\t\t\tvar b1 = - diff.dot( segDir );\r\n\t\t\tvar c = diff.lengthSq();\r\n\t\t\tvar det = Math.abs( 1 - a01 * a01 );\r\n\t\t\tvar s0, s1, sqrDist, extDet;\r\n\r\n\t\t\tif ( det > 0 ) {\r\n\r\n\t\t\t\t// The ray and segment are not parallel.\r\n\r\n\t\t\t\ts0 = a01 * b1 - b0;\r\n\t\t\t\ts1 = a01 * b0 - b1;\r\n\t\t\t\textDet = segExtent * det;\r\n\r\n\t\t\t\tif ( s0 >= 0 ) {\r\n\r\n\t\t\t\t\tif ( s1 >= - extDet ) {\r\n\r\n\t\t\t\t\t\tif ( s1 <= extDet ) {\r\n\r\n\t\t\t\t\t\t\t// region 0\r\n\t\t\t\t\t\t\t// Minimum at interior points of ray and segment.\r\n\r\n\t\t\t\t\t\t\tvar invDet = 1 / det;\r\n\t\t\t\t\t\t\ts0 *= invDet;\r\n\t\t\t\t\t\t\ts1 *= invDet;\r\n\t\t\t\t\t\t\tsqrDist = s0 * ( s0 + a01 * s1 + 2 * b0 ) + s1 * ( a01 * s0 + s1 + 2 * b1 ) + c;\r\n\r\n\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\t// region 1\r\n\r\n\t\t\t\t\t\t\ts1 = segExtent;\r\n\t\t\t\t\t\t\ts0 = Math.max( 0, - ( a01 * s1 + b0 ) );\r\n\t\t\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t// region 5\r\n\r\n\t\t\t\t\t\ts1 = - segExtent;\r\n\t\t\t\t\t\ts0 = Math.max( 0, - ( a01 * s1 + b0 ) );\r\n\t\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tif ( s1 <= - extDet ) {\r\n\r\n\t\t\t\t\t\t// region 4\r\n\r\n\t\t\t\t\t\ts0 = Math.max( 0, - ( - a01 * segExtent + b0 ) );\r\n\t\t\t\t\t\ts1 = ( s0 > 0 ) ? - segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );\r\n\t\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\r\n\r\n\t\t\t\t\t} else if ( s1 <= extDet ) {\r\n\r\n\t\t\t\t\t\t// region 3\r\n\r\n\t\t\t\t\t\ts0 = 0;\r\n\t\t\t\t\t\ts1 = Math.min( Math.max( - segExtent, - b1 ), segExtent );\r\n\t\t\t\t\t\tsqrDist = s1 * ( s1 + 2 * b1 ) + c;\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t// region 2\r\n\r\n\t\t\t\t\t\ts0 = Math.max( 0, - ( a01 * segExtent + b0 ) );\r\n\t\t\t\t\t\ts1 = ( s0 > 0 ) ? segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );\r\n\t\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t// Ray and segment are parallel.\r\n\r\n\t\t\t\ts1 = ( a01 > 0 ) ? - segExtent : segExtent;\r\n\t\t\t\ts0 = Math.max( 0, - ( a01 * s1 + b0 ) );\r\n\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( optionalPointOnRay ) {\r\n\r\n\t\t\t\toptionalPointOnRay.copy( this.direction ).multiplyScalar( s0 ).add( this.origin );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( optionalPointOnSegment ) {\r\n\r\n\t\t\t\toptionalPointOnSegment.copy( segDir ).multiplyScalar( s1 ).add( segCenter );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn sqrDist;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\r\n\tisIntersectionSphere: function ( sphere ) {\r\n\r\n\t\treturn this.distanceToPoint( sphere.center ) <= sphere.radius;\r\n\r\n\t},\r\n\r\n\tintersectSphere: function () {\r\n\r\n\t\t// from http://www.scratchapixel.com/lessons/3d-basic-lessons/lesson-7-intersecting-simple-shapes/ray-sphere-intersection/\r\n\r\n\t\tvar v1 = new THREE.Vector3();\r\n\r\n\t\treturn function ( sphere, optionalTarget ) {\r\n\r\n\t\t\tv1.subVectors( sphere.center, this.origin );\r\n\r\n\t\t\tvar tca = v1.dot( this.direction );\r\n\r\n\t\t\tvar d2 = v1.dot( v1 ) - tca * tca;\r\n\r\n\t\t\tvar radius2 = sphere.radius * sphere.radius;\r\n\r\n\t\t\tif ( d2 > radius2 ) return null;\r\n\r\n\t\t\tvar thc = Math.sqrt( radius2 - d2 );\r\n\r\n\t\t\t// t0 = first intersect point - entrance on front of sphere\r\n\t\t\tvar t0 = tca - thc;\r\n\r\n\t\t\t// t1 = second intersect point - exit point on back of sphere\r\n\t\t\tvar t1 = tca + thc;\r\n\r\n\t\t\t// test to see if both t0 and t1 are behind the ray - if so, return null\r\n\t\t\tif ( t0 < 0 && t1 < 0 ) return null;\r\n\r\n\t\t\t// test to see if t0 is behind the ray:\r\n\t\t\t// if it is, the ray is inside the sphere, so return the second exit point scaled by t1,\r\n\t\t\t// in order to always return an intersect point that is in front of the ray.\r\n\t\t\tif ( t0 < 0 ) return this.at( t1, optionalTarget );\r\n\r\n\t\t\t// else t0 is in front of the ray, so return the first collision point scaled by t0 \r\n\t\t\treturn this.at( t0, optionalTarget );\r\n\r\n\t\t}\r\n\r\n\t}(),\r\n\r\n\tisIntersectionPlane: function ( plane ) {\r\n\r\n\t\t// check if the ray lies on the plane first\r\n\r\n\t\tvar distToPoint = plane.distanceToPoint( this.origin );\r\n\r\n\t\tif ( distToPoint === 0 ) {\r\n\r\n\t\t\treturn true;\r\n\r\n\t\t}\r\n\r\n\t\tvar denominator = plane.normal.dot( this.direction );\r\n\r\n\t\tif ( denominator * distToPoint < 0 ) {\r\n\r\n\t\t\treturn true;\r\n\r\n\t\t}\r\n\r\n\t\t// ray origin is behind the plane (and is pointing behind it)\r\n\r\n\t\treturn false;\r\n\r\n\t},\r\n\r\n\tdistanceToPlane: function ( plane ) {\r\n\r\n\t\tvar denominator = plane.normal.dot( this.direction );\r\n\t\tif ( denominator == 0 ) {\r\n\r\n\t\t\t// line is coplanar, return origin\r\n\t\t\tif ( plane.distanceToPoint( this.origin ) == 0 ) {\r\n\r\n\t\t\t\treturn 0;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// Null is preferable to undefined since undefined means.... it is undefined\r\n\r\n\t\t\treturn null;\r\n\r\n\t\t}\r\n\r\n\t\tvar t = - ( this.origin.dot( plane.normal ) + plane.constant ) / denominator;\r\n\r\n\t\t// Return if the ray never intersects the plane\r\n\r\n\t\treturn t >= 0 ? t :  null;\r\n\r\n\t},\r\n\r\n\tintersectPlane: function ( plane, optionalTarget ) {\r\n\r\n\t\tvar t = this.distanceToPlane( plane );\r\n\r\n\t\tif ( t === null ) {\r\n\r\n\t\t\treturn null;\r\n\t\t}\r\n\r\n\t\treturn this.at( t, optionalTarget );\r\n\r\n\t},\r\n\r\n\tisIntersectionBox: function () {\r\n\r\n\t\tvar v = new THREE.Vector3();\r\n\r\n\t\treturn function ( box ) {\r\n\r\n\t\t\treturn this.intersectBox( box, v ) !== null;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tintersectBox: function ( box, optionalTarget ) {\r\n\r\n\t\t// http://www.scratchapixel.com/lessons/3d-basic-lessons/lesson-7-intersecting-simple-shapes/ray-box-intersection/\r\n\r\n\t\tvar tmin,tmax,tymin,tymax,tzmin,tzmax;\r\n\r\n\t\tvar invdirx = 1 / this.direction.x,\r\n\t\t\tinvdiry = 1 / this.direction.y,\r\n\t\t\tinvdirz = 1 / this.direction.z;\r\n\r\n\t\tvar origin = this.origin;\r\n\r\n\t\tif ( invdirx >= 0 ) {\r\n\r\n\t\t\ttmin = ( box.min.x - origin.x ) * invdirx;\r\n\t\t\ttmax = ( box.max.x - origin.x ) * invdirx;\r\n\r\n\t\t} else {\r\n\r\n\t\t\ttmin = ( box.max.x - origin.x ) * invdirx;\r\n\t\t\ttmax = ( box.min.x - origin.x ) * invdirx;\r\n\t\t}\r\n\r\n\t\tif ( invdiry >= 0 ) {\r\n\r\n\t\t\ttymin = ( box.min.y - origin.y ) * invdiry;\r\n\t\t\ttymax = ( box.max.y - origin.y ) * invdiry;\r\n\r\n\t\t} else {\r\n\r\n\t\t\ttymin = ( box.max.y - origin.y ) * invdiry;\r\n\t\t\ttymax = ( box.min.y - origin.y ) * invdiry;\r\n\t\t}\r\n\r\n\t\tif ( ( tmin > tymax ) || ( tymin > tmax ) ) return null;\r\n\r\n\t\t// These lines also handle the case where tmin or tmax is NaN\r\n\t\t// (result of 0 * Infinity). x !== x returns true if x is NaN\r\n\r\n\t\tif ( tymin > tmin || tmin !== tmin ) tmin = tymin;\r\n\r\n\t\tif ( tymax < tmax || tmax !== tmax ) tmax = tymax;\r\n\r\n\t\tif ( invdirz >= 0 ) {\r\n\r\n\t\t\ttzmin = ( box.min.z - origin.z ) * invdirz;\r\n\t\t\ttzmax = ( box.max.z - origin.z ) * invdirz;\r\n\r\n\t\t} else {\r\n\r\n\t\t\ttzmin = ( box.max.z - origin.z ) * invdirz;\r\n\t\t\ttzmax = ( box.min.z - origin.z ) * invdirz;\r\n\t\t}\r\n\r\n\t\tif ( ( tmin > tzmax ) || ( tzmin > tmax ) ) return null;\r\n\r\n\t\tif ( tzmin > tmin || tmin !== tmin ) tmin = tzmin;\r\n\r\n\t\tif ( tzmax < tmax || tmax !== tmax ) tmax = tzmax;\r\n\r\n\t\t//return point closest to the ray (positive side)\r\n\r\n\t\tif ( tmax < 0 ) return null;\r\n\r\n\t\treturn this.at( tmin >= 0 ? tmin : tmax, optionalTarget );\r\n\r\n\t},\r\n\r\n\tintersectTriangle: function () {\r\n\r\n\t\t// Compute the offset origin, edges, and normal.\r\n\t\tvar diff = new THREE.Vector3();\r\n\t\tvar edge1 = new THREE.Vector3();\r\n\t\tvar edge2 = new THREE.Vector3();\r\n\t\tvar normal = new THREE.Vector3();\r\n\r\n\t\treturn function ( a, b, c, backfaceCulling, optionalTarget ) {\r\n\r\n\t\t\t// from http://www.geometrictools.com/LibMathematics/Intersection/Wm5IntrRay3Triangle3.cpp\r\n\r\n\t\t\tedge1.subVectors( b, a );\r\n\t\t\tedge2.subVectors( c, a );\r\n\t\t\tnormal.crossVectors( edge1, edge2 );\r\n\r\n\t\t\t// Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,\r\n\t\t\t// E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by\r\n\t\t\t//   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))\r\n\t\t\t//   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))\r\n\t\t\t//   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)\r\n\t\t\tvar DdN = this.direction.dot( normal );\r\n\t\t\tvar sign;\r\n\r\n\t\t\tif ( DdN > 0 ) {\r\n\r\n\t\t\t\tif ( backfaceCulling ) return null;\r\n\t\t\t\tsign = 1;\r\n\r\n\t\t\t} else if ( DdN < 0 ) {\r\n\r\n\t\t\t\tsign = - 1;\r\n\t\t\t\tDdN = - DdN;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\treturn null;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tdiff.subVectors( this.origin, a );\r\n\t\t\tvar DdQxE2 = sign * this.direction.dot( edge2.crossVectors( diff, edge2 ) );\r\n\r\n\t\t\t// b1 < 0, no intersection\r\n\t\t\tif ( DdQxE2 < 0 ) {\r\n\r\n\t\t\t\treturn null;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar DdE1xQ = sign * this.direction.dot( edge1.cross( diff ) );\r\n\r\n\t\t\t// b2 < 0, no intersection\r\n\t\t\tif ( DdE1xQ < 0 ) {\r\n\r\n\t\t\t\treturn null;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// b1+b2 > 1, no intersection\r\n\t\t\tif ( DdQxE2 + DdE1xQ > DdN ) {\r\n\r\n\t\t\t\treturn null;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// Line intersects triangle, check if ray does.\r\n\t\t\tvar QdN = - sign * diff.dot( normal );\r\n\r\n\t\t\t// t < 0, no intersection\r\n\t\t\tif ( QdN < 0 ) {\r\n\r\n\t\t\t\treturn null;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// Ray intersects triangle.\r\n\t\t\treturn this.at( QdN / DdN, optionalTarget );\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tapplyMatrix4: function ( matrix4 ) {\r\n\r\n\t\tthis.direction.add( this.origin ).applyMatrix4( matrix4 );\r\n\t\tthis.origin.applyMatrix4( matrix4 );\r\n\t\tthis.direction.sub( this.origin );\r\n\t\tthis.direction.normalize();\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tequals: function ( ray ) {\r\n\r\n\t\treturn ray.origin.equals( this.origin ) && ray.direction.equals( this.direction );\r\n\r\n\t},\r\n\r\n\tclone: function () {\r\n\r\n\t\treturn new THREE.Ray().copy( this );\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/math/Sphere.js\r\n\r\n/**\r\n * @author bhouston / http://exocortex.com\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.Sphere = function ( center, radius ) {\r\n\r\n\tthis.center = ( center !== undefined ) ? center : new THREE.Vector3();\r\n\tthis.radius = ( radius !== undefined ) ? radius : 0;\r\n\r\n};\r\n\r\nTHREE.Sphere.prototype = {\r\n\r\n\tconstructor: THREE.Sphere,\r\n\r\n\tset: function ( center, radius ) {\r\n\r\n\t\tthis.center.copy( center );\r\n\t\tthis.radius = radius;\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tsetFromPoints: function () {\r\n\r\n\t\tvar box = new THREE.Box3();\r\n\r\n\t\treturn function ( points, optionalCenter ) {\r\n\r\n\t\t\tvar center = this.center;\r\n\r\n\t\t\tif ( optionalCenter !== undefined ) {\r\n\r\n\t\t\t\tcenter.copy( optionalCenter );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tbox.setFromPoints( points ).center( center );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar maxRadiusSq = 0;\r\n\r\n\t\t\tfor ( var i = 0, il = points.length; i < il; i ++ ) {\r\n\r\n\t\t\t\tmaxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( points[ i ] ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis.radius = Math.sqrt( maxRadiusSq );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tcopy: function ( sphere ) {\r\n\r\n\t\tthis.center.copy( sphere.center );\r\n\t\tthis.radius = sphere.radius;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tempty: function () {\r\n\r\n\t\treturn ( this.radius <= 0 );\r\n\r\n\t},\r\n\r\n\tcontainsPoint: function ( point ) {\r\n\r\n\t\treturn ( point.distanceToSquared( this.center ) <= ( this.radius * this.radius ) );\r\n\r\n\t},\r\n\r\n\tdistanceToPoint: function ( point ) {\r\n\r\n\t\treturn ( point.distanceTo( this.center ) - this.radius );\r\n\r\n\t},\r\n\r\n\tintersectsSphere: function ( sphere ) {\r\n\r\n\t\tvar radiusSum = this.radius + sphere.radius;\r\n\r\n\t\treturn sphere.center.distanceToSquared( this.center ) <= ( radiusSum * radiusSum );\r\n\r\n\t},\r\n\r\n\tclampPoint: function ( point, optionalTarget ) {\r\n\r\n\t\tvar deltaLengthSq = this.center.distanceToSquared( point );\r\n\r\n\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\t\tresult.copy( point );\r\n\r\n\t\tif ( deltaLengthSq > ( this.radius * this.radius ) ) {\r\n\r\n\t\t\tresult.sub( this.center ).normalize();\r\n\t\t\tresult.multiplyScalar( this.radius ).add( this.center );\r\n\r\n\t\t}\r\n\r\n\t\treturn result;\r\n\r\n\t},\r\n\r\n\tgetBoundingBox: function ( optionalTarget ) {\r\n\r\n\t\tvar box = optionalTarget || new THREE.Box3();\r\n\r\n\t\tbox.set( this.center, this.center );\r\n\t\tbox.expandByScalar( this.radius );\r\n\r\n\t\treturn box;\r\n\r\n\t},\r\n\r\n\tapplyMatrix4: function ( matrix ) {\r\n\r\n\t\tthis.center.applyMatrix4( matrix );\r\n\t\tthis.radius = this.radius * matrix.getMaxScaleOnAxis();\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\ttranslate: function ( offset ) {\r\n\r\n\t\tthis.center.add( offset );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tequals: function ( sphere ) {\r\n\r\n\t\treturn sphere.center.equals( this.center ) && ( sphere.radius === this.radius );\r\n\r\n\t},\r\n\r\n\tclone: function () {\r\n\r\n\t\treturn new THREE.Sphere().copy( this );\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/math/Frustum.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author bhouston / http://exocortex.com\r\n */\r\n\r\nTHREE.Frustum = function ( p0, p1, p2, p3, p4, p5 ) {\r\n\r\n\tthis.planes = [\r\n\r\n\t\t( p0 !== undefined ) ? p0 : new THREE.Plane(),\r\n\t\t( p1 !== undefined ) ? p1 : new THREE.Plane(),\r\n\t\t( p2 !== undefined ) ? p2 : new THREE.Plane(),\r\n\t\t( p3 !== undefined ) ? p3 : new THREE.Plane(),\r\n\t\t( p4 !== undefined ) ? p4 : new THREE.Plane(),\r\n\t\t( p5 !== undefined ) ? p5 : new THREE.Plane()\r\n\r\n\t];\r\n\r\n};\r\n\r\nTHREE.Frustum.prototype = {\r\n\r\n\tconstructor: THREE.Frustum,\r\n\r\n\tset: function ( p0, p1, p2, p3, p4, p5 ) {\r\n\r\n\t\tvar planes = this.planes;\r\n\r\n\t\tplanes[ 0 ].copy( p0 );\r\n\t\tplanes[ 1 ].copy( p1 );\r\n\t\tplanes[ 2 ].copy( p2 );\r\n\t\tplanes[ 3 ].copy( p3 );\r\n\t\tplanes[ 4 ].copy( p4 );\r\n\t\tplanes[ 5 ].copy( p5 );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tcopy: function ( frustum ) {\r\n\r\n\t\tvar planes = this.planes;\r\n\r\n\t\tfor ( var i = 0; i < 6; i ++ ) {\r\n\r\n\t\t\tplanes[ i ].copy( frustum.planes[ i ] );\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetFromMatrix: function ( m ) {\r\n\r\n\t\tvar planes = this.planes;\r\n\t\tvar me = m.elements;\r\n\t\tvar me0 = me[ 0 ], me1 = me[ 1 ], me2 = me[ 2 ], me3 = me[ 3 ];\r\n\t\tvar me4 = me[ 4 ], me5 = me[ 5 ], me6 = me[ 6 ], me7 = me[ 7 ];\r\n\t\tvar me8 = me[ 8 ], me9 = me[ 9 ], me10 = me[ 10 ], me11 = me[ 11 ];\r\n\t\tvar me12 = me[ 12 ], me13 = me[ 13 ], me14 = me[ 14 ], me15 = me[ 15 ];\r\n\r\n\t\tplanes[ 0 ].setComponents( me3 - me0, me7 - me4, me11 - me8, me15 - me12 ).normalize();\r\n\t\tplanes[ 1 ].setComponents( me3 + me0, me7 + me4, me11 + me8, me15 + me12 ).normalize();\r\n\t\tplanes[ 2 ].setComponents( me3 + me1, me7 + me5, me11 + me9, me15 + me13 ).normalize();\r\n\t\tplanes[ 3 ].setComponents( me3 - me1, me7 - me5, me11 - me9, me15 - me13 ).normalize();\r\n\t\tplanes[ 4 ].setComponents( me3 - me2, me7 - me6, me11 - me10, me15 - me14 ).normalize();\r\n\t\tplanes[ 5 ].setComponents( me3 + me2, me7 + me6, me11 + me10, me15 + me14 ).normalize();\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tintersectsObject: function () {\r\n\r\n\t\tvar sphere = new THREE.Sphere();\r\n\r\n\t\treturn function ( object ) {\r\n\r\n\t\t\tvar geometry = object.geometry;\r\n\r\n\t\t\tif ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();\r\n\r\n\t\t\tsphere.copy( geometry.boundingSphere );\r\n\t\t\tsphere.applyMatrix4( object.matrixWorld );\r\n\r\n\t\t\treturn this.intersectsSphere( sphere );\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tintersectsSphere: function ( sphere ) {\r\n\r\n\t\tvar planes = this.planes;\r\n\t\tvar center = sphere.center;\r\n\t\tvar negRadius = - sphere.radius;\r\n\r\n\t\tfor ( var i = 0; i < 6; i ++ ) {\r\n\r\n\t\t\tvar distance = planes[ i ].distanceToPoint( center );\r\n\r\n\t\t\tif ( distance < negRadius ) {\r\n\r\n\t\t\t\treturn false;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn true;\r\n\r\n\t},\r\n\r\n\tintersectsBox: function () {\r\n\r\n\t\tvar p1 = new THREE.Vector3(),\r\n\t\t\tp2 = new THREE.Vector3();\r\n\r\n\t\treturn function ( box ) {\r\n\r\n\t\t\tvar planes = this.planes;\r\n\r\n\t\t\tfor ( var i = 0; i < 6 ; i ++ ) {\r\n\r\n\t\t\t\tvar plane = planes[ i ];\r\n\r\n\t\t\t\tp1.x = plane.normal.x > 0 ? box.min.x : box.max.x;\r\n\t\t\t\tp2.x = plane.normal.x > 0 ? box.max.x : box.min.x;\r\n\t\t\t\tp1.y = plane.normal.y > 0 ? box.min.y : box.max.y;\r\n\t\t\t\tp2.y = plane.normal.y > 0 ? box.max.y : box.min.y;\r\n\t\t\t\tp1.z = plane.normal.z > 0 ? box.min.z : box.max.z;\r\n\t\t\t\tp2.z = plane.normal.z > 0 ? box.max.z : box.min.z;\r\n\r\n\t\t\t\tvar d1 = plane.distanceToPoint( p1 );\r\n\t\t\t\tvar d2 = plane.distanceToPoint( p2 );\r\n\r\n\t\t\t\t// if both outside plane, no intersection\r\n\r\n\t\t\t\tif ( d1 < 0 && d2 < 0 ) {\r\n\r\n\t\t\t\t\treturn false;\r\n\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\treturn true;\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\r\n\tcontainsPoint: function ( point ) {\r\n\r\n\t\tvar planes = this.planes;\r\n\r\n\t\tfor ( var i = 0; i < 6; i ++ ) {\r\n\r\n\t\t\tif ( planes[ i ].distanceToPoint( point ) < 0 ) {\r\n\r\n\t\t\t\treturn false;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn true;\r\n\r\n\t},\r\n\r\n\tclone: function () {\r\n\r\n\t\treturn new THREE.Frustum().copy( this );\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/math/Plane.js\r\n\r\n/**\r\n * @author bhouston / http://exocortex.com\r\n */\r\n\r\nTHREE.Plane = function ( normal, constant ) {\r\n\r\n\tthis.normal = ( normal !== undefined ) ? normal : new THREE.Vector3( 1, 0, 0 );\r\n\tthis.constant = ( constant !== undefined ) ? constant : 0;\r\n\r\n};\r\n\r\nTHREE.Plane.prototype = {\r\n\r\n\tconstructor: THREE.Plane,\r\n\r\n\tset: function ( normal, constant ) {\r\n\r\n\t\tthis.normal.copy( normal );\r\n\t\tthis.constant = constant;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetComponents: function ( x, y, z, w ) {\r\n\r\n\t\tthis.normal.set( x, y, z );\r\n\t\tthis.constant = w;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetFromNormalAndCoplanarPoint: function ( normal, point ) {\r\n\r\n\t\tthis.normal.copy( normal );\r\n\t\tthis.constant = - point.dot( this.normal );\t// must be this.normal, not normal, as this.normal is normalized\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetFromCoplanarPoints: function () {\r\n\r\n\t\tvar v1 = new THREE.Vector3();\r\n\t\tvar v2 = new THREE.Vector3();\r\n\r\n\t\treturn function ( a, b, c ) {\r\n\r\n\t\t\tvar normal = v1.subVectors( c, b ).cross( v2.subVectors( a, b ) ).normalize();\r\n\r\n\t\t\t// Q: should an error be thrown if normal is zero (e.g. degenerate plane)?\r\n\r\n\t\t\tthis.setFromNormalAndCoplanarPoint( normal, a );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\r\n\tcopy: function ( plane ) {\r\n\r\n\t\tthis.normal.copy( plane.normal );\r\n\t\tthis.constant = plane.constant;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tnormalize: function () {\r\n\r\n\t\t// Note: will lead to a divide by zero if the plane is invalid.\r\n\r\n\t\tvar inverseNormalLength = 1.0 / this.normal.length();\r\n\t\tthis.normal.multiplyScalar( inverseNormalLength );\r\n\t\tthis.constant *= inverseNormalLength;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tnegate: function () {\r\n\r\n\t\tthis.constant *= - 1;\r\n\t\tthis.normal.negate();\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tdistanceToPoint: function ( point ) {\r\n\r\n\t\treturn this.normal.dot( point ) + this.constant;\r\n\r\n\t},\r\n\r\n\tdistanceToSphere: function ( sphere ) {\r\n\r\n\t\treturn this.distanceToPoint( sphere.center ) - sphere.radius;\r\n\r\n\t},\r\n\r\n\tprojectPoint: function ( point, optionalTarget ) {\r\n\r\n\t\treturn this.orthoPoint( point, optionalTarget ).sub( point ).negate();\r\n\r\n\t},\r\n\r\n\torthoPoint: function ( point, optionalTarget ) {\r\n\r\n\t\tvar perpendicularMagnitude = this.distanceToPoint( point );\r\n\r\n\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\t\treturn result.copy( this.normal ).multiplyScalar( perpendicularMagnitude );\r\n\r\n\t},\r\n\r\n\tisIntersectionLine: function ( line ) {\r\n\r\n\t\t// Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.\r\n\r\n\t\tvar startSign = this.distanceToPoint( line.start );\r\n\t\tvar endSign = this.distanceToPoint( line.end );\r\n\r\n\t\treturn ( startSign < 0 && endSign > 0 ) || ( endSign < 0 && startSign > 0 );\r\n\r\n\t},\r\n\r\n\tintersectLine: function () {\r\n\r\n\t\tvar v1 = new THREE.Vector3();\r\n\r\n\t\treturn function ( line, optionalTarget ) {\r\n\r\n\t\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\r\n\t\t\tvar direction = line.delta( v1 );\r\n\r\n\t\t\tvar denominator = this.normal.dot( direction );\r\n\r\n\t\t\tif ( denominator == 0 ) {\r\n\r\n\t\t\t\t// line is coplanar, return origin\r\n\t\t\t\tif ( this.distanceToPoint( line.start ) == 0 ) {\r\n\r\n\t\t\t\t\treturn result.copy( line.start );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Unsure if this is the correct method to handle this case.\r\n\t\t\t\treturn undefined;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar t = - ( line.start.dot( this.normal ) + this.constant ) / denominator;\r\n\r\n\t\t\tif ( t < 0 || t > 1 ) {\r\n\r\n\t\t\t\treturn undefined;\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn result.copy( direction ).multiplyScalar( t ).add( line.start );\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\r\n\tcoplanarPoint: function ( optionalTarget ) {\r\n\r\n\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\t\treturn result.copy( this.normal ).multiplyScalar( - this.constant );\r\n\r\n\t},\r\n\r\n\tapplyMatrix4: function () {\r\n\r\n\t\tvar v1 = new THREE.Vector3();\r\n\t\tvar v2 = new THREE.Vector3();\r\n\t\tvar m1 = new THREE.Matrix3();\r\n\r\n\t\treturn function ( matrix, optionalNormalMatrix ) {\r\n\r\n\t\t\t// compute new normal based on theory here:\r\n\t\t\t// http://www.songho.ca/opengl/gl_normaltransform.html\r\n\t\t\tvar normalMatrix = optionalNormalMatrix || m1.getNormalMatrix( matrix );\r\n\t\t\tvar newNormal = v1.copy( this.normal ).applyMatrix3( normalMatrix );\r\n\r\n\t\t\tvar newCoplanarPoint = this.coplanarPoint( v2 );\r\n\t\t\tnewCoplanarPoint.applyMatrix4( matrix );\r\n\r\n\t\t\tthis.setFromNormalAndCoplanarPoint( newNormal, newCoplanarPoint );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\ttranslate: function ( offset ) {\r\n\r\n\t\tthis.constant = this.constant - offset.dot( this.normal );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tequals: function ( plane ) {\r\n\r\n\t\treturn plane.normal.equals( this.normal ) && ( plane.constant == this.constant );\r\n\r\n\t},\r\n\r\n\tclone: function () {\r\n\r\n\t\treturn new THREE.Plane().copy( this );\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/math/Math.js\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.Math = {\r\n\r\n\tgenerateUUID: function () {\r\n\r\n\t\t// http://www.broofa.com/Tools/Math.uuid.htm\r\n\r\n\t\tvar chars = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.split( '' );\r\n\t\tvar uuid = new Array( 36 );\r\n\t\tvar rnd = 0, r;\r\n\r\n\t\treturn function () {\r\n\r\n\t\t\tfor ( var i = 0; i < 36; i ++ ) {\r\n\r\n\t\t\t\tif ( i == 8 || i == 13 || i == 18 || i == 23 ) {\r\n\r\n\t\t\t\t\tuuid[ i ] = '-';\r\n\r\n\t\t\t\t} else if ( i == 14 ) {\r\n\r\n\t\t\t\t\tuuid[ i ] = '4';\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tif ( rnd <= 0x02 ) rnd = 0x2000000 + ( Math.random() * 0x1000000 ) | 0;\r\n\t\t\t\t\tr = rnd & 0xf;\r\n\t\t\t\t\trnd = rnd >> 4;\r\n\t\t\t\t\tuuid[ i ] = chars[ ( i == 19 ) ? ( r & 0x3 ) | 0x8 : r ];\r\n\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\treturn uuid.join( '' );\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\t// Clamp value to range <a, b>\r\n\r\n\tclamp: function ( x, a, b ) {\r\n\r\n\t\treturn ( x < a ) ? a : ( ( x > b ) ? b : x );\r\n\r\n\t},\r\n\r\n\t// Clamp value to range <a, inf)\r\n\r\n\tclampBottom: function ( x, a ) {\r\n\r\n\t\treturn x < a ? a : x;\r\n\r\n\t},\r\n\r\n\t// Linear mapping from range <a1, a2> to range <b1, b2>\r\n\r\n\tmapLinear: function ( x, a1, a2, b1, b2 ) {\r\n\r\n\t\treturn b1 + ( x - a1 ) * ( b2 - b1 ) / ( a2 - a1 );\r\n\r\n\t},\r\n\r\n\t// http://en.wikipedia.org/wiki/Smoothstep\r\n\r\n\tsmoothstep: function ( x, min, max ) {\r\n\r\n\t\tif ( x <= min ) return 0;\r\n\t\tif ( x >= max ) return 1;\r\n\r\n\t\tx = ( x - min ) / ( max - min );\r\n\r\n\t\treturn x * x * ( 3 - 2 * x );\r\n\r\n\t},\r\n\r\n\tsmootherstep: function ( x, min, max ) {\r\n\r\n\t\tif ( x <= min ) return 0;\r\n\t\tif ( x >= max ) return 1;\r\n\r\n\t\tx = ( x - min ) / ( max - min );\r\n\r\n\t\treturn x * x * x * ( x * ( x * 6 - 15 ) + 10 );\r\n\r\n\t},\r\n\r\n\t// Random float from <0, 1> with 16 bits of randomness\r\n\t// (standard Math.random() creates repetitive patterns when applied over larger space)\r\n\r\n\trandom16: function () {\r\n\r\n\t\treturn ( 65280 * Math.random() + 255 * Math.random() ) / 65535;\r\n\r\n\t},\r\n\r\n\t// Random integer from <low, high> interval\r\n\r\n\trandInt: function ( low, high ) {\r\n\r\n\t\treturn Math.floor( this.randFloat( low, high ) );\r\n\r\n\t},\r\n\r\n\t// Random float from <low, high> interval\r\n\r\n\trandFloat: function ( low, high ) {\r\n\r\n\t\treturn low + Math.random() * ( high - low );\r\n\r\n\t},\r\n\r\n\t// Random float from <-range/2, range/2> interval\r\n\r\n\trandFloatSpread: function ( range ) {\r\n\r\n\t\treturn range * ( 0.5 - Math.random() );\r\n\r\n\t},\r\n\r\n\tdegToRad: function () {\r\n\r\n\t\tvar degreeToRadiansFactor = Math.PI / 180;\r\n\r\n\t\treturn function ( degrees ) {\r\n\r\n\t\t\treturn degrees * degreeToRadiansFactor;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tradToDeg: function () {\r\n\r\n\t\tvar radianToDegreesFactor = 180 / Math.PI;\r\n\r\n\t\treturn function ( radians ) {\r\n\r\n\t\t\treturn radians * radianToDegreesFactor;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tisPowerOfTwo: function ( value ) {\r\n\r\n\t\treturn ( value & ( value - 1 ) ) === 0 && value !== 0;\r\n\r\n\t},\r\n\r\n\tnextPowerOfTwo: function ( value ) {\r\n\r\n\t\tvalue --;\r\n\t\tvalue |= value >> 1;\r\n\t\tvalue |= value >> 2;\r\n\t\tvalue |= value >> 4;\r\n\t\tvalue |= value >> 8;\r\n\t\tvalue |= value >> 16;\r\n\t\tvalue ++;\r\n\r\n\t\treturn value;\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/math/Spline.js\r\n\r\n/**\r\n * Spline from Tween.js, slightly optimized (and trashed)\r\n * http://sole.github.com/tween.js/examples/05_spline.html\r\n *\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.Spline = function ( points ) {\r\n\r\n\tthis.points = points;\r\n\r\n\tvar c = [], v3 = { x: 0, y: 0, z: 0 },\r\n\tpoint, intPoint, weight, w2, w3,\r\n\tpa, pb, pc, pd;\r\n\r\n\tthis.initFromArray = function ( a ) {\r\n\r\n\t\tthis.points = [];\r\n\r\n\t\tfor ( var i = 0; i < a.length; i ++ ) {\r\n\r\n\t\t\tthis.points[ i ] = { x: a[ i ][ 0 ], y: a[ i ][ 1 ], z: a[ i ][ 2 ] };\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tthis.getPoint = function ( k ) {\r\n\r\n\t\tpoint = ( this.points.length - 1 ) * k;\r\n\t\tintPoint = Math.floor( point );\r\n\t\tweight = point - intPoint;\r\n\r\n\t\tc[ 0 ] = intPoint === 0 ? intPoint : intPoint - 1;\r\n\t\tc[ 1 ] = intPoint;\r\n\t\tc[ 2 ] = intPoint  > this.points.length - 2 ? this.points.length - 1 : intPoint + 1;\r\n\t\tc[ 3 ] = intPoint  > this.points.length - 3 ? this.points.length - 1 : intPoint + 2;\r\n\r\n\t\tpa = this.points[ c[ 0 ] ];\r\n\t\tpb = this.points[ c[ 1 ] ];\r\n\t\tpc = this.points[ c[ 2 ] ];\r\n\t\tpd = this.points[ c[ 3 ] ];\r\n\r\n\t\tw2 = weight * weight;\r\n\t\tw3 = weight * w2;\r\n\r\n\t\tv3.x = interpolate( pa.x, pb.x, pc.x, pd.x, weight, w2, w3 );\r\n\t\tv3.y = interpolate( pa.y, pb.y, pc.y, pd.y, weight, w2, w3 );\r\n\t\tv3.z = interpolate( pa.z, pb.z, pc.z, pd.z, weight, w2, w3 );\r\n\r\n\t\treturn v3;\r\n\r\n\t};\r\n\r\n\tthis.getControlPointsArray = function () {\r\n\r\n\t\tvar i, p, l = this.points.length,\r\n\t\t\tcoords = [];\r\n\r\n\t\tfor ( i = 0; i < l; i ++ ) {\r\n\r\n\t\t\tp = this.points[ i ];\r\n\t\t\tcoords[ i ] = [ p.x, p.y, p.z ];\r\n\r\n\t\t}\r\n\r\n\t\treturn coords;\r\n\r\n\t};\r\n\r\n\t// approximate length by summing linear segments\r\n\r\n\tthis.getLength = function ( nSubDivisions ) {\r\n\r\n\t\tvar i, index, nSamples, position,\r\n\t\t\tpoint = 0, intPoint = 0, oldIntPoint = 0,\r\n\t\t\toldPosition = new THREE.Vector3(),\r\n\t\t\ttmpVec = new THREE.Vector3(),\r\n\t\t\tchunkLengths = [],\r\n\t\t\ttotalLength = 0;\r\n\r\n\t\t// first point has 0 length\r\n\r\n\t\tchunkLengths[ 0 ] = 0;\r\n\r\n\t\tif ( ! nSubDivisions ) nSubDivisions = 100;\r\n\r\n\t\tnSamples = this.points.length * nSubDivisions;\r\n\r\n\t\toldPosition.copy( this.points[ 0 ] );\r\n\r\n\t\tfor ( i = 1; i < nSamples; i ++ ) {\r\n\r\n\t\t\tindex = i / nSamples;\r\n\r\n\t\t\tposition = this.getPoint( index );\r\n\t\t\ttmpVec.copy( position );\r\n\r\n\t\t\ttotalLength += tmpVec.distanceTo( oldPosition );\r\n\r\n\t\t\toldPosition.copy( position );\r\n\r\n\t\t\tpoint = ( this.points.length - 1 ) * index;\r\n\t\t\tintPoint = Math.floor( point );\r\n\r\n\t\t\tif ( intPoint != oldIntPoint ) {\r\n\r\n\t\t\t\tchunkLengths[ intPoint ] = totalLength;\r\n\t\t\t\toldIntPoint = intPoint;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// last point ends with total length\r\n\r\n\t\tchunkLengths[ chunkLengths.length ] = totalLength;\r\n\r\n\t\treturn { chunks: chunkLengths, total: totalLength };\r\n\r\n\t};\r\n\r\n\tthis.reparametrizeByArcLength = function ( samplingCoef ) {\r\n\r\n\t\tvar i, j,\r\n\t\t\tindex, indexCurrent, indexNext,\r\n\t\t\trealDistance,\r\n\t\t\tsampling, position,\r\n\t\t\tnewpoints = [],\r\n\t\t\ttmpVec = new THREE.Vector3(),\r\n\t\t\tsl = this.getLength();\r\n\r\n\t\tnewpoints.push( tmpVec.copy( this.points[ 0 ] ).clone() );\r\n\r\n\t\tfor ( i = 1; i < this.points.length; i ++ ) {\r\n\r\n\t\t\t//tmpVec.copy( this.points[ i - 1 ] );\r\n\t\t\t//linearDistance = tmpVec.distanceTo( this.points[ i ] );\r\n\r\n\t\t\trealDistance = sl.chunks[ i ] - sl.chunks[ i - 1 ];\r\n\r\n\t\t\tsampling = Math.ceil( samplingCoef * realDistance / sl.total );\r\n\r\n\t\t\tindexCurrent = ( i - 1 ) / ( this.points.length - 1 );\r\n\t\t\tindexNext = i / ( this.points.length - 1 );\r\n\r\n\t\t\tfor ( j = 1; j < sampling - 1; j ++ ) {\r\n\r\n\t\t\t\tindex = indexCurrent + j * ( 1 / sampling ) * ( indexNext - indexCurrent );\r\n\r\n\t\t\t\tposition = this.getPoint( index );\r\n\t\t\t\tnewpoints.push( tmpVec.copy( position ).clone() );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tnewpoints.push( tmpVec.copy( this.points[ i ] ).clone() );\r\n\r\n\t\t}\r\n\r\n\t\tthis.points = newpoints;\r\n\r\n\t};\r\n\r\n\t// Catmull-Rom\r\n\r\n\tfunction interpolate( p0, p1, p2, p3, t, t2, t3 ) {\r\n\r\n\t\tvar v0 = ( p2 - p0 ) * 0.5,\r\n\t\t\tv1 = ( p3 - p1 ) * 0.5;\r\n\r\n\t\treturn ( 2 * ( p1 - p2 ) + v0 + v1 ) * t3 + ( - 3 * ( p1 - p2 ) - 2 * v0 - v1 ) * t2 + v0 * t + p1;\r\n\r\n\t};\r\n\r\n};\r\n\r\n// File:src/math/Triangle.js\r\n\r\n/**\r\n * @author bhouston / http://exocortex.com\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.Triangle = function ( a, b, c ) {\r\n\r\n\tthis.a = ( a !== undefined ) ? a : new THREE.Vector3();\r\n\tthis.b = ( b !== undefined ) ? b : new THREE.Vector3();\r\n\tthis.c = ( c !== undefined ) ? c : new THREE.Vector3();\r\n\r\n};\r\n\r\nTHREE.Triangle.normal = function () {\r\n\r\n\tvar v0 = new THREE.Vector3();\r\n\r\n\treturn function ( a, b, c, optionalTarget ) {\r\n\r\n\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\r\n\t\tresult.subVectors( c, b );\r\n\t\tv0.subVectors( a, b );\r\n\t\tresult.cross( v0 );\r\n\r\n\t\tvar resultLengthSq = result.lengthSq();\r\n\t\tif ( resultLengthSq > 0 ) {\r\n\r\n\t\t\treturn result.multiplyScalar( 1 / Math.sqrt( resultLengthSq ) );\r\n\r\n\t\t}\r\n\r\n\t\treturn result.set( 0, 0, 0 );\r\n\r\n\t};\r\n\r\n}();\r\n\r\n// static/instance method to calculate barycoordinates\r\n// based on: http://www.blackpawn.com/texts/pointinpoly/default.html\r\nTHREE.Triangle.barycoordFromPoint = function () {\r\n\r\n\tvar v0 = new THREE.Vector3();\r\n\tvar v1 = new THREE.Vector3();\r\n\tvar v2 = new THREE.Vector3();\r\n\r\n\treturn function ( point, a, b, c, optionalTarget ) {\r\n\r\n\t\tv0.subVectors( c, a );\r\n\t\tv1.subVectors( b, a );\r\n\t\tv2.subVectors( point, a );\r\n\r\n\t\tvar dot00 = v0.dot( v0 );\r\n\t\tvar dot01 = v0.dot( v1 );\r\n\t\tvar dot02 = v0.dot( v2 );\r\n\t\tvar dot11 = v1.dot( v1 );\r\n\t\tvar dot12 = v1.dot( v2 );\r\n\r\n\t\tvar denom = ( dot00 * dot11 - dot01 * dot01 );\r\n\r\n\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\r\n\t\t// colinear or singular triangle\r\n\t\tif ( denom == 0 ) {\r\n\t\t\t// arbitrary location outside of triangle?\r\n\t\t\t// not sure if this is the best idea, maybe should be returning undefined\r\n\t\t\treturn result.set( - 2, - 1, - 1 );\r\n\t\t}\r\n\r\n\t\tvar invDenom = 1 / denom;\r\n\t\tvar u = ( dot11 * dot02 - dot01 * dot12 ) * invDenom;\r\n\t\tvar v = ( dot00 * dot12 - dot01 * dot02 ) * invDenom;\r\n\r\n\t\t// barycoordinates must always sum to 1\r\n\t\treturn result.set( 1 - u - v, v, u );\r\n\r\n\t};\r\n\r\n}();\r\n\r\nTHREE.Triangle.containsPoint = function () {\r\n\r\n\tvar v1 = new THREE.Vector3();\r\n\r\n\treturn function ( point, a, b, c ) {\r\n\r\n\t\tvar result = THREE.Triangle.barycoordFromPoint( point, a, b, c, v1 );\r\n\r\n\t\treturn ( result.x >= 0 ) && ( result.y >= 0 ) && ( ( result.x + result.y ) <= 1 );\r\n\r\n\t};\r\n\r\n}();\r\n\r\nTHREE.Triangle.prototype = {\r\n\r\n\tconstructor: THREE.Triangle,\r\n\r\n\tset: function ( a, b, c ) {\r\n\r\n\t\tthis.a.copy( a );\r\n\t\tthis.b.copy( b );\r\n\t\tthis.c.copy( c );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetFromPointsAndIndices: function ( points, i0, i1, i2 ) {\r\n\r\n\t\tthis.a.copy( points[ i0 ] );\r\n\t\tthis.b.copy( points[ i1 ] );\r\n\t\tthis.c.copy( points[ i2 ] );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tcopy: function ( triangle ) {\r\n\r\n\t\tthis.a.copy( triangle.a );\r\n\t\tthis.b.copy( triangle.b );\r\n\t\tthis.c.copy( triangle.c );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tarea: function () {\r\n\r\n\t\tvar v0 = new THREE.Vector3();\r\n\t\tvar v1 = new THREE.Vector3();\r\n\r\n\t\treturn function () {\r\n\r\n\t\t\tv0.subVectors( this.c, this.b );\r\n\t\t\tv1.subVectors( this.a, this.b );\r\n\r\n\t\t\treturn v0.cross( v1 ).length() * 0.5;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tmidpoint: function ( optionalTarget ) {\r\n\r\n\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\t\treturn result.addVectors( this.a, this.b ).add( this.c ).multiplyScalar( 1 / 3 );\r\n\r\n\t},\r\n\r\n\tnormal: function ( optionalTarget ) {\r\n\r\n\t\treturn THREE.Triangle.normal( this.a, this.b, this.c, optionalTarget );\r\n\r\n\t},\r\n\r\n\tplane: function ( optionalTarget ) {\r\n\r\n\t\tvar result = optionalTarget || new THREE.Plane();\r\n\r\n\t\treturn result.setFromCoplanarPoints( this.a, this.b, this.c );\r\n\r\n\t},\r\n\r\n\tbarycoordFromPoint: function ( point, optionalTarget ) {\r\n\r\n\t\treturn THREE.Triangle.barycoordFromPoint( point, this.a, this.b, this.c, optionalTarget );\r\n\r\n\t},\r\n\r\n\tcontainsPoint: function ( point ) {\r\n\r\n\t\treturn THREE.Triangle.containsPoint( point, this.a, this.b, this.c );\r\n\r\n\t},\r\n\r\n\tequals: function ( triangle ) {\r\n\r\n\t\treturn triangle.a.equals( this.a ) && triangle.b.equals( this.b ) && triangle.c.equals( this.c );\r\n\r\n\t},\r\n\r\n\tclone: function () {\r\n\r\n\t\treturn new THREE.Triangle().copy( this );\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/core/Clock.js\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.Clock = function ( autoStart ) {\r\n\r\n\tthis.autoStart = ( autoStart !== undefined ) ? autoStart : true;\r\n\r\n\tthis.startTime = 0;\r\n\tthis.oldTime = 0;\r\n\tthis.elapsedTime = 0;\r\n\r\n\tthis.running = false;\r\n\r\n};\r\n\r\nTHREE.Clock.prototype = {\r\n\r\n\tconstructor: THREE.Clock,\r\n\r\n\tstart: function () {\r\n\r\n\t\tthis.startTime = self.performance !== undefined && self.performance.now !== undefined\r\n\t\t\t\t\t ? self.performance.now()\r\n\t\t\t\t\t : Date.now();\r\n\r\n\t\tthis.oldTime = this.startTime;\r\n\t\tthis.running = true;\r\n\t},\r\n\r\n\tstop: function () {\r\n\r\n\t\tthis.getElapsedTime();\r\n\t\tthis.running = false;\r\n\r\n\t},\r\n\r\n\tgetElapsedTime: function () {\r\n\r\n\t\tthis.getDelta();\r\n\t\treturn this.elapsedTime;\r\n\r\n\t},\r\n\r\n\tgetDelta: function () {\r\n\r\n\t\tvar diff = 0;\r\n\r\n\t\tif ( this.autoStart && ! this.running ) {\r\n\r\n\t\t\tthis.start();\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.running ) {\r\n\r\n\t\t\tvar newTime = self.performance !== undefined && self.performance.now !== undefined\r\n\t\t\t\t\t ? self.performance.now()\r\n\t\t\t\t\t : Date.now();\r\n\r\n\t\t\tdiff = 0.001 * ( newTime - this.oldTime );\r\n\t\t\tthis.oldTime = newTime;\r\n\r\n\t\t\tthis.elapsedTime += diff;\r\n\r\n\t\t}\r\n\r\n\t\treturn diff;\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/core/EventDispatcher.js\r\n\r\n/**\r\n * https://github.com/mrdoob/eventdispatcher.js/\r\n */\r\n\r\nTHREE.EventDispatcher = function () {}\r\n\r\nTHREE.EventDispatcher.prototype = {\r\n\r\n\tconstructor: THREE.EventDispatcher,\r\n\r\n\tapply: function ( object ) {\r\n\r\n\t\tobject.addEventListener = THREE.EventDispatcher.prototype.addEventListener;\r\n\t\tobject.hasEventListener = THREE.EventDispatcher.prototype.hasEventListener;\r\n\t\tobject.removeEventListener = THREE.EventDispatcher.prototype.removeEventListener;\r\n\t\tobject.dispatchEvent = THREE.EventDispatcher.prototype.dispatchEvent;\r\n\r\n\t},\r\n\r\n\taddEventListener: function ( type, listener ) {\r\n\r\n\t\tif ( this._listeners === undefined ) this._listeners = {};\r\n\r\n\t\tvar listeners = this._listeners;\r\n\r\n\t\tif ( listeners[ type ] === undefined ) {\r\n\r\n\t\t\tlisteners[ type ] = [];\r\n\r\n\t\t}\r\n\r\n\t\tif ( listeners[ type ].indexOf( listener ) === - 1 ) {\r\n\r\n\t\t\tlisteners[ type ].push( listener );\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\thasEventListener: function ( type, listener ) {\r\n\r\n\t\tif ( this._listeners === undefined ) return false;\r\n\r\n\t\tvar listeners = this._listeners;\r\n\r\n\t\tif ( listeners[ type ] !== undefined && listeners[ type ].indexOf( listener ) !== - 1 ) {\r\n\r\n\t\t\treturn true;\r\n\r\n\t\t}\r\n\r\n\t\treturn false;\r\n\r\n\t},\r\n\r\n\tremoveEventListener: function ( type, listener ) {\r\n\r\n\t\tif ( this._listeners === undefined ) return;\r\n\r\n\t\tvar listeners = this._listeners;\r\n\t\tvar listenerArray = listeners[ type ];\r\n\r\n\t\tif ( listenerArray !== undefined ) {\r\n\r\n\t\t\tvar index = listenerArray.indexOf( listener );\r\n\r\n\t\t\tif ( index !== - 1 ) {\r\n\r\n\t\t\t\tlistenerArray.splice( index, 1 );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tdispatchEvent: function ( event ) {\r\n\r\n\t\tif ( this._listeners === undefined ) return;\r\n\r\n\t\tvar listeners = this._listeners;\r\n\t\tvar listenerArray = listeners[ event.type ];\r\n\r\n\t\tif ( listenerArray !== undefined ) {\r\n\r\n\t\t\tevent.target = this;\r\n\r\n\t\t\tvar array = [];\r\n\t\t\tvar length = listenerArray.length;\r\n\r\n\t\t\tfor ( var i = 0; i < length; i ++ ) {\r\n\r\n\t\t\t\tarray[ i ] = listenerArray[ i ];\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfor ( var i = 0; i < length; i ++ ) {\r\n\r\n\t\t\t\tarray[ i ].call( this, event );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/core/Raycaster.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author bhouston / http://exocortex.com/\r\n * @author stephomi / http://stephaneginier.com/\r\n */\r\n\r\n( function ( THREE ) {\r\n\r\n\tTHREE.Raycaster = function ( origin, direction, near, far ) {\r\n\r\n\t\tthis.ray = new THREE.Ray( origin, direction );\r\n\t\t// direction is assumed to be normalized (for accurate distance calculations)\r\n\r\n\t\tthis.near = near || 0;\r\n\t\tthis.far = far || Infinity;\r\n\r\n\t\tthis.params = {\r\n\t\t\tSprite: {},\r\n\t\t\tMesh: {},\r\n\t\t\tPointCloud: { threshold: 1 },\r\n\t\t\tLOD: {},\r\n\t\t\tLine: {}\r\n\t\t};\r\n\r\n\t};\r\n\r\n\tvar descSort = function ( a, b ) {\r\n\r\n\t\treturn a.distance - b.distance;\r\n\r\n\t};\r\n\r\n\tvar intersectObject = function ( object, raycaster, intersects, recursive ) {\r\n\r\n\t\tobject.raycast( raycaster, intersects );\r\n\r\n\t\tif ( recursive === true ) {\r\n\r\n\t\t\tvar children = object.children;\r\n\r\n\t\t\tfor ( var i = 0, l = children.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tintersectObject( children[ i ], raycaster, intersects, true );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\t//\r\n\r\n\tTHREE.Raycaster.prototype = {\r\n\r\n\t\tconstructor: THREE.Raycaster,\r\n\r\n\t\tprecision: 0.0001,\r\n\t\tlinePrecision: 1,\r\n\r\n\t\tset: function ( origin, direction ) {\r\n\r\n\t\t\t// direction is assumed to be normalized (for accurate distance calculations)\r\n\r\n\t\t\tthis.ray.set( origin, direction );\r\n\r\n\t\t},\r\n\r\n\t\tsetFromCamera: function ( coords, camera ) {\r\n\r\n\t\t\t// camera is assumed _not_ to be a child of a transformed object\r\n\r\n\t\t\tif ( camera instanceof THREE.PerspectiveCamera ) {\r\n\r\n\t\t\t\tthis.ray.origin.copy( camera.position );\r\n\t\t\t\tthis.ray.direction.set( coords.x, coords.y, 0.5 ).unproject( camera ).sub( camera.position ).normalize();\r\n\r\n\t\t\t} else if ( camera instanceof THREE.OrthographicCamera ) {\r\n\r\n\t\t\t\tthis.ray.origin.set( coords.x, coords.y, - 1 ).unproject( camera );\r\n\t\t\t\tthis.ray.direction.set( 0, 0, - 1 ).transformDirection( camera.matrixWorld );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tTHREE.error( 'THREE.Raycaster: Unsupported camera type.' );\r\n\r\n\t\t\t}\r\n\r\n\t\t},\r\n\r\n\t\tintersectObject: function ( object, recursive ) {\r\n\r\n\t\t\tvar intersects = [];\r\n\r\n\t\t\tintersectObject( object, this, intersects, recursive );\r\n\r\n\t\t\tintersects.sort( descSort );\r\n\r\n\t\t\treturn intersects;\r\n\r\n\t\t},\r\n\r\n\t\tintersectObjects: function ( objects, recursive ) {\r\n\r\n\t\t\tvar intersects = [];\r\n\r\n\t\t\tif ( objects instanceof Array === false ) {\r\n\r\n\t\t\t\tTHREE.warn( 'THREE.Raycaster.intersectObjects: objects is not an Array.' );\r\n\t\t\t\treturn intersects;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfor ( var i = 0, l = objects.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tintersectObject( objects[ i ], this, intersects, recursive );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tintersects.sort( descSort );\r\n\r\n\t\t\treturn intersects;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n}( THREE ) );\r\n\r\n// File:src/core/Object3D.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author WestLangley / http://github.com/WestLangley\r\n */\r\n\r\nTHREE.Object3D = function () {\r\n\r\n\tObject.defineProperty( this, 'id', { value: THREE.Object3DIdCount ++ } );\r\n\r\n\tthis.uuid = THREE.Math.generateUUID();\r\n\r\n\tthis.name = '';\r\n\tthis.type = 'Object3D';\r\n\r\n\tthis.parent = undefined;\r\n\tthis.children = [];\r\n\r\n\tthis.up = THREE.Object3D.DefaultUp.clone();\r\n\r\n\tvar position = new THREE.Vector3();\r\n\tvar rotation = new THREE.Euler();\r\n\tvar quaternion = new THREE.Quaternion();\r\n\tvar scale = new THREE.Vector3( 1, 1, 1 );\r\n\r\n\tvar onRotationChange = function () {\r\n\t\tquaternion.setFromEuler( rotation, false );\r\n\t};\r\n\r\n\tvar onQuaternionChange = function () {\r\n\t\trotation.setFromQuaternion( quaternion, undefined, false );\r\n\t};\r\n\r\n\trotation.onChange( onRotationChange );\r\n\tquaternion.onChange( onQuaternionChange );\r\n\r\n\tObject.defineProperties( this, {\r\n\t\tposition: {\r\n\t\t\tenumerable: true,\r\n\t\t\tvalue: position\r\n\t\t},\r\n\t\trotation: {\r\n\t\t\tenumerable: true,\r\n\t\t\tvalue: rotation\r\n\t\t},\r\n\t\tquaternion: {\r\n\t\t\tenumerable: true,\r\n\t\t\tvalue: quaternion\r\n\t\t},\r\n\t\tscale: {\r\n\t\t\tenumerable: true,\r\n\t\t\tvalue: scale\r\n\t\t}\r\n\t} );\r\n\r\n\tthis.rotationAutoUpdate = true;\r\n\r\n\tthis.matrix = new THREE.Matrix4();\r\n\tthis.matrixWorld = new THREE.Matrix4();\r\n\r\n\tthis.matrixAutoUpdate = true;\r\n\tthis.matrixWorldNeedsUpdate = false;\r\n\r\n\tthis.visible = true;\r\n\r\n\tthis.castShadow = false;\r\n\tthis.receiveShadow = false;\r\n\r\n\tthis.frustumCulled = true;\r\n\tthis.renderOrder = 0;\r\n\r\n\tthis.userData = {};\r\n\r\n};\r\n\r\nTHREE.Object3D.DefaultUp = new THREE.Vector3( 0, 1, 0 );\r\n\r\nTHREE.Object3D.prototype = {\r\n\r\n\tconstructor: THREE.Object3D,\r\n\r\n\tget eulerOrder () {\r\n\r\n\t\tTHREE.warn( 'THREE.Object3D: .eulerOrder has been moved to .rotation.order.' );\r\n\r\n\t\treturn this.rotation.order;\r\n\r\n\t},\r\n\r\n\tset eulerOrder ( value ) {\r\n\r\n\t\tTHREE.warn( 'THREE.Object3D: .eulerOrder has been moved to .rotation.order.' );\r\n\r\n\t\tthis.rotation.order = value;\r\n\r\n\t},\r\n\r\n\tget useQuaternion () {\r\n\r\n\t\tTHREE.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );\r\n\r\n\t},\r\n\r\n\tset useQuaternion ( value ) {\r\n\r\n\t\tTHREE.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );\r\n\r\n\t},\r\n\r\n\tapplyMatrix: function ( matrix ) {\r\n\r\n\t\tthis.matrix.multiplyMatrices( matrix, this.matrix );\r\n\r\n\t\tthis.matrix.decompose( this.position, this.quaternion, this.scale );\r\n\r\n\t},\r\n\r\n\tsetRotationFromAxisAngle: function ( axis, angle ) {\r\n\r\n\t\t// assumes axis is normalized\r\n\r\n\t\tthis.quaternion.setFromAxisAngle( axis, angle );\r\n\r\n\t},\r\n\r\n\tsetRotationFromEuler: function ( euler ) {\r\n\r\n\t\tthis.quaternion.setFromEuler( euler, true );\r\n\r\n\t},\r\n\r\n\tsetRotationFromMatrix: function ( m ) {\r\n\r\n\t\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\r\n\r\n\t\tthis.quaternion.setFromRotationMatrix( m );\r\n\r\n\t},\r\n\r\n\tsetRotationFromQuaternion: function ( q ) {\r\n\r\n\t\t// assumes q is normalized\r\n\r\n\t\tthis.quaternion.copy( q );\r\n\r\n\t},\r\n\r\n\trotateOnAxis: function () {\r\n\r\n\t\t// rotate object on axis in object space\r\n\t\t// axis is assumed to be normalized\r\n\r\n\t\tvar q1 = new THREE.Quaternion();\r\n\r\n\t\treturn function ( axis, angle ) {\r\n\r\n\t\t\tq1.setFromAxisAngle( axis, angle );\r\n\r\n\t\t\tthis.quaternion.multiply( q1 );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t}(),\r\n\r\n\trotateX: function () {\r\n\r\n\t\tvar v1 = new THREE.Vector3( 1, 0, 0 );\r\n\r\n\t\treturn function ( angle ) {\r\n\r\n\t\t\treturn this.rotateOnAxis( v1, angle );\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\trotateY: function () {\r\n\r\n\t\tvar v1 = new THREE.Vector3( 0, 1, 0 );\r\n\r\n\t\treturn function ( angle ) {\r\n\r\n\t\t\treturn this.rotateOnAxis( v1, angle );\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\trotateZ: function () {\r\n\r\n\t\tvar v1 = new THREE.Vector3( 0, 0, 1 );\r\n\r\n\t\treturn function ( angle ) {\r\n\r\n\t\t\treturn this.rotateOnAxis( v1, angle );\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\ttranslateOnAxis: function () {\r\n\r\n\t\t// translate object by distance along axis in object space\r\n\t\t// axis is assumed to be normalized\r\n\r\n\t\tvar v1 = new THREE.Vector3();\r\n\r\n\t\treturn function ( axis, distance ) {\r\n\r\n\t\t\tv1.copy( axis ).applyQuaternion( this.quaternion );\r\n\r\n\t\t\tthis.position.add( v1.multiplyScalar( distance ) );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t}(),\r\n\r\n\ttranslate: function ( distance, axis ) {\r\n\r\n\t\tTHREE.warn( 'THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.' );\r\n\t\treturn this.translateOnAxis( axis, distance );\r\n\r\n\t},\r\n\r\n\ttranslateX: function () {\r\n\r\n\t\tvar v1 = new THREE.Vector3( 1, 0, 0 );\r\n\r\n\t\treturn function ( distance ) {\r\n\r\n\t\t\treturn this.translateOnAxis( v1, distance );\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\ttranslateY: function () {\r\n\r\n\t\tvar v1 = new THREE.Vector3( 0, 1, 0 );\r\n\r\n\t\treturn function ( distance ) {\r\n\r\n\t\t\treturn this.translateOnAxis( v1, distance );\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\ttranslateZ: function () {\r\n\r\n\t\tvar v1 = new THREE.Vector3( 0, 0, 1 );\r\n\r\n\t\treturn function ( distance ) {\r\n\r\n\t\t\treturn this.translateOnAxis( v1, distance );\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tlocalToWorld: function ( vector ) {\r\n\r\n\t\treturn vector.applyMatrix4( this.matrixWorld );\r\n\r\n\t},\r\n\r\n\tworldToLocal: function () {\r\n\r\n\t\tvar m1 = new THREE.Matrix4();\r\n\r\n\t\treturn function ( vector ) {\r\n\r\n\t\t\treturn vector.applyMatrix4( m1.getInverse( this.matrixWorld ) );\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tlookAt: function () {\r\n\r\n\t\t// This routine does not support objects with rotated and/or translated parent(s)\r\n\r\n\t\tvar m1 = new THREE.Matrix4();\r\n\r\n\t\treturn function ( vector ) {\r\n\r\n\t\t\tm1.lookAt( vector, this.position, this.up );\r\n\r\n\t\t\tthis.quaternion.setFromRotationMatrix( m1 );\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tadd: function ( object ) {\r\n\r\n\t\tif ( arguments.length > 1 ) {\r\n\r\n\t\t\tfor ( var i = 0; i < arguments.length; i ++ ) {\r\n\r\n\t\t\t\tthis.add( arguments[ i ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t\tif ( object === this ) {\r\n\r\n\t\t\tTHREE.error( \"THREE.Object3D.add: object can't be added as a child of itself.\", object );\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\tif ( object instanceof THREE.Object3D ) {\r\n\r\n\t\t\tif ( object.parent !== undefined ) {\r\n\r\n\t\t\t\tobject.parent.remove( object );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tobject.parent = this;\r\n\t\t\tobject.dispatchEvent( { type: 'added' } );\r\n\r\n\t\t\tthis.children.push( object );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tTHREE.error( \"THREE.Object3D.add: object not an instance of THREE.Object3D.\", object );\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tremove: function ( object ) {\r\n\r\n\t\tif ( arguments.length > 1 ) {\r\n\r\n\t\t\tfor ( var i = 0; i < arguments.length; i ++ ) {\r\n\r\n\t\t\t\tthis.remove( arguments[ i ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t};\r\n\r\n\t\tvar index = this.children.indexOf( object );\r\n\r\n\t\tif ( index !== - 1 ) {\r\n\r\n\t\t\tobject.parent = undefined;\r\n\r\n\t\t\tobject.dispatchEvent( { type: 'removed' } );\r\n\r\n\t\t\tthis.children.splice( index, 1 );\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tgetChildByName: function ( name ) {\r\n\r\n\t\tTHREE.warn( 'THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().' );\r\n\t\treturn this.getObjectByName( name );\r\n\r\n\t},\r\n\r\n\tgetObjectById: function ( id ) {\r\n\r\n\t\treturn this.getObjectByProperty( 'id', id );\r\n\r\n\t},\r\n\r\n\tgetObjectByName: function ( name ) {\r\n\r\n\t\treturn this.getObjectByProperty( 'name', name );\r\n\r\n\t},\r\n\r\n\tgetObjectByProperty: function ( name, value ) {\r\n\r\n\t\tif ( this[ name ] === value ) return this;\r\n\r\n\t\tfor ( var i = 0, l = this.children.length; i < l; i ++ ) {\r\n\r\n\t\t\tvar child = this.children[ i ];\r\n\t\t\tvar object = child.getObjectByProperty( name, value );\r\n\r\n\t\t\tif ( object !== undefined ) {\r\n\r\n\t\t\t\treturn object;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn undefined;\r\n\r\n\t},\r\n\r\n\tgetWorldPosition: function ( optionalTarget ) {\r\n\r\n\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\r\n\t\tthis.updateMatrixWorld( true );\r\n\r\n\t\treturn result.setFromMatrixPosition( this.matrixWorld );\r\n\r\n\t},\r\n\r\n\tgetWorldQuaternion: function () {\r\n\r\n\t\tvar position = new THREE.Vector3();\r\n\t\tvar scale = new THREE.Vector3();\r\n\r\n\t\treturn function ( optionalTarget ) {\r\n\r\n\t\t\tvar result = optionalTarget || new THREE.Quaternion();\r\n\r\n\t\t\tthis.updateMatrixWorld( true );\r\n\r\n\t\t\tthis.matrixWorld.decompose( position, result, scale );\r\n\r\n\t\t\treturn result;\r\n\r\n\t\t}\r\n\r\n\t}(),\r\n\r\n\tgetWorldRotation: function () {\r\n\r\n\t\tvar quaternion = new THREE.Quaternion();\r\n\r\n\t\treturn function ( optionalTarget ) {\r\n\r\n\t\t\tvar result = optionalTarget || new THREE.Euler();\r\n\r\n\t\t\tthis.getWorldQuaternion( quaternion );\r\n\r\n\t\t\treturn result.setFromQuaternion( quaternion, this.rotation.order, false );\r\n\r\n\t\t}\r\n\r\n\t}(),\r\n\r\n\tgetWorldScale: function () {\r\n\r\n\t\tvar position = new THREE.Vector3();\r\n\t\tvar quaternion = new THREE.Quaternion();\r\n\r\n\t\treturn function ( optionalTarget ) {\r\n\r\n\t\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\r\n\t\t\tthis.updateMatrixWorld( true );\r\n\r\n\t\t\tthis.matrixWorld.decompose( position, quaternion, result );\r\n\r\n\t\t\treturn result;\r\n\r\n\t\t}\r\n\r\n\t}(),\r\n\r\n\tgetWorldDirection: function () {\r\n\r\n\t\tvar quaternion = new THREE.Quaternion();\r\n\r\n\t\treturn function ( optionalTarget ) {\r\n\r\n\t\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\r\n\t\t\tthis.getWorldQuaternion( quaternion );\r\n\r\n\t\t\treturn result.set( 0, 0, 1 ).applyQuaternion( quaternion );\r\n\r\n\t\t}\r\n\r\n\t}(),\r\n\r\n\traycast: function () {},\r\n\r\n\ttraverse: function ( callback ) {\r\n\r\n\t\tcallback( this );\r\n\r\n\t\tfor ( var i = 0, l = this.children.length; i < l; i ++ ) {\r\n\r\n\t\t\tthis.children[ i ].traverse( callback );\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\ttraverseVisible: function ( callback ) {\r\n\r\n\t\tif ( this.visible === false ) return;\r\n\r\n\t\tcallback( this );\r\n\r\n\t\tfor ( var i = 0, l = this.children.length; i < l; i ++ ) {\r\n\r\n\t\t\tthis.children[ i ].traverseVisible( callback );\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\ttraverseAncestors: function ( callback ) {\r\n\r\n\t\tif ( this.parent ) {\r\n\r\n\t\t\tcallback( this.parent );\r\n\r\n\t\t\tthis.parent.traverseAncestors( callback );\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tupdateMatrix: function () {\r\n\r\n\t\tthis.matrix.compose( this.position, this.quaternion, this.scale );\r\n\r\n\t\tthis.matrixWorldNeedsUpdate = true;\r\n\r\n\t},\r\n\r\n\tupdateMatrixWorld: function ( force ) {\r\n\r\n\t\tif ( this.matrixAutoUpdate === true ) this.updateMatrix();\r\n\r\n\t\tif ( this.matrixWorldNeedsUpdate === true || force === true ) {\r\n\r\n\t\t\tif ( this.parent === undefined ) {\r\n\r\n\t\t\t\tthis.matrixWorld.copy( this.matrix );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tthis.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis.matrixWorldNeedsUpdate = false;\r\n\r\n\t\t\tforce = true;\r\n\r\n\t\t}\r\n\r\n\t\t// update children\r\n\r\n\t\tfor ( var i = 0, l = this.children.length; i < l; i ++ ) {\r\n\r\n\t\t\tthis.children[ i ].updateMatrixWorld( force );\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\ttoJSON: function () {\r\n\r\n\t\tvar output = {\r\n\t\t\tmetadata: {\r\n\t\t\t\tversion: 4.3,\r\n\t\t\t\ttype: 'Object',\r\n\t\t\t\tgenerator: 'ObjectExporter'\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\t//\r\n\r\n\t\tvar geometries = {};\r\n\r\n\t\tvar parseGeometry = function ( geometry ) {\r\n\r\n\t\t\tif ( output.geometries === undefined ) {\r\n\r\n\t\t\t\toutput.geometries = [];\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( geometries[ geometry.uuid ] === undefined ) {\r\n\r\n\t\t\t\tvar json = geometry.toJSON();\r\n\r\n\t\t\t\tdelete json.metadata;\r\n\r\n\t\t\t\tgeometries[ geometry.uuid ] = json;\r\n\r\n\t\t\t\toutput.geometries.push( json );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn geometry.uuid;\r\n\r\n\t\t};\r\n\r\n\t\t//\r\n\r\n\t\tvar materials = {};\r\n\r\n\t\tvar parseMaterial = function ( material ) {\r\n\r\n\t\t\tif ( output.materials === undefined ) {\r\n\r\n\t\t\t\toutput.materials = [];\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( materials[ material.uuid ] === undefined ) {\r\n\r\n\t\t\t\tvar json = material.toJSON();\r\n\r\n\t\t\t\tdelete json.metadata;\r\n\r\n\t\t\t\tmaterials[ material.uuid ] = json;\r\n\r\n\t\t\t\toutput.materials.push( json );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn material.uuid;\r\n\r\n\t\t};\r\n\r\n\t\t//\r\n\r\n\t\tvar parseObject = function ( object ) {\r\n\r\n\t\t\tvar data = {};\r\n\r\n\t\t\tdata.uuid = object.uuid;\r\n\t\t\tdata.type = object.type;\r\n\r\n\t\t\tif ( object.name !== '' ) data.name = object.name;\r\n\t\t\tif ( JSON.stringify( object.userData ) !== '{}' ) data.userData = object.userData;\r\n\t\t\tif ( object.visible !== true ) data.visible = object.visible;\r\n\r\n\t\t\tif ( object instanceof THREE.PerspectiveCamera ) {\r\n\r\n\t\t\t\tdata.fov = object.fov;\r\n\t\t\t\tdata.aspect = object.aspect;\r\n\t\t\t\tdata.near = object.near;\r\n\t\t\t\tdata.far = object.far;\r\n\r\n\t\t\t} else if ( object instanceof THREE.OrthographicCamera ) {\r\n\r\n\t\t\t\tdata.left = object.left;\r\n\t\t\t\tdata.right = object.right;\r\n\t\t\t\tdata.top = object.top;\r\n\t\t\t\tdata.bottom = object.bottom;\r\n\t\t\t\tdata.near = object.near;\r\n\t\t\t\tdata.far = object.far;\r\n\r\n\t\t\t} else if ( object instanceof THREE.AmbientLight ) {\r\n\r\n\t\t\t\tdata.color = object.color.getHex();\r\n\r\n\t\t\t} else if ( object instanceof THREE.DirectionalLight ) {\r\n\r\n\t\t\t\tdata.color = object.color.getHex();\r\n\t\t\t\tdata.intensity = object.intensity;\r\n\r\n\t\t\t} else if ( object instanceof THREE.PointLight ) {\r\n\r\n\t\t\t\tdata.color = object.color.getHex();\r\n\t\t\t\tdata.intensity = object.intensity;\r\n\t\t\t\tdata.distance = object.distance;\r\n\t\t\t\tdata.decay = object.decay;\r\n\r\n\t\t\t} else if ( object instanceof THREE.SpotLight ) {\r\n\r\n\t\t\t\tdata.color = object.color.getHex();\r\n\t\t\t\tdata.intensity = object.intensity;\r\n\t\t\t\tdata.distance = object.distance;\r\n\t\t\t\tdata.angle = object.angle;\r\n\t\t\t\tdata.exponent = object.exponent;\r\n\t\t\t\tdata.decay = object.decay;\r\n\r\n\t\t\t} else if ( object instanceof THREE.HemisphereLight ) {\r\n\r\n\t\t\t\tdata.color = object.color.getHex();\r\n\t\t\t\tdata.groundColor = object.groundColor.getHex();\r\n\r\n\t\t\t} else if ( object instanceof THREE.Mesh || object instanceof THREE.Line || object instanceof THREE.PointCloud ) {\r\n\r\n\t\t\t\tdata.geometry = parseGeometry( object.geometry );\r\n\t\t\t\tdata.material = parseMaterial( object.material );\r\n\r\n\t\t\t\tif ( object instanceof THREE.Line ) data.mode = object.mode;\r\n\r\n\t\t\t} else if ( object instanceof THREE.Sprite ) {\r\n\r\n\t\t\t\tdata.material = parseMaterial( object.material );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tdata.matrix = object.matrix.toArray();\r\n\r\n\t\t\tif ( object.children.length > 0 ) {\r\n\r\n\t\t\t\tdata.children = [];\r\n\r\n\t\t\t\tfor ( var i = 0; i < object.children.length; i ++ ) {\r\n\r\n\t\t\t\t\tdata.children.push( parseObject( object.children[ i ] ) );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn data;\r\n\r\n\t\t}\r\n\r\n\t\toutput.object = parseObject( this );\r\n\r\n\t\treturn output;\r\n\r\n\t},\r\n\r\n\tclone: function ( object, recursive ) {\r\n\r\n\t\tif ( object === undefined ) object = new THREE.Object3D();\r\n\t\tif ( recursive === undefined ) recursive = true;\r\n\r\n\t\tobject.name = this.name;\r\n\r\n\t\tobject.up.copy( this.up );\r\n\r\n\t\tobject.position.copy( this.position );\r\n\t\tobject.quaternion.copy( this.quaternion );\r\n\t\tobject.scale.copy( this.scale );\r\n\r\n\t\tobject.rotationAutoUpdate = this.rotationAutoUpdate;\r\n\r\n\t\tobject.matrix.copy( this.matrix );\r\n\t\tobject.matrixWorld.copy( this.matrixWorld );\r\n\r\n\t\tobject.matrixAutoUpdate = this.matrixAutoUpdate;\r\n\t\tobject.matrixWorldNeedsUpdate = this.matrixWorldNeedsUpdate;\r\n\r\n\t\tobject.visible = this.visible;\r\n\r\n\t\tobject.castShadow = this.castShadow;\r\n\t\tobject.receiveShadow = this.receiveShadow;\r\n\r\n\t\tobject.frustumCulled = this.frustumCulled;\r\n\r\n\t\tobject.userData = JSON.parse( JSON.stringify( this.userData ) );\r\n\r\n\t\tif ( recursive === true ) {\r\n\r\n\t\t\tfor ( var i = 0; i < this.children.length; i ++ ) {\r\n\r\n\t\t\t\tvar child = this.children[ i ];\r\n\t\t\t\tobject.add( child.clone() );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn object;\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.EventDispatcher.prototype.apply( THREE.Object3D.prototype );\r\n\r\nTHREE.Object3DIdCount = 0;\r\n\r\n// File:src/core/Face3.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.Face3 = function ( a, b, c, normal, color, materialIndex ) {\r\n\r\n\tthis.a = a;\r\n\tthis.b = b;\r\n\tthis.c = c;\r\n\r\n\tthis.normal = normal instanceof THREE.Vector3 ? normal : new THREE.Vector3();\r\n\tthis.vertexNormals = normal instanceof Array ? normal : [];\r\n\r\n\tthis.color = color instanceof THREE.Color ? color : new THREE.Color();\r\n\tthis.vertexColors = color instanceof Array ? color : [];\r\n\r\n\tthis.vertexTangents = [];\r\n\r\n\tthis.materialIndex = materialIndex !== undefined ? materialIndex : 0;\r\n\r\n};\r\n\r\nTHREE.Face3.prototype = {\r\n\r\n\tconstructor: THREE.Face3,\r\n\r\n\tclone: function () {\r\n\r\n\t\tvar face = new THREE.Face3( this.a, this.b, this.c );\r\n\r\n\t\tface.normal.copy( this.normal );\r\n\t\tface.color.copy( this.color );\r\n\r\n\t\tface.materialIndex = this.materialIndex;\r\n\r\n\t\tfor ( var i = 0, il = this.vertexNormals.length; i < il; i ++ ) {\r\n\r\n\t\t\tface.vertexNormals[ i ] = this.vertexNormals[ i ].clone();\r\n\r\n\t\t}\r\n\r\n\t\tfor ( var i = 0, il = this.vertexColors.length; i < il; i ++ ) {\r\n\r\n\t\t\tface.vertexColors[ i ] = this.vertexColors[ i ].clone();\r\n\r\n\t\t}\r\n\r\n\t\tfor ( var i = 0, il = this.vertexTangents.length; i < il; i ++ ) {\r\n\r\n\t\t\tface.vertexTangents[ i ] = this.vertexTangents[ i ].clone();\r\n\r\n\t\t}\r\n\r\n\t\treturn face;\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/core/Face4.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.Face4 = function ( a, b, c, d, normal, color, materialIndex ) {\r\n\r\n\tTHREE.warn( 'THREE.Face4 has been removed. A THREE.Face3 will be created instead.' )\r\n\treturn new THREE.Face3( a, b, c, normal, color, materialIndex );\r\n\r\n};\r\n\r\n// File:src/core/BufferAttribute.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.BufferAttribute = function ( array, itemSize ) {\r\n\r\n\tthis.array = array;\r\n\tthis.itemSize = itemSize;\r\n\r\n\tthis.needsUpdate = false;\r\n\r\n};\r\n\r\nTHREE.BufferAttribute.prototype = {\r\n\r\n\tconstructor: THREE.BufferAttribute,\r\n\r\n\tget length () {\r\n\r\n\t\treturn this.array.length;\r\n\r\n\t},\r\n\r\n\tcopyAt: function ( index1, attribute, index2 ) {\r\n\r\n\t\tindex1 *= this.itemSize;\r\n\t\tindex2 *= attribute.itemSize;\r\n\r\n\t\tfor ( var i = 0, l = this.itemSize; i < l; i ++ ) {\r\n\r\n\t\t\tthis.array[ index1 + i ] = attribute.array[ index2 + i ];\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tset: function ( value, offset ) {\r\n\r\n\t\tif ( offset === undefined ) offset = 0;\r\n\r\n\t\tthis.array.set( value, offset );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetX: function ( index, x ) {\r\n\r\n\t\tthis.array[ index * this.itemSize ] = x;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetY: function ( index, y ) {\r\n\r\n\t\tthis.array[ index * this.itemSize + 1 ] = y;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetZ: function ( index, z ) {\r\n\r\n\t\tthis.array[ index * this.itemSize + 2 ] = z;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetXY: function ( index, x, y ) {\r\n\r\n\t\tindex *= this.itemSize;\r\n\r\n\t\tthis.array[ index     ] = x;\r\n\t\tthis.array[ index + 1 ] = y;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetXYZ: function ( index, x, y, z ) {\r\n\r\n\t\tindex *= this.itemSize;\r\n\r\n\t\tthis.array[ index     ] = x;\r\n\t\tthis.array[ index + 1 ] = y;\r\n\t\tthis.array[ index + 2 ] = z;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetXYZW: function ( index, x, y, z, w ) {\r\n\r\n\t\tindex *= this.itemSize;\r\n\r\n\t\tthis.array[ index     ] = x;\r\n\t\tthis.array[ index + 1 ] = y;\r\n\t\tthis.array[ index + 2 ] = z;\r\n\t\tthis.array[ index + 3 ] = w;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tclone: function () {\r\n\r\n\t\treturn new THREE.BufferAttribute( new this.array.constructor( this.array ), this.itemSize );\r\n\r\n\t}\r\n\r\n};\r\n\r\n//\r\n\r\nTHREE.Int8Attribute = function ( data, itemSize ) {\r\n\r\n\tTHREE.warn( 'THREE.Int8Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead.' );\r\n\treturn new THREE.BufferAttribute( data, itemSize );\r\n\r\n};\r\n\r\nTHREE.Uint8Attribute = function ( data, itemSize ) {\r\n\r\n\tTHREE.warn( 'THREE.Uint8Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead.' );\r\n\treturn new THREE.BufferAttribute( data, itemSize );\r\n\r\n};\r\n\r\nTHREE.Uint8ClampedAttribute = function ( data, itemSize ) {\r\n\r\n\tTHREE.warn( 'THREE.Uint8ClampedAttribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead.' );\r\n\treturn new THREE.BufferAttribute( data, itemSize );\r\n\r\n\r\n};\r\n\r\nTHREE.Int16Attribute = function ( data, itemSize ) {\r\n\r\n\tTHREE.warn( 'THREE.Int16Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead.' );\r\n\treturn new THREE.BufferAttribute( data, itemSize );\r\n\r\n};\r\n\r\nTHREE.Uint16Attribute = function ( data, itemSize ) {\r\n\r\n\tTHREE.warn( 'THREE.Uint16Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead.' );\r\n\treturn new THREE.BufferAttribute( data, itemSize );\r\n\r\n};\r\n\r\nTHREE.Int32Attribute = function ( data, itemSize ) {\r\n\r\n\tTHREE.warn( 'THREE.Int32Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead.' );\r\n\treturn new THREE.BufferAttribute( data, itemSize );\r\n\r\n};\r\n\r\nTHREE.Uint32Attribute = function ( data, itemSize ) {\r\n\r\n\tTHREE.warn( 'THREE.Uint32Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead.' );\r\n\treturn new THREE.BufferAttribute( data, itemSize );\r\n\r\n};\r\n\r\nTHREE.Float32Attribute = function ( data, itemSize ) {\r\n\r\n\tTHREE.warn( 'THREE.Float32Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead.' );\r\n\treturn new THREE.BufferAttribute( data, itemSize );\r\n\r\n};\r\n\r\nTHREE.Float64Attribute = function ( data, itemSize ) {\r\n\r\n\tTHREE.warn( 'THREE.Float64Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead.' );\r\n\treturn new THREE.BufferAttribute( data, itemSize );\r\n\r\n};\r\n\r\n// File:src/core/DynamicBufferAttribute.js\r\n\r\n/**\r\n * @author benaadams / https://twitter.com/ben_a_adams\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.DynamicBufferAttribute = function ( array, itemSize ) {\r\n\r\n\tTHREE.BufferAttribute.call( this, array, itemSize );\r\n\r\n\tthis.updateRange = { offset: 0, count: -1 };\r\n\r\n};\r\n\r\nTHREE.DynamicBufferAttribute.prototype = Object.create( THREE.BufferAttribute.prototype );\r\nTHREE.DynamicBufferAttribute.prototype.constructor = THREE.DynamicBufferAttribute;\r\n\r\nTHREE.DynamicBufferAttribute.prototype.clone = function () {\r\n\r\n\treturn new THREE.DynamicBufferAttribute( new this.array.constructor( this.array ), this.itemSize );\r\n\r\n};\r\n\r\n// File:src/core/BufferGeometry.js\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.BufferGeometry = function () {\r\n\r\n\tObject.defineProperty( this, 'id', { value: THREE.GeometryIdCount ++ } );\r\n\r\n\tthis.uuid = THREE.Math.generateUUID();\r\n\r\n\tthis.name = '';\r\n\tthis.type = 'BufferGeometry';\r\n\r\n\tthis.attributes = {};\r\n\tthis.attributesKeys = [];\r\n\r\n\tthis.drawcalls = [];\r\n\tthis.offsets = this.drawcalls; // backwards compatibility\r\n\r\n\tthis.boundingBox = null;\r\n\tthis.boundingSphere = null;\r\n\r\n};\r\n\r\nTHREE.BufferGeometry.prototype = {\r\n\r\n\tconstructor: THREE.BufferGeometry,\r\n\r\n\taddAttribute: function ( name, attribute ) {\r\n\r\n\t\tif ( attribute instanceof THREE.BufferAttribute === false ) {\r\n\r\n\t\t\tTHREE.warn( 'THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).' );\r\n\r\n\t\t\tthis.attributes[ name ] = { array: arguments[ 1 ], itemSize: arguments[ 2 ] };\r\n\r\n\t\t\treturn;\r\n\r\n\t\t}\r\n\r\n\t\tthis.attributes[ name ] = attribute;\r\n\t\tthis.attributesKeys = Object.keys( this.attributes );\r\n\r\n\t},\r\n\r\n\tgetAttribute: function ( name ) {\r\n\r\n\t\treturn this.attributes[ name ];\r\n\r\n\t},\r\n\r\n\taddDrawCall: function ( start, count, indexOffset ) {\r\n\r\n\t\tthis.drawcalls.push( {\r\n\r\n\t\t\tstart: start,\r\n\t\t\tcount: count,\r\n\t\t\tindex: indexOffset !== undefined ? indexOffset : 0\r\n\r\n\t\t} );\r\n\r\n\t},\r\n\r\n\tapplyMatrix: function ( matrix ) {\r\n\r\n\t\tvar position = this.attributes.position;\r\n\r\n\t\tif ( position !== undefined ) {\r\n\r\n\t\t\tmatrix.applyToVector3Array( position.array );\r\n\t\t\tposition.needsUpdate = true;\r\n\r\n\t\t}\r\n\r\n\t\tvar normal = this.attributes.normal;\r\n\r\n\t\tif ( normal !== undefined ) {\r\n\r\n\t\t\tvar normalMatrix = new THREE.Matrix3().getNormalMatrix( matrix );\r\n\r\n\t\t\tnormalMatrix.applyToVector3Array( normal.array );\r\n\t\t\tnormal.needsUpdate = true;\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.boundingBox !== null ) {\r\n\r\n\t\t\tthis.computeBoundingBox();\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.boundingSphere !== null ) {\r\n\r\n\t\t\tthis.computeBoundingSphere();\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tcenter: function () {\r\n\r\n\t\tthis.computeBoundingBox();\r\n\r\n\t\tvar offset = this.boundingBox.center().negate();\r\n\r\n\t\tthis.applyMatrix( new THREE.Matrix4().setPosition( offset ) );\r\n\r\n\t\treturn offset;\r\n\r\n\t},\r\n\r\n\tfromGeometry: function ( geometry, settings ) {\r\n\r\n\t\tsettings = settings || { 'vertexColors': THREE.NoColors };\r\n\r\n\t\tvar vertices = geometry.vertices;\r\n\t\tvar faces = geometry.faces;\r\n\t\tvar faceVertexUvs = geometry.faceVertexUvs;\r\n\t\tvar vertexColors = settings.vertexColors;\r\n\t\tvar hasFaceVertexUv = faceVertexUvs[ 0 ].length > 0;\r\n\t\tvar hasFaceVertexNormals = faces[ 0 ].vertexNormals.length == 3;\r\n\r\n\t\tvar positions = new Float32Array( faces.length * 3 * 3 );\r\n\t\tthis.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );\r\n\r\n\t\tvar normals = new Float32Array( faces.length * 3 * 3 );\r\n\t\tthis.addAttribute( 'normal', new THREE.BufferAttribute( normals, 3 ) );\r\n\r\n\t\tif ( vertexColors !== THREE.NoColors ) {\r\n\r\n\t\t\tvar colors = new Float32Array( faces.length * 3 * 3 );\r\n\t\t\tthis.addAttribute( 'color', new THREE.BufferAttribute( colors, 3 ) );\r\n\r\n\t\t}\r\n\r\n\t\tif ( hasFaceVertexUv === true ) {\r\n\r\n\t\t\tvar uvs = new Float32Array( faces.length * 3 * 2 );\r\n\t\t\tthis.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ) );\r\n\r\n\t\t}\r\n\r\n\t\tfor ( var i = 0, i2 = 0, i3 = 0; i < faces.length; i ++, i2 += 6, i3 += 9 ) {\r\n\r\n\t\t\tvar face = faces[ i ];\r\n\r\n\t\t\tvar a = vertices[ face.a ];\r\n\t\t\tvar b = vertices[ face.b ];\r\n\t\t\tvar c = vertices[ face.c ];\r\n\r\n\t\t\tpositions[ i3     ] = a.x;\r\n\t\t\tpositions[ i3 + 1 ] = a.y;\r\n\t\t\tpositions[ i3 + 2 ] = a.z;\r\n\r\n\t\t\tpositions[ i3 + 3 ] = b.x;\r\n\t\t\tpositions[ i3 + 4 ] = b.y;\r\n\t\t\tpositions[ i3 + 5 ] = b.z;\r\n\r\n\t\t\tpositions[ i3 + 6 ] = c.x;\r\n\t\t\tpositions[ i3 + 7 ] = c.y;\r\n\t\t\tpositions[ i3 + 8 ] = c.z;\r\n\r\n\t\t\tif ( hasFaceVertexNormals === true ) {\r\n\r\n\t\t\t\tvar na = face.vertexNormals[ 0 ];\r\n\t\t\t\tvar nb = face.vertexNormals[ 1 ];\r\n\t\t\t\tvar nc = face.vertexNormals[ 2 ];\r\n\r\n\t\t\t\tnormals[ i3     ] = na.x;\r\n\t\t\t\tnormals[ i3 + 1 ] = na.y;\r\n\t\t\t\tnormals[ i3 + 2 ] = na.z;\r\n\r\n\t\t\t\tnormals[ i3 + 3 ] = nb.x;\r\n\t\t\t\tnormals[ i3 + 4 ] = nb.y;\r\n\t\t\t\tnormals[ i3 + 5 ] = nb.z;\r\n\r\n\t\t\t\tnormals[ i3 + 6 ] = nc.x;\r\n\t\t\t\tnormals[ i3 + 7 ] = nc.y;\r\n\t\t\t\tnormals[ i3 + 8 ] = nc.z;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tvar n = face.normal;\r\n\r\n\t\t\t\tnormals[ i3     ] = n.x;\r\n\t\t\t\tnormals[ i3 + 1 ] = n.y;\r\n\t\t\t\tnormals[ i3 + 2 ] = n.z;\r\n\r\n\t\t\t\tnormals[ i3 + 3 ] = n.x;\r\n\t\t\t\tnormals[ i3 + 4 ] = n.y;\r\n\t\t\t\tnormals[ i3 + 5 ] = n.z;\r\n\r\n\t\t\t\tnormals[ i3 + 6 ] = n.x;\r\n\t\t\t\tnormals[ i3 + 7 ] = n.y;\r\n\t\t\t\tnormals[ i3 + 8 ] = n.z;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( vertexColors === THREE.FaceColors ) {\r\n\r\n\t\t\t\tvar fc = face.color;\r\n\r\n\t\t\t\tcolors[ i3     ] = fc.r;\r\n\t\t\t\tcolors[ i3 + 1 ] = fc.g;\r\n\t\t\t\tcolors[ i3 + 2 ] = fc.b;\r\n\r\n\t\t\t\tcolors[ i3 + 3 ] = fc.r;\r\n\t\t\t\tcolors[ i3 + 4 ] = fc.g;\r\n\t\t\t\tcolors[ i3 + 5 ] = fc.b;\r\n\r\n\t\t\t\tcolors[ i3 + 6 ] = fc.r;\r\n\t\t\t\tcolors[ i3 + 7 ] = fc.g;\r\n\t\t\t\tcolors[ i3 + 8 ] = fc.b;\r\n\r\n\t\t\t} else if ( vertexColors === THREE.VertexColors ) {\r\n\r\n\t\t\t\tvar vca = face.vertexColors[ 0 ];\r\n\t\t\t\tvar vcb = face.vertexColors[ 1 ];\r\n\t\t\t\tvar vcc = face.vertexColors[ 2 ];\r\n\r\n\t\t\t\tcolors[ i3     ] = vca.r;\r\n\t\t\t\tcolors[ i3 + 1 ] = vca.g;\r\n\t\t\t\tcolors[ i3 + 2 ] = vca.b;\r\n\r\n\t\t\t\tcolors[ i3 + 3 ] = vcb.r;\r\n\t\t\t\tcolors[ i3 + 4 ] = vcb.g;\r\n\t\t\t\tcolors[ i3 + 5 ] = vcb.b;\r\n\r\n\t\t\t\tcolors[ i3 + 6 ] = vcc.r;\r\n\t\t\t\tcolors[ i3 + 7 ] = vcc.g;\r\n\t\t\t\tcolors[ i3 + 8 ] = vcc.b;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( hasFaceVertexUv === true ) {\r\n\r\n\t\t\t\tvar uva = faceVertexUvs[ 0 ][ i ][ 0 ];\r\n\t\t\t\tvar uvb = faceVertexUvs[ 0 ][ i ][ 1 ];\r\n\t\t\t\tvar uvc = faceVertexUvs[ 0 ][ i ][ 2 ];\r\n\r\n\t\t\t\tuvs[ i2     ] = uva.x;\r\n\t\t\t\tuvs[ i2 + 1 ] = uva.y;\r\n\r\n\t\t\t\tuvs[ i2 + 2 ] = uvb.x;\r\n\t\t\t\tuvs[ i2 + 3 ] = uvb.y;\r\n\r\n\t\t\t\tuvs[ i2 + 4 ] = uvc.x;\r\n\t\t\t\tuvs[ i2 + 5 ] = uvc.y;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tthis.computeBoundingSphere()\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tcomputeBoundingBox: function () {\r\n\r\n\t\tvar vector = new THREE.Vector3();\r\n\r\n\t\treturn function () {\r\n\r\n\t\t\tif ( this.boundingBox === null ) {\r\n\r\n\t\t\t\tthis.boundingBox = new THREE.Box3();\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar positions = this.attributes.position.array;\r\n\r\n\t\t\tif ( positions ) {\r\n\r\n\t\t\t\tvar bb = this.boundingBox;\r\n\t\t\t\tbb.makeEmpty();\r\n\r\n\t\t\t\tfor ( var i = 0, il = positions.length; i < il; i += 3 ) {\r\n\r\n\t\t\t\t\tvector.set( positions[ i ], positions[ i + 1 ], positions[ i + 2 ] );\r\n\t\t\t\t\tbb.expandByPoint( vector );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( positions === undefined || positions.length === 0 ) {\r\n\r\n\t\t\t\tthis.boundingBox.min.set( 0, 0, 0 );\r\n\t\t\t\tthis.boundingBox.max.set( 0, 0, 0 );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( isNaN( this.boundingBox.min.x ) || isNaN( this.boundingBox.min.y ) || isNaN( this.boundingBox.min.z ) ) {\r\n\r\n\t\t\t\tTHREE.error( 'THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The \"position\" attribute is likely to have NaN values.' );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}(),\r\n\r\n\tcomputeBoundingSphere: function () {\r\n\r\n\t\tvar box = new THREE.Box3();\r\n\t\tvar vector = new THREE.Vector3();\r\n\r\n\t\treturn function () {\r\n\r\n\t\t\tif ( this.boundingSphere === null ) {\r\n\r\n\t\t\t\tthis.boundingSphere = new THREE.Sphere();\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar positions = this.attributes.position.array;\r\n\r\n\t\t\tif ( positions ) {\r\n\r\n\t\t\t\tbox.makeEmpty();\r\n\r\n\t\t\t\tvar center = this.boundingSphere.center;\r\n\r\n\t\t\t\tfor ( var i = 0, il = positions.length; i < il; i += 3 ) {\r\n\r\n\t\t\t\t\tvector.set( positions[ i ], positions[ i + 1 ], positions[ i + 2 ] );\r\n\t\t\t\t\tbox.expandByPoint( vector );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tbox.center( center );\r\n\r\n\t\t\t\t// hoping to find a boundingSphere with a radius smaller than the\r\n\t\t\t\t// boundingSphere of the boundingBox:  sqrt(3) smaller in the best case\r\n\r\n\t\t\t\tvar maxRadiusSq = 0;\r\n\r\n\t\t\t\tfor ( var i = 0, il = positions.length; i < il; i += 3 ) {\r\n\r\n\t\t\t\t\tvector.set( positions[ i ], positions[ i + 1 ], positions[ i + 2 ] );\r\n\t\t\t\t\tmaxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( vector ) );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tthis.boundingSphere.radius = Math.sqrt( maxRadiusSq );\r\n\r\n\t\t\t\tif ( isNaN( this.boundingSphere.radius ) ) {\r\n\r\n\t\t\t\t\tTHREE.error( 'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The \"position\" attribute is likely to have NaN values.' );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}(),\r\n\r\n\tcomputeFaceNormals: function () {\r\n\r\n\t\t// backwards compatibility\r\n\r\n\t},\r\n\r\n\tcomputeVertexNormals: function () {\r\n\r\n\t\tvar attributes = this.attributes;\r\n\r\n\t\tif ( attributes.position ) {\r\n\r\n\t\t\tvar positions = attributes.position.array;\r\n\r\n\t\t\tif ( attributes.normal === undefined ) {\r\n\r\n\t\t\t\tthis.addAttribute( 'normal', new THREE.BufferAttribute( new Float32Array( positions.length ), 3 ) );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t// reset existing normals to zero\r\n\r\n\t\t\t\tvar normals = attributes.normal.array;\r\n\r\n\t\t\t\tfor ( var i = 0, il = normals.length; i < il; i ++ ) {\r\n\r\n\t\t\t\t\tnormals[ i ] = 0;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar normals = attributes.normal.array;\r\n\r\n\t\t\tvar vA, vB, vC,\r\n\r\n\t\t\tpA = new THREE.Vector3(),\r\n\t\t\tpB = new THREE.Vector3(),\r\n\t\t\tpC = new THREE.Vector3(),\r\n\r\n\t\t\tcb = new THREE.Vector3(),\r\n\t\t\tab = new THREE.Vector3();\r\n\r\n\t\t\t// indexed elements\r\n\r\n\t\t\tif ( attributes.index ) {\r\n\r\n\t\t\t\tvar indices = attributes.index.array;\r\n\r\n\t\t\t\tvar offsets = ( this.offsets.length > 0 ? this.offsets : [ { start: 0, count: indices.length, index: 0 } ] );\r\n\r\n\t\t\t\tfor ( var j = 0, jl = offsets.length; j < jl; ++ j ) {\r\n\r\n\t\t\t\t\tvar start = offsets[ j ].start;\r\n\t\t\t\t\tvar count = offsets[ j ].count;\r\n\t\t\t\t\tvar index = offsets[ j ].index;\r\n\r\n\t\t\t\t\tfor ( var i = start, il = start + count; i < il; i += 3 ) {\r\n\r\n\t\t\t\t\t\tvA = ( index + indices[ i     ] ) * 3;\r\n\t\t\t\t\t\tvB = ( index + indices[ i + 1 ] ) * 3;\r\n\t\t\t\t\t\tvC = ( index + indices[ i + 2 ] ) * 3;\r\n\r\n\t\t\t\t\t\tpA.fromArray( positions, vA );\r\n\t\t\t\t\t\tpB.fromArray( positions, vB );\r\n\t\t\t\t\t\tpC.fromArray( positions, vC );\r\n\r\n\t\t\t\t\t\tcb.subVectors( pC, pB );\r\n\t\t\t\t\t\tab.subVectors( pA, pB );\r\n\t\t\t\t\t\tcb.cross( ab );\r\n\r\n\t\t\t\t\t\tnormals[ vA     ] += cb.x;\r\n\t\t\t\t\t\tnormals[ vA + 1 ] += cb.y;\r\n\t\t\t\t\t\tnormals[ vA + 2 ] += cb.z;\r\n\r\n\t\t\t\t\t\tnormals[ vB     ] += cb.x;\r\n\t\t\t\t\t\tnormals[ vB + 1 ] += cb.y;\r\n\t\t\t\t\t\tnormals[ vB + 2 ] += cb.z;\r\n\r\n\t\t\t\t\t\tnormals[ vC     ] += cb.x;\r\n\t\t\t\t\t\tnormals[ vC + 1 ] += cb.y;\r\n\t\t\t\t\t\tnormals[ vC + 2 ] += cb.z;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t// non-indexed elements (unconnected triangle soup)\r\n\r\n\t\t\t\tfor ( var i = 0, il = positions.length; i < il; i += 9 ) {\r\n\r\n\t\t\t\t\tpA.fromArray( positions, i );\r\n\t\t\t\t\tpB.fromArray( positions, i + 3 );\r\n\t\t\t\t\tpC.fromArray( positions, i + 6 );\r\n\r\n\t\t\t\t\tcb.subVectors( pC, pB );\r\n\t\t\t\t\tab.subVectors( pA, pB );\r\n\t\t\t\t\tcb.cross( ab );\r\n\r\n\t\t\t\t\tnormals[ i     ] = cb.x;\r\n\t\t\t\t\tnormals[ i + 1 ] = cb.y;\r\n\t\t\t\t\tnormals[ i + 2 ] = cb.z;\r\n\r\n\t\t\t\t\tnormals[ i + 3 ] = cb.x;\r\n\t\t\t\t\tnormals[ i + 4 ] = cb.y;\r\n\t\t\t\t\tnormals[ i + 5 ] = cb.z;\r\n\r\n\t\t\t\t\tnormals[ i + 6 ] = cb.x;\r\n\t\t\t\t\tnormals[ i + 7 ] = cb.y;\r\n\t\t\t\t\tnormals[ i + 8 ] = cb.z;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis.normalizeNormals();\r\n\r\n\t\t\tattributes.normal.needsUpdate = true;\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tcomputeTangents: function () {\r\n\r\n\t\t// based on http://www.terathon.com/code/tangent.html\r\n\t\t// (per vertex tangents)\r\n\r\n\t\tif ( this.attributes.index === undefined ||\r\n\t\t\t this.attributes.position === undefined ||\r\n\t\t\t this.attributes.normal === undefined ||\r\n\t\t\t this.attributes.uv === undefined ) {\r\n\r\n\t\t\tTHREE.warn( 'THREE.BufferGeometry: Missing required attributes (index, position, normal or uv) in BufferGeometry.computeTangents()' );\r\n\t\t\treturn;\r\n\r\n\t\t}\r\n\r\n\t\tvar indices = this.attributes.index.array;\r\n\t\tvar positions = this.attributes.position.array;\r\n\t\tvar normals = this.attributes.normal.array;\r\n\t\tvar uvs = this.attributes.uv.array;\r\n\r\n\t\tvar nVertices = positions.length / 3;\r\n\r\n\t\tif ( this.attributes.tangent === undefined ) {\r\n\r\n\t\t\tthis.addAttribute( 'tangent', new THREE.BufferAttribute( new Float32Array( 4 * nVertices ), 4 ) );\r\n\r\n\t\t}\r\n\r\n\t\tvar tangents = this.attributes.tangent.array;\r\n\r\n\t\tvar tan1 = [], tan2 = [];\r\n\r\n\t\tfor ( var k = 0; k < nVertices; k ++ ) {\r\n\r\n\t\t\ttan1[ k ] = new THREE.Vector3();\r\n\t\t\ttan2[ k ] = new THREE.Vector3();\r\n\r\n\t\t}\r\n\r\n\t\tvar vA = new THREE.Vector3(),\r\n\t\t\tvB = new THREE.Vector3(),\r\n\t\t\tvC = new THREE.Vector3(),\r\n\r\n\t\t\tuvA = new THREE.Vector2(),\r\n\t\t\tuvB = new THREE.Vector2(),\r\n\t\t\tuvC = new THREE.Vector2(),\r\n\r\n\t\t\tx1, x2, y1, y2, z1, z2,\r\n\t\t\ts1, s2, t1, t2, r;\r\n\r\n\t\tvar sdir = new THREE.Vector3(), tdir = new THREE.Vector3();\r\n\r\n\t\tfunction handleTriangle( a, b, c ) {\r\n\r\n\t\t\tvA.fromArray( positions, a * 3 );\r\n\t\t\tvB.fromArray( positions, b * 3 );\r\n\t\t\tvC.fromArray( positions, c * 3 );\r\n\r\n\t\t\tuvA.fromArray( uvs, a * 2 );\r\n\t\t\tuvB.fromArray( uvs, b * 2 );\r\n\t\t\tuvC.fromArray( uvs, c * 2 );\r\n\r\n\t\t\tx1 = vB.x - vA.x;\r\n\t\t\tx2 = vC.x - vA.x;\r\n\r\n\t\t\ty1 = vB.y - vA.y;\r\n\t\t\ty2 = vC.y - vA.y;\r\n\r\n\t\t\tz1 = vB.z - vA.z;\r\n\t\t\tz2 = vC.z - vA.z;\r\n\r\n\t\t\ts1 = uvB.x - uvA.x;\r\n\t\t\ts2 = uvC.x - uvA.x;\r\n\r\n\t\t\tt1 = uvB.y - uvA.y;\r\n\t\t\tt2 = uvC.y - uvA.y;\r\n\r\n\t\t\tr = 1.0 / ( s1 * t2 - s2 * t1 );\r\n\r\n\t\t\tsdir.set(\r\n\t\t\t\t( t2 * x1 - t1 * x2 ) * r,\r\n\t\t\t\t( t2 * y1 - t1 * y2 ) * r,\r\n\t\t\t\t( t2 * z1 - t1 * z2 ) * r\r\n\t\t\t);\r\n\r\n\t\t\ttdir.set(\r\n\t\t\t\t( s1 * x2 - s2 * x1 ) * r,\r\n\t\t\t\t( s1 * y2 - s2 * y1 ) * r,\r\n\t\t\t\t( s1 * z2 - s2 * z1 ) * r\r\n\t\t\t);\r\n\r\n\t\t\ttan1[ a ].add( sdir );\r\n\t\t\ttan1[ b ].add( sdir );\r\n\t\t\ttan1[ c ].add( sdir );\r\n\r\n\t\t\ttan2[ a ].add( tdir );\r\n\t\t\ttan2[ b ].add( tdir );\r\n\t\t\ttan2[ c ].add( tdir );\r\n\r\n\t\t}\r\n\r\n\t\tvar i, il;\r\n\t\tvar j, jl;\r\n\t\tvar iA, iB, iC;\r\n\r\n\t\tif ( this.drawcalls.length === 0 ) {\r\n\r\n\t\t\tthis.addDrawCall( 0, indices.length, 0 );\r\n\r\n\t\t}\r\n\r\n\t\tvar drawcalls = this.drawcalls;\r\n\r\n\t\tfor ( j = 0, jl = drawcalls.length; j < jl; ++ j ) {\r\n\r\n\t\t\tvar start = drawcalls[ j ].start;\r\n\t\t\tvar count = drawcalls[ j ].count;\r\n\t\t\tvar index = drawcalls[ j ].index;\r\n\r\n\t\t\tfor ( i = start, il = start + count; i < il; i += 3 ) {\r\n\r\n\t\t\t\tiA = index + indices[ i ];\r\n\t\t\t\tiB = index + indices[ i + 1 ];\r\n\t\t\t\tiC = index + indices[ i + 2 ];\r\n\r\n\t\t\t\thandleTriangle( iA, iB, iC );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tvar tmp = new THREE.Vector3(), tmp2 = new THREE.Vector3();\r\n\t\tvar n = new THREE.Vector3(), n2 = new THREE.Vector3();\r\n\t\tvar w, t, test;\r\n\r\n\t\tfunction handleVertex( v ) {\r\n\r\n\t\t\tn.fromArray( normals, v * 3 );\r\n\t\t\tn2.copy( n );\r\n\r\n\t\t\tt = tan1[ v ];\r\n\r\n\t\t\t// Gram-Schmidt orthogonalize\r\n\r\n\t\t\ttmp.copy( t );\r\n\t\t\ttmp.sub( n.multiplyScalar( n.dot( t ) ) ).normalize();\r\n\r\n\t\t\t// Calculate handedness\r\n\r\n\t\t\ttmp2.crossVectors( n2, t );\r\n\t\t\ttest = tmp2.dot( tan2[ v ] );\r\n\t\t\tw = ( test < 0.0 ) ? - 1.0 : 1.0;\r\n\r\n\t\t\ttangents[ v * 4     ] = tmp.x;\r\n\t\t\ttangents[ v * 4 + 1 ] = tmp.y;\r\n\t\t\ttangents[ v * 4 + 2 ] = tmp.z;\r\n\t\t\ttangents[ v * 4 + 3 ] = w;\r\n\r\n\t\t}\r\n\r\n\t\tfor ( j = 0, jl = drawcalls.length; j < jl; ++ j ) {\r\n\r\n\t\t\tvar start = drawcalls[ j ].start;\r\n\t\t\tvar count = drawcalls[ j ].count;\r\n\t\t\tvar index = drawcalls[ j ].index;\r\n\r\n\t\t\tfor ( i = start, il = start + count; i < il; i += 3 ) {\r\n\r\n\t\t\t\tiA = index + indices[ i ];\r\n\t\t\t\tiB = index + indices[ i + 1 ];\r\n\t\t\t\tiC = index + indices[ i + 2 ];\r\n\r\n\t\t\t\thandleVertex( iA );\r\n\t\t\t\thandleVertex( iB );\r\n\t\t\t\thandleVertex( iC );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\t/*\r\n\tCompute the draw offset for large models by chunking the index buffer into chunks of 65k addressable vertices.\r\n\tThis method will effectively rewrite the index buffer and remap all attributes to match the new indices.\r\n\tWARNING: This method will also expand the vertex count to prevent sprawled triangles across draw offsets.\r\n\tsize - Defaults to 65535, but allows for larger or smaller chunks.\r\n\t*/\r\n\tcomputeOffsets: function ( size ) {\r\n\r\n\t\tif ( size === undefined ) size = 65535; // WebGL limits type of index buffer values to 16-bit.\r\n\r\n\t\tvar indices = this.attributes.index.array;\r\n\t\tvar vertices = this.attributes.position.array;\r\n\r\n\t\tvar facesCount = ( indices.length / 3 );\r\n\r\n\t\t/*\r\n\t\tconsole.log(\"Computing buffers in offsets of \"+size+\" -> indices:\"+indices.length+\" vertices:\"+vertices.length);\r\n\t\tconsole.log(\"Faces to process: \"+(indices.length/3));\r\n\t\tconsole.log(\"Reordering \"+verticesCount+\" vertices.\");\r\n\t\t*/\r\n\r\n\t\tvar sortedIndices = new Uint16Array( indices.length ); //16-bit buffers\r\n\t\tvar indexPtr = 0;\r\n\t\tvar vertexPtr = 0;\r\n\r\n\t\tvar offsets = [ { start:0, count:0, index:0 } ];\r\n\t\tvar offset = offsets[ 0 ];\r\n\r\n\t\tvar duplicatedVertices = 0;\r\n\t\tvar newVerticeMaps = 0;\r\n\t\tvar faceVertices = new Int32Array( 6 );\r\n\t\tvar vertexMap = new Int32Array( vertices.length );\r\n\t\tvar revVertexMap = new Int32Array( vertices.length );\r\n\t\tfor ( var j = 0; j < vertices.length; j ++ ) { vertexMap[ j ] = - 1; revVertexMap[ j ] = - 1; }\r\n\r\n\t\t/*\r\n\t\t\tTraverse every face and reorder vertices in the proper offsets of 65k.\r\n\t\t\tWe can have more than 65k entries in the index buffer per offset, but only reference 65k values.\r\n\t\t*/\r\n\t\tfor ( var findex = 0; findex < facesCount; findex ++ ) {\r\n\t\t\tnewVerticeMaps = 0;\r\n\r\n\t\t\tfor ( var vo = 0; vo < 3; vo ++ ) {\r\n\t\t\t\tvar vid = indices[ findex * 3 + vo ];\r\n\t\t\t\tif ( vertexMap[ vid ] == - 1 ) {\r\n\t\t\t\t\t//Unmapped vertice\r\n\t\t\t\t\tfaceVertices[ vo * 2 ] = vid;\r\n\t\t\t\t\tfaceVertices[ vo * 2 + 1 ] = - 1;\r\n\t\t\t\t\tnewVerticeMaps ++;\r\n\t\t\t\t} else if ( vertexMap[ vid ] < offset.index ) {\r\n\t\t\t\t\t//Reused vertices from previous block (duplicate)\r\n\t\t\t\t\tfaceVertices[ vo * 2 ] = vid;\r\n\t\t\t\t\tfaceVertices[ vo * 2 + 1 ] = - 1;\r\n\t\t\t\t\tduplicatedVertices ++;\r\n\t\t\t\t} else {\r\n\t\t\t\t\t//Reused vertice in the current block\r\n\t\t\t\t\tfaceVertices[ vo * 2 ] = vid;\r\n\t\t\t\t\tfaceVertices[ vo * 2 + 1 ] = vertexMap[ vid ];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tvar faceMax = vertexPtr + newVerticeMaps;\r\n\t\t\tif ( faceMax > ( offset.index + size ) ) {\r\n\t\t\t\tvar new_offset = { start:indexPtr, count:0, index:vertexPtr };\r\n\t\t\t\toffsets.push( new_offset );\r\n\t\t\t\toffset = new_offset;\r\n\r\n\t\t\t\t//Re-evaluate reused vertices in light of new offset.\r\n\t\t\t\tfor ( var v = 0; v < 6; v += 2 ) {\r\n\t\t\t\t\tvar new_vid = faceVertices[ v + 1 ];\r\n\t\t\t\t\tif ( new_vid > - 1 && new_vid < offset.index )\r\n\t\t\t\t\t\tfaceVertices[ v + 1 ] = - 1;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t//Reindex the face.\r\n\t\t\tfor ( var v = 0; v < 6; v += 2 ) {\r\n\t\t\t\tvar vid = faceVertices[ v ];\r\n\t\t\t\tvar new_vid = faceVertices[ v + 1 ];\r\n\r\n\t\t\t\tif ( new_vid === - 1 )\r\n\t\t\t\t\tnew_vid = vertexPtr ++;\r\n\r\n\t\t\t\tvertexMap[ vid ] = new_vid;\r\n\t\t\t\trevVertexMap[ new_vid ] = vid;\r\n\t\t\t\tsortedIndices[ indexPtr ++ ] = new_vid - offset.index; //XXX overflows at 16bit\r\n\t\t\t\toffset.count ++;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t/* Move all attribute values to map to the new computed indices , also expand the vertice stack to match our new vertexPtr. */\r\n\t\tthis.reorderBuffers( sortedIndices, revVertexMap, vertexPtr );\r\n\t\tthis.offsets = offsets; // TODO: Deprecate\r\n\t\tthis.drawcalls = offsets;\r\n\r\n\t\t/*\r\n\t\tvar orderTime = Date.now();\r\n\t\tconsole.log(\"Reorder time: \"+(orderTime-s)+\"ms\");\r\n\t\tconsole.log(\"Duplicated \"+duplicatedVertices+\" vertices.\");\r\n\t\tconsole.log(\"Compute Buffers time: \"+(Date.now()-s)+\"ms\");\r\n\t\tconsole.log(\"Draw offsets: \"+offsets.length);\r\n\t\t*/\r\n\r\n\t\treturn offsets;\r\n\r\n\t},\r\n\r\n\tmerge: function ( geometry, offset ) {\r\n\r\n\t\tif ( geometry instanceof THREE.BufferGeometry === false ) {\r\n\r\n\t\t\tTHREE.error( 'THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.', geometry );\r\n\t\t\treturn;\r\n\r\n\t\t}\r\n\r\n\t\tif ( offset === undefined ) offset = 0;\r\n\r\n\t\tvar attributes = this.attributes;\r\n\r\n\t\tfor ( var key in attributes ) {\r\n\r\n\t\t\tif ( geometry.attributes[ key ] === undefined ) continue;\r\n\r\n\t\t\tvar attribute1 = attributes[ key ];\r\n\t\t\tvar attributeArray1 = attribute1.array;\r\n\r\n\t\t\tvar attribute2 = geometry.attributes[ key ];\r\n\t\t\tvar attributeArray2 = attribute2.array;\r\n\r\n\t\t\tvar attributeSize = attribute2.itemSize;\r\n\r\n\t\t\tfor ( var i = 0, j = attributeSize * offset; i < attributeArray2.length; i ++, j ++ ) {\r\n\r\n\t\t\t\tattributeArray1[ j ] = attributeArray2[ i ];\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tnormalizeNormals: function () {\r\n\r\n\t\tvar normals = this.attributes.normal.array;\r\n\r\n\t\tvar x, y, z, n;\r\n\r\n\t\tfor ( var i = 0, il = normals.length; i < il; i += 3 ) {\r\n\r\n\t\t\tx = normals[ i ];\r\n\t\t\ty = normals[ i + 1 ];\r\n\t\t\tz = normals[ i + 2 ];\r\n\r\n\t\t\tn = 1.0 / Math.sqrt( x * x + y * y + z * z );\r\n\r\n\t\t\tnormals[ i     ] *= n;\r\n\t\t\tnormals[ i + 1 ] *= n;\r\n\t\t\tnormals[ i + 2 ] *= n;\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\t/*\r\n\t\treoderBuffers:\r\n\t\tReorder attributes based on a new indexBuffer and indexMap.\r\n\t\tindexBuffer - Uint16Array of the new ordered indices.\r\n\t\tindexMap - Int32Array where the position is the new vertex ID and the value the old vertex ID for each vertex.\r\n\t\tvertexCount - Amount of total vertices considered in this reordering (in case you want to grow the vertice stack).\r\n\t*/\r\n\treorderBuffers: function ( indexBuffer, indexMap, vertexCount ) {\r\n\r\n\t\t/* Create a copy of all attributes for reordering. */\r\n\t\tvar sortedAttributes = {};\r\n\t\tfor ( var attr in this.attributes ) {\r\n\t\t\tif ( attr == 'index' )\r\n\t\t\t\tcontinue;\r\n\t\t\tvar sourceArray = this.attributes[ attr ].array;\r\n\t\t\tsortedAttributes[ attr ] = new sourceArray.constructor( this.attributes[ attr ].itemSize * vertexCount );\r\n\t\t}\r\n\r\n\t\t/* Move attribute positions based on the new index map */\r\n\t\tfor ( var new_vid = 0; new_vid < vertexCount; new_vid ++ ) {\r\n\t\t\tvar vid = indexMap[ new_vid ];\r\n\t\t\tfor ( var attr in this.attributes ) {\r\n\t\t\t\tif ( attr == 'index' )\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\tvar attrArray = this.attributes[ attr ].array;\r\n\t\t\t\tvar attrSize = this.attributes[ attr ].itemSize;\r\n\t\t\t\tvar sortedAttr = sortedAttributes[ attr ];\r\n\t\t\t\tfor ( var k = 0; k < attrSize; k ++ )\r\n\t\t\t\t\tsortedAttr[ new_vid * attrSize + k ] = attrArray[ vid * attrSize + k ];\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t/* Carry the new sorted buffers locally */\r\n\t\tthis.attributes[ 'index' ].array = indexBuffer;\r\n\t\tfor ( var attr in this.attributes ) {\r\n\t\t\tif ( attr == 'index' )\r\n\t\t\t\tcontinue;\r\n\t\t\tthis.attributes[ attr ].array = sortedAttributes[ attr ];\r\n\t\t\tthis.attributes[ attr ].numItems = this.attributes[ attr ].itemSize * vertexCount;\r\n\t\t}\r\n\t},\r\n\r\n\ttoJSON: function () {\r\n\r\n\t\tvar output = {\r\n\t\t\tmetadata: {\r\n\t\t\t\tversion: 4.0,\r\n\t\t\t\ttype: 'BufferGeometry',\r\n\t\t\t\tgenerator: 'BufferGeometryExporter'\r\n\t\t\t},\r\n\t\t\tuuid: this.uuid,\r\n\t\t\ttype: this.type,\r\n\t\t\tdata: {\r\n\t\t\t\tattributes: {}\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\tvar attributes = this.attributes;\r\n\t\tvar offsets = this.offsets;\r\n\t\tvar boundingSphere = this.boundingSphere;\r\n\r\n\t\tfor ( var key in attributes ) {\r\n\r\n\t\t\tvar attribute = attributes[ key ];\r\n\r\n\t\t\tvar array = Array.prototype.slice.call( attribute.array );\r\n\r\n\t\t\toutput.data.attributes[ key ] = {\r\n\t\t\t\titemSize: attribute.itemSize,\r\n\t\t\t\ttype: attribute.array.constructor.name,\r\n\t\t\t\tarray: array\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( offsets.length > 0 ) {\r\n\r\n\t\t\toutput.data.offsets = JSON.parse( JSON.stringify( offsets ) );\r\n\r\n\t\t}\r\n\r\n\t\tif ( boundingSphere !== null ) {\r\n\r\n\t\t\toutput.data.boundingSphere = {\r\n\t\t\t\tcenter: boundingSphere.center.toArray(),\r\n\t\t\t\tradius: boundingSphere.radius\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn output;\r\n\r\n\t},\r\n\r\n\tclone: function () {\r\n\r\n\t\tvar geometry = new THREE.BufferGeometry();\r\n\r\n\t\tfor ( var attr in this.attributes ) {\r\n\r\n\t\t\tvar sourceAttr = this.attributes[ attr ];\r\n\t\t\tgeometry.addAttribute( attr, sourceAttr.clone() );\r\n\r\n\t\t}\r\n\r\n\t\tfor ( var i = 0, il = this.offsets.length; i < il; i ++ ) {\r\n\r\n\t\t\tvar offset = this.offsets[ i ];\r\n\r\n\t\t\tgeometry.offsets.push( {\r\n\r\n\t\t\t\tstart: offset.start,\r\n\t\t\t\tindex: offset.index,\r\n\t\t\t\tcount: offset.count\r\n\r\n\t\t\t} );\r\n\r\n\t\t}\r\n\r\n\t\treturn geometry;\r\n\r\n\t},\r\n\r\n\tdispose: function () {\r\n\r\n\t\tthis.dispatchEvent( { type: 'dispose' } );\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.EventDispatcher.prototype.apply( THREE.BufferGeometry.prototype );\r\n\r\n// File:src/core/Geometry.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author kile / http://kile.stravaganza.org/\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author zz85 / http://www.lab4games.net/zz85/blog\r\n * @author bhouston / http://exocortex.com\r\n */\r\n\r\nTHREE.Geometry = function () {\r\n\r\n\tObject.defineProperty( this, 'id', { value: THREE.GeometryIdCount ++ } );\r\n\r\n\tthis.uuid = THREE.Math.generateUUID();\r\n\r\n\tthis.name = '';\r\n\tthis.type = 'Geometry';\r\n\r\n\tthis.vertices = [];\r\n\tthis.colors = [];  // one-to-one vertex colors, used in Points and Line\r\n\r\n\tthis.faces = [];\r\n\r\n\tthis.faceVertexUvs = [ [] ];\r\n\r\n\tthis.morphTargets = [];\r\n\tthis.morphColors = [];\r\n\tthis.morphNormals = [];\r\n\r\n\tthis.skinWeights = [];\r\n\tthis.skinIndices = [];\r\n\r\n\tthis.lineDistances = [];\r\n\r\n\tthis.boundingBox = null;\r\n\tthis.boundingSphere = null;\r\n\r\n\tthis.hasTangents = false;\r\n\r\n\tthis.dynamic = true; // the intermediate typed arrays will be deleted when set to false\r\n\r\n\t// update flags\r\n\r\n\tthis.verticesNeedUpdate = false;\r\n\tthis.elementsNeedUpdate = false;\r\n\tthis.uvsNeedUpdate = false;\r\n\tthis.normalsNeedUpdate = false;\r\n\tthis.tangentsNeedUpdate = false;\r\n\tthis.colorsNeedUpdate = false;\r\n\tthis.lineDistancesNeedUpdate = false;\r\n\r\n\tthis.groupsNeedUpdate = false;\r\n\r\n};\r\n\r\nTHREE.Geometry.prototype = {\r\n\r\n\tconstructor: THREE.Geometry,\r\n\r\n\tapplyMatrix: function ( matrix ) {\r\n\r\n\t\tvar normalMatrix = new THREE.Matrix3().getNormalMatrix( matrix );\r\n\r\n\t\tfor ( var i = 0, il = this.vertices.length; i < il; i ++ ) {\r\n\r\n\t\t\tvar vertex = this.vertices[ i ];\r\n\t\t\tvertex.applyMatrix4( matrix );\r\n\r\n\t\t}\r\n\r\n\t\tfor ( var i = 0, il = this.faces.length; i < il; i ++ ) {\r\n\r\n\t\t\tvar face = this.faces[ i ];\r\n\t\t\tface.normal.applyMatrix3( normalMatrix ).normalize();\r\n\r\n\t\t\tfor ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {\r\n\r\n\t\t\t\tface.vertexNormals[ j ].applyMatrix3( normalMatrix ).normalize();\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.boundingBox !== null ) {\r\n\r\n\t\t\tthis.computeBoundingBox();\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.boundingSphere !== null ) {\r\n\r\n\t\t\tthis.computeBoundingSphere();\r\n\r\n\t\t}\r\n\r\n\t\tthis.verticesNeedUpdate = true;\r\n\t\tthis.normalsNeedUpdate = true;\r\n\r\n\t},\r\n\r\n\tfromBufferGeometry: function ( geometry ) {\r\n\r\n\t\tvar scope = this;\r\n\r\n\t\tvar attributes = geometry.attributes;\r\n\r\n\t\tvar vertices = attributes.position.array;\r\n\t\tvar indices = attributes.index !== undefined ? attributes.index.array : undefined;\r\n\t\tvar normals = attributes.normal !== undefined ? attributes.normal.array : undefined;\r\n\t\tvar colors = attributes.color !== undefined ? attributes.color.array : undefined;\r\n\t\tvar uvs = attributes.uv !== undefined ? attributes.uv.array : undefined;\r\n\r\n\t\tvar tempNormals = [];\r\n\t\tvar tempUVs = [];\r\n\r\n\t\tfor ( var i = 0, j = 0; i < vertices.length; i += 3, j += 2 ) {\r\n\r\n\t\t\tscope.vertices.push( new THREE.Vector3( vertices[ i ], vertices[ i + 1 ], vertices[ i + 2 ] ) );\r\n\r\n\t\t\tif ( normals !== undefined ) {\r\n\r\n\t\t\t\ttempNormals.push( new THREE.Vector3( normals[ i ], normals[ i + 1 ], normals[ i + 2 ] ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( colors !== undefined ) {\r\n\r\n\t\t\t\tscope.colors.push( new THREE.Color( colors[ i ], colors[ i + 1 ], colors[ i + 2 ] ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( uvs !== undefined ) {\r\n\r\n\t\t\t\ttempUVs.push( new THREE.Vector2( uvs[ j ], uvs[ j + 1 ] ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tvar addFace = function ( a, b, c ) {\r\n\r\n\t\t\tvar vertexNormals = normals !== undefined ? [ tempNormals[ a ].clone(), tempNormals[ b ].clone(), tempNormals[ c ].clone() ] : [];\r\n\t\t\tvar vertexColors = colors !== undefined ? [ scope.colors[ a ].clone(), scope.colors[ b ].clone(), scope.colors[ c ].clone() ] : [];\r\n\r\n\t\t\tscope.faces.push( new THREE.Face3( a, b, c, vertexNormals, vertexColors ) );\r\n\r\n\t\t\tif ( uvs !== undefined ) {\r\n\r\n\t\t\t\tscope.faceVertexUvs[ 0 ].push( [ tempUVs[ a ].clone(), tempUVs[ b ].clone(), tempUVs[ c ].clone() ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t};\r\n\r\n\t\tif ( indices !== undefined ) {\r\n\r\n\t\t\tvar drawcalls = geometry.drawcalls;\r\n\r\n\t\t\tif ( drawcalls.length > 0 ) {\r\n\r\n\t\t\t\tfor ( var i = 0; i < drawcalls.length; i ++ ) {\r\n\r\n\t\t\t\t\tvar drawcall = drawcalls[ i ];\r\n\r\n\t\t\t\t\tvar start = drawcall.start;\r\n\t\t\t\t\tvar count = drawcall.count;\r\n\t\t\t\t\tvar index = drawcall.index;\r\n\r\n\t\t\t\t\tfor ( var j = start, jl = start + count; j < jl; j += 3 ) {\r\n\r\n\t\t\t\t\t\taddFace( index + indices[ j ], index + indices[ j + 1 ], index + indices[ j + 2 ] );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tfor ( var i = 0; i < indices.length; i += 3 ) {\r\n\r\n\t\t\t\t\taddFace( indices[ i ], indices[ i + 1 ], indices[ i + 2 ] );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\tfor ( var i = 0; i < vertices.length / 3; i += 3 ) {\r\n\r\n\t\t\t\taddFace( i, i + 1, i + 2 );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tthis.computeFaceNormals();\r\n\r\n\t\tif ( geometry.boundingBox !== null ) {\r\n\r\n\t\t\tthis.boundingBox = geometry.boundingBox.clone();\r\n\r\n\t\t}\r\n\r\n\t\tif ( geometry.boundingSphere !== null ) {\r\n\r\n\t\t\tthis.boundingSphere = geometry.boundingSphere.clone();\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tcenter: function () {\r\n\r\n\t\tthis.computeBoundingBox();\r\n\r\n\t\tvar offset = this.boundingBox.center().negate();\r\n\r\n\t\tthis.applyMatrix( new THREE.Matrix4().setPosition( offset ) );\r\n\r\n\t\treturn offset;\r\n\r\n\t},\r\n\r\n\tcomputeFaceNormals: function () {\r\n\r\n\t\tvar cb = new THREE.Vector3(), ab = new THREE.Vector3();\r\n\r\n\t\tfor ( var f = 0, fl = this.faces.length; f < fl; f ++ ) {\r\n\r\n\t\t\tvar face = this.faces[ f ];\r\n\r\n\t\t\tvar vA = this.vertices[ face.a ];\r\n\t\t\tvar vB = this.vertices[ face.b ];\r\n\t\t\tvar vC = this.vertices[ face.c ];\r\n\r\n\t\t\tcb.subVectors( vC, vB );\r\n\t\t\tab.subVectors( vA, vB );\r\n\t\t\tcb.cross( ab );\r\n\r\n\t\t\tcb.normalize();\r\n\r\n\t\t\tface.normal.copy( cb );\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tcomputeVertexNormals: function ( areaWeighted ) {\r\n\r\n\t\tvar v, vl, f, fl, face, vertices;\r\n\r\n\t\tvertices = new Array( this.vertices.length );\r\n\r\n\t\tfor ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {\r\n\r\n\t\t\tvertices[ v ] = new THREE.Vector3();\r\n\r\n\t\t}\r\n\r\n\t\tif ( areaWeighted ) {\r\n\r\n\t\t\t// vertex normals weighted by triangle areas\r\n\t\t\t// http://www.iquilezles.org/www/articles/normals/normals.htm\r\n\r\n\t\t\tvar vA, vB, vC;\r\n\t\t\tvar cb = new THREE.Vector3(), ab = new THREE.Vector3();\r\n\r\n\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\r\n\r\n\t\t\t\tface = this.faces[ f ];\r\n\r\n\t\t\t\tvA = this.vertices[ face.a ];\r\n\t\t\t\tvB = this.vertices[ face.b ];\r\n\t\t\t\tvC = this.vertices[ face.c ];\r\n\r\n\t\t\t\tcb.subVectors( vC, vB );\r\n\t\t\t\tab.subVectors( vA, vB );\r\n\t\t\t\tcb.cross( ab );\r\n\r\n\t\t\t\tvertices[ face.a ].add( cb );\r\n\t\t\t\tvertices[ face.b ].add( cb );\r\n\t\t\t\tvertices[ face.c ].add( cb );\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\r\n\r\n\t\t\t\tface = this.faces[ f ];\r\n\r\n\t\t\t\tvertices[ face.a ].add( face.normal );\r\n\t\t\t\tvertices[ face.b ].add( face.normal );\r\n\t\t\t\tvertices[ face.c ].add( face.normal );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tfor ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {\r\n\r\n\t\t\tvertices[ v ].normalize();\r\n\r\n\t\t}\r\n\r\n\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\r\n\r\n\t\t\tface = this.faces[ f ];\r\n\r\n\t\t\tface.vertexNormals[ 0 ] = vertices[ face.a ].clone();\r\n\t\t\tface.vertexNormals[ 1 ] = vertices[ face.b ].clone();\r\n\t\t\tface.vertexNormals[ 2 ] = vertices[ face.c ].clone();\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tcomputeMorphNormals: function () {\r\n\r\n\t\tvar i, il, f, fl, face;\r\n\r\n\t\t// save original normals\r\n\t\t// - create temp variables on first access\r\n\t\t//   otherwise just copy (for faster repeated calls)\r\n\r\n\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\r\n\r\n\t\t\tface = this.faces[ f ];\r\n\r\n\t\t\tif ( ! face.__originalFaceNormal ) {\r\n\r\n\t\t\t\tface.__originalFaceNormal = face.normal.clone();\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tface.__originalFaceNormal.copy( face.normal );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( ! face.__originalVertexNormals ) face.__originalVertexNormals = [];\r\n\r\n\t\t\tfor ( i = 0, il = face.vertexNormals.length; i < il; i ++ ) {\r\n\r\n\t\t\t\tif ( ! face.__originalVertexNormals[ i ] ) {\r\n\r\n\t\t\t\t\tface.__originalVertexNormals[ i ] = face.vertexNormals[ i ].clone();\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tface.__originalVertexNormals[ i ].copy( face.vertexNormals[ i ] );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// use temp geometry to compute face and vertex normals for each morph\r\n\r\n\t\tvar tmpGeo = new THREE.Geometry();\r\n\t\ttmpGeo.faces = this.faces;\r\n\r\n\t\tfor ( i = 0, il = this.morphTargets.length; i < il; i ++ ) {\r\n\r\n\t\t\t// create on first access\r\n\r\n\t\t\tif ( ! this.morphNormals[ i ] ) {\r\n\r\n\t\t\t\tthis.morphNormals[ i ] = {};\r\n\t\t\t\tthis.morphNormals[ i ].faceNormals = [];\r\n\t\t\t\tthis.morphNormals[ i ].vertexNormals = [];\r\n\r\n\t\t\t\tvar dstNormalsFace = this.morphNormals[ i ].faceNormals;\r\n\t\t\t\tvar dstNormalsVertex = this.morphNormals[ i ].vertexNormals;\r\n\r\n\t\t\t\tvar faceNormal, vertexNormals;\r\n\r\n\t\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\r\n\r\n\t\t\t\t\tfaceNormal = new THREE.Vector3();\r\n\t\t\t\t\tvertexNormals = { a: new THREE.Vector3(), b: new THREE.Vector3(), c: new THREE.Vector3() };\r\n\r\n\t\t\t\t\tdstNormalsFace.push( faceNormal );\r\n\t\t\t\t\tdstNormalsVertex.push( vertexNormals );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar morphNormals = this.morphNormals[ i ];\r\n\r\n\t\t\t// set vertices to morph target\r\n\r\n\t\t\ttmpGeo.vertices = this.morphTargets[ i ].vertices;\r\n\r\n\t\t\t// compute morph normals\r\n\r\n\t\t\ttmpGeo.computeFaceNormals();\r\n\t\t\ttmpGeo.computeVertexNormals();\r\n\r\n\t\t\t// store morph normals\r\n\r\n\t\t\tvar faceNormal, vertexNormals;\r\n\r\n\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\r\n\r\n\t\t\t\tface = this.faces[ f ];\r\n\r\n\t\t\t\tfaceNormal = morphNormals.faceNormals[ f ];\r\n\t\t\t\tvertexNormals = morphNormals.vertexNormals[ f ];\r\n\r\n\t\t\t\tfaceNormal.copy( face.normal );\r\n\r\n\t\t\t\tvertexNormals.a.copy( face.vertexNormals[ 0 ] );\r\n\t\t\t\tvertexNormals.b.copy( face.vertexNormals[ 1 ] );\r\n\t\t\t\tvertexNormals.c.copy( face.vertexNormals[ 2 ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// restore original normals\r\n\r\n\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\r\n\r\n\t\t\tface = this.faces[ f ];\r\n\r\n\t\t\tface.normal = face.__originalFaceNormal;\r\n\t\t\tface.vertexNormals = face.__originalVertexNormals;\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tcomputeTangents: function () {\r\n\r\n\t\t// based on http://www.terathon.com/code/tangent.html\r\n\t\t// tangents go to vertices\r\n\r\n\t\tvar f, fl, v, vl, i, vertexIndex,\r\n\t\t\tface, uv, vA, vB, vC, uvA, uvB, uvC,\r\n\t\t\tx1, x2, y1, y2, z1, z2,\r\n\t\t\ts1, s2, t1, t2, r, t, test,\r\n\t\t\ttan1 = [], tan2 = [],\r\n\t\t\tsdir = new THREE.Vector3(), tdir = new THREE.Vector3(),\r\n\t\t\ttmp = new THREE.Vector3(), tmp2 = new THREE.Vector3(),\r\n\t\t\tn = new THREE.Vector3(), w;\r\n\r\n\t\tfor ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {\r\n\r\n\t\t\ttan1[ v ] = new THREE.Vector3();\r\n\t\t\ttan2[ v ] = new THREE.Vector3();\r\n\r\n\t\t}\r\n\r\n\t\tfunction handleTriangle( context, a, b, c, ua, ub, uc ) {\r\n\r\n\t\t\tvA = context.vertices[ a ];\r\n\t\t\tvB = context.vertices[ b ];\r\n\t\t\tvC = context.vertices[ c ];\r\n\r\n\t\t\tuvA = uv[ ua ];\r\n\t\t\tuvB = uv[ ub ];\r\n\t\t\tuvC = uv[ uc ];\r\n\r\n\t\t\tx1 = vB.x - vA.x;\r\n\t\t\tx2 = vC.x - vA.x;\r\n\t\t\ty1 = vB.y - vA.y;\r\n\t\t\ty2 = vC.y - vA.y;\r\n\t\t\tz1 = vB.z - vA.z;\r\n\t\t\tz2 = vC.z - vA.z;\r\n\r\n\t\t\ts1 = uvB.x - uvA.x;\r\n\t\t\ts2 = uvC.x - uvA.x;\r\n\t\t\tt1 = uvB.y - uvA.y;\r\n\t\t\tt2 = uvC.y - uvA.y;\r\n\r\n\t\t\tr = 1.0 / ( s1 * t2 - s2 * t1 );\r\n\t\t\tsdir.set( ( t2 * x1 - t1 * x2 ) * r,\r\n\t\t\t\t\t  ( t2 * y1 - t1 * y2 ) * r,\r\n\t\t\t\t\t  ( t2 * z1 - t1 * z2 ) * r );\r\n\t\t\ttdir.set( ( s1 * x2 - s2 * x1 ) * r,\r\n\t\t\t\t\t  ( s1 * y2 - s2 * y1 ) * r,\r\n\t\t\t\t\t  ( s1 * z2 - s2 * z1 ) * r );\r\n\r\n\t\t\ttan1[ a ].add( sdir );\r\n\t\t\ttan1[ b ].add( sdir );\r\n\t\t\ttan1[ c ].add( sdir );\r\n\r\n\t\t\ttan2[ a ].add( tdir );\r\n\t\t\ttan2[ b ].add( tdir );\r\n\t\t\ttan2[ c ].add( tdir );\r\n\r\n\t\t}\r\n\r\n\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\r\n\r\n\t\t\tface = this.faces[ f ];\r\n\t\t\tuv = this.faceVertexUvs[ 0 ][ f ]; // use UV layer 0 for tangents\r\n\r\n\t\t\thandleTriangle( this, face.a, face.b, face.c, 0, 1, 2 );\r\n\r\n\t\t}\r\n\r\n\t\tvar faceIndex = [ 'a', 'b', 'c', 'd' ];\r\n\r\n\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\r\n\r\n\t\t\tface = this.faces[ f ];\r\n\r\n\t\t\tfor ( i = 0; i < Math.min( face.vertexNormals.length, 3 ); i ++ ) {\r\n\r\n\t\t\t\tn.copy( face.vertexNormals[ i ] );\r\n\r\n\t\t\t\tvertexIndex = face[ faceIndex[ i ] ];\r\n\r\n\t\t\t\tt = tan1[ vertexIndex ];\r\n\r\n\t\t\t\t// Gram-Schmidt orthogonalize\r\n\r\n\t\t\t\ttmp.copy( t );\r\n\t\t\t\ttmp.sub( n.multiplyScalar( n.dot( t ) ) ).normalize();\r\n\r\n\t\t\t\t// Calculate handedness\r\n\r\n\t\t\t\ttmp2.crossVectors( face.vertexNormals[ i ], t );\r\n\t\t\t\ttest = tmp2.dot( tan2[ vertexIndex ] );\r\n\t\t\t\tw = ( test < 0.0 ) ? - 1.0 : 1.0;\r\n\r\n\t\t\t\tface.vertexTangents[ i ] = new THREE.Vector4( tmp.x, tmp.y, tmp.z, w );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tthis.hasTangents = true;\r\n\r\n\t},\r\n\r\n\tcomputeLineDistances: function () {\r\n\r\n\t\tvar d = 0;\r\n\t\tvar vertices = this.vertices;\r\n\r\n\t\tfor ( var i = 0, il = vertices.length; i < il; i ++ ) {\r\n\r\n\t\t\tif ( i > 0 ) {\r\n\r\n\t\t\t\td += vertices[ i ].distanceTo( vertices[ i - 1 ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis.lineDistances[ i ] = d;\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tcomputeBoundingBox: function () {\r\n\r\n\t\tif ( this.boundingBox === null ) {\r\n\r\n\t\t\tthis.boundingBox = new THREE.Box3();\r\n\r\n\t\t}\r\n\r\n\t\tthis.boundingBox.setFromPoints( this.vertices );\r\n\r\n\t},\r\n\r\n\tcomputeBoundingSphere: function () {\r\n\r\n\t\tif ( this.boundingSphere === null ) {\r\n\r\n\t\t\tthis.boundingSphere = new THREE.Sphere();\r\n\r\n\t\t}\r\n\r\n\t\tthis.boundingSphere.setFromPoints( this.vertices );\r\n\r\n\t},\r\n\r\n\tmerge: function ( geometry, matrix, materialIndexOffset ) {\r\n\r\n\t\tif ( geometry instanceof THREE.Geometry === false ) {\r\n\r\n\t\t\tTHREE.error( 'THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.', geometry );\r\n\t\t\treturn;\r\n\r\n\t\t}\r\n\r\n\t\tvar normalMatrix,\r\n\t\tvertexOffset = this.vertices.length,\r\n\t\tvertices1 = this.vertices,\r\n\t\tvertices2 = geometry.vertices,\r\n\t\tfaces1 = this.faces,\r\n\t\tfaces2 = geometry.faces,\r\n\t\tuvs1 = this.faceVertexUvs[ 0 ],\r\n\t\tuvs2 = geometry.faceVertexUvs[ 0 ];\r\n\r\n\t\tif ( materialIndexOffset === undefined ) materialIndexOffset = 0;\r\n\r\n\t\tif ( matrix !== undefined ) {\r\n\r\n\t\t\tnormalMatrix = new THREE.Matrix3().getNormalMatrix( matrix );\r\n\r\n\t\t}\r\n\r\n\t\t// vertices\r\n\r\n\t\tfor ( var i = 0, il = vertices2.length; i < il; i ++ ) {\r\n\r\n\t\t\tvar vertex = vertices2[ i ];\r\n\r\n\t\t\tvar vertexCopy = vertex.clone();\r\n\r\n\t\t\tif ( matrix !== undefined ) vertexCopy.applyMatrix4( matrix );\r\n\r\n\t\t\tvertices1.push( vertexCopy );\r\n\r\n\t\t}\r\n\r\n\t\t// faces\r\n\r\n\t\tfor ( i = 0, il = faces2.length; i < il; i ++ ) {\r\n\r\n\t\t\tvar face = faces2[ i ], faceCopy, normal, color,\r\n\t\t\tfaceVertexNormals = face.vertexNormals,\r\n\t\t\tfaceVertexColors = face.vertexColors;\r\n\r\n\t\t\tfaceCopy = new THREE.Face3( face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset );\r\n\t\t\tfaceCopy.normal.copy( face.normal );\r\n\r\n\t\t\tif ( normalMatrix !== undefined ) {\r\n\r\n\t\t\t\tfaceCopy.normal.applyMatrix3( normalMatrix ).normalize();\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfor ( var j = 0, jl = faceVertexNormals.length; j < jl; j ++ ) {\r\n\r\n\t\t\t\tnormal = faceVertexNormals[ j ].clone();\r\n\r\n\t\t\t\tif ( normalMatrix !== undefined ) {\r\n\r\n\t\t\t\t\tnormal.applyMatrix3( normalMatrix ).normalize();\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tfaceCopy.vertexNormals.push( normal );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfaceCopy.color.copy( face.color );\r\n\r\n\t\t\tfor ( var j = 0, jl = faceVertexColors.length; j < jl; j ++ ) {\r\n\r\n\t\t\t\tcolor = faceVertexColors[ j ];\r\n\t\t\t\tfaceCopy.vertexColors.push( color.clone() );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfaceCopy.materialIndex = face.materialIndex + materialIndexOffset;\r\n\r\n\t\t\tfaces1.push( faceCopy );\r\n\r\n\t\t}\r\n\r\n\t\t// uvs\r\n\r\n\t\tfor ( i = 0, il = uvs2.length; i < il; i ++ ) {\r\n\r\n\t\t\tvar uv = uvs2[ i ], uvCopy = [];\r\n\r\n\t\t\tif ( uv === undefined ) {\r\n\r\n\t\t\t\tcontinue;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfor ( var j = 0, jl = uv.length; j < jl; j ++ ) {\r\n\r\n\t\t\t\tuvCopy.push( uv[ j ].clone() );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tuvs1.push( uvCopy );\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tmergeMesh: function ( mesh ) {\r\n\r\n\t\tif ( mesh instanceof THREE.Mesh === false ) {\r\n\r\n\t\t\tTHREE.error( 'THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.', mesh );\r\n\t\t\treturn;\r\n\r\n\t\t}\r\n\r\n\t\tmesh.matrixAutoUpdate && mesh.updateMatrix();\r\n\r\n\t\tthis.merge( mesh.geometry, mesh.matrix );\r\n\r\n\t},\r\n\r\n\t/*\r\n\t * Checks for duplicate vertices with hashmap.\r\n\t * Duplicated vertices are removed\r\n\t * and faces' vertices are updated.\r\n\t */\r\n\r\n\tmergeVertices: function () {\r\n\r\n\t\tvar verticesMap = {}; // Hashmap for looking up vertice by position coordinates (and making sure they are unique)\r\n\t\tvar unique = [], changes = [];\r\n\r\n\t\tvar v, key;\r\n\t\tvar precisionPoints = 4; // number of decimal points, eg. 4 for epsilon of 0.0001\r\n\t\tvar precision = Math.pow( 10, precisionPoints );\r\n\t\tvar i, il, face;\r\n\t\tvar indices, j, jl;\r\n\r\n\t\tfor ( i = 0, il = this.vertices.length; i < il; i ++ ) {\r\n\r\n\t\t\tv = this.vertices[ i ];\r\n\t\t\tkey = Math.round( v.x * precision ) + '_' + Math.round( v.y * precision ) + '_' + Math.round( v.z * precision );\r\n\r\n\t\t\tif ( verticesMap[ key ] === undefined ) {\r\n\r\n\t\t\t\tverticesMap[ key ] = i;\r\n\t\t\t\tunique.push( this.vertices[ i ] );\r\n\t\t\t\tchanges[ i ] = unique.length - 1;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t//console.log('Duplicate vertex found. ', i, ' could be using ', verticesMap[key]);\r\n\t\t\t\tchanges[ i ] = changes[ verticesMap[ key ] ];\r\n\r\n\t\t\t}\r\n\r\n\t\t};\r\n\r\n\r\n\t\t// if faces are completely degenerate after merging vertices, we\r\n\t\t// have to remove them from the geometry.\r\n\t\tvar faceIndicesToRemove = [];\r\n\r\n\t\tfor ( i = 0, il = this.faces.length; i < il; i ++ ) {\r\n\r\n\t\t\tface = this.faces[ i ];\r\n\r\n\t\t\tface.a = changes[ face.a ];\r\n\t\t\tface.b = changes[ face.b ];\r\n\t\t\tface.c = changes[ face.c ];\r\n\r\n\t\t\tindices = [ face.a, face.b, face.c ];\r\n\r\n\t\t\tvar dupIndex = - 1;\r\n\r\n\t\t\t// if any duplicate vertices are found in a Face3\r\n\t\t\t// we have to remove the face as nothing can be saved\r\n\t\t\tfor ( var n = 0; n < 3; n ++ ) {\r\n\t\t\t\tif ( indices[ n ] == indices[ ( n + 1 ) % 3 ] ) {\r\n\r\n\t\t\t\t\tdupIndex = n;\r\n\t\t\t\t\tfaceIndicesToRemove.push( i );\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tfor ( i = faceIndicesToRemove.length - 1; i >= 0; i -- ) {\r\n\t\t\tvar idx = faceIndicesToRemove[ i ];\r\n\r\n\t\t\tthis.faces.splice( idx, 1 );\r\n\r\n\t\t\tfor ( j = 0, jl = this.faceVertexUvs.length; j < jl; j ++ ) {\r\n\r\n\t\t\t\tthis.faceVertexUvs[ j ].splice( idx, 1 );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// Use unique set of vertices\r\n\r\n\t\tvar diff = this.vertices.length - unique.length;\r\n\t\tthis.vertices = unique;\r\n\t\treturn diff;\r\n\r\n\t},\r\n\r\n\ttoJSON: function () {\r\n\r\n\t\tvar output = {\r\n\t\t\tmetadata: {\r\n\t\t\t\tversion: 4.0,\r\n\t\t\t\ttype: 'BufferGeometry',\r\n\t\t\t\tgenerator: 'BufferGeometryExporter'\r\n\t\t\t},\r\n\t\t\tuuid: this.uuid,\r\n\t\t\ttype: this.type\r\n\t\t};\r\n\r\n\t\tif ( this.name !== \"\" ) output.name = this.name;\r\n\r\n\t\tif ( this.parameters !== undefined ) {\r\n\r\n\t\t\tvar parameters = this.parameters;\r\n\r\n\t\t\tfor ( var key in parameters ) {\r\n\r\n\t\t\t\tif ( parameters[ key ] !== undefined ) output[ key ] = parameters[ key ];\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn output;\r\n\r\n\t\t}\r\n\r\n\t\tvar vertices = [];\r\n\r\n\t\tfor ( var i = 0; i < this.vertices.length; i ++ ) {\r\n\r\n\t\t\tvar vertex = this.vertices[ i ];\r\n\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\r\n\r\n\t\t}\r\n\r\n\t\tvar faces = [];\r\n\t\tvar normals = [];\r\n\t\tvar normalsHash = {};\r\n\t\tvar colors = [];\r\n\t\tvar colorsHash = {};\r\n\t\tvar uvs = [];\r\n\t\tvar uvsHash = {};\r\n\r\n\t\tfor ( var i = 0; i < this.faces.length; i ++ ) {\r\n\r\n\t\t\tvar face = this.faces[ i ];\r\n\r\n\t\t\tvar hasMaterial = false; // face.materialIndex !== undefined;\r\n\t\t\tvar hasFaceUv = false; // deprecated\r\n\t\t\tvar hasFaceVertexUv = this.faceVertexUvs[ 0 ][ i ] !== undefined;\r\n\t\t\tvar hasFaceNormal = face.normal.length() > 0;\r\n\t\t\tvar hasFaceVertexNormal = face.vertexNormals.length > 0;\r\n\t\t\tvar hasFaceColor = face.color.r !== 1 || face.color.g !== 1 || face.color.b !== 1;\r\n\t\t\tvar hasFaceVertexColor = face.vertexColors.length > 0;\r\n\r\n\t\t\tvar faceType = 0;\r\n\r\n\t\t\tfaceType = setBit( faceType, 0, 0 );\r\n\t\t\tfaceType = setBit( faceType, 1, hasMaterial );\r\n\t\t\tfaceType = setBit( faceType, 2, hasFaceUv );\r\n\t\t\tfaceType = setBit( faceType, 3, hasFaceVertexUv );\r\n\t\t\tfaceType = setBit( faceType, 4, hasFaceNormal );\r\n\t\t\tfaceType = setBit( faceType, 5, hasFaceVertexNormal );\r\n\t\t\tfaceType = setBit( faceType, 6, hasFaceColor );\r\n\t\t\tfaceType = setBit( faceType, 7, hasFaceVertexColor );\r\n\r\n\t\t\tfaces.push( faceType );\r\n\t\t\tfaces.push( face.a, face.b, face.c );\r\n\r\n\r\n\t\t\t/*\r\n\t\t\tif ( hasMaterial ) {\r\n\r\n\t\t\t\tfaces.push( face.materialIndex );\r\n\r\n\t\t\t}\r\n\t\t\t*/\r\n\r\n\t\t\tif ( hasFaceVertexUv ) {\r\n\r\n\t\t\t\tvar faceVertexUvs = this.faceVertexUvs[ 0 ][ i ];\r\n\r\n\t\t\t\tfaces.push(\r\n\t\t\t\t\tgetUvIndex( faceVertexUvs[ 0 ] ),\r\n\t\t\t\t\tgetUvIndex( faceVertexUvs[ 1 ] ),\r\n\t\t\t\t\tgetUvIndex( faceVertexUvs[ 2 ] )\r\n\t\t\t\t);\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( hasFaceNormal ) {\r\n\r\n\t\t\t\tfaces.push( getNormalIndex( face.normal ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( hasFaceVertexNormal ) {\r\n\r\n\t\t\t\tvar vertexNormals = face.vertexNormals;\r\n\r\n\t\t\t\tfaces.push(\r\n\t\t\t\t\tgetNormalIndex( vertexNormals[ 0 ] ),\r\n\t\t\t\t\tgetNormalIndex( vertexNormals[ 1 ] ),\r\n\t\t\t\t\tgetNormalIndex( vertexNormals[ 2 ] )\r\n\t\t\t\t);\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( hasFaceColor ) {\r\n\r\n\t\t\t\tfaces.push( getColorIndex( face.color ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( hasFaceVertexColor ) {\r\n\r\n\t\t\t\tvar vertexColors = face.vertexColors;\r\n\r\n\t\t\t\tfaces.push(\r\n\t\t\t\t\tgetColorIndex( vertexColors[ 0 ] ),\r\n\t\t\t\t\tgetColorIndex( vertexColors[ 1 ] ),\r\n\t\t\t\t\tgetColorIndex( vertexColors[ 2 ] )\r\n\t\t\t\t);\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tfunction setBit( value, position, enabled ) {\r\n\r\n\t\t\treturn enabled ? value | ( 1 << position ) : value & ( ~ ( 1 << position) );\r\n\r\n\t\t}\r\n\r\n\t\tfunction getNormalIndex( normal ) {\r\n\r\n\t\t\tvar hash = normal.x.toString() + normal.y.toString() + normal.z.toString();\r\n\r\n\t\t\tif ( normalsHash[ hash ] !== undefined ) {\r\n\r\n\t\t\t\treturn normalsHash[ hash ];\r\n\r\n\t\t\t}\r\n\r\n\t\t\tnormalsHash[ hash ] = normals.length / 3;\r\n\t\t\tnormals.push( normal.x, normal.y, normal.z );\r\n\r\n\t\t\treturn normalsHash[ hash ];\r\n\r\n\t\t}\r\n\r\n\t\tfunction getColorIndex( color ) {\r\n\r\n\t\t\tvar hash = color.r.toString() + color.g.toString() + color.b.toString();\r\n\r\n\t\t\tif ( colorsHash[ hash ] !== undefined ) {\r\n\r\n\t\t\t\treturn colorsHash[ hash ];\r\n\r\n\t\t\t}\r\n\r\n\t\t\tcolorsHash[ hash ] = colors.length;\r\n\t\t\tcolors.push( color.getHex() );\r\n\r\n\t\t\treturn colorsHash[ hash ];\r\n\r\n\t\t}\r\n\r\n\t\tfunction getUvIndex( uv ) {\r\n\r\n\t\t\tvar hash = uv.x.toString() + uv.y.toString();\r\n\r\n\t\t\tif ( uvsHash[ hash ] !== undefined ) {\r\n\r\n\t\t\t\treturn uvsHash[ hash ];\r\n\r\n\t\t\t}\r\n\r\n\t\t\tuvsHash[ hash ] = uvs.length / 2;\r\n\t\t\tuvs.push( uv.x, uv.y );\r\n\r\n\t\t\treturn uvsHash[ hash ];\r\n\r\n\t\t}\r\n\r\n\t\toutput.data = {};\r\n\r\n\t\toutput.data.vertices = vertices;\r\n\t\toutput.data.normals = normals;\r\n\t\tif ( colors.length > 0 ) output.data.colors = colors;\r\n\t\tif ( uvs.length > 0 ) output.data.uvs = [ uvs ]; // temporal backward compatibility\r\n\t\toutput.data.faces = faces;\r\n\r\n\t\t//\r\n\r\n\t\treturn output;\r\n\r\n\t},\r\n\r\n\tclone: function () {\r\n\r\n\t\tvar geometry = new THREE.Geometry();\r\n\r\n\t\tvar vertices = this.vertices;\r\n\r\n\t\tfor ( var i = 0, il = vertices.length; i < il; i ++ ) {\r\n\r\n\t\t\tgeometry.vertices.push( vertices[ i ].clone() );\r\n\r\n\t\t}\r\n\r\n\t\tvar faces = this.faces;\r\n\r\n\t\tfor ( var i = 0, il = faces.length; i < il; i ++ ) {\r\n\r\n\t\t\tgeometry.faces.push( faces[ i ].clone() );\r\n\r\n\t\t}\r\n\r\n\t\tfor ( var i = 0, il = this.faceVertexUvs.length; i < il; i ++ ) {\r\n\r\n\t\t\tvar faceVertexUvs = this.faceVertexUvs[ i ];\r\n\r\n\t\t\tif ( geometry.faceVertexUvs[ i ] === undefined ) {\r\n\r\n\t\t\t\tgeometry.faceVertexUvs[ i ] = [];\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfor ( var j = 0, jl = faceVertexUvs.length; j < jl; j ++ ) {\r\n\r\n\t\t\t\tvar uvs = faceVertexUvs[ j ], uvsCopy = [];\r\n\r\n\t\t\t\tfor ( var k = 0, kl = uvs.length; k < kl; k ++ ) {\r\n\r\n\t\t\t\t\tvar uv = uvs[ k ];\r\n\r\n\t\t\t\t\tuvsCopy.push( uv.clone() );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tgeometry.faceVertexUvs[ i ].push( uvsCopy );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn geometry;\r\n\r\n\t},\r\n\r\n\tdispose: function () {\r\n\r\n\t\tthis.dispatchEvent( { type: 'dispose' } );\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.EventDispatcher.prototype.apply( THREE.Geometry.prototype );\r\n\r\nTHREE.GeometryIdCount = 0;\r\n\r\n// File:src/cameras/Camera.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author WestLangley / http://github.com/WestLangley\r\n*/\r\n\r\nTHREE.Camera = function () {\r\n\r\n\tTHREE.Object3D.call( this );\r\n\r\n\tthis.type = 'Camera';\r\n\r\n\tthis.matrixWorldInverse = new THREE.Matrix4();\r\n\tthis.projectionMatrix = new THREE.Matrix4();\r\n\r\n};\r\n\r\nTHREE.Camera.prototype = Object.create( THREE.Object3D.prototype );\r\nTHREE.Camera.prototype.constructor = THREE.Camera;\r\n\r\nTHREE.Camera.prototype.getWorldDirection = function () {\r\n\r\n\tvar quaternion = new THREE.Quaternion();\r\n\r\n\treturn function ( optionalTarget ) {\r\n\r\n\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\r\n\t\tthis.getWorldQuaternion( quaternion );\r\n\r\n\t\treturn result.set( 0, 0, - 1 ).applyQuaternion( quaternion );\r\n\r\n\t}\r\n\r\n}();\r\n\r\nTHREE.Camera.prototype.lookAt = function () {\r\n\r\n\t// This routine does not support cameras with rotated and/or translated parent(s)\r\n\r\n\tvar m1 = new THREE.Matrix4();\r\n\r\n\treturn function ( vector ) {\r\n\r\n\t\tm1.lookAt( this.position, vector, this.up );\r\n\r\n\t\tthis.quaternion.setFromRotationMatrix( m1 );\r\n\r\n\t};\r\n\r\n}();\r\n\r\nTHREE.Camera.prototype.clone = function ( camera ) {\r\n\r\n\tif ( camera === undefined ) camera = new THREE.Camera();\r\n\r\n\tTHREE.Object3D.prototype.clone.call( this, camera );\r\n\r\n\tcamera.matrixWorldInverse.copy( this.matrixWorldInverse );\r\n\tcamera.projectionMatrix.copy( this.projectionMatrix );\r\n\r\n\treturn camera;\r\n};\r\n\r\n// File:src/cameras/CubeCamera.js\r\n\r\n/**\r\n * Camera for rendering cube maps\r\n *\t- renders scene into axis-aligned cube\r\n *\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.CubeCamera = function ( near, far, cubeResolution ) {\r\n\r\n\tTHREE.Object3D.call( this );\r\n\r\n\tthis.type = 'CubeCamera';\r\n\r\n\tvar fov = 90, aspect = 1;\r\n\r\n\tvar cameraPX = new THREE.PerspectiveCamera( fov, aspect, near, far );\r\n\tcameraPX.up.set( 0, - 1, 0 );\r\n\tcameraPX.lookAt( new THREE.Vector3( 1, 0, 0 ) );\r\n\tthis.add( cameraPX );\r\n\r\n\tvar cameraNX = new THREE.PerspectiveCamera( fov, aspect, near, far );\r\n\tcameraNX.up.set( 0, - 1, 0 );\r\n\tcameraNX.lookAt( new THREE.Vector3( - 1, 0, 0 ) );\r\n\tthis.add( cameraNX );\r\n\r\n\tvar cameraPY = new THREE.PerspectiveCamera( fov, aspect, near, far );\r\n\tcameraPY.up.set( 0, 0, 1 );\r\n\tcameraPY.lookAt( new THREE.Vector3( 0, 1, 0 ) );\r\n\tthis.add( cameraPY );\r\n\r\n\tvar cameraNY = new THREE.PerspectiveCamera( fov, aspect, near, far );\r\n\tcameraNY.up.set( 0, 0, - 1 );\r\n\tcameraNY.lookAt( new THREE.Vector3( 0, - 1, 0 ) );\r\n\tthis.add( cameraNY );\r\n\r\n\tvar cameraPZ = new THREE.PerspectiveCamera( fov, aspect, near, far );\r\n\tcameraPZ.up.set( 0, - 1, 0 );\r\n\tcameraPZ.lookAt( new THREE.Vector3( 0, 0, 1 ) );\r\n\tthis.add( cameraPZ );\r\n\r\n\tvar cameraNZ = new THREE.PerspectiveCamera( fov, aspect, near, far );\r\n\tcameraNZ.up.set( 0, - 1, 0 );\r\n\tcameraNZ.lookAt( new THREE.Vector3( 0, 0, - 1 ) );\r\n\tthis.add( cameraNZ );\r\n\r\n\tthis.renderTarget = new THREE.WebGLRenderTargetCube( cubeResolution, cubeResolution, { format: THREE.RGBFormat, magFilter: THREE.LinearFilter, minFilter: THREE.LinearFilter } );\r\n\r\n\tthis.updateCubeMap = function ( renderer, scene ) {\r\n\r\n\t\tvar renderTarget = this.renderTarget;\r\n\t\tvar generateMipmaps = renderTarget.generateMipmaps;\r\n\r\n\t\trenderTarget.generateMipmaps = false;\r\n\r\n\t\trenderTarget.activeCubeFace = 0;\r\n\t\trenderer.render( scene, cameraPX, renderTarget );\r\n\r\n\t\trenderTarget.activeCubeFace = 1;\r\n\t\trenderer.render( scene, cameraNX, renderTarget );\r\n\r\n\t\trenderTarget.activeCubeFace = 2;\r\n\t\trenderer.render( scene, cameraPY, renderTarget );\r\n\r\n\t\trenderTarget.activeCubeFace = 3;\r\n\t\trenderer.render( scene, cameraNY, renderTarget );\r\n\r\n\t\trenderTarget.activeCubeFace = 4;\r\n\t\trenderer.render( scene, cameraPZ, renderTarget );\r\n\r\n\t\trenderTarget.generateMipmaps = generateMipmaps;\r\n\r\n\t\trenderTarget.activeCubeFace = 5;\r\n\t\trenderer.render( scene, cameraNZ, renderTarget );\r\n\r\n\t};\r\n\r\n};\r\n\r\nTHREE.CubeCamera.prototype = Object.create( THREE.Object3D.prototype );\r\nTHREE.CubeCamera.prototype.constructor = THREE.CubeCamera;\r\n\r\n// File:src/cameras/OrthographicCamera.js\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.OrthographicCamera = function ( left, right, top, bottom, near, far ) {\r\n\r\n\tTHREE.Camera.call( this );\r\n\r\n\tthis.type = 'OrthographicCamera';\r\n\r\n\tthis.zoom = 1;\r\n\r\n\tthis.left = left;\r\n\tthis.right = right;\r\n\tthis.top = top;\r\n\tthis.bottom = bottom;\r\n\r\n\tthis.near = ( near !== undefined ) ? near : 0.1;\r\n\tthis.far = ( far !== undefined ) ? far : 2000;\r\n\r\n\tthis.updateProjectionMatrix();\r\n\r\n};\r\n\r\nTHREE.OrthographicCamera.prototype = Object.create( THREE.Camera.prototype );\r\nTHREE.OrthographicCamera.prototype.constructor = THREE.OrthographicCamera;\r\n\r\nTHREE.OrthographicCamera.prototype.updateProjectionMatrix = function () {\r\n\r\n\tvar dx = ( this.right - this.left ) / ( 2 * this.zoom );\r\n\tvar dy = ( this.top - this.bottom ) / ( 2 * this.zoom );\r\n\tvar cx = ( this.right + this.left ) / 2;\r\n\tvar cy = ( this.top + this.bottom ) / 2;\r\n\r\n\tthis.projectionMatrix.makeOrthographic( cx - dx, cx + dx, cy + dy, cy - dy, this.near, this.far );\r\n\r\n};\r\n\r\nTHREE.OrthographicCamera.prototype.clone = function () {\r\n\r\n\tvar camera = new THREE.OrthographicCamera();\r\n\r\n\tTHREE.Camera.prototype.clone.call( this, camera );\r\n\r\n\tcamera.zoom = this.zoom;\r\n\r\n\tcamera.left = this.left;\r\n\tcamera.right = this.right;\r\n\tcamera.top = this.top;\r\n\tcamera.bottom = this.bottom;\r\n\r\n\tcamera.near = this.near;\r\n\tcamera.far = this.far;\r\n\r\n\tcamera.projectionMatrix.copy( this.projectionMatrix );\r\n\r\n\treturn camera;\r\n};\r\n\r\n// File:src/cameras/PerspectiveCamera.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author greggman / http://games.greggman.com/\r\n * @author zz85 / http://www.lab4games.net/zz85/blog\r\n */\r\n\r\nTHREE.PerspectiveCamera = function ( fov, aspect, near, far ) {\r\n\r\n\tTHREE.Camera.call( this );\r\n\r\n\tthis.type = 'PerspectiveCamera';\r\n\r\n\tthis.zoom = 1;\r\n\r\n\tthis.fov = fov !== undefined ? fov : 50;\r\n\tthis.aspect = aspect !== undefined ? aspect : 1;\r\n\tthis.near = near !== undefined ? near : 0.1;\r\n\tthis.far = far !== undefined ? far : 2000;\r\n\r\n\tthis.updateProjectionMatrix();\r\n\r\n};\r\n\r\nTHREE.PerspectiveCamera.prototype = Object.create( THREE.Camera.prototype );\r\nTHREE.PerspectiveCamera.prototype.constructor = THREE.PerspectiveCamera;\r\n\r\n\r\n/**\r\n * Uses Focal Length (in mm) to estimate and set FOV\r\n * 35mm (fullframe) camera is used if frame size is not specified;\r\n * Formula based on http://www.bobatkins.com/photography/technical/field_of_view.html\r\n */\r\n\r\nTHREE.PerspectiveCamera.prototype.setLens = function ( focalLength, frameHeight ) {\r\n\r\n\tif ( frameHeight === undefined ) frameHeight = 24;\r\n\r\n\tthis.fov = 2 * THREE.Math.radToDeg( Math.atan( frameHeight / ( focalLength * 2 ) ) );\r\n\tthis.updateProjectionMatrix();\r\n\r\n}\r\n\r\n\r\n/**\r\n * Sets an offset in a larger frustum. This is useful for multi-window or\r\n * multi-monitor/multi-machine setups.\r\n *\r\n * For example, if you have 3x2 monitors and each monitor is 1920x1080 and\r\n * the monitors are in grid like this\r\n *\r\n *   +---+---+---+\r\n *   | A | B | C |\r\n *   +---+---+---+\r\n *   | D | E | F |\r\n *   +---+---+---+\r\n *\r\n * then for each monitor you would call it like this\r\n *\r\n *   var w = 1920;\r\n *   var h = 1080;\r\n *   var fullWidth = w * 3;\r\n *   var fullHeight = h * 2;\r\n *\r\n *   --A--\r\n *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );\r\n *   --B--\r\n *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );\r\n *   --C--\r\n *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );\r\n *   --D--\r\n *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );\r\n *   --E--\r\n *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );\r\n *   --F--\r\n *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );\r\n *\r\n *   Note there is no reason monitors have to be the same size or in a grid.\r\n */\r\n\r\nTHREE.PerspectiveCamera.prototype.setViewOffset = function ( fullWidth, fullHeight, x, y, width, height ) {\r\n\r\n\tthis.fullWidth = fullWidth;\r\n\tthis.fullHeight = fullHeight;\r\n\tthis.x = x;\r\n\tthis.y = y;\r\n\tthis.width = width;\r\n\tthis.height = height;\r\n\r\n\tthis.updateProjectionMatrix();\r\n\r\n};\r\n\r\n\r\nTHREE.PerspectiveCamera.prototype.updateProjectionMatrix = function () {\r\n\r\n\tvar fov = THREE.Math.radToDeg( 2 * Math.atan( Math.tan( THREE.Math.degToRad( this.fov ) * 0.5 ) / this.zoom ) );\r\n\r\n\tif ( this.fullWidth ) {\r\n\r\n\t\tvar aspect = this.fullWidth / this.fullHeight;\r\n\t\tvar top = Math.tan( THREE.Math.degToRad( fov * 0.5 ) ) * this.near;\r\n\t\tvar bottom = - top;\r\n\t\tvar left = aspect * bottom;\r\n\t\tvar right = aspect * top;\r\n\t\tvar width = Math.abs( right - left );\r\n\t\tvar height = Math.abs( top - bottom );\r\n\r\n\t\tthis.projectionMatrix.makeFrustum(\r\n\t\t\tleft + this.x * width / this.fullWidth,\r\n\t\t\tleft + ( this.x + this.width ) * width / this.fullWidth,\r\n\t\t\ttop - ( this.y + this.height ) * height / this.fullHeight,\r\n\t\t\ttop - this.y * height / this.fullHeight,\r\n\t\t\tthis.near,\r\n\t\t\tthis.far\r\n\t\t);\r\n\r\n\t} else {\r\n\r\n\t\tthis.projectionMatrix.makePerspective( fov, this.aspect, this.near, this.far );\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.PerspectiveCamera.prototype.clone = function () {\r\n\r\n\tvar camera = new THREE.PerspectiveCamera();\r\n\r\n\tTHREE.Camera.prototype.clone.call( this, camera );\r\n\r\n\tcamera.zoom = this.zoom;\r\n\r\n\tcamera.fov = this.fov;\r\n\tcamera.aspect = this.aspect;\r\n\tcamera.near = this.near;\r\n\tcamera.far = this.far;\r\n\r\n\tcamera.projectionMatrix.copy( this.projectionMatrix );\r\n\r\n\treturn camera;\r\n\r\n};\r\n\r\n// File:src/lights/Light.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.Light = function ( color ) {\r\n\r\n\tTHREE.Object3D.call( this );\r\n\r\n\tthis.type = 'Light';\r\n\t\r\n\tthis.color = new THREE.Color( color );\r\n\r\n};\r\n\r\nTHREE.Light.prototype = Object.create( THREE.Object3D.prototype );\r\nTHREE.Light.prototype.constructor = THREE.Light;\r\n\r\nTHREE.Light.prototype.clone = function ( light ) {\r\n\r\n\tif ( light === undefined ) light = new THREE.Light();\r\n\r\n\tTHREE.Object3D.prototype.clone.call( this, light );\r\n\r\n\tlight.color.copy( this.color );\r\n\r\n\treturn light;\r\n\r\n};\r\n\r\n// File:src/lights/AmbientLight.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.AmbientLight = function ( color ) {\r\n\r\n\tTHREE.Light.call( this, color );\r\n\r\n\tthis.type = 'AmbientLight';\r\n\r\n};\r\n\r\nTHREE.AmbientLight.prototype = Object.create( THREE.Light.prototype );\r\nTHREE.AmbientLight.prototype.constructor = THREE.AmbientLight;\r\n\r\nTHREE.AmbientLight.prototype.clone = function () {\r\n\r\n\tvar light = new THREE.AmbientLight();\r\n\r\n\tTHREE.Light.prototype.clone.call( this, light );\r\n\r\n\treturn light;\r\n\r\n};\r\n\r\n// File:src/lights/AreaLight.js\r\n\r\n/**\r\n * @author MPanknin / http://www.redplant.de/\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.AreaLight = function ( color, intensity ) {\r\n\r\n\tTHREE.Light.call( this, color );\r\n\r\n\tthis.type = 'AreaLight';\r\n\r\n\tthis.normal = new THREE.Vector3( 0, - 1, 0 );\r\n\tthis.right = new THREE.Vector3( 1, 0, 0 );\r\n\r\n\tthis.intensity = ( intensity !== undefined ) ? intensity : 1;\r\n\r\n\tthis.width = 1.0;\r\n\tthis.height = 1.0;\r\n\r\n\tthis.constantAttenuation = 1.5;\r\n\tthis.linearAttenuation = 0.5;\r\n\tthis.quadraticAttenuation = 0.1;\r\n\r\n};\r\n\r\nTHREE.AreaLight.prototype = Object.create( THREE.Light.prototype );\r\nTHREE.AreaLight.prototype.constructor = THREE.AreaLight;\r\n\r\n\r\n// File:src/lights/DirectionalLight.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.DirectionalLight = function ( color, intensity ) {\r\n\r\n\tTHREE.Light.call( this, color );\r\n\r\n\tthis.type = 'DirectionalLight';\r\n\r\n\tthis.position.set( 0, 1, 0 );\r\n\tthis.target = new THREE.Object3D();\r\n\r\n\tthis.intensity = ( intensity !== undefined ) ? intensity : 1;\r\n\r\n\tthis.castShadow = false;\r\n\tthis.onlyShadow = false;\r\n\r\n\t//\r\n\r\n\tthis.shadowCameraNear = 50;\r\n\tthis.shadowCameraFar = 5000;\r\n\r\n\tthis.shadowCameraLeft = - 500;\r\n\tthis.shadowCameraRight = 500;\r\n\tthis.shadowCameraTop = 500;\r\n\tthis.shadowCameraBottom = - 500;\r\n\r\n\tthis.shadowCameraVisible = false;\r\n\r\n\tthis.shadowBias = 0;\r\n\tthis.shadowDarkness = 0.5;\r\n\r\n\tthis.shadowMapWidth = 512;\r\n\tthis.shadowMapHeight = 512;\r\n\r\n\t//\r\n\r\n\tthis.shadowCascade = false;\r\n\r\n\tthis.shadowCascadeOffset = new THREE.Vector3( 0, 0, - 1000 );\r\n\tthis.shadowCascadeCount = 2;\r\n\r\n\tthis.shadowCascadeBias = [ 0, 0, 0 ];\r\n\tthis.shadowCascadeWidth = [ 512, 512, 512 ];\r\n\tthis.shadowCascadeHeight = [ 512, 512, 512 ];\r\n\r\n\tthis.shadowCascadeNearZ = [ - 1.000, 0.990, 0.998 ];\r\n\tthis.shadowCascadeFarZ  = [ 0.990, 0.998, 1.000 ];\r\n\r\n\tthis.shadowCascadeArray = [];\r\n\r\n\t//\r\n\r\n\tthis.shadowMap = null;\r\n\tthis.shadowMapSize = null;\r\n\tthis.shadowCamera = null;\r\n\tthis.shadowMatrix = null;\r\n\r\n};\r\n\r\nTHREE.DirectionalLight.prototype = Object.create( THREE.Light.prototype );\r\nTHREE.DirectionalLight.prototype.constructor = THREE.DirectionalLight;\r\n\r\nTHREE.DirectionalLight.prototype.clone = function () {\r\n\r\n\tvar light = new THREE.DirectionalLight();\r\n\r\n\tTHREE.Light.prototype.clone.call( this, light );\r\n\r\n\tlight.target = this.target.clone();\r\n\r\n\tlight.intensity = this.intensity;\r\n\r\n\tlight.castShadow = this.castShadow;\r\n\tlight.onlyShadow = this.onlyShadow;\r\n\r\n\t//\r\n\r\n\tlight.shadowCameraNear = this.shadowCameraNear;\r\n\tlight.shadowCameraFar = this.shadowCameraFar;\r\n\r\n\tlight.shadowCameraLeft = this.shadowCameraLeft;\r\n\tlight.shadowCameraRight = this.shadowCameraRight;\r\n\tlight.shadowCameraTop = this.shadowCameraTop;\r\n\tlight.shadowCameraBottom = this.shadowCameraBottom;\r\n\r\n\tlight.shadowCameraVisible = this.shadowCameraVisible;\r\n\r\n\tlight.shadowBias = this.shadowBias;\r\n\tlight.shadowDarkness = this.shadowDarkness;\r\n\r\n\tlight.shadowMapWidth = this.shadowMapWidth;\r\n\tlight.shadowMapHeight = this.shadowMapHeight;\r\n\r\n\t//\r\n\r\n\tlight.shadowCascade = this.shadowCascade;\r\n\r\n\tlight.shadowCascadeOffset.copy( this.shadowCascadeOffset );\r\n\tlight.shadowCascadeCount = this.shadowCascadeCount;\r\n\r\n\tlight.shadowCascadeBias = this.shadowCascadeBias.slice( 0 );\r\n\tlight.shadowCascadeWidth = this.shadowCascadeWidth.slice( 0 );\r\n\tlight.shadowCascadeHeight = this.shadowCascadeHeight.slice( 0 );\r\n\r\n\tlight.shadowCascadeNearZ = this.shadowCascadeNearZ.slice( 0 );\r\n\tlight.shadowCascadeFarZ  = this.shadowCascadeFarZ.slice( 0 );\r\n\r\n\treturn light;\r\n\r\n};\r\n\r\n// File:src/lights/HemisphereLight.js\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.HemisphereLight = function ( skyColor, groundColor, intensity ) {\r\n\r\n\tTHREE.Light.call( this, skyColor );\r\n\r\n\tthis.type = 'HemisphereLight';\r\n\r\n\tthis.position.set( 0, 100, 0 );\r\n\r\n\tthis.groundColor = new THREE.Color( groundColor );\r\n\tthis.intensity = ( intensity !== undefined ) ? intensity : 1;\r\n\r\n};\r\n\r\nTHREE.HemisphereLight.prototype = Object.create( THREE.Light.prototype );\r\nTHREE.HemisphereLight.prototype.constructor = THREE.HemisphereLight;\r\n\r\nTHREE.HemisphereLight.prototype.clone = function () {\r\n\r\n\tvar light = new THREE.HemisphereLight();\r\n\r\n\tTHREE.Light.prototype.clone.call( this, light );\r\n\r\n\tlight.groundColor.copy( this.groundColor );\r\n\tlight.intensity = this.intensity;\r\n\r\n\treturn light;\r\n\r\n};\r\n\r\n// File:src/lights/PointLight.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.PointLight = function ( color, intensity, distance, decay ) {\r\n\r\n\tTHREE.Light.call( this, color );\r\n\r\n\tthis.type = 'PointLight';\r\n\r\n\tthis.intensity = ( intensity !== undefined ) ? intensity : 1;\r\n\tthis.distance = ( distance !== undefined ) ? distance : 0;\r\n\tthis.decay = ( decay !== undefined ) ? decay : 1;\t// for physically correct lights, should be 2.\r\n\r\n};\r\n\r\nTHREE.PointLight.prototype = Object.create( THREE.Light.prototype );\r\nTHREE.PointLight.prototype.constructor = THREE.PointLight;\r\n\r\nTHREE.PointLight.prototype.clone = function () {\r\n\r\n\tvar light = new THREE.PointLight();\r\n\r\n\tTHREE.Light.prototype.clone.call( this, light );\r\n\r\n\tlight.intensity = this.intensity;\r\n\tlight.distance = this.distance;\r\n\tlight.decay = this.decay;\r\n\r\n\treturn light;\r\n\r\n};\r\n\r\n// File:src/lights/SpotLight.js\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.SpotLight = function ( color, intensity, distance, angle, exponent, decay ) {\r\n\r\n\tTHREE.Light.call( this, color );\r\n\r\n\tthis.type = 'SpotLight';\r\n\r\n\tthis.position.set( 0, 1, 0 );\r\n\tthis.target = new THREE.Object3D();\r\n\r\n\tthis.intensity = ( intensity !== undefined ) ? intensity : 1;\r\n\tthis.distance = ( distance !== undefined ) ? distance : 0;\r\n\tthis.angle = ( angle !== undefined ) ? angle : Math.PI / 3;\r\n\tthis.exponent = ( exponent !== undefined ) ? exponent : 10;\r\n\tthis.decay = ( decay !== undefined ) ? decay : 1;\t// for physically correct lights, should be 2.\r\n\r\n\tthis.castShadow = false;\r\n\tthis.onlyShadow = false;\r\n\r\n\t//\r\n\r\n\tthis.shadowCameraNear = 50;\r\n\tthis.shadowCameraFar = 5000;\r\n\tthis.shadowCameraFov = 50;\r\n\r\n\tthis.shadowCameraVisible = false;\r\n\r\n\tthis.shadowBias = 0;\r\n\tthis.shadowDarkness = 0.5;\r\n\r\n\tthis.shadowMapWidth = 512;\r\n\tthis.shadowMapHeight = 512;\r\n\r\n\t//\r\n\r\n\tthis.shadowMap = null;\r\n\tthis.shadowMapSize = null;\r\n\tthis.shadowCamera = null;\r\n\tthis.shadowMatrix = null;\r\n\r\n};\r\n\r\nTHREE.SpotLight.prototype = Object.create( THREE.Light.prototype );\r\nTHREE.SpotLight.prototype.constructor = THREE.SpotLight;\r\n\r\nTHREE.SpotLight.prototype.clone = function () {\r\n\r\n\tvar light = new THREE.SpotLight();\r\n\r\n\tTHREE.Light.prototype.clone.call( this, light );\r\n\r\n\tlight.target = this.target.clone();\r\n\r\n\tlight.intensity = this.intensity;\r\n\tlight.distance = this.distance;\r\n\tlight.angle = this.angle;\r\n\tlight.exponent = this.exponent;\r\n\tlight.decay = this.decay;\r\n\r\n\tlight.castShadow = this.castShadow;\r\n\tlight.onlyShadow = this.onlyShadow;\r\n\r\n\t//\r\n\r\n\tlight.shadowCameraNear = this.shadowCameraNear;\r\n\tlight.shadowCameraFar = this.shadowCameraFar;\r\n\tlight.shadowCameraFov = this.shadowCameraFov;\r\n\r\n\tlight.shadowCameraVisible = this.shadowCameraVisible;\r\n\r\n\tlight.shadowBias = this.shadowBias;\r\n\tlight.shadowDarkness = this.shadowDarkness;\r\n\r\n\tlight.shadowMapWidth = this.shadowMapWidth;\r\n\tlight.shadowMapHeight = this.shadowMapHeight;\r\n\r\n\treturn light;\r\n\r\n};\r\n\r\n// File:src/loaders/Cache.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.Cache = {\r\n\r\n\tfiles: {},\r\n\r\n\tadd: function ( key, file ) {\r\n\r\n\t\t// console.log( 'THREE.Cache', 'Adding key:', key );\r\n\r\n\t\tthis.files[ key ] = file;\r\n\r\n\t},\r\n\r\n\tget: function ( key ) {\r\n\r\n\t\t// console.log( 'THREE.Cache', 'Checking key:', key );\r\n\r\n\t\treturn this.files[ key ];\r\n\r\n\t},\r\n\r\n\tremove: function ( key ) {\r\n\r\n\t\tdelete this.files[ key ];\r\n\r\n\t},\r\n\r\n\tclear: function () {\r\n\r\n\t\tthis.files = {}\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/loaders/Loader.js\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.Loader = function ( showStatus ) {\r\n\r\n\tthis.showStatus = showStatus;\r\n\tthis.statusDomElement = showStatus ? THREE.Loader.prototype.addStatusElement() : null;\r\n\r\n\tthis.imageLoader = new THREE.ImageLoader();\r\n\r\n\tthis.onLoadStart = function () {};\r\n\tthis.onLoadProgress = function () {};\r\n\tthis.onLoadComplete = function () {};\r\n\r\n};\r\n\r\nTHREE.Loader.prototype = {\r\n\r\n\tconstructor: THREE.Loader,\r\n\r\n\tcrossOrigin: undefined,\r\n\r\n\taddStatusElement: function () {\r\n\r\n\t\tvar e = document.createElement( 'div' );\r\n\r\n\t\te.style.position = 'absolute';\r\n\t\te.style.right = '0px';\r\n\t\te.style.top = '0px';\r\n\t\te.style.fontSize = '0.8em';\r\n\t\te.style.textAlign = 'left';\r\n\t\te.style.background = 'rgba(0,0,0,0.25)';\r\n\t\te.style.color = '#fff';\r\n\t\te.style.width = '120px';\r\n\t\te.style.padding = '0.5em 0.5em 0.5em 0.5em';\r\n\t\te.style.zIndex = 1000;\r\n\r\n\t\te.innerHTML = 'Loading ...';\r\n\r\n\t\treturn e;\r\n\r\n\t},\r\n\r\n\tupdateProgress: function ( progress ) {\r\n\r\n\t\tvar message = 'Loaded ';\r\n\r\n\t\tif ( progress.total ) {\r\n\r\n\t\t\tmessage += ( 100 * progress.loaded / progress.total ).toFixed( 0 ) + '%';\r\n\r\n\r\n\t\t} else {\r\n\r\n\t\t\tmessage += ( progress.loaded / 1024 ).toFixed( 2 ) + ' KB';\r\n\r\n\t\t}\r\n\r\n\t\tthis.statusDomElement.innerHTML = message;\r\n\r\n\t},\r\n\r\n\textractUrlBase: function ( url ) {\r\n\r\n\t\tvar parts = url.split( '/' );\r\n\r\n\t\tif ( parts.length === 1 ) return './';\r\n\r\n\t\tparts.pop();\r\n\r\n\t\treturn parts.join( '/' ) + '/';\r\n\r\n\t},\r\n\r\n\tinitMaterials: function ( materials, texturePath ) {\r\n\r\n\t\tvar array = [];\r\n\r\n\t\tfor ( var i = 0; i < materials.length; ++ i ) {\r\n\r\n\t\t\tarray[ i ] = this.createMaterial( materials[ i ], texturePath );\r\n\r\n\t\t}\r\n\r\n\t\treturn array;\r\n\r\n\t},\r\n\r\n\tneedsTangents: function ( materials ) {\r\n\r\n\t\tfor ( var i = 0, il = materials.length; i < il; i ++ ) {\r\n\r\n\t\t\tvar m = materials[ i ];\r\n\r\n\t\t\tif ( m instanceof THREE.ShaderMaterial ) return true;\r\n\r\n\t\t}\r\n\r\n\t\treturn false;\r\n\r\n\t},\r\n\r\n\tcreateMaterial: function ( m, texturePath ) {\r\n\r\n\t\tvar scope = this;\r\n\r\n\t\tfunction nearest_pow2( n ) {\r\n\r\n\t\t\tvar l = Math.log( n ) / Math.LN2;\r\n\t\t\treturn Math.pow( 2, Math.round(  l ) );\r\n\r\n\t\t}\r\n\r\n\t\tfunction create_texture( where, name, sourceFile, repeat, offset, wrap, anisotropy ) {\r\n\r\n\t\t\tvar fullPath = texturePath + sourceFile;\r\n\r\n\t\t\tvar texture;\r\n\r\n\t\t\tvar loader = THREE.Loader.Handlers.get( fullPath );\r\n\r\n\t\t\tif ( loader !== null ) {\r\n\r\n\t\t\t\ttexture = loader.load( fullPath );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\ttexture = new THREE.Texture();\r\n\r\n\t\t\t\tloader = scope.imageLoader;\r\n\t\t\t\tloader.crossOrigin = scope.crossOrigin;\r\n\t\t\t\tloader.load( fullPath, function ( image ) {\r\n\r\n\t\t\t\t\tif ( THREE.Math.isPowerOfTwo( image.width ) === false ||\r\n\t\t\t\t\t\t THREE.Math.isPowerOfTwo( image.height ) === false ) {\r\n\r\n\t\t\t\t\t\tvar width = nearest_pow2( image.width );\r\n\t\t\t\t\t\tvar height = nearest_pow2( image.height );\r\n\r\n\t\t\t\t\t\tvar canvas = document.createElement( 'canvas' );\r\n\t\t\t\t\t\tcanvas.width = width;\r\n\t\t\t\t\t\tcanvas.height = height;\r\n\r\n\t\t\t\t\t\tvar context = canvas.getContext( '2d' );\r\n\t\t\t\t\t\tcontext.drawImage( image, 0, 0, width, height );\r\n\r\n\t\t\t\t\t\ttexture.image = canvas;\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\ttexture.image = image;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\ttexture.needsUpdate = true;\r\n\r\n\t\t\t\t} );\r\n\r\n\t\t\t}\r\n\r\n\t\t\ttexture.sourceFile = sourceFile;\r\n\r\n\t\t\tif ( repeat ) {\r\n\r\n\t\t\t\ttexture.repeat.set( repeat[ 0 ], repeat[ 1 ] );\r\n\r\n\t\t\t\tif ( repeat[ 0 ] !== 1 ) texture.wrapS = THREE.RepeatWrapping;\r\n\t\t\t\tif ( repeat[ 1 ] !== 1 ) texture.wrapT = THREE.RepeatWrapping;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( offset ) {\r\n\r\n\t\t\t\ttexture.offset.set( offset[ 0 ], offset[ 1 ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( wrap ) {\r\n\r\n\t\t\t\tvar wrapMap = {\r\n\t\t\t\t\t'repeat': THREE.RepeatWrapping,\r\n\t\t\t\t\t'mirror': THREE.MirroredRepeatWrapping\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( wrapMap[ wrap[ 0 ] ] !== undefined ) texture.wrapS = wrapMap[ wrap[ 0 ] ];\r\n\t\t\t\tif ( wrapMap[ wrap[ 1 ] ] !== undefined ) texture.wrapT = wrapMap[ wrap[ 1 ] ];\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( anisotropy ) {\r\n\r\n\t\t\t\ttexture.anisotropy = anisotropy;\r\n\r\n\t\t\t}\r\n\r\n\t\t\twhere[ name ] = texture;\r\n\r\n\t\t}\r\n\r\n\t\tfunction rgb2hex( rgb ) {\r\n\r\n\t\t\treturn ( rgb[ 0 ] * 255 << 16 ) + ( rgb[ 1 ] * 255 << 8 ) + rgb[ 2 ] * 255;\r\n\r\n\t\t}\r\n\r\n\t\t// defaults\r\n\r\n\t\tvar mtype = 'MeshLambertMaterial';\r\n\t\tvar mpars = { color: 0xeeeeee, opacity: 1.0, map: null, lightMap: null, normalMap: null, bumpMap: null, wireframe: false };\r\n\r\n\t\t// parameters from model file\r\n\r\n\t\tif ( m.shading ) {\r\n\r\n\t\t\tvar shading = m.shading.toLowerCase();\r\n\r\n\t\t\tif ( shading === 'phong' ) mtype = 'MeshPhongMaterial';\r\n\t\t\telse if ( shading === 'basic' ) mtype = 'MeshBasicMaterial';\r\n\r\n\t\t}\r\n\r\n\t\tif ( m.blending !== undefined && THREE[ m.blending ] !== undefined ) {\r\n\r\n\t\t\tmpars.blending = THREE[ m.blending ];\r\n\r\n\t\t}\r\n\r\n\t\tif ( m.transparent !== undefined ) {\r\n\r\n\t\t\tmpars.transparent = m.transparent;\r\n\r\n\t\t}\r\n\r\n\t\tif ( m.opacity !== undefined && m.opacity < 1.0 ) {\r\n\r\n\t\t\tmpars.transparent = true;\r\n\r\n\t\t}\r\n\r\n\t\tif ( m.depthTest !== undefined ) {\r\n\r\n\t\t\tmpars.depthTest = m.depthTest;\r\n\r\n\t\t}\r\n\r\n\t\tif ( m.depthWrite !== undefined ) {\r\n\r\n\t\t\tmpars.depthWrite = m.depthWrite;\r\n\r\n\t\t}\r\n\r\n\t\tif ( m.visible !== undefined ) {\r\n\r\n\t\t\tmpars.visible = m.visible;\r\n\r\n\t\t}\r\n\r\n\t\tif ( m.flipSided !== undefined ) {\r\n\r\n\t\t\tmpars.side = THREE.BackSide;\r\n\r\n\t\t}\r\n\r\n\t\tif ( m.doubleSided !== undefined ) {\r\n\r\n\t\t\tmpars.side = THREE.DoubleSide;\r\n\r\n\t\t}\r\n\r\n\t\tif ( m.wireframe !== undefined ) {\r\n\r\n\t\t\tmpars.wireframe = m.wireframe;\r\n\r\n\t\t}\r\n\r\n\t\tif ( m.vertexColors !== undefined ) {\r\n\r\n\t\t\tif ( m.vertexColors === 'face' ) {\r\n\r\n\t\t\t\tmpars.vertexColors = THREE.FaceColors;\r\n\r\n\t\t\t} else if ( m.vertexColors ) {\r\n\r\n\t\t\t\tmpars.vertexColors = THREE.VertexColors;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// colors\r\n\r\n\t\tif ( m.colorDiffuse ) {\r\n\r\n\t\t\tmpars.color = rgb2hex( m.colorDiffuse );\r\n\r\n\t\t} else if ( m.DbgColor ) {\r\n\r\n\t\t\tmpars.color = m.DbgColor;\r\n\r\n\t\t}\r\n\r\n\t\tif ( m.colorSpecular ) {\r\n\r\n\t\t\tmpars.specular = rgb2hex( m.colorSpecular );\r\n\r\n\t\t}\r\n\r\n\t\tif ( m.colorEmissive ) {\r\n\r\n\t\t\tmpars.emissive = rgb2hex( m.colorEmissive );\r\n\r\n\t\t}\r\n\r\n\t\t// modifiers\r\n\r\n\t\tif ( m.transparency !== undefined ) {\r\n\r\n\t\t\tconsole.warn( 'THREE.Loader: transparency has been renamed to opacity' );\r\n\t\t\tm.opacity = m.transparency;\r\n\r\n\t\t}\r\n\r\n\t\tif ( m.opacity !== undefined ) {\r\n\r\n\t\t\tmpars.opacity = m.opacity;\r\n\r\n\t\t}\r\n\r\n\t\tif ( m.specularCoef ) {\r\n\r\n\t\t\tmpars.shininess = m.specularCoef;\r\n\r\n\t\t}\r\n\r\n\t\t// textures\r\n\r\n\t\tif ( m.mapDiffuse && texturePath ) {\r\n\r\n\t\t\tcreate_texture( mpars, 'map', m.mapDiffuse, m.mapDiffuseRepeat, m.mapDiffuseOffset, m.mapDiffuseWrap, m.mapDiffuseAnisotropy );\r\n\r\n\t\t}\r\n\r\n\t\tif ( m.mapLight && texturePath ) {\r\n\r\n\t\t\tcreate_texture( mpars, 'lightMap', m.mapLight, m.mapLightRepeat, m.mapLightOffset, m.mapLightWrap, m.mapLightAnisotropy );\r\n\r\n\t\t}\r\n\r\n\t\tif ( m.mapBump && texturePath ) {\r\n\r\n\t\t\tcreate_texture( mpars, 'bumpMap', m.mapBump, m.mapBumpRepeat, m.mapBumpOffset, m.mapBumpWrap, m.mapBumpAnisotropy );\r\n\r\n\t\t}\r\n\r\n\t\tif ( m.mapNormal && texturePath ) {\r\n\r\n\t\t\tcreate_texture( mpars, 'normalMap', m.mapNormal, m.mapNormalRepeat, m.mapNormalOffset, m.mapNormalWrap, m.mapNormalAnisotropy );\r\n\r\n\t\t}\r\n\r\n\t\tif ( m.mapSpecular && texturePath ) {\r\n\r\n\t\t\tcreate_texture( mpars, 'specularMap', m.mapSpecular, m.mapSpecularRepeat, m.mapSpecularOffset, m.mapSpecularWrap, m.mapSpecularAnisotropy );\r\n\r\n\t\t}\r\n\r\n\t\tif ( m.mapAlpha && texturePath ) {\r\n\r\n\t\t\tcreate_texture( mpars, 'alphaMap', m.mapAlpha, m.mapAlphaRepeat, m.mapAlphaOffset, m.mapAlphaWrap, m.mapAlphaAnisotropy );\r\n\r\n\t\t}\r\n\r\n\t\t//\r\n\r\n\t\tif ( m.mapBumpScale ) {\r\n\r\n\t\t\tmpars.bumpScale = m.mapBumpScale;\r\n\r\n\t\t}\r\n\r\n\t\tif ( m.mapNormalFactor ) {\r\n\r\n\t\t\tmpars.normalScale = new THREE.Vector2( m.mapNormalFactor, m.mapNormalFactor );\r\n\r\n\t\t}\r\n\r\n\t\tvar material = new THREE[ mtype ]( mpars );\r\n\r\n\t\tif ( m.DbgName !== undefined ) material.name = m.DbgName;\r\n\r\n\t\treturn material;\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.Loader.Handlers = {\r\n\r\n\thandlers: [],\r\n\r\n\tadd: function ( regex, loader ) {\r\n\r\n\t\tthis.handlers.push( regex, loader );\r\n\r\n\t},\r\n\r\n\tget: function ( file ) {\r\n\r\n\t\tfor ( var i = 0, l = this.handlers.length; i < l; i += 2 ) {\r\n\r\n\t\t\tvar regex = this.handlers[ i ];\r\n\t\t\tvar loader  = this.handlers[ i + 1 ];\r\n\r\n\t\t\tif ( regex.test( file ) ) {\r\n\r\n\t\t\t\treturn loader;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn null;\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/loaders/XHRLoader.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.XHRLoader = function ( manager ) {\r\n\r\n\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\r\n\r\n};\r\n\r\nTHREE.XHRLoader.prototype = {\r\n\r\n\tconstructor: THREE.XHRLoader,\r\n\r\n\tload: function ( url, onLoad, onProgress, onError ) {\r\n\r\n\t\tvar scope = this;\r\n\r\n\t\tvar cached = THREE.Cache.get( url );\r\n\r\n\t\tif ( cached !== undefined ) {\r\n\r\n\t\t\tif ( onLoad ) onLoad( cached );\r\n\t\t\treturn;\r\n\r\n\t\t}\r\n\r\n\t\tvar request = new XMLHttpRequest();\r\n\t\trequest.open( 'GET', url, true );\r\n\r\n\t\trequest.addEventListener( 'load', function ( event ) {\r\n\r\n\t\t\tTHREE.Cache.add( url, this.response );\r\n\r\n\t\t\tif ( onLoad ) onLoad( this.response );\r\n\r\n\t\t\tscope.manager.itemEnd( url );\r\n\r\n\t\t}, false );\r\n\r\n\t\tif ( onProgress !== undefined ) {\r\n\r\n\t\t\trequest.addEventListener( 'progress', function ( event ) {\r\n\r\n\t\t\t\tonProgress( event );\r\n\r\n\t\t\t}, false );\r\n\r\n\t\t}\r\n\r\n\t\tif ( onError !== undefined ) {\r\n\r\n\t\t\trequest.addEventListener( 'error', function ( event ) {\r\n\r\n\t\t\t\tonError( event );\r\n\r\n\t\t\t}, false );\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.crossOrigin !== undefined ) request.crossOrigin = this.crossOrigin;\r\n\t\tif ( this.responseType !== undefined ) request.responseType = this.responseType;\r\n\r\n\t\trequest.send( null );\r\n\r\n\t\tscope.manager.itemStart( url );\r\n\r\n\t},\r\n\r\n\tsetResponseType: function ( value ) {\r\n\r\n\t\tthis.responseType = value;\r\n\r\n\t},\r\n\r\n\tsetCrossOrigin: function ( value ) {\r\n\r\n\t\tthis.crossOrigin = value;\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/loaders/ImageLoader.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.ImageLoader = function ( manager ) {\r\n\r\n\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\r\n\r\n};\r\n\r\nTHREE.ImageLoader.prototype = {\r\n\r\n\tconstructor: THREE.ImageLoader,\r\n\r\n\tload: function ( url, onLoad, onProgress, onError ) {\r\n\r\n\t\tvar scope = this;\r\n\r\n\t\tvar cached = THREE.Cache.get( url );\r\n\r\n\t\tif ( cached !== undefined ) {\r\n\r\n\t\t\tonLoad( cached );\r\n\t\t\treturn;\r\n\r\n\t\t}\r\n\r\n\t\tvar image = document.createElement( 'img' );\r\n\r\n\t\timage.addEventListener( 'load', function ( event ) {\r\n\r\n\t\t\tTHREE.Cache.add( url, this );\r\n\r\n\t\t\tif ( onLoad ) onLoad( this );\r\n\t\t\t\r\n\t\t\tscope.manager.itemEnd( url );\r\n\r\n\t\t}, false );\r\n\r\n\t\tif ( onProgress !== undefined ) {\r\n\r\n\t\t\timage.addEventListener( 'progress', function ( event ) {\r\n\r\n\t\t\t\tonProgress( event );\r\n\r\n\t\t\t}, false );\r\n\r\n\t\t}\r\n\r\n\t\tif ( onError !== undefined ) {\r\n\r\n\t\t\timage.addEventListener( 'error', function ( event ) {\r\n\r\n\t\t\t\tonError( event );\r\n\r\n\t\t\t}, false );\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.crossOrigin !== undefined ) image.crossOrigin = this.crossOrigin;\r\n\r\n\t\timage.src = url;\r\n\r\n\t\tscope.manager.itemStart( url );\r\n\r\n\t\treturn image;\r\n\r\n\t},\r\n\r\n\tsetCrossOrigin: function ( value ) {\r\n\r\n\t\tthis.crossOrigin = value;\r\n\r\n\t}\r\n\r\n}\r\n\r\n// File:src/loaders/JSONLoader.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.JSONLoader = function ( showStatus ) {\r\n\r\n\tTHREE.Loader.call( this, showStatus );\r\n\r\n\tthis.withCredentials = false;\r\n\r\n};\r\n\r\nTHREE.JSONLoader.prototype = Object.create( THREE.Loader.prototype );\r\nTHREE.JSONLoader.prototype.constructor = THREE.JSONLoader;\r\n\r\nTHREE.JSONLoader.prototype.load = function ( url, callback, texturePath ) {\r\n\r\n\t// todo: unify load API to for easier SceneLoader use\r\n\r\n\ttexturePath = texturePath && ( typeof texturePath === 'string' ) ? texturePath : this.extractUrlBase( url );\r\n\r\n\tthis.onLoadStart();\r\n\tthis.loadAjaxJSON( this, url, callback, texturePath );\r\n\r\n};\r\n\r\nTHREE.JSONLoader.prototype.loadAjaxJSON = function ( context, url, callback, texturePath, callbackProgress ) {\r\n\r\n\tvar xhr = new XMLHttpRequest();\r\n\r\n\tvar length = 0;\r\n\r\n\txhr.onreadystatechange = function () {\r\n\r\n\t\tif ( xhr.readyState === xhr.DONE ) {\r\n\r\n\t\t\tif ( xhr.status === 200 || xhr.status === 0 ) {\r\n\r\n\t\t\t\tif ( xhr.responseText ) {\r\n\r\n\t\t\t\t\tvar json = JSON.parse( xhr.responseText );\r\n\t\t\t\t\tvar metadata = json.metadata;\r\n\r\n\t\t\t\t\tif ( metadata !== undefined ) {\r\n\r\n\t\t\t\t\t\tif ( metadata.type === 'object' ) {\r\n\r\n\t\t\t\t\t\t\tTHREE.error( 'THREE.JSONLoader: ' + url + ' should be loaded with THREE.ObjectLoader instead.' );\r\n\t\t\t\t\t\t\treturn;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tif ( metadata.type === 'scene' ) {\r\n\r\n\t\t\t\t\t\t\tTHREE.error( 'THREE.JSONLoader: ' + url + ' seems to be a Scene. Use THREE.SceneLoader instead.' );\r\n\t\t\t\t\t\t\treturn;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tvar result = context.parse( json, texturePath );\r\n\t\t\t\t\tcallback( result.geometry, result.materials );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tTHREE.error( 'THREE.JSONLoader: ' + url + ' seems to be unreachable or the file is empty.' );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// in context of more complex asset initialization\r\n\t\t\t\t// do not block on single failed file\r\n\t\t\t\t// maybe should go even one more level up\r\n\r\n\t\t\t\tcontext.onLoadComplete();\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tTHREE.error( 'THREE.JSONLoader: Couldn\\'t load ' + url + ' (' + xhr.status + ')' );\r\n\r\n\t\t\t}\r\n\r\n\t\t} else if ( xhr.readyState === xhr.LOADING ) {\r\n\r\n\t\t\tif ( callbackProgress ) {\r\n\r\n\t\t\t\tif ( length === 0 ) {\r\n\r\n\t\t\t\t\tlength = xhr.getResponseHeader( 'Content-Length' );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tcallbackProgress( { total: length, loaded: xhr.responseText.length } );\r\n\r\n\t\t\t}\r\n\r\n\t\t} else if ( xhr.readyState === xhr.HEADERS_RECEIVED ) {\r\n\r\n\t\t\tif ( callbackProgress !== undefined ) {\r\n\r\n\t\t\t\tlength = xhr.getResponseHeader( 'Content-Length' );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\txhr.open( 'GET', url, true );\r\n\txhr.withCredentials = this.withCredentials;\r\n\txhr.send( null );\r\n\r\n};\r\n\r\nTHREE.JSONLoader.prototype.parse = function ( json, texturePath ) {\r\n\r\n\tvar geometry = new THREE.Geometry(),\r\n\tscale = ( json.scale !== undefined ) ? 1.0 / json.scale : 1.0;\r\n\r\n\tparseModel( scale );\r\n\r\n\tparseSkin();\r\n\tparseMorphing( scale );\r\n\r\n\tgeometry.computeFaceNormals();\r\n\tgeometry.computeBoundingSphere();\r\n\r\n\tfunction parseModel( scale ) {\r\n\r\n\t\tfunction isBitSet( value, position ) {\r\n\r\n\t\t\treturn value & ( 1 << position );\r\n\r\n\t\t}\r\n\r\n\t\tvar i, j, fi,\r\n\r\n\t\toffset, zLength,\r\n\r\n\t\tcolorIndex, normalIndex, uvIndex, materialIndex,\r\n\r\n\t\ttype,\r\n\t\tisQuad,\r\n\t\thasMaterial,\r\n\t\thasFaceVertexUv,\r\n\t\thasFaceNormal, hasFaceVertexNormal,\r\n\t\thasFaceColor, hasFaceVertexColor,\r\n\r\n\t\tvertex, face, faceA, faceB, hex, normal,\r\n\r\n\t\tuvLayer, uv, u, v,\r\n\r\n\t\tfaces = json.faces,\r\n\t\tvertices = json.vertices,\r\n\t\tnormals = json.normals,\r\n\t\tcolors = json.colors,\r\n\r\n\t\tnUvLayers = 0;\r\n\r\n\t\tif ( json.uvs !== undefined ) {\r\n\r\n\t\t\t// disregard empty arrays\r\n\r\n\t\t\tfor ( i = 0; i < json.uvs.length; i ++ ) {\r\n\r\n\t\t\t\tif ( json.uvs[ i ].length ) nUvLayers ++;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfor ( i = 0; i < nUvLayers; i ++ ) {\r\n\r\n\t\t\t\tgeometry.faceVertexUvs[ i ] = [];\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\toffset = 0;\r\n\t\tzLength = vertices.length;\r\n\r\n\t\twhile ( offset < zLength ) {\r\n\r\n\t\t\tvertex = new THREE.Vector3();\r\n\r\n\t\t\tvertex.x = vertices[ offset ++ ] * scale;\r\n\t\t\tvertex.y = vertices[ offset ++ ] * scale;\r\n\t\t\tvertex.z = vertices[ offset ++ ] * scale;\r\n\r\n\t\t\tgeometry.vertices.push( vertex );\r\n\r\n\t\t}\r\n\r\n\t\toffset = 0;\r\n\t\tzLength = faces.length;\r\n\r\n\t\twhile ( offset < zLength ) {\r\n\r\n\t\t\ttype = faces[ offset ++ ];\r\n\r\n\r\n\t\t\tisQuad              = isBitSet( type, 0 );\r\n\t\t\thasMaterial         = isBitSet( type, 1 );\r\n\t\t\thasFaceVertexUv     = isBitSet( type, 3 );\r\n\t\t\thasFaceNormal       = isBitSet( type, 4 );\r\n\t\t\thasFaceVertexNormal = isBitSet( type, 5 );\r\n\t\t\thasFaceColor\t     = isBitSet( type, 6 );\r\n\t\t\thasFaceVertexColor  = isBitSet( type, 7 );\r\n\r\n\t\t\t// console.log(\"type\", type, \"bits\", isQuad, hasMaterial, hasFaceVertexUv, hasFaceNormal, hasFaceVertexNormal, hasFaceColor, hasFaceVertexColor);\r\n\r\n\t\t\tif ( isQuad ) {\r\n\r\n\t\t\t\tfaceA = new THREE.Face3();\r\n\t\t\t\tfaceA.a = faces[ offset ];\r\n\t\t\t\tfaceA.b = faces[ offset + 1 ];\r\n\t\t\t\tfaceA.c = faces[ offset + 3 ];\r\n\r\n\t\t\t\tfaceB = new THREE.Face3();\r\n\t\t\t\tfaceB.a = faces[ offset + 1 ];\r\n\t\t\t\tfaceB.b = faces[ offset + 2 ];\r\n\t\t\t\tfaceB.c = faces[ offset + 3 ];\r\n\r\n\t\t\t\toffset += 4;\r\n\r\n\t\t\t\tif ( hasMaterial ) {\r\n\r\n\t\t\t\t\tmaterialIndex = faces[ offset ++ ];\r\n\t\t\t\t\tfaceA.materialIndex = materialIndex;\r\n\t\t\t\t\tfaceB.materialIndex = materialIndex;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// to get face <=> uv index correspondence\r\n\r\n\t\t\t\tfi = geometry.faces.length;\r\n\r\n\t\t\t\tif ( hasFaceVertexUv ) {\r\n\r\n\t\t\t\t\tfor ( i = 0; i < nUvLayers; i ++ ) {\r\n\r\n\t\t\t\t\t\tuvLayer = json.uvs[ i ];\r\n\r\n\t\t\t\t\t\tgeometry.faceVertexUvs[ i ][ fi ] = [];\r\n\t\t\t\t\t\tgeometry.faceVertexUvs[ i ][ fi + 1 ] = []\r\n\r\n\t\t\t\t\t\tfor ( j = 0; j < 4; j ++ ) {\r\n\r\n\t\t\t\t\t\t\tuvIndex = faces[ offset ++ ];\r\n\r\n\t\t\t\t\t\t\tu = uvLayer[ uvIndex * 2 ];\r\n\t\t\t\t\t\t\tv = uvLayer[ uvIndex * 2 + 1 ];\r\n\r\n\t\t\t\t\t\t\tuv = new THREE.Vector2( u, v );\r\n\r\n\t\t\t\t\t\t\tif ( j !== 2 ) geometry.faceVertexUvs[ i ][ fi ].push( uv );\r\n\t\t\t\t\t\t\tif ( j !== 0 ) geometry.faceVertexUvs[ i ][ fi + 1 ].push( uv );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( hasFaceNormal ) {\r\n\r\n\t\t\t\t\tnormalIndex = faces[ offset ++ ] * 3;\r\n\r\n\t\t\t\t\tfaceA.normal.set(\r\n\t\t\t\t\t\tnormals[ normalIndex ++ ],\r\n\t\t\t\t\t\tnormals[ normalIndex ++ ],\r\n\t\t\t\t\t\tnormals[ normalIndex ]\r\n\t\t\t\t\t);\r\n\r\n\t\t\t\t\tfaceB.normal.copy( faceA.normal );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( hasFaceVertexNormal ) {\r\n\r\n\t\t\t\t\tfor ( i = 0; i < 4; i ++ ) {\r\n\r\n\t\t\t\t\t\tnormalIndex = faces[ offset ++ ] * 3;\r\n\r\n\t\t\t\t\t\tnormal = new THREE.Vector3(\r\n\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\r\n\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\r\n\t\t\t\t\t\t\tnormals[ normalIndex ]\r\n\t\t\t\t\t\t);\r\n\r\n\r\n\t\t\t\t\t\tif ( i !== 2 ) faceA.vertexNormals.push( normal );\r\n\t\t\t\t\t\tif ( i !== 0 ) faceB.vertexNormals.push( normal );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\r\n\t\t\t\tif ( hasFaceColor ) {\r\n\r\n\t\t\t\t\tcolorIndex = faces[ offset ++ ];\r\n\t\t\t\t\thex = colors[ colorIndex ];\r\n\r\n\t\t\t\t\tfaceA.color.setHex( hex );\r\n\t\t\t\t\tfaceB.color.setHex( hex );\r\n\r\n\t\t\t\t}\r\n\r\n\r\n\t\t\t\tif ( hasFaceVertexColor ) {\r\n\r\n\t\t\t\t\tfor ( i = 0; i < 4; i ++ ) {\r\n\r\n\t\t\t\t\t\tcolorIndex = faces[ offset ++ ];\r\n\t\t\t\t\t\thex = colors[ colorIndex ];\r\n\r\n\t\t\t\t\t\tif ( i !== 2 ) faceA.vertexColors.push( new THREE.Color( hex ) );\r\n\t\t\t\t\t\tif ( i !== 0 ) faceB.vertexColors.push( new THREE.Color( hex ) );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tgeometry.faces.push( faceA );\r\n\t\t\t\tgeometry.faces.push( faceB );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tface = new THREE.Face3();\r\n\t\t\t\tface.a = faces[ offset ++ ];\r\n\t\t\t\tface.b = faces[ offset ++ ];\r\n\t\t\t\tface.c = faces[ offset ++ ];\r\n\r\n\t\t\t\tif ( hasMaterial ) {\r\n\r\n\t\t\t\t\tmaterialIndex = faces[ offset ++ ];\r\n\t\t\t\t\tface.materialIndex = materialIndex;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// to get face <=> uv index correspondence\r\n\r\n\t\t\t\tfi = geometry.faces.length;\r\n\r\n\t\t\t\tif ( hasFaceVertexUv ) {\r\n\r\n\t\t\t\t\tfor ( i = 0; i < nUvLayers; i ++ ) {\r\n\r\n\t\t\t\t\t\tuvLayer = json.uvs[ i ];\r\n\r\n\t\t\t\t\t\tgeometry.faceVertexUvs[ i ][ fi ] = [];\r\n\r\n\t\t\t\t\t\tfor ( j = 0; j < 3; j ++ ) {\r\n\r\n\t\t\t\t\t\t\tuvIndex = faces[ offset ++ ];\r\n\r\n\t\t\t\t\t\t\tu = uvLayer[ uvIndex * 2 ];\r\n\t\t\t\t\t\t\tv = uvLayer[ uvIndex * 2 + 1 ];\r\n\r\n\t\t\t\t\t\t\tuv = new THREE.Vector2( u, v );\r\n\r\n\t\t\t\t\t\t\tgeometry.faceVertexUvs[ i ][ fi ].push( uv );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( hasFaceNormal ) {\r\n\r\n\t\t\t\t\tnormalIndex = faces[ offset ++ ] * 3;\r\n\r\n\t\t\t\t\tface.normal.set(\r\n\t\t\t\t\t\tnormals[ normalIndex ++ ],\r\n\t\t\t\t\t\tnormals[ normalIndex ++ ],\r\n\t\t\t\t\t\tnormals[ normalIndex ]\r\n\t\t\t\t\t);\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( hasFaceVertexNormal ) {\r\n\r\n\t\t\t\t\tfor ( i = 0; i < 3; i ++ ) {\r\n\r\n\t\t\t\t\t\tnormalIndex = faces[ offset ++ ] * 3;\r\n\r\n\t\t\t\t\t\tnormal = new THREE.Vector3(\r\n\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\r\n\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\r\n\t\t\t\t\t\t\tnormals[ normalIndex ]\r\n\t\t\t\t\t\t);\r\n\r\n\t\t\t\t\t\tface.vertexNormals.push( normal );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\r\n\t\t\t\tif ( hasFaceColor ) {\r\n\r\n\t\t\t\t\tcolorIndex = faces[ offset ++ ];\r\n\t\t\t\t\tface.color.setHex( colors[ colorIndex ] );\r\n\r\n\t\t\t\t}\r\n\r\n\r\n\t\t\t\tif ( hasFaceVertexColor ) {\r\n\r\n\t\t\t\t\tfor ( i = 0; i < 3; i ++ ) {\r\n\r\n\t\t\t\t\t\tcolorIndex = faces[ offset ++ ];\r\n\t\t\t\t\t\tface.vertexColors.push( new THREE.Color( colors[ colorIndex ] ) );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tgeometry.faces.push( face );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tfunction parseSkin() {\r\n\t\tvar influencesPerVertex = ( json.influencesPerVertex !== undefined ) ? json.influencesPerVertex : 2;\r\n\r\n\t\tif ( json.skinWeights ) {\r\n\r\n\t\t\tfor ( var i = 0, l = json.skinWeights.length; i < l; i += influencesPerVertex ) {\r\n\r\n\t\t\t\tvar x =                               json.skinWeights[ i     ];\r\n\t\t\t\tvar y = ( influencesPerVertex > 1 ) ? json.skinWeights[ i + 1 ] : 0;\r\n\t\t\t\tvar z = ( influencesPerVertex > 2 ) ? json.skinWeights[ i + 2 ] : 0;\r\n\t\t\t\tvar w = ( influencesPerVertex > 3 ) ? json.skinWeights[ i + 3 ] : 0;\r\n\r\n\t\t\t\tgeometry.skinWeights.push( new THREE.Vector4( x, y, z, w ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( json.skinIndices ) {\r\n\r\n\t\t\tfor ( var i = 0, l = json.skinIndices.length; i < l; i += influencesPerVertex ) {\r\n\r\n\t\t\t\tvar a =                               json.skinIndices[ i     ];\r\n\t\t\t\tvar b = ( influencesPerVertex > 1 ) ? json.skinIndices[ i + 1 ] : 0;\r\n\t\t\t\tvar c = ( influencesPerVertex > 2 ) ? json.skinIndices[ i + 2 ] : 0;\r\n\t\t\t\tvar d = ( influencesPerVertex > 3 ) ? json.skinIndices[ i + 3 ] : 0;\r\n\r\n\t\t\t\tgeometry.skinIndices.push( new THREE.Vector4( a, b, c, d ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tgeometry.bones = json.bones;\r\n\r\n\t\tif ( geometry.bones && geometry.bones.length > 0 && ( geometry.skinWeights.length !== geometry.skinIndices.length || geometry.skinIndices.length !== geometry.vertices.length ) ) {\r\n\r\n\t\t\tTHREE.warn( 'THREE.JSONLoader: When skinning, number of vertices (' + geometry.vertices.length + '), skinIndices (' +\r\n\t\t\t\t\tgeometry.skinIndices.length + '), and skinWeights (' + geometry.skinWeights.length + ') should match.' );\r\n\r\n\t\t}\r\n\r\n\r\n\t\t// could change this to json.animations[0] or remove completely\r\n\r\n\t\tgeometry.animation = json.animation;\r\n\t\tgeometry.animations = json.animations;\r\n\r\n\t};\r\n\r\n\tfunction parseMorphing( scale ) {\r\n\r\n\t\tif ( json.morphTargets !== undefined ) {\r\n\r\n\t\t\tvar i, l, v, vl, dstVertices, srcVertices;\r\n\r\n\t\t\tfor ( i = 0, l = json.morphTargets.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tgeometry.morphTargets[ i ] = {};\r\n\t\t\t\tgeometry.morphTargets[ i ].name = json.morphTargets[ i ].name;\r\n\t\t\t\tgeometry.morphTargets[ i ].vertices = [];\r\n\r\n\t\t\t\tdstVertices = geometry.morphTargets[ i ].vertices;\r\n\t\t\t\tsrcVertices = json.morphTargets [ i ].vertices;\r\n\r\n\t\t\t\tfor ( v = 0, vl = srcVertices.length; v < vl; v += 3 ) {\r\n\r\n\t\t\t\t\tvar vertex = new THREE.Vector3();\r\n\t\t\t\t\tvertex.x = srcVertices[ v ] * scale;\r\n\t\t\t\t\tvertex.y = srcVertices[ v + 1 ] * scale;\r\n\t\t\t\t\tvertex.z = srcVertices[ v + 2 ] * scale;\r\n\r\n\t\t\t\t\tdstVertices.push( vertex );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( json.morphColors !== undefined ) {\r\n\r\n\t\t\tvar i, l, c, cl, dstColors, srcColors, color;\r\n\r\n\t\t\tfor ( i = 0, l = json.morphColors.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tgeometry.morphColors[ i ] = {};\r\n\t\t\t\tgeometry.morphColors[ i ].name = json.morphColors[ i ].name;\r\n\t\t\t\tgeometry.morphColors[ i ].colors = [];\r\n\r\n\t\t\t\tdstColors = geometry.morphColors[ i ].colors;\r\n\t\t\t\tsrcColors = json.morphColors [ i ].colors;\r\n\r\n\t\t\t\tfor ( c = 0, cl = srcColors.length; c < cl; c += 3 ) {\r\n\r\n\t\t\t\t\tcolor = new THREE.Color( 0xffaa00 );\r\n\t\t\t\t\tcolor.setRGB( srcColors[ c ], srcColors[ c + 1 ], srcColors[ c + 2 ] );\r\n\t\t\t\t\tdstColors.push( color );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tif ( json.materials === undefined || json.materials.length === 0 ) {\r\n\r\n\t\treturn { geometry: geometry };\r\n\r\n\t} else {\r\n\r\n\t\tvar materials = this.initMaterials( json.materials, texturePath );\r\n\r\n\t\tif ( this.needsTangents( materials ) ) {\r\n\r\n\t\t\tgeometry.computeTangents();\r\n\r\n\t\t}\r\n\r\n\t\treturn { geometry: geometry, materials: materials };\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/loaders/LoadingManager.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.LoadingManager = function ( onLoad, onProgress, onError ) {\r\n\r\n\tvar scope = this;\r\n\r\n\tvar loaded = 0, total = 0;\r\n\r\n\tthis.onLoad = onLoad;\r\n\tthis.onProgress = onProgress;\r\n\tthis.onError = onError;\r\n\r\n\tthis.itemStart = function ( url ) {\r\n\r\n\t\ttotal ++;\r\n\r\n\t};\r\n\r\n\tthis.itemEnd = function ( url ) {\r\n\r\n\t\tloaded ++;\r\n\r\n\t\tif ( scope.onProgress !== undefined ) {\r\n\r\n\t\t\tscope.onProgress( url, loaded, total );\r\n\r\n\t\t}\r\n\r\n\t\tif ( loaded === total && scope.onLoad !== undefined ) {\r\n\r\n\t\t\tscope.onLoad();\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n};\r\n\r\nTHREE.DefaultLoadingManager = new THREE.LoadingManager();\r\n\r\n// File:src/loaders/BufferGeometryLoader.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.BufferGeometryLoader = function ( manager ) {\r\n\r\n\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\r\n\r\n};\r\n\r\nTHREE.BufferGeometryLoader.prototype = {\r\n\r\n\tconstructor: THREE.BufferGeometryLoader,\r\n\r\n\tload: function ( url, onLoad, onProgress, onError ) {\r\n\r\n\t\tvar scope = this;\r\n\r\n\t\tvar loader = new THREE.XHRLoader( scope.manager );\r\n\t\tloader.setCrossOrigin( this.crossOrigin );\r\n\t\tloader.load( url, function ( text ) {\r\n\r\n\t\t\tonLoad( scope.parse( JSON.parse( text ) ) );\r\n\r\n\t\t}, onProgress, onError );\r\n\r\n\t},\r\n\r\n\tsetCrossOrigin: function ( value ) {\r\n\r\n\t\tthis.crossOrigin = value;\r\n\r\n\t},\r\n\r\n\tparse: function ( json ) {\r\n\r\n\t\tvar geometry = new THREE.BufferGeometry();\r\n\r\n\t\tvar attributes = json.data.attributes;\r\n\r\n\t\tfor ( var key in attributes ) {\r\n\r\n\t\t\tvar attribute = attributes[ key ];\r\n\t\t\tvar typedArray = new self[ attribute.type ]( attribute.array );\r\n\r\n\t\t\tgeometry.addAttribute( key, new THREE.BufferAttribute( typedArray, attribute.itemSize ) );\r\n\r\n\t\t}\r\n\r\n\t\tvar offsets = json.data.offsets;\r\n\r\n\t\tif ( offsets !== undefined ) {\r\n\r\n\t\t\tgeometry.offsets = JSON.parse( JSON.stringify( offsets ) );\r\n\r\n\t\t}\r\n\r\n\t\tvar boundingSphere = json.data.boundingSphere;\r\n\r\n\t\tif ( boundingSphere !== undefined ) {\r\n\r\n\t\t\tvar center = new THREE.Vector3();\r\n\r\n\t\t\tif ( boundingSphere.center !== undefined ) {\r\n\r\n\t\t\t\tcenter.fromArray( boundingSphere.center );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tgeometry.boundingSphere = new THREE.Sphere( center, boundingSphere.radius );\r\n\r\n\t\t}\r\n\r\n\t\treturn geometry;\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/loaders/MaterialLoader.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.MaterialLoader = function ( manager ) {\r\n\r\n\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\r\n\r\n};\r\n\r\nTHREE.MaterialLoader.prototype = {\r\n\r\n\tconstructor: THREE.MaterialLoader,\r\n\r\n\tload: function ( url, onLoad, onProgress, onError ) {\r\n\r\n\t\tvar scope = this;\r\n\r\n\t\tvar loader = new THREE.XHRLoader( scope.manager );\r\n\t\tloader.setCrossOrigin( this.crossOrigin );\r\n\t\tloader.load( url, function ( text ) {\r\n\r\n\t\t\tonLoad( scope.parse( JSON.parse( text ) ) );\r\n\r\n\t\t}, onProgress, onError );\r\n\r\n\t},\r\n\r\n\tsetCrossOrigin: function ( value ) {\r\n\r\n\t\tthis.crossOrigin = value;\r\n\r\n\t},\r\n\r\n\tparse: function ( json ) {\r\n\r\n\t\tvar material = new THREE[ json.type ];\r\n\r\n\t\tif ( json.color !== undefined ) material.color.setHex( json.color );\r\n\t\tif ( json.emissive !== undefined ) material.emissive.setHex( json.emissive );\r\n\t\tif ( json.specular !== undefined ) material.specular.setHex( json.specular );\r\n\t\tif ( json.shininess !== undefined ) material.shininess = json.shininess;\r\n\t\tif ( json.uniforms !== undefined ) material.uniforms = json.uniforms;\r\n\t\tif ( json.vertexShader !== undefined ) material.vertexShader = json.vertexShader;\r\n\t\tif ( json.fragmentShader !== undefined ) material.fragmentShader = json.fragmentShader;\r\n\t\tif ( json.vertexColors !== undefined ) material.vertexColors = json.vertexColors;\r\n\t\tif ( json.shading !== undefined ) material.shading = json.shading;\r\n\t\tif ( json.blending !== undefined ) material.blending = json.blending;\r\n\t\tif ( json.side !== undefined ) material.side = json.side;\r\n\t\tif ( json.opacity !== undefined ) material.opacity = json.opacity;\r\n\t\tif ( json.transparent !== undefined ) material.transparent = json.transparent;\r\n\t\tif ( json.wireframe !== undefined ) material.wireframe = json.wireframe;\r\n\r\n\t\t// for PointCloudMaterial\r\n\t\tif ( json.size !== undefined ) material.size = json.size;\r\n\t\tif ( json.sizeAttenuation !== undefined ) material.sizeAttenuation = json.sizeAttenuation;\r\n\r\n\t\tif ( json.materials !== undefined ) {\r\n\r\n\t\t\tfor ( var i = 0, l = json.materials.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tmaterial.materials.push( this.parse( json.materials[ i ] ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn material;\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/loaders/ObjectLoader.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.ObjectLoader = function ( manager ) {\r\n\r\n\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\r\n\tthis.texturePath = '';\r\n\r\n};\r\n\r\nTHREE.ObjectLoader.prototype = {\r\n\r\n\tconstructor: THREE.ObjectLoader,\r\n\r\n\tload: function ( url, onLoad, onProgress, onError ) {\r\n\r\n\t\tif ( this.texturePath === '' ) {\r\n\r\n\t\t\tthis.texturePath = url.substring( 0, url.lastIndexOf( '/' ) + 1 );\r\n\r\n\t\t}\r\n\r\n\t\tvar scope = this;\r\n\r\n\t\tvar loader = new THREE.XHRLoader( scope.manager );\r\n\t\tloader.setCrossOrigin( this.crossOrigin );\r\n\t\tloader.load( url, function ( text ) {\r\n\r\n\t\t\tscope.parse( JSON.parse( text ), onLoad );\r\n\r\n\t\t}, onProgress, onError );\r\n\r\n\t},\r\n\r\n\tsetTexturePath: function ( value ) {\r\n\r\n\t\tthis.texturePath = value;\r\n\r\n\t},\r\n\r\n\tsetCrossOrigin: function ( value ) {\r\n\r\n\t\tthis.crossOrigin = value;\r\n\r\n\t},\r\n\r\n\tparse: function ( json, onLoad ) {\r\n\r\n\t\tvar geometries = this.parseGeometries( json.geometries );\r\n\r\n\t\tvar images = this.parseImages( json.images, function () {\r\n\r\n\t\t\tif ( onLoad !== undefined ) onLoad( object );\r\n\r\n\t\t} );\r\n\t\tvar textures  = this.parseTextures( json.textures, images );\r\n\t\tvar materials = this.parseMaterials( json.materials, textures );\r\n\t\tvar object = this.parseObject( json.object, geometries, materials );\r\n\r\n\t\tif ( json.images === undefined || json.images.length === 0 ) {\r\n\r\n\t\t\tif ( onLoad !== undefined ) onLoad( object );\r\n\r\n\t\t}\r\n\r\n\t\treturn object;\r\n\r\n\t},\r\n\r\n\tparseGeometries: function ( json ) {\r\n\r\n\t\tvar geometries = {};\r\n\r\n\t\tif ( json !== undefined ) {\r\n\r\n\t\t\tvar geometryLoader = new THREE.JSONLoader();\r\n\t\t\tvar bufferGeometryLoader = new THREE.BufferGeometryLoader();\r\n\r\n\t\t\tfor ( var i = 0, l = json.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tvar geometry;\r\n\t\t\t\tvar data = json[ i ];\r\n\r\n\t\t\t\tswitch ( data.type ) {\r\n\r\n\t\t\t\t\tcase 'PlaneGeometry':\r\n\t\t\t\t\tcase 'PlaneBufferGeometry':\r\n\r\n\t\t\t\t\t\tgeometry = new THREE[ data.type ](\r\n\t\t\t\t\t\t\tdata.width,\r\n\t\t\t\t\t\t\tdata.height,\r\n\t\t\t\t\t\t\tdata.widthSegments,\r\n\t\t\t\t\t\t\tdata.heightSegments\r\n\t\t\t\t\t\t);\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'BoxGeometry':\r\n\t\t\t\t\tcase 'CubeGeometry': // backwards compatible\r\n\r\n\t\t\t\t\t\tgeometry = new THREE.BoxGeometry(\r\n\t\t\t\t\t\t\tdata.width,\r\n\t\t\t\t\t\t\tdata.height,\r\n\t\t\t\t\t\t\tdata.depth,\r\n\t\t\t\t\t\t\tdata.widthSegments,\r\n\t\t\t\t\t\t\tdata.heightSegments,\r\n\t\t\t\t\t\t\tdata.depthSegments\r\n\t\t\t\t\t\t);\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'CircleGeometry':\r\n\r\n\t\t\t\t\t\tgeometry = new THREE.CircleGeometry(\r\n\t\t\t\t\t\t\tdata.radius,\r\n\t\t\t\t\t\t\tdata.segments\r\n\t\t\t\t\t\t);\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'CylinderGeometry':\r\n\r\n\t\t\t\t\t\tgeometry = new THREE.CylinderGeometry(\r\n\t\t\t\t\t\t\tdata.radiusTop,\r\n\t\t\t\t\t\t\tdata.radiusBottom,\r\n\t\t\t\t\t\t\tdata.height,\r\n\t\t\t\t\t\t\tdata.radialSegments,\r\n\t\t\t\t\t\t\tdata.heightSegments,\r\n\t\t\t\t\t\t\tdata.openEnded\r\n\t\t\t\t\t\t);\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'SphereGeometry':\r\n\r\n\t\t\t\t\t\tgeometry = new THREE.SphereGeometry(\r\n\t\t\t\t\t\t\tdata.radius,\r\n\t\t\t\t\t\t\tdata.widthSegments,\r\n\t\t\t\t\t\t\tdata.heightSegments,\r\n\t\t\t\t\t\t\tdata.phiStart,\r\n\t\t\t\t\t\t\tdata.phiLength,\r\n\t\t\t\t\t\t\tdata.thetaStart,\r\n\t\t\t\t\t\t\tdata.thetaLength\r\n\t\t\t\t\t\t);\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'IcosahedronGeometry':\r\n\r\n\t\t\t\t\t\tgeometry = new THREE.IcosahedronGeometry(\r\n\t\t\t\t\t\t\tdata.radius,\r\n\t\t\t\t\t\t\tdata.detail\r\n\t\t\t\t\t\t);\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'TorusGeometry':\r\n\r\n\t\t\t\t\t\tgeometry = new THREE.TorusGeometry(\r\n\t\t\t\t\t\t\tdata.radius,\r\n\t\t\t\t\t\t\tdata.tube,\r\n\t\t\t\t\t\t\tdata.radialSegments,\r\n\t\t\t\t\t\t\tdata.tubularSegments,\r\n\t\t\t\t\t\t\tdata.arc\r\n\t\t\t\t\t\t);\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'TorusKnotGeometry':\r\n\r\n\t\t\t\t\t\tgeometry = new THREE.TorusKnotGeometry(\r\n\t\t\t\t\t\t\tdata.radius,\r\n\t\t\t\t\t\t\tdata.tube,\r\n\t\t\t\t\t\t\tdata.radialSegments,\r\n\t\t\t\t\t\t\tdata.tubularSegments,\r\n\t\t\t\t\t\t\tdata.p,\r\n\t\t\t\t\t\t\tdata.q,\r\n\t\t\t\t\t\t\tdata.heightScale\r\n\t\t\t\t\t\t);\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'BufferGeometry':\r\n\r\n\t\t\t\t\t\tgeometry = bufferGeometryLoader.parse( data );\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'Geometry':\r\n\r\n\t\t\t\t\t\tgeometry = geometryLoader.parse( data.data ).geometry;\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tgeometry.uuid = data.uuid;\r\n\r\n\t\t\t\tif ( data.name !== undefined ) geometry.name = data.name;\r\n\r\n\t\t\t\tgeometries[ data.uuid ] = geometry;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn geometries;\r\n\r\n\t},\r\n\r\n\tparseMaterials: function ( json, textures ) {\r\n\r\n\t\tvar materials = {};\r\n\r\n\t\tif ( json !== undefined ) {\r\n\r\n\t\t\tvar getTexture = function ( name ) {\r\n\r\n\t\t\t\tif ( textures[ name ] === undefined ) {\r\n\r\n\t\t\t\t\tTHREE.warn( 'THREE.ObjectLoader: Undefined texture', name );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn textures[ name ];\r\n\r\n\t\t\t};\r\n\r\n\t\t\tvar loader = new THREE.MaterialLoader();\r\n\r\n\t\t\tfor ( var i = 0, l = json.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tvar data = json[ i ];\r\n\t\t\t\tvar material = loader.parse( data );\r\n\r\n\t\t\t\tmaterial.uuid = data.uuid;\r\n\r\n\t\t\t\tif ( data.name !== undefined ) material.name = data.name;\r\n\r\n\t\t\t\tif ( data.map !== undefined ) {\r\n\r\n\t\t\t\t\tmaterial.map = getTexture( data.map );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( data.bumpMap !== undefined ) {\r\n\r\n\t\t\t\t\tmaterial.bumpMap = getTexture( data.bumpMap );\r\n\t\t\t\t\tif ( data.bumpScale ) {\r\n\t\t\t\t\t\tmaterial.bumpScale = new THREE.Vector2( data.bumpScale, data.bumpScale );\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( data.alphaMap !== undefined ) {\r\n\r\n\t\t\t\t\tmaterial.alphaMap = getTexture( data.alphaMap );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( data.envMap !== undefined ) {\r\n\r\n\t\t\t\t\tmaterial.envMap = getTexture( data.envMap );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( data.normalMap !== undefined ) {\r\n\r\n\t\t\t\t\tmaterial.normalMap = getTexture( data.normalMap );\r\n\t\t\t\t\tif ( data.normalScale ) {\r\n\t\t\t\t\t\tmaterial.normalScale = new THREE.Vector2( data.normalScale, data.normalScale );\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( data.lightMap !== undefined ) {\r\n\r\n\t\t\t\t\tmaterial.lightMap = getTexture( data.lightMap );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( data.specularMap !== undefined ) {\r\n\r\n\t\t\t\t\tmaterial.specularMap = getTexture( data.specularMap );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tmaterials[ data.uuid ] = material;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn materials;\r\n\r\n\t},\r\n\r\n\tparseImages: function ( json, onLoad ) {\r\n\r\n\t\tvar scope = this;\r\n\t\tvar images = {};\r\n\r\n\t\tif ( json !== undefined && json.length > 0 ) {\r\n\r\n\t\t\tvar manager = new THREE.LoadingManager( onLoad );\r\n\r\n\t\t\tvar loader = new THREE.ImageLoader( manager );\r\n\t\t\tloader.setCrossOrigin( this.crossOrigin );\r\n\r\n\t\t\tvar loadImage = function ( url ) {\r\n\r\n\t\t\t\tscope.manager.itemStart( url );\r\n\r\n\t\t\t\treturn loader.load( url, function () {\r\n\r\n\t\t\t\t\tscope.manager.itemEnd( url );\r\n\r\n\t\t\t\t} );\r\n\r\n\t\t\t};\r\n\r\n\t\t\tfor ( var i = 0, l = json.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tvar image = json[ i ];\r\n\t\t\t\tvar path = /^(\\/\\/)|([a-z]+:(\\/\\/)?)/i.test( image.url ) ? image.url : scope.texturePath + image.url;\r\n\r\n\t\t\t\timages[ image.uuid ] = loadImage( path );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn images;\r\n\r\n\t},\r\n\r\n\tparseTextures: function ( json, images ) {\r\n\r\n\t\tvar textures = {};\r\n\r\n\t\tif ( json !== undefined ) {\r\n\r\n\t\t\tfor ( var i = 0, l = json.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tvar data = json[ i ];\r\n\r\n\t\t\t\tif ( data.image === undefined ) {\r\n\r\n\t\t\t\t\tTHREE.warn( 'THREE.ObjectLoader: No \"image\" speficied for', data.uuid );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( images[ data.image ] === undefined ) {\r\n\r\n\t\t\t\t\tTHREE.warn( 'THREE.ObjectLoader: Undefined image', data.image );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tvar texture = new THREE.Texture( images[ data.image ] );\r\n\t\t\t\ttexture.needsUpdate = true;\r\n\r\n\t\t\t\ttexture.uuid = data.uuid;\r\n\r\n\t\t\t\tif ( data.name !== undefined ) texture.name = data.name;\r\n\t\t\t\tif ( data.repeat !== undefined ) texture.repeat = new THREE.Vector2( data.repeat[ 0 ], data.repeat[ 1 ] );\r\n\t\t\t\tif ( data.minFilter !== undefined ) texture.minFilter = THREE[ data.minFilter ];\r\n\t\t\t\tif ( data.magFilter !== undefined ) texture.magFilter = THREE[ data.magFilter ];\r\n\t\t\t\tif ( data.anisotropy !== undefined ) texture.anisotropy = data.anisotropy;\r\n\t\t\t\tif ( data.wrap instanceof Array ) {\r\n\r\n\t\t\t\t\ttexture.wrapS = THREE[ data.wrap[ 0 ] ];\r\n\t\t\t\t\ttexture.wrapT = THREE[ data.wrap[ 1 ] ];\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\ttextures[ data.uuid ] = texture;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn textures;\r\n\r\n\t},\r\n\r\n\tparseObject: function () {\r\n\r\n\t\tvar matrix = new THREE.Matrix4();\r\n\r\n\t\treturn function ( data, geometries, materials ) {\r\n\r\n\t\t\tvar object;\r\n\r\n\t\t\tvar getGeometry = function ( name ) {\r\n\r\n\t\t\t\tif ( geometries[ name ] === undefined ) {\r\n\r\n\t\t\t\t\tTHREE.warn( 'THREE.ObjectLoader: Undefined geometry', name );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn geometries[ name ];\r\n\r\n\t\t\t};\r\n\r\n\t\t\tvar getMaterial = function ( name ) {\r\n\r\n\t\t\t\tif ( materials[ name ] === undefined ) {\r\n\r\n\t\t\t\t\tTHREE.warn( 'THREE.ObjectLoader: Undefined material', name );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn materials[ name ];\r\n\r\n\t\t\t};\r\n\r\n\t\t\tswitch ( data.type ) {\r\n\r\n\t\t\t\tcase 'Scene':\r\n\r\n\t\t\t\t\tobject = new THREE.Scene();\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'PerspectiveCamera':\r\n\r\n\t\t\t\t\tobject = new THREE.PerspectiveCamera( data.fov, data.aspect, data.near, data.far );\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'OrthographicCamera':\r\n\r\n\t\t\t\t\tobject = new THREE.OrthographicCamera( data.left, data.right, data.top, data.bottom, data.near, data.far );\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'AmbientLight':\r\n\r\n\t\t\t\t\tobject = new THREE.AmbientLight( data.color );\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'DirectionalLight':\r\n\r\n\t\t\t\t\tobject = new THREE.DirectionalLight( data.color, data.intensity );\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'PointLight':\r\n\r\n\t\t\t\t\tobject = new THREE.PointLight( data.color, data.intensity, data.distance, data.decay );\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'SpotLight':\r\n\r\n\t\t\t\t\tobject = new THREE.SpotLight( data.color, data.intensity, data.distance, data.angle, data.exponent, data.decay );\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'HemisphereLight':\r\n\r\n\t\t\t\t\tobject = new THREE.HemisphereLight( data.color, data.groundColor, data.intensity );\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'Mesh':\r\n\r\n\t\t\t\t\tobject = new THREE.Mesh( getGeometry( data.geometry ), getMaterial( data.material ) );\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'Line':\r\n\r\n\t\t\t\t\tobject = new THREE.Line( getGeometry( data.geometry ), getMaterial( data.material ), data.mode );\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'PointCloud':\r\n\r\n\t\t\t\t\tobject = new THREE.PointCloud( getGeometry( data.geometry ), getMaterial( data.material ) );\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'Sprite':\r\n\r\n\t\t\t\t\tobject = new THREE.Sprite( getMaterial( data.material ) );\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'Group':\r\n\r\n\t\t\t\t\tobject = new THREE.Group();\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tdefault:\r\n\r\n\t\t\t\t\tobject = new THREE.Object3D();\r\n\r\n\t\t\t}\r\n\r\n\t\t\tobject.uuid = data.uuid;\r\n\r\n\t\t\tif ( data.name !== undefined ) object.name = data.name;\r\n\t\t\tif ( data.matrix !== undefined ) {\r\n\r\n\t\t\t\tmatrix.fromArray( data.matrix );\r\n\t\t\t\tmatrix.decompose( object.position, object.quaternion, object.scale );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tif ( data.position !== undefined ) object.position.fromArray( data.position );\r\n\t\t\t\tif ( data.rotation !== undefined ) object.rotation.fromArray( data.rotation );\r\n\t\t\t\tif ( data.scale !== undefined ) object.scale.fromArray( data.scale );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( data.visible !== undefined ) object.visible = data.visible;\r\n\t\t\tif ( data.userData !== undefined ) object.userData = data.userData;\r\n\r\n\t\t\tif ( data.children !== undefined ) {\r\n\r\n\t\t\t\tfor ( var child in data.children ) {\r\n\r\n\t\t\t\t\tobject.add( this.parseObject( data.children[ child ], geometries, materials ) );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn object;\r\n\r\n\t\t}\r\n\r\n\t}()\r\n\r\n};\r\n\r\n// File:src/loaders/TextureLoader.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.TextureLoader = function ( manager ) {\r\n\r\n\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\r\n\r\n};\r\n\r\nTHREE.TextureLoader.prototype = {\r\n\r\n\tconstructor: THREE.TextureLoader,\r\n\r\n\tload: function ( url, onLoad, onProgress, onError ) {\r\n\r\n\t\tvar scope = this;\r\n\r\n\t\tvar loader = new THREE.ImageLoader( scope.manager );\r\n\t\tloader.setCrossOrigin( this.crossOrigin );\r\n\t\tloader.load( url, function ( image ) {\r\n\r\n\t\t\tvar texture = new THREE.Texture( image );\r\n\t\t\ttexture.needsUpdate = true;\r\n\r\n\t\t\tif ( onLoad !== undefined ) {\r\n\r\n\t\t\t\tonLoad( texture );\r\n\r\n\t\t\t}\r\n\r\n\t\t}, onProgress, onError );\r\n\r\n\t},\r\n\r\n\tsetCrossOrigin: function ( value ) {\r\n\r\n\t\tthis.crossOrigin = value;\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/loaders/BinaryTextureLoader.js\r\n\r\n/**\r\n * @author Nikos M. / https://github.com/foo123/\r\n *\r\n * Abstract Base class to load generic binary textures formats (rgbe, hdr, ...)\r\n */\r\n\r\nTHREE.DataTextureLoader = THREE.BinaryTextureLoader = function () {\r\n\r\n\t// override in sub classes\r\n\tthis._parser = null;\r\n\r\n};\r\n\r\nTHREE.BinaryTextureLoader.prototype = {\r\n\r\n\tconstructor: THREE.BinaryTextureLoader,\r\n\r\n\tload: function ( url, onLoad, onProgress, onError ) {\r\n\r\n\t\tvar scope = this;\r\n\r\n\t\tvar texture = new THREE.DataTexture( );\r\n\r\n\t\tvar loader = new THREE.XHRLoader();\r\n\t\tloader.setResponseType( 'arraybuffer' );\r\n\r\n\t\tloader.load( url, function ( buffer ) {\r\n\r\n\t\t\tvar texData = scope._parser( buffer );\r\n\r\n\t\t\tif ( !texData ) return;\r\n\r\n\t\t\tif ( undefined !== texData.image ) {\r\n\r\n\t\t\t\ttexture.image = texData.image;\r\n\r\n\t\t\t} else if ( undefined !== texData.data ) {\r\n\r\n\t\t\t\ttexture.image.width = texData.width;\r\n\t\t\t\ttexture.image.height = texData.height;\r\n\t\t\t\ttexture.image.data = texData.data;\r\n\r\n\t\t\t}\r\n\r\n\t\t\ttexture.wrapS = undefined !== texData.wrapS ? texData.wrapS : THREE.ClampToEdgeWrapping;\r\n\t\t\ttexture.wrapT = undefined !== texData.wrapT ? texData.wrapT : THREE.ClampToEdgeWrapping;\r\n\r\n\t\t\ttexture.magFilter = undefined !== texData.magFilter ? texData.magFilter : THREE.LinearFilter;\r\n\t\t\ttexture.minFilter = undefined !== texData.minFilter ? texData.minFilter : THREE.LinearMipMapLinearFilter;\r\n\r\n\t\t\ttexture.anisotropy = undefined !== texData.anisotropy ? texData.anisotropy : 1;\r\n\r\n\t\t\tif ( undefined !== texData.format ) {\r\n\r\n\t\t\t\ttexture.format = texData.format;\r\n\r\n\t\t\t}\r\n\t\t\tif ( undefined !== texData.type ) {\r\n\r\n\t\t\t\ttexture.type = texData.type;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( undefined !== texData.mipmaps ) {\r\n\r\n\t\t\t\ttexture.mipmaps = texData.mipmaps;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( 1 === texData.mipmapCount ) {\r\n\r\n\t\t\t\ttexture.minFilter = THREE.LinearFilter;\r\n\r\n\t\t\t}\r\n\r\n\t\t\ttexture.needsUpdate = true;\r\n\r\n\t\t\tif ( onLoad ) onLoad( texture, texData );\r\n\r\n\t\t}, onProgress, onError );\r\n\r\n\r\n\t\treturn texture;\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/loaders/CompressedTextureLoader.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n *\r\n * Abstract Base class to block based textures loader (dds, pvr, ...)\r\n */\r\n\r\nTHREE.CompressedTextureLoader = function () {\r\n\r\n\t// override in sub classes\r\n\tthis._parser = null;\r\n\r\n};\r\n\r\n\r\nTHREE.CompressedTextureLoader.prototype = {\r\n\r\n\tconstructor: THREE.CompressedTextureLoader,\r\n\r\n\tload: function ( url, onLoad, onError ) {\r\n\r\n\t\tvar scope = this;\r\n\r\n\t\tvar images = [];\r\n\r\n\t\tvar texture = new THREE.CompressedTexture();\r\n\t\ttexture.image = images;\r\n\r\n\t\tvar loader = new THREE.XHRLoader();\r\n\t\tloader.setResponseType( 'arraybuffer' );\r\n\r\n\t\tif ( url instanceof Array ) {\r\n\r\n\t\t\tvar loaded = 0;\r\n\r\n\t\t\tvar loadTexture = function ( i ) {\r\n\r\n\t\t\t\tloader.load( url[ i ], function ( buffer ) {\r\n\r\n\t\t\t\t\tvar texDatas = scope._parser( buffer, true );\r\n\r\n\t\t\t\t\timages[ i ] = {\r\n\t\t\t\t\t\twidth: texDatas.width,\r\n\t\t\t\t\t\theight: texDatas.height,\r\n\t\t\t\t\t\tformat: texDatas.format,\r\n\t\t\t\t\t\tmipmaps: texDatas.mipmaps\r\n\t\t\t\t\t};\r\n\r\n\t\t\t\t\tloaded += 1;\r\n\r\n\t\t\t\t\tif ( loaded === 6 ) {\r\n\r\n\t\t\t\t\t\tif (texDatas.mipmapCount == 1)\r\n \t\t\t\t\t\t\ttexture.minFilter = THREE.LinearFilter;\r\n\r\n\t\t\t\t\t\ttexture.format = texDatas.format;\r\n\t\t\t\t\t\ttexture.needsUpdate = true;\r\n\r\n\t\t\t\t\t\tif ( onLoad ) onLoad( texture );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} );\r\n\r\n\t\t\t};\r\n\r\n\t\t\tfor ( var i = 0, il = url.length; i < il; ++ i ) {\r\n\r\n\t\t\t\tloadTexture( i );\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\t// compressed cubemap texture stored in a single DDS file\r\n\r\n\t\t\tloader.load( url, function ( buffer ) {\r\n\r\n\t\t\t\tvar texDatas = scope._parser( buffer, true );\r\n\r\n\t\t\t\tif ( texDatas.isCubemap ) {\r\n\r\n\t\t\t\t\tvar faces = texDatas.mipmaps.length / texDatas.mipmapCount;\r\n\r\n\t\t\t\t\tfor ( var f = 0; f < faces; f ++ ) {\r\n\r\n\t\t\t\t\t\timages[ f ] = { mipmaps : [] };\r\n\r\n\t\t\t\t\t\tfor ( var i = 0; i < texDatas.mipmapCount; i ++ ) {\r\n\r\n\t\t\t\t\t\t\timages[ f ].mipmaps.push( texDatas.mipmaps[ f * texDatas.mipmapCount + i ] );\r\n\t\t\t\t\t\t\timages[ f ].format = texDatas.format;\r\n\t\t\t\t\t\t\timages[ f ].width = texDatas.width;\r\n\t\t\t\t\t\t\timages[ f ].height = texDatas.height;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\ttexture.image.width = texDatas.width;\r\n\t\t\t\t\ttexture.image.height = texDatas.height;\r\n\t\t\t\t\ttexture.mipmaps = texDatas.mipmaps;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( texDatas.mipmapCount === 1 ) {\r\n\r\n\t\t\t\t\ttexture.minFilter = THREE.LinearFilter;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\ttexture.format = texDatas.format;\r\n\t\t\t\ttexture.needsUpdate = true;\r\n\r\n\t\t\t\tif ( onLoad ) onLoad( texture );\r\n\r\n\t\t\t} );\r\n\r\n\t\t}\r\n\r\n\t\treturn texture;\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/materials/Material.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.Material = function () {\r\n\r\n\tObject.defineProperty( this, 'id', { value: THREE.MaterialIdCount ++ } );\r\n\r\n\tthis.uuid = THREE.Math.generateUUID();\r\n\r\n\tthis.name = '';\r\n\tthis.type = 'Material';\r\n\r\n\tthis.side = THREE.FrontSide;\r\n\r\n\tthis.opacity = 1;\r\n\tthis.transparent = false;\r\n\r\n\tthis.blending = THREE.NormalBlending;\r\n\r\n\tthis.blendSrc = THREE.SrcAlphaFactor;\r\n\tthis.blendDst = THREE.OneMinusSrcAlphaFactor;\r\n\tthis.blendEquation = THREE.AddEquation;\r\n\tthis.blendSrcAlpha = null;\r\n\tthis.blendDstAlpha = null;\r\n\tthis.blendEquationAlpha = null;\r\n\r\n\tthis.depthTest = true;\r\n\tthis.depthWrite = true;\r\n\r\n\tthis.colorWrite = true;\r\n\r\n\tthis.polygonOffset = false;\r\n\tthis.polygonOffsetFactor = 0;\r\n\tthis.polygonOffsetUnits = 0;\r\n\r\n\tthis.alphaTest = 0;\r\n\r\n\tthis.overdraw = 0; // Overdrawn pixels (typically between 0 and 1) for fixing antialiasing gaps in CanvasRenderer\r\n\r\n\tthis.visible = true;\r\n\r\n\tthis._needsUpdate = true;\r\n\r\n};\r\n\r\nTHREE.Material.prototype = {\r\n\r\n\tconstructor: THREE.Material,\r\n\r\n\tget needsUpdate () {\r\n\r\n\t\treturn this._needsUpdate;\r\n\r\n\t},\r\n\r\n\tset needsUpdate ( value ) {\r\n\r\n\t\tif ( value === true ) this.update();\r\n\r\n\t\tthis._needsUpdate = value;\r\n\r\n\t},\r\n\r\n\tsetValues: function ( values ) {\r\n\r\n\t\tif ( values === undefined ) return;\r\n\r\n\t\tfor ( var key in values ) {\r\n\r\n\t\t\tvar newValue = values[ key ];\r\n\r\n\t\t\tif ( newValue === undefined ) {\r\n\r\n\t\t\t\tTHREE.warn( \"THREE.Material: '\" + key + \"' parameter is undefined.\" );\r\n\t\t\t\tcontinue;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( key in this ) {\r\n\r\n\t\t\t\tvar currentValue = this[ key ];\r\n\r\n\t\t\t\tif ( currentValue instanceof THREE.Color ) {\r\n\r\n\t\t\t\t\tcurrentValue.set( newValue );\r\n\r\n\t\t\t\t} else if ( currentValue instanceof THREE.Vector3 && newValue instanceof THREE.Vector3 ) {\r\n\r\n\t\t\t\t\tcurrentValue.copy( newValue );\r\n\r\n\t\t\t\t} else if ( key == 'overdraw' ) {\r\n\r\n\t\t\t\t\t// ensure overdraw is backwards-compatable with legacy boolean type\r\n\t\t\t\t\tthis[ key ] = Number( newValue );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tthis[ key ] = newValue;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\ttoJSON: function () {\r\n\r\n\t\tvar output = {\r\n\t\t\tmetadata: {\r\n\t\t\t\tversion: 4.2,\r\n\t\t\t\ttype: 'material',\r\n\t\t\t\tgenerator: 'MaterialExporter'\r\n\t\t\t},\r\n\t\t\tuuid: this.uuid,\r\n\t\t\ttype: this.type\r\n\t\t};\r\n\r\n\t\tif ( this.name !== \"\" ) output.name = this.name;\r\n\r\n\t\tif ( this instanceof THREE.MeshBasicMaterial ) {\r\n\r\n\t\t\toutput.color = this.color.getHex();\r\n\t\t\tif ( this.vertexColors !== THREE.NoColors ) output.vertexColors = this.vertexColors;\r\n\t\t\tif ( this.blending !== THREE.NormalBlending ) output.blending = this.blending;\r\n\t\t\tif ( this.side !== THREE.FrontSide ) output.side = this.side;\r\n\r\n\t\t} else if ( this instanceof THREE.MeshLambertMaterial ) {\r\n\r\n\t\t\toutput.color = this.color.getHex();\r\n\t\t\toutput.emissive = this.emissive.getHex();\r\n\t\t\tif ( this.vertexColors !== THREE.NoColors ) output.vertexColors = this.vertexColors;\r\n\t\t\tif ( this.shading !== THREE.SmoothShading ) output.shading = this.shading;\r\n\t\t\tif ( this.blending !== THREE.NormalBlending ) output.blending = this.blending;\r\n\t\t\tif ( this.side !== THREE.FrontSide ) output.side = this.side;\r\n\r\n\t\t} else if ( this instanceof THREE.MeshPhongMaterial ) {\r\n\r\n\t\t\toutput.color = this.color.getHex();\r\n\t\t\toutput.emissive = this.emissive.getHex();\r\n\t\t\toutput.specular = this.specular.getHex();\r\n\t\t\toutput.shininess = this.shininess;\r\n\t\t\tif ( this.vertexColors !== THREE.NoColors ) output.vertexColors = this.vertexColors;\r\n\t\t\tif ( this.shading !== THREE.SmoothShading ) output.shading = this.shading;\r\n\t\t\tif ( this.blending !== THREE.NormalBlending ) output.blending = this.blending;\r\n\t\t\tif ( this.side !== THREE.FrontSide ) output.side = this.side;\r\n\r\n\t\t} else if ( this instanceof THREE.MeshNormalMaterial ) {\r\n\r\n\t\t\tif ( this.blending !== THREE.NormalBlending ) output.blending = this.blending;\r\n\t\t\tif ( this.side !== THREE.FrontSide ) output.side = this.side;\r\n\r\n\t\t} else if ( this instanceof THREE.MeshDepthMaterial ) {\r\n\r\n\t\t\tif ( this.blending !== THREE.NormalBlending ) output.blending = this.blending;\r\n\t\t\tif ( this.side !== THREE.FrontSide ) output.side = this.side;\r\n\r\n\t\t} else if ( this instanceof THREE.PointCloudMaterial ) {\r\n\r\n\t\t\toutput.size  = this.size;\r\n\t\t\toutput.sizeAttenuation = this.sizeAttenuation;\r\n\t\t\toutput.color = this.color.getHex();\r\n\r\n\t\t\tif ( this.vertexColors !== THREE.NoColors ) output.vertexColors = this.vertexColors;\r\n\t\t\tif ( this.blending !== THREE.NormalBlending ) output.blending = this.blending;\r\n\r\n\t\t} else if ( this instanceof THREE.ShaderMaterial ) {\r\n\r\n\t\t\toutput.uniforms = this.uniforms;\r\n\t\t\toutput.vertexShader = this.vertexShader;\r\n\t\t\toutput.fragmentShader = this.fragmentShader;\r\n\r\n\t\t} else if ( this instanceof THREE.SpriteMaterial ) {\r\n\r\n\t\t\toutput.color = this.color.getHex();\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.opacity < 1 ) output.opacity = this.opacity;\r\n\t\tif ( this.transparent !== false ) output.transparent = this.transparent;\r\n\t\tif ( this.wireframe !== false ) output.wireframe = this.wireframe;\r\n\r\n\t\treturn output;\r\n\r\n\t},\r\n\r\n\tclone: function ( material ) {\r\n\r\n\t\tif ( material === undefined ) material = new THREE.Material();\r\n\r\n\t\tmaterial.name = this.name;\r\n\r\n\t\tmaterial.side = this.side;\r\n\r\n\t\tmaterial.opacity = this.opacity;\r\n\t\tmaterial.transparent = this.transparent;\r\n\r\n\t\tmaterial.blending = this.blending;\r\n\r\n\t\tmaterial.blendSrc = this.blendSrc;\r\n\t\tmaterial.blendDst = this.blendDst;\r\n\t\tmaterial.blendEquation = this.blendEquation;\r\n\t\tmaterial.blendSrcAlpha = this.blendSrcAlpha;\r\n\t\tmaterial.blendDstAlpha = this.blendDstAlpha;\r\n\t\tmaterial.blendEquationAlpha = this.blendEquationAlpha;\r\n\r\n\t\tmaterial.depthTest = this.depthTest;\r\n\t\tmaterial.depthWrite = this.depthWrite;\r\n\r\n\t\tmaterial.polygonOffset = this.polygonOffset;\r\n\t\tmaterial.polygonOffsetFactor = this.polygonOffsetFactor;\r\n\t\tmaterial.polygonOffsetUnits = this.polygonOffsetUnits;\r\n\r\n\t\tmaterial.alphaTest = this.alphaTest;\r\n\r\n\t\tmaterial.overdraw = this.overdraw;\r\n\r\n\t\tmaterial.visible = this.visible;\r\n\r\n\t\treturn material;\r\n\r\n\t},\r\n\r\n\tupdate: function () {\r\n\r\n\t\tthis.dispatchEvent( { type: 'update' } );\r\n\r\n\t},\r\n\r\n\tdispose: function () {\r\n\r\n\t\tthis.dispatchEvent( { type: 'dispose' } );\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.EventDispatcher.prototype.apply( THREE.Material.prototype );\r\n\r\nTHREE.MaterialIdCount = 0;\r\n\r\n// File:src/materials/LineBasicMaterial.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n *\r\n * parameters = {\r\n *  color: <hex>,\r\n *  opacity: <float>,\r\n *\r\n *  blending: THREE.NormalBlending,\r\n *  depthTest: <bool>,\r\n *  depthWrite: <bool>,\r\n *\r\n *  linewidth: <float>,\r\n *  linecap: \"round\",\r\n *  linejoin: \"round\",\r\n *\r\n *  vertexColors: <bool>\r\n *\r\n *  fog: <bool>\r\n * }\r\n */\r\n\r\nTHREE.LineBasicMaterial = function ( parameters ) {\r\n\r\n\tTHREE.Material.call( this );\r\n\r\n\tthis.type = 'LineBasicMaterial';\r\n\r\n\tthis.color = new THREE.Color( 0xffffff );\r\n\r\n\tthis.linewidth = 1;\r\n\tthis.linecap = 'round';\r\n\tthis.linejoin = 'round';\r\n\r\n\tthis.vertexColors = THREE.NoColors;\r\n\r\n\tthis.fog = true;\r\n\r\n\tthis.setValues( parameters );\r\n\r\n};\r\n\r\nTHREE.LineBasicMaterial.prototype = Object.create( THREE.Material.prototype );\r\nTHREE.LineBasicMaterial.prototype.constructor = THREE.LineBasicMaterial;\r\n\r\nTHREE.LineBasicMaterial.prototype.clone = function () {\r\n\r\n\tvar material = new THREE.LineBasicMaterial();\r\n\r\n\tTHREE.Material.prototype.clone.call( this, material );\r\n\r\n\tmaterial.color.copy( this.color );\r\n\r\n\tmaterial.linewidth = this.linewidth;\r\n\tmaterial.linecap = this.linecap;\r\n\tmaterial.linejoin = this.linejoin;\r\n\r\n\tmaterial.vertexColors = this.vertexColors;\r\n\r\n\tmaterial.fog = this.fog;\r\n\r\n\treturn material;\r\n\r\n};\r\n\r\n// File:src/materials/LineDashedMaterial.js\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n *\r\n * parameters = {\r\n *  color: <hex>,\r\n *  opacity: <float>,\r\n *\r\n *  blending: THREE.NormalBlending,\r\n *  depthTest: <bool>,\r\n *  depthWrite: <bool>,\r\n *\r\n *  linewidth: <float>,\r\n *\r\n *  scale: <float>,\r\n *  dashSize: <float>,\r\n *  gapSize: <float>,\r\n *\r\n *  vertexColors: <bool>\r\n *\r\n *  fog: <bool>\r\n * }\r\n */\r\n\r\nTHREE.LineDashedMaterial = function ( parameters ) {\r\n\r\n\tTHREE.Material.call( this );\r\n\r\n\tthis.type = 'LineDashedMaterial';\r\n\r\n\tthis.color = new THREE.Color( 0xffffff );\r\n\r\n\tthis.linewidth = 1;\r\n\r\n\tthis.scale = 1;\r\n\tthis.dashSize = 3;\r\n\tthis.gapSize = 1;\r\n\r\n\tthis.vertexColors = false;\r\n\r\n\tthis.fog = true;\r\n\r\n\tthis.setValues( parameters );\r\n\r\n};\r\n\r\nTHREE.LineDashedMaterial.prototype = Object.create( THREE.Material.prototype );\r\nTHREE.LineDashedMaterial.prototype.constructor = THREE.LineDashedMaterial;\r\n\r\nTHREE.LineDashedMaterial.prototype.clone = function () {\r\n\r\n\tvar material = new THREE.LineDashedMaterial();\r\n\r\n\tTHREE.Material.prototype.clone.call( this, material );\r\n\r\n\tmaterial.color.copy( this.color );\r\n\r\n\tmaterial.linewidth = this.linewidth;\r\n\r\n\tmaterial.scale = this.scale;\r\n\tmaterial.dashSize = this.dashSize;\r\n\tmaterial.gapSize = this.gapSize;\r\n\r\n\tmaterial.vertexColors = this.vertexColors;\r\n\r\n\tmaterial.fog = this.fog;\r\n\r\n\treturn material;\r\n\r\n};\r\n\r\n// File:src/materials/MeshBasicMaterial.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n *\r\n * parameters = {\r\n *  color: <hex>,\r\n *  opacity: <float>,\r\n *  map: new THREE.Texture( <Image> ),\r\n *\r\n *  lightMap: new THREE.Texture( <Image> ),\r\n *\r\n *  specularMap: new THREE.Texture( <Image> ),\r\n *\r\n *  alphaMap: new THREE.Texture( <Image> ),\r\n *\r\n *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),\r\n *  combine: THREE.Multiply,\r\n *  reflectivity: <float>,\r\n *  refractionRatio: <float>,\r\n *\r\n *  shading: THREE.SmoothShading,\r\n *  blending: THREE.NormalBlending,\r\n *  depthTest: <bool>,\r\n *  depthWrite: <bool>,\r\n *\r\n *  wireframe: <boolean>,\r\n *  wireframeLinewidth: <float>,\r\n *\r\n *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,\r\n *\r\n *  skinning: <bool>,\r\n *  morphTargets: <bool>,\r\n *\r\n *  fog: <bool>\r\n * }\r\n */\r\n\r\nTHREE.MeshBasicMaterial = function ( parameters ) {\r\n\r\n\tTHREE.Material.call( this );\r\n\r\n\tthis.type = 'MeshBasicMaterial';\r\n\r\n\tthis.color = new THREE.Color( 0xffffff ); // emissive\r\n\r\n\tthis.map = null;\r\n\r\n\tthis.lightMap = null;\r\n\r\n\tthis.specularMap = null;\r\n\r\n\tthis.alphaMap = null;\r\n\r\n\tthis.envMap = null;\r\n\tthis.combine = THREE.MultiplyOperation;\r\n\tthis.reflectivity = 1;\r\n\tthis.refractionRatio = 0.98;\r\n\r\n\tthis.fog = true;\r\n\r\n\tthis.shading = THREE.SmoothShading;\r\n\r\n\tthis.wireframe = false;\r\n\tthis.wireframeLinewidth = 1;\r\n\tthis.wireframeLinecap = 'round';\r\n\tthis.wireframeLinejoin = 'round';\r\n\r\n\tthis.vertexColors = THREE.NoColors;\r\n\r\n\tthis.skinning = false;\r\n\tthis.morphTargets = false;\r\n\r\n\tthis.setValues( parameters );\r\n\r\n};\r\n\r\nTHREE.MeshBasicMaterial.prototype = Object.create( THREE.Material.prototype );\r\nTHREE.MeshBasicMaterial.prototype.constructor = THREE.MeshBasicMaterial;\r\n\r\nTHREE.MeshBasicMaterial.prototype.clone = function () {\r\n\r\n\tvar material = new THREE.MeshBasicMaterial();\r\n\r\n\tTHREE.Material.prototype.clone.call( this, material );\r\n\r\n\tmaterial.color.copy( this.color );\r\n\r\n\tmaterial.map = this.map;\r\n\r\n\tmaterial.lightMap = this.lightMap;\r\n\r\n\tmaterial.specularMap = this.specularMap;\r\n\r\n\tmaterial.alphaMap = this.alphaMap;\r\n\r\n\tmaterial.envMap = this.envMap;\r\n\tmaterial.combine = this.combine;\r\n\tmaterial.reflectivity = this.reflectivity;\r\n\tmaterial.refractionRatio = this.refractionRatio;\r\n\r\n\tmaterial.fog = this.fog;\r\n\r\n\tmaterial.shading = this.shading;\r\n\r\n\tmaterial.wireframe = this.wireframe;\r\n\tmaterial.wireframeLinewidth = this.wireframeLinewidth;\r\n\tmaterial.wireframeLinecap = this.wireframeLinecap;\r\n\tmaterial.wireframeLinejoin = this.wireframeLinejoin;\r\n\r\n\tmaterial.vertexColors = this.vertexColors;\r\n\r\n\tmaterial.skinning = this.skinning;\r\n\tmaterial.morphTargets = this.morphTargets;\r\n\r\n\treturn material;\r\n\r\n};\r\n\r\n// File:src/materials/MeshLambertMaterial.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n *\r\n * parameters = {\r\n *  color: <hex>,\r\n *  emissive: <hex>,\r\n *  opacity: <float>,\r\n *\r\n *  map: new THREE.Texture( <Image> ),\r\n *\r\n *  lightMap: new THREE.Texture( <Image> ),\r\n *\r\n *  specularMap: new THREE.Texture( <Image> ),\r\n *\r\n *  alphaMap: new THREE.Texture( <Image> ),\r\n *\r\n *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),\r\n *  combine: THREE.Multiply,\r\n *  reflectivity: <float>,\r\n *  refractionRatio: <float>,\r\n *\r\n *  shading: THREE.SmoothShading,\r\n *  blending: THREE.NormalBlending,\r\n *  depthTest: <bool>,\r\n *  depthWrite: <bool>,\r\n *\r\n *  wireframe: <boolean>,\r\n *  wireframeLinewidth: <float>,\r\n *\r\n *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,\r\n *\r\n *  skinning: <bool>,\r\n *  morphTargets: <bool>,\r\n *  morphNormals: <bool>,\r\n *\r\n *\tfog: <bool>\r\n * }\r\n */\r\n\r\nTHREE.MeshLambertMaterial = function ( parameters ) {\r\n\r\n\tTHREE.Material.call( this );\r\n\r\n\tthis.type = 'MeshLambertMaterial';\r\n\r\n\tthis.color = new THREE.Color( 0xffffff ); // diffuse\r\n\tthis.emissive = new THREE.Color( 0x000000 );\r\n\r\n\tthis.wrapAround = false;\r\n\tthis.wrapRGB = new THREE.Vector3( 1, 1, 1 );\r\n\r\n\tthis.map = null;\r\n\r\n\tthis.lightMap = null;\r\n\r\n\tthis.specularMap = null;\r\n\r\n\tthis.alphaMap = null;\r\n\r\n\tthis.envMap = null;\r\n\tthis.combine = THREE.MultiplyOperation;\r\n\tthis.reflectivity = 1;\r\n\tthis.refractionRatio = 0.98;\r\n\r\n\tthis.fog = true;\r\n\r\n\tthis.shading = THREE.SmoothShading;\r\n\r\n\tthis.wireframe = false;\r\n\tthis.wireframeLinewidth = 1;\r\n\tthis.wireframeLinecap = 'round';\r\n\tthis.wireframeLinejoin = 'round';\r\n\r\n\tthis.vertexColors = THREE.NoColors;\r\n\r\n\tthis.skinning = false;\r\n\tthis.morphTargets = false;\r\n\tthis.morphNormals = false;\r\n\r\n\tthis.setValues( parameters );\r\n\r\n};\r\n\r\nTHREE.MeshLambertMaterial.prototype = Object.create( THREE.Material.prototype );\r\nTHREE.MeshLambertMaterial.prototype.constructor = THREE.MeshLambertMaterial;\r\n\r\nTHREE.MeshLambertMaterial.prototype.clone = function () {\r\n\r\n\tvar material = new THREE.MeshLambertMaterial();\r\n\r\n\tTHREE.Material.prototype.clone.call( this, material );\r\n\r\n\tmaterial.color.copy( this.color );\r\n\tmaterial.emissive.copy( this.emissive );\r\n\r\n\tmaterial.wrapAround = this.wrapAround;\r\n\tmaterial.wrapRGB.copy( this.wrapRGB );\r\n\r\n\tmaterial.map = this.map;\r\n\r\n\tmaterial.lightMap = this.lightMap;\r\n\r\n\tmaterial.specularMap = this.specularMap;\r\n\r\n\tmaterial.alphaMap = this.alphaMap;\r\n\r\n\tmaterial.envMap = this.envMap;\r\n\tmaterial.combine = this.combine;\r\n\tmaterial.reflectivity = this.reflectivity;\r\n\tmaterial.refractionRatio = this.refractionRatio;\r\n\r\n\tmaterial.fog = this.fog;\r\n\r\n\tmaterial.shading = this.shading;\r\n\r\n\tmaterial.wireframe = this.wireframe;\r\n\tmaterial.wireframeLinewidth = this.wireframeLinewidth;\r\n\tmaterial.wireframeLinecap = this.wireframeLinecap;\r\n\tmaterial.wireframeLinejoin = this.wireframeLinejoin;\r\n\r\n\tmaterial.vertexColors = this.vertexColors;\r\n\r\n\tmaterial.skinning = this.skinning;\r\n\tmaterial.morphTargets = this.morphTargets;\r\n\tmaterial.morphNormals = this.morphNormals;\r\n\r\n\treturn material;\r\n\r\n};\r\n\r\n// File:src/materials/MeshPhongMaterial.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n *\r\n * parameters = {\r\n *  color: <hex>,\r\n *  emissive: <hex>,\r\n *  specular: <hex>,\r\n *  shininess: <float>,\r\n *  opacity: <float>,\r\n *\r\n *  map: new THREE.Texture( <Image> ),\r\n *\r\n *  lightMap: new THREE.Texture( <Image> ),\r\n *\r\n *  bumpMap: new THREE.Texture( <Image> ),\r\n *  bumpScale: <float>,\r\n *\r\n *  normalMap: new THREE.Texture( <Image> ),\r\n *  normalScale: <Vector2>,\r\n *\r\n *  specularMap: new THREE.Texture( <Image> ),\r\n *\r\n *  alphaMap: new THREE.Texture( <Image> ),\r\n *\r\n *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),\r\n *  combine: THREE.Multiply,\r\n *  reflectivity: <float>,\r\n *  refractionRatio: <float>,\r\n *\r\n *  shading: THREE.SmoothShading,\r\n *  blending: THREE.NormalBlending,\r\n *  depthTest: <bool>,\r\n *  depthWrite: <bool>,\r\n *\r\n *  wireframe: <boolean>,\r\n *  wireframeLinewidth: <float>,\r\n *\r\n *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,\r\n *\r\n *  skinning: <bool>,\r\n *  morphTargets: <bool>,\r\n *  morphNormals: <bool>,\r\n *\r\n *\tfog: <bool>\r\n * }\r\n */\r\n\r\nTHREE.MeshPhongMaterial = function ( parameters ) {\r\n\r\n\tTHREE.Material.call( this );\r\n\r\n\tthis.type = 'MeshPhongMaterial';\r\n\r\n\tthis.color = new THREE.Color( 0xffffff ); // diffuse\r\n\tthis.emissive = new THREE.Color( 0x000000 );\r\n\tthis.specular = new THREE.Color( 0x111111 );\r\n\tthis.shininess = 30;\r\n\r\n\tthis.metal = false;\r\n\r\n\tthis.wrapAround = false;\r\n\tthis.wrapRGB = new THREE.Vector3( 1, 1, 1 );\r\n\r\n\tthis.map = null;\r\n\r\n\tthis.lightMap = null;\r\n\r\n\tthis.bumpMap = null;\r\n\tthis.bumpScale = 1;\r\n\r\n\tthis.normalMap = null;\r\n\tthis.normalScale = new THREE.Vector2( 1, 1 );\r\n\r\n\tthis.specularMap = null;\r\n\r\n\tthis.alphaMap = null;\r\n\r\n\tthis.envMap = null;\r\n\tthis.combine = THREE.MultiplyOperation;\r\n\tthis.reflectivity = 1;\r\n\tthis.refractionRatio = 0.98;\r\n\r\n\tthis.fog = true;\r\n\r\n\tthis.shading = THREE.SmoothShading;\r\n\r\n\tthis.wireframe = false;\r\n\tthis.wireframeLinewidth = 1;\r\n\tthis.wireframeLinecap = 'round';\r\n\tthis.wireframeLinejoin = 'round';\r\n\r\n\tthis.vertexColors = THREE.NoColors;\r\n\r\n\tthis.skinning = false;\r\n\tthis.morphTargets = false;\r\n\tthis.morphNormals = false;\r\n\r\n\tthis.setValues( parameters );\r\n\r\n};\r\n\r\nTHREE.MeshPhongMaterial.prototype = Object.create( THREE.Material.prototype );\r\nTHREE.MeshPhongMaterial.prototype.constructor = THREE.MeshPhongMaterial;\r\n\r\nTHREE.MeshPhongMaterial.prototype.clone = function () {\r\n\r\n\tvar material = new THREE.MeshPhongMaterial();\r\n\r\n\tTHREE.Material.prototype.clone.call( this, material );\r\n\r\n\tmaterial.color.copy( this.color );\r\n\tmaterial.emissive.copy( this.emissive );\r\n\tmaterial.specular.copy( this.specular );\r\n\tmaterial.shininess = this.shininess;\r\n\r\n\tmaterial.metal = this.metal;\r\n\r\n\tmaterial.wrapAround = this.wrapAround;\r\n\tmaterial.wrapRGB.copy( this.wrapRGB );\r\n\r\n\tmaterial.map = this.map;\r\n\r\n\tmaterial.lightMap = this.lightMap;\r\n\r\n\tmaterial.bumpMap = this.bumpMap;\r\n\tmaterial.bumpScale = this.bumpScale;\r\n\r\n\tmaterial.normalMap = this.normalMap;\r\n\tmaterial.normalScale.copy( this.normalScale );\r\n\r\n\tmaterial.specularMap = this.specularMap;\r\n\r\n\tmaterial.alphaMap = this.alphaMap;\r\n\r\n\tmaterial.envMap = this.envMap;\r\n\tmaterial.combine = this.combine;\r\n\tmaterial.reflectivity = this.reflectivity;\r\n\tmaterial.refractionRatio = this.refractionRatio;\r\n\r\n\tmaterial.fog = this.fog;\r\n\r\n\tmaterial.shading = this.shading;\r\n\r\n\tmaterial.wireframe = this.wireframe;\r\n\tmaterial.wireframeLinewidth = this.wireframeLinewidth;\r\n\tmaterial.wireframeLinecap = this.wireframeLinecap;\r\n\tmaterial.wireframeLinejoin = this.wireframeLinejoin;\r\n\r\n\tmaterial.vertexColors = this.vertexColors;\r\n\r\n\tmaterial.skinning = this.skinning;\r\n\tmaterial.morphTargets = this.morphTargets;\r\n\tmaterial.morphNormals = this.morphNormals;\r\n\r\n\treturn material;\r\n\r\n};\r\n\r\n// File:src/materials/MeshDepthMaterial.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n *\r\n * parameters = {\r\n *  opacity: <float>,\r\n *\r\n *  blending: THREE.NormalBlending,\r\n *  depthTest: <bool>,\r\n *  depthWrite: <bool>,\r\n *\r\n *  wireframe: <boolean>,\r\n *  wireframeLinewidth: <float>\r\n * }\r\n */\r\n\r\nTHREE.MeshDepthMaterial = function ( parameters ) {\r\n\r\n\tTHREE.Material.call( this );\r\n\r\n\tthis.type = 'MeshDepthMaterial';\r\n\r\n\tthis.morphTargets = false;\r\n\tthis.wireframe = false;\r\n\tthis.wireframeLinewidth = 1;\r\n\r\n\tthis.setValues( parameters );\r\n\r\n};\r\n\r\nTHREE.MeshDepthMaterial.prototype = Object.create( THREE.Material.prototype );\r\nTHREE.MeshDepthMaterial.prototype.constructor = THREE.MeshDepthMaterial;\r\n\r\nTHREE.MeshDepthMaterial.prototype.clone = function () {\r\n\r\n\tvar material = new THREE.MeshDepthMaterial();\r\n\r\n\tTHREE.Material.prototype.clone.call( this, material );\r\n\r\n\tmaterial.wireframe = this.wireframe;\r\n\tmaterial.wireframeLinewidth = this.wireframeLinewidth;\r\n\r\n\treturn material;\r\n\r\n};\r\n\r\n// File:src/materials/MeshNormalMaterial.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n *\r\n * parameters = {\r\n *  opacity: <float>,\r\n *\r\n *  shading: THREE.FlatShading,\r\n *  blending: THREE.NormalBlending,\r\n *  depthTest: <bool>,\r\n *  depthWrite: <bool>,\r\n *\r\n *  wireframe: <boolean>,\r\n *  wireframeLinewidth: <float>\r\n * }\r\n */\r\n\r\nTHREE.MeshNormalMaterial = function ( parameters ) {\r\n\r\n\tTHREE.Material.call( this, parameters );\r\n\r\n\tthis.type = 'MeshNormalMaterial';\r\n\r\n\tthis.wireframe = false;\r\n\tthis.wireframeLinewidth = 1;\r\n\r\n\tthis.morphTargets = false;\r\n\r\n\tthis.setValues( parameters );\r\n\r\n};\r\n\r\nTHREE.MeshNormalMaterial.prototype = Object.create( THREE.Material.prototype );\r\nTHREE.MeshNormalMaterial.prototype.constructor = THREE.MeshNormalMaterial;\r\n\r\nTHREE.MeshNormalMaterial.prototype.clone = function () {\r\n\r\n\tvar material = new THREE.MeshNormalMaterial();\r\n\r\n\tTHREE.Material.prototype.clone.call( this, material );\r\n\r\n\tmaterial.wireframe = this.wireframe;\r\n\tmaterial.wireframeLinewidth = this.wireframeLinewidth;\r\n\r\n\treturn material;\r\n\r\n};\r\n\r\n// File:src/materials/MeshFaceMaterial.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.MeshFaceMaterial = function ( materials ) {\r\n\r\n\tthis.uuid = THREE.Math.generateUUID();\r\n\r\n\tthis.type = 'MeshFaceMaterial';\r\n\t\r\n\tthis.materials = materials instanceof Array ? materials : [];\r\n\r\n};\r\n\r\nTHREE.MeshFaceMaterial.prototype = {\r\n\r\n\tconstructor: THREE.MeshFaceMaterial,\r\n\r\n\ttoJSON: function () {\r\n\r\n\t\tvar output = {\r\n\t\t\tmetadata: {\r\n\t\t\t\tversion: 4.2,\r\n\t\t\t\ttype: 'material',\r\n\t\t\t\tgenerator: 'MaterialExporter'\r\n\t\t\t},\r\n\t\t\tuuid: this.uuid,\r\n\t\t\ttype: this.type,\r\n\t\t\tmaterials: []\r\n\t\t};\r\n\r\n\t\tfor ( var i = 0, l = this.materials.length; i < l; i ++ ) {\r\n\r\n\t\t\toutput.materials.push( this.materials[ i ].toJSON() );\r\n\r\n\t\t}\r\n\r\n\t\treturn output;\r\n\r\n\t},\r\n\r\n\tclone: function () {\r\n\r\n\t\tvar material = new THREE.MeshFaceMaterial();\r\n\r\n\t\tfor ( var i = 0; i < this.materials.length; i ++ ) {\r\n\r\n\t\t\tmaterial.materials.push( this.materials[ i ].clone() );\r\n\r\n\t\t}\r\n\r\n\t\treturn material;\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/materials/PointCloudMaterial.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n *\r\n * parameters = {\r\n *  color: <hex>,\r\n *  opacity: <float>,\r\n *  map: new THREE.Texture( <Image> ),\r\n *\r\n *  size: <float>,\r\n *  sizeAttenuation: <bool>,\r\n *\r\n *  blending: THREE.NormalBlending,\r\n *  depthTest: <bool>,\r\n *  depthWrite: <bool>,\r\n *\r\n *  vertexColors: <bool>,\r\n *\r\n *  fog: <bool>\r\n * }\r\n */\r\n\r\nTHREE.PointCloudMaterial = function ( parameters ) {\r\n\r\n\tTHREE.Material.call( this );\r\n\r\n\tthis.type = 'PointCloudMaterial';\r\n\r\n\tthis.color = new THREE.Color( 0xffffff );\r\n\r\n\tthis.map = null;\r\n\r\n\tthis.size = 1;\r\n\tthis.sizeAttenuation = true;\r\n\r\n\tthis.vertexColors = THREE.NoColors;\r\n\r\n\tthis.fog = true;\r\n\r\n\tthis.setValues( parameters );\r\n\r\n};\r\n\r\nTHREE.PointCloudMaterial.prototype = Object.create( THREE.Material.prototype );\r\nTHREE.PointCloudMaterial.prototype.constructor = THREE.PointCloudMaterial;\r\n\r\nTHREE.PointCloudMaterial.prototype.clone = function () {\r\n\r\n\tvar material = new THREE.PointCloudMaterial();\r\n\r\n\tTHREE.Material.prototype.clone.call( this, material );\r\n\r\n\tmaterial.color.copy( this.color );\r\n\r\n\tmaterial.map = this.map;\r\n\r\n\tmaterial.size = this.size;\r\n\tmaterial.sizeAttenuation = this.sizeAttenuation;\r\n\r\n\tmaterial.vertexColors = this.vertexColors;\r\n\r\n\tmaterial.fog = this.fog;\r\n\r\n\treturn material;\r\n\r\n};\r\n\r\n// backwards compatibility\r\n\r\nTHREE.ParticleBasicMaterial = function ( parameters ) {\r\n\r\n\tTHREE.warn( 'THREE.ParticleBasicMaterial has been renamed to THREE.PointCloudMaterial.' );\r\n\treturn new THREE.PointCloudMaterial( parameters );\r\n\r\n};\r\n\r\nTHREE.ParticleSystemMaterial = function ( parameters ) {\r\n\r\n\tTHREE.warn( 'THREE.ParticleSystemMaterial has been renamed to THREE.PointCloudMaterial.' );\r\n\treturn new THREE.PointCloudMaterial( parameters );\r\n\r\n};\r\n\r\n// File:src/materials/ShaderMaterial.js\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n *\r\n * parameters = {\r\n *  defines: { \"label\" : \"value\" },\r\n *  uniforms: { \"parameter1\": { type: \"f\", value: 1.0 }, \"parameter2\": { type: \"i\" value2: 2 } },\r\n *\r\n *  fragmentShader: <string>,\r\n *  vertexShader: <string>,\r\n *\r\n *  shading: THREE.SmoothShading,\r\n *  blending: THREE.NormalBlending,\r\n *  depthTest: <bool>,\r\n *  depthWrite: <bool>,\r\n *\r\n *  wireframe: <boolean>,\r\n *  wireframeLinewidth: <float>,\r\n *\r\n *  lights: <bool>,\r\n *\r\n *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,\r\n *\r\n *  skinning: <bool>,\r\n *  morphTargets: <bool>,\r\n *  morphNormals: <bool>,\r\n *\r\n *\tfog: <bool>\r\n * }\r\n */\r\n\r\nTHREE.ShaderMaterial = function ( parameters ) {\r\n\r\n\tTHREE.Material.call( this );\r\n\r\n\tthis.type = 'ShaderMaterial';\r\n\r\n\tthis.defines = {};\r\n\tthis.uniforms = {};\r\n\tthis.attributes = null;\r\n\r\n\tthis.vertexShader = 'void main() {\\n\\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n}';\r\n\tthis.fragmentShader = 'void main() {\\n\\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\\n}';\r\n\r\n\tthis.shading = THREE.SmoothShading;\r\n\r\n\tthis.linewidth = 1;\r\n\r\n\tthis.wireframe = false;\r\n\tthis.wireframeLinewidth = 1;\r\n\r\n\tthis.fog = false; // set to use scene fog\r\n\r\n\tthis.lights = false; // set to use scene lights\r\n\r\n\tthis.vertexColors = THREE.NoColors; // set to use \"color\" attribute stream\r\n\r\n\tthis.skinning = false; // set to use skinning attribute streams\r\n\r\n\tthis.morphTargets = false; // set to use morph targets\r\n\tthis.morphNormals = false; // set to use morph normals\r\n\r\n\t// When rendered geometry doesn't include these attributes but the material does,\r\n\t// use these default values in WebGL. This avoids errors when buffer data is missing.\r\n\tthis.defaultAttributeValues = {\r\n\t\t'color': [ 1, 1, 1 ],\r\n\t\t'uv': [ 0, 0 ],\r\n\t\t'uv2': [ 0, 0 ]\r\n\t};\r\n\r\n\tthis.index0AttributeName = undefined;\r\n\r\n\tthis.setValues( parameters );\r\n\r\n};\r\n\r\nTHREE.ShaderMaterial.prototype = Object.create( THREE.Material.prototype );\r\nTHREE.ShaderMaterial.prototype.constructor = THREE.ShaderMaterial;\r\n\r\nTHREE.ShaderMaterial.prototype.clone = function () {\r\n\r\n\tvar material = new THREE.ShaderMaterial();\r\n\r\n\tTHREE.Material.prototype.clone.call( this, material );\r\n\r\n\tmaterial.fragmentShader = this.fragmentShader;\r\n\tmaterial.vertexShader = this.vertexShader;\r\n\r\n\tmaterial.uniforms = THREE.UniformsUtils.clone( this.uniforms );\r\n\r\n\tmaterial.attributes = this.attributes;\r\n\tmaterial.defines = this.defines;\r\n\r\n\tmaterial.shading = this.shading;\r\n\r\n\tmaterial.wireframe = this.wireframe;\r\n\tmaterial.wireframeLinewidth = this.wireframeLinewidth;\r\n\r\n\tmaterial.fog = this.fog;\r\n\r\n\tmaterial.lights = this.lights;\r\n\r\n\tmaterial.vertexColors = this.vertexColors;\r\n\r\n\tmaterial.skinning = this.skinning;\r\n\r\n\tmaterial.morphTargets = this.morphTargets;\r\n\tmaterial.morphNormals = this.morphNormals;\r\n\r\n\treturn material;\r\n\r\n};\r\n\r\n// File:src/materials/RawShaderMaterial.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.RawShaderMaterial = function ( parameters ) {\r\n\r\n\tTHREE.ShaderMaterial.call( this, parameters );\r\n\r\n\tthis.type = 'RawShaderMaterial';\r\n\r\n};\r\n\r\nTHREE.RawShaderMaterial.prototype = Object.create( THREE.ShaderMaterial.prototype );\r\nTHREE.RawShaderMaterial.prototype.constructor = THREE.RawShaderMaterial;\r\n\r\nTHREE.RawShaderMaterial.prototype.clone = function () {\r\n\r\n\tvar material = new THREE.RawShaderMaterial();\r\n\r\n\tTHREE.ShaderMaterial.prototype.clone.call( this, material );\r\n\r\n\treturn material;\r\n\r\n};\r\n\r\n// File:src/materials/SpriteMaterial.js\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n *\r\n * parameters = {\r\n *  color: <hex>,\r\n *  opacity: <float>,\r\n *  map: new THREE.Texture( <Image> ),\r\n *\r\n *  blending: THREE.NormalBlending,\r\n *  depthTest: <bool>,\r\n *  depthWrite: <bool>,\r\n *\r\n *\tuvOffset: new THREE.Vector2(),\r\n *\tuvScale: new THREE.Vector2(),\r\n *\r\n *  fog: <bool>\r\n * }\r\n */\r\n\r\nTHREE.SpriteMaterial = function ( parameters ) {\r\n\r\n\tTHREE.Material.call( this );\r\n\r\n\tthis.type = 'SpriteMaterial';\r\n\r\n\tthis.color = new THREE.Color( 0xffffff );\r\n\tthis.map = null;\r\n\r\n\tthis.rotation = 0;\r\n\r\n\tthis.fog = false;\r\n\r\n\t// set parameters\r\n\r\n\tthis.setValues( parameters );\r\n\r\n};\r\n\r\nTHREE.SpriteMaterial.prototype = Object.create( THREE.Material.prototype );\r\nTHREE.SpriteMaterial.prototype.constructor = THREE.SpriteMaterial;\r\n\r\nTHREE.SpriteMaterial.prototype.clone = function () {\r\n\r\n\tvar material = new THREE.SpriteMaterial();\r\n\r\n\tTHREE.Material.prototype.clone.call( this, material );\r\n\r\n\tmaterial.color.copy( this.color );\r\n\tmaterial.map = this.map;\r\n\r\n\tmaterial.rotation = this.rotation;\r\n\r\n\tmaterial.fog = this.fog;\r\n\r\n\treturn material;\r\n\r\n};\r\n\r\n// File:src/textures/Texture.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author szimek / https://github.com/szimek/\r\n */\r\n\r\nTHREE.Texture = function ( image, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {\r\n\r\n\tObject.defineProperty( this, 'id', { value: THREE.TextureIdCount ++ } );\r\n\r\n\tthis.uuid = THREE.Math.generateUUID();\r\n\r\n\tthis.name = '';\r\n\tthis.sourceFile = '';\r\n\r\n\tthis.image = image !== undefined ? image : THREE.Texture.DEFAULT_IMAGE;\r\n\tthis.mipmaps = [];\r\n\r\n\tthis.mapping = mapping !== undefined ? mapping : THREE.Texture.DEFAULT_MAPPING;\r\n\r\n\tthis.wrapS = wrapS !== undefined ? wrapS : THREE.ClampToEdgeWrapping;\r\n\tthis.wrapT = wrapT !== undefined ? wrapT : THREE.ClampToEdgeWrapping;\r\n\r\n\tthis.magFilter = magFilter !== undefined ? magFilter : THREE.LinearFilter;\r\n\tthis.minFilter = minFilter !== undefined ? minFilter : THREE.LinearMipMapLinearFilter;\r\n\r\n\tthis.anisotropy = anisotropy !== undefined ? anisotropy : 1;\r\n\r\n\tthis.format = format !== undefined ? format : THREE.RGBAFormat;\r\n\tthis.type = type !== undefined ? type : THREE.UnsignedByteType;\r\n\r\n\tthis.offset = new THREE.Vector2( 0, 0 );\r\n\tthis.repeat = new THREE.Vector2( 1, 1 );\r\n\r\n\tthis.generateMipmaps = true;\r\n\tthis.premultiplyAlpha = false;\r\n\tthis.flipY = true;\r\n\tthis.unpackAlignment = 4; // valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)\r\n\r\n\tthis._needsUpdate = false;\r\n\tthis.onUpdate = null;\r\n\r\n};\r\n\r\nTHREE.Texture.DEFAULT_IMAGE = undefined;\r\nTHREE.Texture.DEFAULT_MAPPING = THREE.UVMapping;\r\n\r\nTHREE.Texture.prototype = {\r\n\r\n\tconstructor: THREE.Texture,\r\n\r\n\tget needsUpdate () {\r\n\r\n\t\treturn this._needsUpdate;\r\n\r\n\t},\r\n\r\n\tset needsUpdate ( value ) {\r\n\r\n\t\tif ( value === true ) this.update();\r\n\r\n\t\tthis._needsUpdate = value;\r\n\r\n\t},\r\n\r\n\tclone: function ( texture ) {\r\n\r\n\t\tif ( texture === undefined ) texture = new THREE.Texture();\r\n\r\n\t\ttexture.image = this.image;\r\n\t\ttexture.mipmaps = this.mipmaps.slice( 0 );\r\n\r\n\t\ttexture.mapping = this.mapping;\r\n\r\n\t\ttexture.wrapS = this.wrapS;\r\n\t\ttexture.wrapT = this.wrapT;\r\n\r\n\t\ttexture.magFilter = this.magFilter;\r\n\t\ttexture.minFilter = this.minFilter;\r\n\r\n\t\ttexture.anisotropy = this.anisotropy;\r\n\r\n\t\ttexture.format = this.format;\r\n\t\ttexture.type = this.type;\r\n\r\n\t\ttexture.offset.copy( this.offset );\r\n\t\ttexture.repeat.copy( this.repeat );\r\n\r\n\t\ttexture.generateMipmaps = this.generateMipmaps;\r\n\t\ttexture.premultiplyAlpha = this.premultiplyAlpha;\r\n\t\ttexture.flipY = this.flipY;\r\n\t\ttexture.unpackAlignment = this.unpackAlignment;\r\n\r\n\t\treturn texture;\r\n\r\n\t},\r\n\r\n\tupdate: function () {\r\n\r\n\t\tthis.dispatchEvent( { type: 'update' } );\r\n\r\n\t},\r\n\r\n\tdispose: function () {\r\n\r\n\t\tthis.dispatchEvent( { type: 'dispose' } );\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.EventDispatcher.prototype.apply( THREE.Texture.prototype );\r\n\r\nTHREE.TextureIdCount = 0;\r\n\r\n// File:src/textures/CubeTexture.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.CubeTexture = function ( images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {\r\n\r\n\tmapping = mapping !== undefined ? mapping : THREE.CubeReflectionMapping;\r\n\t\r\n\tTHREE.Texture.call( this, images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );\r\n\r\n\tthis.images = images;\r\n\r\n};\r\n\r\nTHREE.CubeTexture.prototype = Object.create( THREE.Texture.prototype );\r\nTHREE.CubeTexture.prototype.constructor = THREE.CubeTexture;\r\n\r\nTHREE.CubeTexture.clone = function ( texture ) {\r\n\r\n\tif ( texture === undefined ) texture = new THREE.CubeTexture();\r\n\r\n\tTHREE.Texture.prototype.clone.call( this, texture );\r\n\r\n\ttexture.images = this.images;\r\n\r\n\treturn texture;\r\n\r\n};\r\n\r\n// File:src/textures/CompressedTexture.js\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.CompressedTexture = function ( mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy ) {\r\n\r\n\tTHREE.Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );\r\n\r\n\tthis.image = { width: width, height: height };\r\n\tthis.mipmaps = mipmaps;\r\n\r\n\t// no flipping for cube textures\r\n\t// (also flipping doesn't work for compressed textures )\r\n\r\n\tthis.flipY = false;\r\n\r\n\t// can't generate mipmaps for compressed textures\r\n\t// mips must be embedded in DDS files\r\n\r\n\tthis.generateMipmaps = false;\r\n\r\n};\r\n\r\nTHREE.CompressedTexture.prototype = Object.create( THREE.Texture.prototype );\r\nTHREE.CompressedTexture.prototype.constructor = THREE.CompressedTexture;\r\n\r\nTHREE.CompressedTexture.prototype.clone = function () {\r\n\r\n\tvar texture = new THREE.CompressedTexture();\r\n\r\n\tTHREE.Texture.prototype.clone.call( this, texture );\r\n\r\n\treturn texture;\r\n\r\n};\r\n\r\n// File:src/textures/DataTexture.js\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.DataTexture = function ( data, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy ) {\r\n\r\n\tTHREE.Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );\r\n\r\n\tthis.image = { data: data, width: width, height: height };\r\n\r\n};\r\n\r\nTHREE.DataTexture.prototype = Object.create( THREE.Texture.prototype );\r\nTHREE.DataTexture.prototype.constructor = THREE.DataTexture;\r\n\r\nTHREE.DataTexture.prototype.clone = function () {\r\n\r\n\tvar texture = new THREE.DataTexture();\r\n\r\n\tTHREE.Texture.prototype.clone.call( this, texture );\r\n\r\n\treturn texture;\r\n\r\n};\r\n\r\n// File:src/textures/VideoTexture.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.VideoTexture = function ( video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {\r\n\r\n\tTHREE.Texture.call( this, video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );\r\n\r\n\tthis.generateMipmaps = false;\r\n\r\n\tvar scope = this;\r\n\r\n\tvar update = function () {\r\n\r\n\t\trequestAnimationFrame( update );\r\n\r\n\t\tif ( video.readyState === video.HAVE_ENOUGH_DATA ) {\r\n\r\n\t\t\tscope.needsUpdate = true;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tupdate();\r\n\r\n};\r\n\r\nTHREE.VideoTexture.prototype = Object.create( THREE.Texture.prototype );\r\nTHREE.VideoTexture.prototype.constructor = THREE.VideoTexture;\r\n\r\n// File:src/objects/Group.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.Group = function () {\r\n\r\n\tTHREE.Object3D.call( this );\r\n\r\n\tthis.type = 'Group';\r\n\r\n};\r\n\r\nTHREE.Group.prototype = Object.create( THREE.Object3D.prototype );\r\nTHREE.Group.prototype.constructor = THREE.Group;\r\n\r\n// File:src/objects/PointCloud.js\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.PointCloud = function ( geometry, material ) {\r\n\r\n\tTHREE.Object3D.call( this );\r\n\r\n\tthis.type = 'PointCloud';\r\n\r\n\tthis.geometry = geometry !== undefined ? geometry : new THREE.Geometry();\r\n\tthis.material = material !== undefined ? material : new THREE.PointCloudMaterial( { color: Math.random() * 0xffffff } );\r\n\r\n};\r\n\r\nTHREE.PointCloud.prototype = Object.create( THREE.Object3D.prototype );\r\nTHREE.PointCloud.prototype.constructor = THREE.PointCloud;\r\n\r\nTHREE.PointCloud.prototype.raycast = ( function () {\r\n\r\n\tvar inverseMatrix = new THREE.Matrix4();\r\n\tvar ray = new THREE.Ray();\r\n\r\n\treturn function ( raycaster, intersects ) {\r\n\r\n\t\tvar object = this;\r\n\t\tvar geometry = object.geometry;\r\n\t\tvar threshold = raycaster.params.PointCloud.threshold;\r\n\r\n\t\tinverseMatrix.getInverse( this.matrixWorld );\r\n\t\tray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );\r\n\r\n\t\tif ( geometry.boundingBox !== null ) {\r\n\r\n\t\t\tif ( ray.isIntersectionBox( geometry.boundingBox ) === false ) {\r\n\r\n\t\t\t\treturn;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tvar localThreshold = threshold / ( ( this.scale.x + this.scale.y + this.scale.z ) / 3 );\r\n\t\tvar position = new THREE.Vector3();\r\n\r\n\t\tvar testPoint = function ( point, index ) {\r\n\r\n\t\t\tvar rayPointDistance = ray.distanceToPoint( point );\r\n\r\n\t\t\tif ( rayPointDistance < localThreshold ) {\r\n\r\n\t\t\t\tvar intersectPoint = ray.closestPointToPoint( point );\r\n\t\t\t\tintersectPoint.applyMatrix4( object.matrixWorld );\r\n\r\n\t\t\t\tvar distance = raycaster.ray.origin.distanceTo( intersectPoint );\r\n\r\n\t\t\t\tintersects.push( {\r\n\r\n\t\t\t\t\tdistance: distance,\r\n\t\t\t\t\tdistanceToRay: rayPointDistance,\r\n\t\t\t\t\tpoint: intersectPoint.clone(),\r\n\t\t\t\t\tindex: index,\r\n\t\t\t\t\tface: null,\r\n\t\t\t\t\tobject: object\r\n\r\n\t\t\t\t} );\r\n\r\n\t\t\t}\r\n\r\n\t\t};\r\n\r\n\t\tif ( geometry instanceof THREE.BufferGeometry ) {\r\n\r\n\t\t\tvar attributes = geometry.attributes;\r\n\t\t\tvar positions = attributes.position.array;\r\n\r\n\t\t\tif ( attributes.index !== undefined ) {\r\n\r\n\t\t\t\tvar indices = attributes.index.array;\r\n\t\t\t\tvar offsets = geometry.offsets;\r\n\r\n\t\t\t\tif ( offsets.length === 0 ) {\r\n\r\n\t\t\t\t\tvar offset = {\r\n\t\t\t\t\t\tstart: 0,\r\n\t\t\t\t\t\tcount: indices.length,\r\n\t\t\t\t\t\tindex: 0\r\n\t\t\t\t\t};\r\n\r\n\t\t\t\t\toffsets = [ offset ];\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tfor ( var oi = 0, ol = offsets.length; oi < ol; ++ oi ) {\r\n\r\n\t\t\t\t\tvar start = offsets[ oi ].start;\r\n\t\t\t\t\tvar count = offsets[ oi ].count;\r\n\t\t\t\t\tvar index = offsets[ oi ].index;\r\n\r\n\t\t\t\t\tfor ( var i = start, il = start + count; i < il; i ++ ) {\r\n\r\n\t\t\t\t\t\tvar a = index + indices[ i ];\r\n\r\n\t\t\t\t\t\tposition.fromArray( positions, a * 3 );\r\n\r\n\t\t\t\t\t\ttestPoint( position, a );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tvar pointCount = positions.length / 3;\r\n\r\n\t\t\t\tfor ( var i = 0; i < pointCount; i ++ ) {\r\n\r\n\t\t\t\t\tposition.set(\r\n\t\t\t\t\t\tpositions[ 3 * i ],\r\n\t\t\t\t\t\tpositions[ 3 * i + 1 ],\r\n\t\t\t\t\t\tpositions[ 3 * i + 2 ]\r\n\t\t\t\t\t);\r\n\r\n\t\t\t\t\ttestPoint( position, i );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\tvar vertices = this.geometry.vertices;\r\n\r\n\t\t\tfor ( var i = 0; i < vertices.length; i ++ ) {\r\n\r\n\t\t\t\ttestPoint( vertices[ i ], i );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n}() );\r\n\r\nTHREE.PointCloud.prototype.clone = function ( object ) {\r\n\r\n\tif ( object === undefined ) object = new THREE.PointCloud( this.geometry, this.material );\r\n\r\n\tTHREE.Object3D.prototype.clone.call( this, object );\r\n\r\n\treturn object;\r\n\r\n};\r\n\r\n// Backwards compatibility\r\n\r\nTHREE.ParticleSystem = function ( geometry, material ) {\r\n\r\n\tTHREE.warn( 'THREE.ParticleSystem has been renamed to THREE.PointCloud.' );\r\n\treturn new THREE.PointCloud( geometry, material );\r\n\r\n};\r\n\r\n// File:src/objects/Line.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.Line = function ( geometry, material, mode ) {\r\n\r\n\tTHREE.Object3D.call( this );\r\n\r\n\tthis.type = 'Line';\r\n\r\n\tthis.geometry = geometry !== undefined ? geometry : new THREE.Geometry();\r\n\tthis.material = material !== undefined ? material : new THREE.LineBasicMaterial( { color: Math.random() * 0xffffff } );\r\n\r\n\tthis.mode = mode !== undefined ? mode : THREE.LineStrip;\r\n\r\n};\r\n\r\nTHREE.LineStrip = 0;\r\nTHREE.LinePieces = 1;\r\n\r\nTHREE.Line.prototype = Object.create( THREE.Object3D.prototype );\r\nTHREE.Line.prototype.constructor = THREE.Line;\r\n\r\nTHREE.Line.prototype.raycast = ( function () {\r\n\r\n\tvar inverseMatrix = new THREE.Matrix4();\r\n\tvar ray = new THREE.Ray();\r\n\tvar sphere = new THREE.Sphere();\r\n\r\n\treturn function ( raycaster, intersects ) {\r\n\r\n\t\tvar precision = raycaster.linePrecision;\r\n\t\tvar precisionSq = precision * precision;\r\n\r\n\t\tvar geometry = this.geometry;\r\n\r\n\t\tif ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();\r\n\r\n\t\t// Checking boundingSphere distance to ray\r\n\r\n\t\tsphere.copy( geometry.boundingSphere );\r\n\t\tsphere.applyMatrix4( this.matrixWorld );\r\n\r\n\t\tif ( raycaster.ray.isIntersectionSphere( sphere ) === false ) {\r\n\r\n\t\t\treturn;\r\n\r\n\t\t}\r\n\r\n\t\tinverseMatrix.getInverse( this.matrixWorld );\r\n\t\tray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );\r\n\r\n\t\tvar vStart = new THREE.Vector3();\r\n\t\tvar vEnd = new THREE.Vector3();\r\n\t\tvar interSegment = new THREE.Vector3();\r\n\t\tvar interRay = new THREE.Vector3();\r\n\t\tvar step = this.mode === THREE.LineStrip ? 1 : 2;\r\n\r\n\t\tif ( geometry instanceof THREE.BufferGeometry ) {\r\n\r\n\t\t\tvar attributes = geometry.attributes;\r\n\r\n\t\t\tif ( attributes.index !== undefined ) {\r\n\r\n\t\t\t\tvar indices = attributes.index.array;\r\n\t\t\t\tvar positions = attributes.position.array;\r\n\t\t\t\tvar offsets = geometry.offsets;\r\n\r\n\t\t\t\tif ( offsets.length === 0 ) {\r\n\r\n\t\t\t\t\toffsets = [ { start: 0, count: indices.length, index: 0 } ];\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tfor ( var oi = 0; oi < offsets.length; oi ++) {\r\n\r\n\t\t\t\t\tvar start = offsets[ oi ].start;\r\n\t\t\t\t\tvar count = offsets[ oi ].count;\r\n\t\t\t\t\tvar index = offsets[ oi ].index;\r\n\r\n\t\t\t\t\tfor ( var i = start; i < start + count - 1; i += step ) {\r\n\r\n\t\t\t\t\t\tvar a = index + indices[ i ];\r\n\t\t\t\t\t\tvar b = index + indices[ i + 1 ];\r\n\r\n\t\t\t\t\t\tvStart.fromArray( positions, a * 3 );\r\n\t\t\t\t\t\tvEnd.fromArray( positions, b * 3 );\r\n\r\n\t\t\t\t\t\tvar distSq = ray.distanceSqToSegment( vStart, vEnd, interRay, interSegment );\r\n\r\n\t\t\t\t\t\tif ( distSq > precisionSq ) continue;\r\n\r\n\t\t\t\t\t\tvar distance = ray.origin.distanceTo( interRay );\r\n\r\n\t\t\t\t\t\tif ( distance < raycaster.near || distance > raycaster.far ) continue;\r\n\r\n\t\t\t\t\t\tintersects.push( {\r\n\r\n\t\t\t\t\t\t\tdistance: distance,\r\n\t\t\t\t\t\t\t// What do we want? intersection point on the ray or on the segment??\r\n\t\t\t\t\t\t\t// point: raycaster.ray.at( distance ),\r\n\t\t\t\t\t\t\tpoint: interSegment.clone().applyMatrix4( this.matrixWorld ),\r\n\t\t\t\t\t\t\tindex: i,\r\n\t\t\t\t\t\t\toffsetIndex: oi,\r\n\t\t\t\t\t\t\tface: null,\r\n\t\t\t\t\t\t\tfaceIndex: null,\r\n\t\t\t\t\t\t\tobject: this\r\n\r\n\t\t\t\t\t\t} );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tvar positions = attributes.position.array;\r\n\r\n\t\t\t\tfor ( var i = 0; i < positions.length / 3 - 1; i += step ) {\r\n\r\n\t\t\t\t\tvStart.fromArray( positions, 3 * i );\r\n\t\t\t\t\tvEnd.fromArray( positions, 3 * i + 3 );\r\n\r\n\t\t\t\t\tvar distSq = ray.distanceSqToSegment( vStart, vEnd, interRay, interSegment );\r\n\r\n\t\t\t\t\tif ( distSq > precisionSq ) continue;\r\n\r\n\t\t\t\t\tvar distance = ray.origin.distanceTo( interRay );\r\n\r\n\t\t\t\t\tif ( distance < raycaster.near || distance > raycaster.far ) continue;\r\n\r\n\t\t\t\t\tintersects.push( {\r\n\r\n\t\t\t\t\t\tdistance: distance,\r\n\t\t\t\t\t\t// What do we want? intersection point on the ray or on the segment??\r\n\t\t\t\t\t\t// point: raycaster.ray.at( distance ),\r\n\t\t\t\t\t\tpoint: interSegment.clone().applyMatrix4( this.matrixWorld ),\r\n\t\t\t\t\t\tindex: i,\r\n\t\t\t\t\t\tface: null,\r\n\t\t\t\t\t\tfaceIndex: null,\r\n\t\t\t\t\t\tobject: this\r\n\r\n\t\t\t\t\t} );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t} else if ( geometry instanceof THREE.Geometry ) {\r\n\r\n\t\t\tvar vertices = geometry.vertices;\r\n\t\t\tvar nbVertices = vertices.length;\r\n\r\n\t\t\tfor ( var i = 0; i < nbVertices - 1; i += step ) {\r\n\r\n\t\t\t\tvar distSq = ray.distanceSqToSegment( vertices[ i ], vertices[ i + 1 ], interRay, interSegment );\r\n\r\n\t\t\t\tif ( distSq > precisionSq ) continue;\r\n\r\n\t\t\t\tvar distance = ray.origin.distanceTo( interRay );\r\n\r\n\t\t\t\tif ( distance < raycaster.near || distance > raycaster.far ) continue;\r\n\r\n\t\t\t\tintersects.push( {\r\n\r\n\t\t\t\t\tdistance: distance,\r\n\t\t\t\t\t// What do we want? intersection point on the ray or on the segment??\r\n\t\t\t\t\t// point: raycaster.ray.at( distance ),\r\n\t\t\t\t\tpoint: interSegment.clone().applyMatrix4( this.matrixWorld ),\r\n\t\t\t\t\tindex: i,\r\n\t\t\t\t\tface: null,\r\n\t\t\t\t\tfaceIndex: null,\r\n\t\t\t\t\tobject: this\r\n\r\n\t\t\t\t} );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n}() );\r\n\r\nTHREE.Line.prototype.clone = function ( object ) {\r\n\r\n\tif ( object === undefined ) object = new THREE.Line( this.geometry, this.material, this.mode );\r\n\r\n\tTHREE.Object3D.prototype.clone.call( this, object );\r\n\r\n\treturn object;\r\n\r\n};\r\n\r\n// File:src/objects/Mesh.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author jonobr1 / http://jonobr1.com/\r\n */\r\n\r\nTHREE.Mesh = function ( geometry, material ) {\r\n\r\n\tTHREE.Object3D.call( this );\r\n\r\n\tthis.type = 'Mesh';\r\n\t\r\n\tthis.geometry = geometry !== undefined ? geometry : new THREE.Geometry();\r\n\tthis.material = material !== undefined ? material : new THREE.MeshBasicMaterial( { color: Math.random() * 0xffffff } );\r\n\r\n\tthis.updateMorphTargets();\r\n\r\n};\r\n\r\nTHREE.Mesh.prototype = Object.create( THREE.Object3D.prototype );\r\nTHREE.Mesh.prototype.constructor = THREE.Mesh;\r\n\r\nTHREE.Mesh.prototype.updateMorphTargets = function () {\r\n\r\n\tif ( this.geometry.morphTargets !== undefined && this.geometry.morphTargets.length > 0 ) {\r\n\r\n\t\tthis.morphTargetBase = - 1;\r\n\t\tthis.morphTargetForcedOrder = [];\r\n\t\tthis.morphTargetInfluences = [];\r\n\t\tthis.morphTargetDictionary = {};\r\n\r\n\t\tfor ( var m = 0, ml = this.geometry.morphTargets.length; m < ml; m ++ ) {\r\n\r\n\t\t\tthis.morphTargetInfluences.push( 0 );\r\n\t\t\tthis.morphTargetDictionary[ this.geometry.morphTargets[ m ].name ] = m;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.Mesh.prototype.getMorphTargetIndexByName = function ( name ) {\r\n\r\n\tif ( this.morphTargetDictionary[ name ] !== undefined ) {\r\n\r\n\t\treturn this.morphTargetDictionary[ name ];\r\n\r\n\t}\r\n\r\n\tTHREE.warn( 'THREE.Mesh.getMorphTargetIndexByName: morph target ' + name + ' does not exist. Returning 0.' );\r\n\r\n\treturn 0;\r\n\r\n};\r\n\r\n\r\nTHREE.Mesh.prototype.raycast = ( function () {\r\n\r\n\tvar inverseMatrix = new THREE.Matrix4();\r\n\tvar ray = new THREE.Ray();\r\n\tvar sphere = new THREE.Sphere();\r\n\r\n\tvar vA = new THREE.Vector3();\r\n\tvar vB = new THREE.Vector3();\r\n\tvar vC = new THREE.Vector3();\r\n\r\n\treturn function ( raycaster, intersects ) {\r\n\r\n\t\tvar geometry = this.geometry;\r\n\r\n\t\t// Checking boundingSphere distance to ray\r\n\r\n\t\tif ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();\r\n\r\n\t\tsphere.copy( geometry.boundingSphere );\r\n\t\tsphere.applyMatrix4( this.matrixWorld );\r\n\r\n\t\tif ( raycaster.ray.isIntersectionSphere( sphere ) === false ) {\r\n\r\n\t\t\treturn;\r\n\r\n\t\t}\r\n\r\n\t\t// Check boundingBox before continuing\r\n\r\n\t\tinverseMatrix.getInverse( this.matrixWorld );\r\n\t\tray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );\r\n\r\n\t\tif ( geometry.boundingBox !== null ) {\r\n\r\n\t\t\tif ( ray.isIntersectionBox( geometry.boundingBox ) === false ) {\r\n\r\n\t\t\t\treturn;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( geometry instanceof THREE.BufferGeometry ) {\r\n\r\n\t\t\tvar material = this.material;\r\n\r\n\t\t\tif ( material === undefined ) return;\r\n\r\n\t\t\tvar attributes = geometry.attributes;\r\n\r\n\t\t\tvar a, b, c;\r\n\t\t\tvar precision = raycaster.precision;\r\n\r\n\t\t\tif ( attributes.index !== undefined ) {\r\n\r\n\t\t\t\tvar indices = attributes.index.array;\r\n\t\t\t\tvar positions = attributes.position.array;\r\n\t\t\t\tvar offsets = geometry.offsets;\r\n\r\n\t\t\t\tif ( offsets.length === 0 ) {\r\n\r\n\t\t\t\t\toffsets = [ { start: 0, count: indices.length, index: 0 } ];\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tfor ( var oi = 0, ol = offsets.length; oi < ol; ++ oi ) {\r\n\r\n\t\t\t\t\tvar start = offsets[ oi ].start;\r\n\t\t\t\t\tvar count = offsets[ oi ].count;\r\n\t\t\t\t\tvar index = offsets[ oi ].index;\r\n\r\n\t\t\t\t\tfor ( var i = start, il = start + count; i < il; i += 3 ) {\r\n\r\n\t\t\t\t\t\ta = index + indices[ i ];\r\n\t\t\t\t\t\tb = index + indices[ i + 1 ];\r\n\t\t\t\t\t\tc = index + indices[ i + 2 ];\r\n\r\n\t\t\t\t\t\tvA.fromArray( positions, a * 3 );\r\n\t\t\t\t\t\tvB.fromArray( positions, b * 3 );\r\n\t\t\t\t\t\tvC.fromArray( positions, c * 3 );\r\n\r\n\t\t\t\t\t\tif ( material.side === THREE.BackSide ) {\r\n\r\n\t\t\t\t\t\t\tvar intersectionPoint = ray.intersectTriangle( vC, vB, vA, true );\r\n\r\n\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\tvar intersectionPoint = ray.intersectTriangle( vA, vB, vC, material.side !== THREE.DoubleSide );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tif ( intersectionPoint === null ) continue;\r\n\r\n\t\t\t\t\t\tintersectionPoint.applyMatrix4( this.matrixWorld );\r\n\r\n\t\t\t\t\t\tvar distance = raycaster.ray.origin.distanceTo( intersectionPoint );\r\n\r\n\t\t\t\t\t\tif ( distance < precision || distance < raycaster.near || distance > raycaster.far ) continue;\r\n\r\n\t\t\t\t\t\tintersects.push( {\r\n\r\n\t\t\t\t\t\t\tdistance: distance,\r\n\t\t\t\t\t\t\tpoint: intersectionPoint,\r\n\t\t\t\t\t\t\tface: new THREE.Face3( a, b, c, THREE.Triangle.normal( vA, vB, vC ) ),\r\n\t\t\t\t\t\t\tfaceIndex: null,\r\n\t\t\t\t\t\t\tobject: this\r\n\r\n\t\t\t\t\t\t} );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tvar positions = attributes.position.array;\r\n\r\n\t\t\t\tfor ( var i = 0, j = 0, il = positions.length; i < il; i += 3, j += 9 ) {\r\n\r\n\t\t\t\t\ta = i;\r\n\t\t\t\t\tb = i + 1;\r\n\t\t\t\t\tc = i + 2;\r\n\r\n\t\t\t\t\tvA.fromArray( positions, j );\r\n\t\t\t\t\tvB.fromArray( positions, j + 3 );\r\n\t\t\t\t\tvC.fromArray( positions, j + 6 );\r\n\r\n\t\t\t\t\tif ( material.side === THREE.BackSide ) {\r\n\r\n\t\t\t\t\t\tvar intersectionPoint = ray.intersectTriangle( vC, vB, vA, true );\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tvar intersectionPoint = ray.intersectTriangle( vA, vB, vC, material.side !== THREE.DoubleSide );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif ( intersectionPoint === null ) continue;\r\n\r\n\t\t\t\t\tintersectionPoint.applyMatrix4( this.matrixWorld );\r\n\r\n\t\t\t\t\tvar distance = raycaster.ray.origin.distanceTo( intersectionPoint );\r\n\r\n\t\t\t\t\tif ( distance < precision || distance < raycaster.near || distance > raycaster.far ) continue;\r\n\r\n\t\t\t\t\tintersects.push( {\r\n\r\n\t\t\t\t\t\tdistance: distance,\r\n\t\t\t\t\t\tpoint: intersectionPoint,\r\n\t\t\t\t\t\tface: new THREE.Face3( a, b, c, THREE.Triangle.normal( vA, vB, vC ) ),\r\n\t\t\t\t\t\tfaceIndex: null,\r\n\t\t\t\t\t\tobject: this\r\n\r\n\t\t\t\t\t} );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t} else if ( geometry instanceof THREE.Geometry ) {\r\n\r\n\t\t\tvar isFaceMaterial = this.material instanceof THREE.MeshFaceMaterial;\r\n\t\t\tvar objectMaterials = isFaceMaterial === true ? this.material.materials : null;\r\n\r\n\t\t\tvar a, b, c;\r\n\t\t\tvar precision = raycaster.precision;\r\n\r\n\t\t\tvar vertices = geometry.vertices;\r\n\r\n\t\t\tfor ( var f = 0, fl = geometry.faces.length; f < fl; f ++ ) {\r\n\r\n\t\t\t\tvar face = geometry.faces[ f ];\r\n\r\n\t\t\t\tvar material = isFaceMaterial === true ? objectMaterials[ face.materialIndex ] : this.material;\r\n\r\n\t\t\t\tif ( material === undefined ) continue;\r\n\r\n\t\t\t\ta = vertices[ face.a ];\r\n\t\t\t\tb = vertices[ face.b ];\r\n\t\t\t\tc = vertices[ face.c ];\r\n\r\n\t\t\t\tif ( material.morphTargets === true ) {\r\n\r\n\t\t\t\t\tvar morphTargets = geometry.morphTargets;\r\n\t\t\t\t\tvar morphInfluences = this.morphTargetInfluences;\r\n\r\n\t\t\t\t\tvA.set( 0, 0, 0 );\r\n\t\t\t\t\tvB.set( 0, 0, 0 );\r\n\t\t\t\t\tvC.set( 0, 0, 0 );\r\n\r\n\t\t\t\t\tfor ( var t = 0, tl = morphTargets.length; t < tl; t ++ ) {\r\n\r\n\t\t\t\t\t\tvar influence = morphInfluences[ t ];\r\n\r\n\t\t\t\t\t\tif ( influence === 0 ) continue;\r\n\r\n\t\t\t\t\t\tvar targets = morphTargets[ t ].vertices;\r\n\r\n\t\t\t\t\t\tvA.x += ( targets[ face.a ].x - a.x ) * influence;\r\n\t\t\t\t\t\tvA.y += ( targets[ face.a ].y - a.y ) * influence;\r\n\t\t\t\t\t\tvA.z += ( targets[ face.a ].z - a.z ) * influence;\r\n\r\n\t\t\t\t\t\tvB.x += ( targets[ face.b ].x - b.x ) * influence;\r\n\t\t\t\t\t\tvB.y += ( targets[ face.b ].y - b.y ) * influence;\r\n\t\t\t\t\t\tvB.z += ( targets[ face.b ].z - b.z ) * influence;\r\n\r\n\t\t\t\t\t\tvC.x += ( targets[ face.c ].x - c.x ) * influence;\r\n\t\t\t\t\t\tvC.y += ( targets[ face.c ].y - c.y ) * influence;\r\n\t\t\t\t\t\tvC.z += ( targets[ face.c ].z - c.z ) * influence;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tvA.add( a );\r\n\t\t\t\t\tvB.add( b );\r\n\t\t\t\t\tvC.add( c );\r\n\r\n\t\t\t\t\ta = vA;\r\n\t\t\t\t\tb = vB;\r\n\t\t\t\t\tc = vC;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( material.side === THREE.BackSide ) {\r\n\r\n\t\t\t\t\tvar intersectionPoint = ray.intersectTriangle( c, b, a, true );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tvar intersectionPoint = ray.intersectTriangle( a, b, c, material.side !== THREE.DoubleSide );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( intersectionPoint === null ) continue;\r\n\r\n\t\t\t\tintersectionPoint.applyMatrix4( this.matrixWorld );\r\n\r\n\t\t\t\tvar distance = raycaster.ray.origin.distanceTo( intersectionPoint );\r\n\r\n\t\t\t\tif ( distance < precision || distance < raycaster.near || distance > raycaster.far ) continue;\r\n\r\n\t\t\t\tintersects.push( {\r\n\r\n\t\t\t\t\tdistance: distance,\r\n\t\t\t\t\tpoint: intersectionPoint,\r\n\t\t\t\t\tface: face,\r\n\t\t\t\t\tfaceIndex: f,\r\n\t\t\t\t\tobject: this\r\n\r\n\t\t\t\t} );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n}() );\r\n\r\nTHREE.Mesh.prototype.clone = function ( object, recursive ) {\r\n\r\n\tif ( object === undefined ) object = new THREE.Mesh( this.geometry, this.material );\r\n\r\n\tTHREE.Object3D.prototype.clone.call( this, object, recursive );\r\n\r\n\treturn object;\r\n\r\n};\r\n\r\n// File:src/objects/Bone.js\r\n\r\n/**\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author ikerr / http://verold.com\r\n */\r\n\r\nTHREE.Bone = function ( skin ) {\r\n\r\n\tTHREE.Object3D.call( this );\r\n\r\n\tthis.type = 'Bone';\r\n\r\n\tthis.skin = skin;\r\n\r\n};\r\n\r\nTHREE.Bone.prototype = Object.create( THREE.Object3D.prototype );\r\nTHREE.Bone.prototype.constructor = THREE.Bone;\r\n\r\n// File:src/objects/Skeleton.js\r\n\r\n/**\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author michael guerrero / http://realitymeltdown.com\r\n * @author ikerr / http://verold.com\r\n */\r\n\r\nTHREE.Skeleton = function ( bones, boneInverses, useVertexTexture ) {\r\n\r\n\tthis.useVertexTexture = useVertexTexture !== undefined ? useVertexTexture : true;\r\n\r\n\tthis.identityMatrix = new THREE.Matrix4();\r\n\r\n\t// copy the bone array\r\n\r\n\tbones = bones || [];\r\n\r\n\tthis.bones = bones.slice( 0 );\r\n\r\n\t// create a bone texture or an array of floats\r\n\r\n\tif ( this.useVertexTexture ) {\r\n\r\n\t\t// layout (1 matrix = 4 pixels)\r\n\t\t//      RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)\r\n\t\t//  with  8x8  pixel texture max   16 bones  (8 * 8  / 4)\r\n\t\t//       16x16 pixel texture max   64 bones (16 * 16 / 4)\r\n\t\t//       32x32 pixel texture max  256 bones (32 * 32 / 4)\r\n\t\t//       64x64 pixel texture max 1024 bones (64 * 64 / 4)\r\n\r\n\t\tvar size;\r\n\r\n\t\tif ( this.bones.length > 256 )\r\n\t\t\tsize = 64;\r\n\t\telse if ( this.bones.length > 64 )\r\n\t\t\tsize = 32;\r\n\t\telse if ( this.bones.length > 16 )\r\n\t\t\tsize = 16;\r\n\t\telse\r\n\t\t\tsize = 8;\r\n\r\n\t\tthis.boneTextureWidth = size;\r\n\t\tthis.boneTextureHeight = size;\r\n\r\n\t\tthis.boneMatrices = new Float32Array( this.boneTextureWidth * this.boneTextureHeight * 4 ); // 4 floats per RGBA pixel\r\n\t\tthis.boneTexture = new THREE.DataTexture( this.boneMatrices, this.boneTextureWidth, this.boneTextureHeight, THREE.RGBAFormat, THREE.FloatType );\r\n\t\tthis.boneTexture.minFilter = THREE.NearestFilter;\r\n\t\tthis.boneTexture.magFilter = THREE.NearestFilter;\r\n\t\tthis.boneTexture.generateMipmaps = false;\r\n\t\tthis.boneTexture.flipY = false;\r\n\r\n\t} else {\r\n\r\n\t\tthis.boneMatrices = new Float32Array( 16 * this.bones.length );\r\n\r\n\t}\r\n\r\n\t// use the supplied bone inverses or calculate the inverses\r\n\r\n\tif ( boneInverses === undefined ) {\r\n\r\n\t\tthis.calculateInverses();\r\n\r\n\t} else {\r\n\r\n\t\tif ( this.bones.length === boneInverses.length ) {\r\n\r\n\t\t\tthis.boneInverses = boneInverses.slice( 0 );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tTHREE.warn( 'THREE.Skeleton bonInverses is the wrong length.' );\r\n\r\n\t\t\tthis.boneInverses = [];\r\n\r\n\t\t\tfor ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {\r\n\r\n\t\t\t\tthis.boneInverses.push( new THREE.Matrix4() );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.Skeleton.prototype.calculateInverses = function () {\r\n\r\n\tthis.boneInverses = [];\r\n\r\n\tfor ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {\r\n\r\n\t\tvar inverse = new THREE.Matrix4();\r\n\r\n\t\tif ( this.bones[ b ] ) {\r\n\r\n\t\t\tinverse.getInverse( this.bones[ b ].matrixWorld );\r\n\r\n\t\t}\r\n\r\n\t\tthis.boneInverses.push( inverse );\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.Skeleton.prototype.pose = function () {\r\n\r\n\tvar bone;\r\n\r\n\t// recover the bind-time world matrices\r\n\r\n\tfor ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {\r\n\r\n\t\tbone = this.bones[ b ];\r\n\r\n\t\tif ( bone ) {\r\n\r\n\t\t\tbone.matrixWorld.getInverse( this.boneInverses[ b ] );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// compute the local matrices, positions, rotations and scales\r\n\r\n\tfor ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {\r\n\r\n\t\tbone = this.bones[ b ];\r\n\r\n\t\tif ( bone ) {\r\n\r\n\t\t\tif ( bone.parent ) {\r\n\r\n\t\t\t\tbone.matrix.getInverse( bone.parent.matrixWorld );\r\n\t\t\t\tbone.matrix.multiply( bone.matrixWorld );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tbone.matrix.copy( bone.matrixWorld );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tbone.matrix.decompose( bone.position, bone.quaternion, bone.scale );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.Skeleton.prototype.update = ( function () {\r\n\r\n\tvar offsetMatrix = new THREE.Matrix4();\r\n\t\r\n\treturn function () {\r\n\r\n\t\t// flatten bone matrices to array\r\n\r\n\t\tfor ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {\r\n\r\n\t\t\t// compute the offset between the current and the original transform\r\n\r\n\t\t\tvar matrix = this.bones[ b ] ? this.bones[ b ].matrixWorld : this.identityMatrix;\r\n\r\n\t\t\toffsetMatrix.multiplyMatrices( matrix, this.boneInverses[ b ] );\r\n\t\t\toffsetMatrix.flattenToArrayOffset( this.boneMatrices, b * 16 );\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.useVertexTexture ) {\r\n\r\n\t\t\tthis.boneTexture.needsUpdate = true;\r\n\r\n\t\t}\r\n\t\t\r\n\t};\r\n\r\n} )();\r\n\r\n\r\n// File:src/objects/SkinnedMesh.js\r\n\r\n/**\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author ikerr / http://verold.com\r\n */\r\n\r\nTHREE.SkinnedMesh = function ( geometry, material, useVertexTexture ) {\r\n\r\n\tTHREE.Mesh.call( this, geometry, material );\r\n\r\n\tthis.type = 'SkinnedMesh';\r\n\r\n\tthis.bindMode = \"attached\";\r\n\tthis.bindMatrix = new THREE.Matrix4();\r\n\tthis.bindMatrixInverse = new THREE.Matrix4();\r\n\r\n\t// init bones\r\n\r\n\t// TODO: remove bone creation as there is no reason (other than\r\n\t// convenience) for THREE.SkinnedMesh to do this.\r\n\r\n\tvar bones = [];\r\n\r\n\tif ( this.geometry && this.geometry.bones !== undefined ) {\r\n\r\n\t\tvar bone, gbone, p, q, s;\r\n\r\n\t\tfor ( var b = 0, bl = this.geometry.bones.length; b < bl; ++ b ) {\r\n\r\n\t\t\tgbone = this.geometry.bones[ b ];\r\n\r\n\t\t\tp = gbone.pos;\r\n\t\t\tq = gbone.rotq;\r\n\t\t\ts = gbone.scl;\r\n\r\n\t\t\tbone = new THREE.Bone( this );\r\n\t\t\tbones.push( bone );\r\n\r\n\t\t\tbone.name = gbone.name;\r\n\t\t\tbone.position.set( p[ 0 ], p[ 1 ], p[ 2 ] );\r\n\t\t\tbone.quaternion.set( q[ 0 ], q[ 1 ], q[ 2 ], q[ 3 ] );\r\n\r\n\t\t\tif ( s !== undefined ) {\r\n\r\n\t\t\t\tbone.scale.set( s[ 0 ], s[ 1 ], s[ 2 ] );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tbone.scale.set( 1, 1, 1 );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tfor ( var b = 0, bl = this.geometry.bones.length; b < bl; ++ b ) {\r\n\r\n\t\t\tgbone = this.geometry.bones[ b ];\r\n\r\n\t\t\tif ( gbone.parent !== - 1 ) {\r\n\r\n\t\t\t\tbones[ gbone.parent ].add( bones[ b ] );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tthis.add( bones[ b ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tthis.normalizeSkinWeights();\r\n\r\n\tthis.updateMatrixWorld( true );\r\n\tthis.bind( new THREE.Skeleton( bones, undefined, useVertexTexture ) );\r\n\r\n};\r\n\r\n\r\nTHREE.SkinnedMesh.prototype = Object.create( THREE.Mesh.prototype );\r\nTHREE.SkinnedMesh.prototype.constructor = THREE.SkinnedMesh;\r\n\r\nTHREE.SkinnedMesh.prototype.bind = function( skeleton, bindMatrix ) {\r\n\r\n\tthis.skeleton = skeleton;\r\n\r\n\tif ( bindMatrix === undefined ) {\r\n\r\n\t\tthis.updateMatrixWorld( true );\r\n\r\n\t\tbindMatrix = this.matrixWorld;\r\n\r\n\t}\r\n\r\n\tthis.bindMatrix.copy( bindMatrix );\r\n\tthis.bindMatrixInverse.getInverse( bindMatrix );\r\n\r\n};\r\n\r\nTHREE.SkinnedMesh.prototype.pose = function () {\r\n\r\n\tthis.skeleton.pose();\r\n\r\n};\r\n\r\nTHREE.SkinnedMesh.prototype.normalizeSkinWeights = function () {\r\n\r\n\tif ( this.geometry instanceof THREE.Geometry ) {\r\n\r\n\t\tfor ( var i = 0; i < this.geometry.skinIndices.length; i ++ ) {\r\n\r\n\t\t\tvar sw = this.geometry.skinWeights[ i ];\r\n\r\n\t\t\tvar scale = 1.0 / sw.lengthManhattan();\r\n\r\n\t\t\tif ( scale !== Infinity ) {\r\n\r\n\t\t\t\tsw.multiplyScalar( scale );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tsw.set( 1 ); // this will be normalized by the shader anyway\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t} else {\r\n\r\n\t\t// skinning weights assumed to be normalized for THREE.BufferGeometry\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.SkinnedMesh.prototype.updateMatrixWorld = function( force ) {\r\n\r\n\tTHREE.Mesh.prototype.updateMatrixWorld.call( this, true );\r\n\r\n\tif ( this.bindMode === \"attached\" ) {\r\n\r\n\t\tthis.bindMatrixInverse.getInverse( this.matrixWorld );\r\n\r\n\t} else if ( this.bindMode === \"detached\" ) {\r\n\r\n\t\tthis.bindMatrixInverse.getInverse( this.bindMatrix );\r\n\r\n\t} else {\r\n\r\n\t\tTHREE.warn( 'THREE.SkinnedMesh unreckognized bindMode: ' + this.bindMode );\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.SkinnedMesh.prototype.clone = function( object ) {\r\n\r\n\tif ( object === undefined ) {\r\n\r\n\t\tobject = new THREE.SkinnedMesh( this.geometry, this.material, this.useVertexTexture );\r\n\r\n\t}\r\n\r\n\tTHREE.Mesh.prototype.clone.call( this, object );\r\n\r\n\treturn object;\r\n\r\n};\r\n\r\n\r\n// File:src/objects/MorphAnimMesh.js\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.MorphAnimMesh = function ( geometry, material ) {\r\n\r\n\tTHREE.Mesh.call( this, geometry, material );\r\n\r\n\tthis.type = 'MorphAnimMesh';\r\n\r\n\t// API\r\n\r\n\tthis.duration = 1000; // milliseconds\r\n\tthis.mirroredLoop = false;\r\n\tthis.time = 0;\r\n\r\n\t// internals\r\n\r\n\tthis.lastKeyframe = 0;\r\n\tthis.currentKeyframe = 0;\r\n\r\n\tthis.direction = 1;\r\n\tthis.directionBackwards = false;\r\n\r\n\tthis.setFrameRange( 0, this.geometry.morphTargets.length - 1 );\r\n\r\n};\r\n\r\nTHREE.MorphAnimMesh.prototype = Object.create( THREE.Mesh.prototype );\r\nTHREE.MorphAnimMesh.prototype.constructor = THREE.MorphAnimMesh;\r\n\r\nTHREE.MorphAnimMesh.prototype.setFrameRange = function ( start, end ) {\r\n\r\n\tthis.startKeyframe = start;\r\n\tthis.endKeyframe = end;\r\n\r\n\tthis.length = this.endKeyframe - this.startKeyframe + 1;\r\n\r\n};\r\n\r\nTHREE.MorphAnimMesh.prototype.setDirectionForward = function () {\r\n\r\n\tthis.direction = 1;\r\n\tthis.directionBackwards = false;\r\n\r\n};\r\n\r\nTHREE.MorphAnimMesh.prototype.setDirectionBackward = function () {\r\n\r\n\tthis.direction = - 1;\r\n\tthis.directionBackwards = true;\r\n\r\n};\r\n\r\nTHREE.MorphAnimMesh.prototype.parseAnimations = function () {\r\n\r\n\tvar geometry = this.geometry;\r\n\r\n\tif ( ! geometry.animations ) geometry.animations = {};\r\n\r\n\tvar firstAnimation, animations = geometry.animations;\r\n\r\n\tvar pattern = /([a-z]+)_?(\\d+)/;\r\n\r\n\tfor ( var i = 0, il = geometry.morphTargets.length; i < il; i ++ ) {\r\n\r\n\t\tvar morph = geometry.morphTargets[ i ];\r\n\t\tvar parts = morph.name.match( pattern );\r\n\r\n\t\tif ( parts && parts.length > 1 ) {\r\n\r\n\t\t\tvar label = parts[ 1 ];\r\n\r\n\t\t\tif ( ! animations[ label ] ) animations[ label ] = { start: Infinity, end: - Infinity };\r\n\r\n\t\t\tvar animation = animations[ label ];\r\n\r\n\t\t\tif ( i < animation.start ) animation.start = i;\r\n\t\t\tif ( i > animation.end ) animation.end = i;\r\n\r\n\t\t\tif ( ! firstAnimation ) firstAnimation = label;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tgeometry.firstAnimation = firstAnimation;\r\n\r\n};\r\n\r\nTHREE.MorphAnimMesh.prototype.setAnimationLabel = function ( label, start, end ) {\r\n\r\n\tif ( ! this.geometry.animations ) this.geometry.animations = {};\r\n\r\n\tthis.geometry.animations[ label ] = { start: start, end: end };\r\n\r\n};\r\n\r\nTHREE.MorphAnimMesh.prototype.playAnimation = function ( label, fps ) {\r\n\r\n\tvar animation = this.geometry.animations[ label ];\r\n\r\n\tif ( animation ) {\r\n\r\n\t\tthis.setFrameRange( animation.start, animation.end );\r\n\t\tthis.duration = 1000 * ( ( animation.end - animation.start ) / fps );\r\n\t\tthis.time = 0;\r\n\r\n\t} else {\r\n\r\n\t\tTHREE.warn( 'THREE.MorphAnimMesh: animation[' + label + '] undefined in .playAnimation()' );\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.MorphAnimMesh.prototype.updateAnimation = function ( delta ) {\r\n\r\n\tvar frameTime = this.duration / this.length;\r\n\r\n\tthis.time += this.direction * delta;\r\n\r\n\tif ( this.mirroredLoop ) {\r\n\r\n\t\tif ( this.time > this.duration || this.time < 0 ) {\r\n\r\n\t\t\tthis.direction *= - 1;\r\n\r\n\t\t\tif ( this.time > this.duration ) {\r\n\r\n\t\t\t\tthis.time = this.duration;\r\n\t\t\t\tthis.directionBackwards = true;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( this.time < 0 ) {\r\n\r\n\t\t\t\tthis.time = 0;\r\n\t\t\t\tthis.directionBackwards = false;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t} else {\r\n\r\n\t\tthis.time = this.time % this.duration;\r\n\r\n\t\tif ( this.time < 0 ) this.time += this.duration;\r\n\r\n\t}\r\n\r\n\tvar keyframe = this.startKeyframe + THREE.Math.clamp( Math.floor( this.time / frameTime ), 0, this.length - 1 );\r\n\r\n\tif ( keyframe !== this.currentKeyframe ) {\r\n\r\n\t\tthis.morphTargetInfluences[ this.lastKeyframe ] = 0;\r\n\t\tthis.morphTargetInfluences[ this.currentKeyframe ] = 1;\r\n\r\n\t\tthis.morphTargetInfluences[ keyframe ] = 0;\r\n\r\n\t\tthis.lastKeyframe = this.currentKeyframe;\r\n\t\tthis.currentKeyframe = keyframe;\r\n\r\n\t}\r\n\r\n\tvar mix = ( this.time % frameTime ) / frameTime;\r\n\r\n\tif ( this.directionBackwards ) {\r\n\r\n\t\tmix = 1 - mix;\r\n\r\n\t}\r\n\r\n\tthis.morphTargetInfluences[ this.currentKeyframe ] = mix;\r\n\tthis.morphTargetInfluences[ this.lastKeyframe ] = 1 - mix;\r\n\r\n};\r\n\r\nTHREE.MorphAnimMesh.prototype.interpolateTargets = function ( a, b, t ) {\r\n\r\n\tvar influences = this.morphTargetInfluences;\r\n\r\n\tfor ( var i = 0, l = influences.length; i < l; i ++ ) {\r\n\r\n\t\tinfluences[ i ] = 0;\r\n\r\n\t}\r\n\r\n\tif ( a > -1 ) influences[ a ] = 1 - t;\r\n\tif ( b > -1 ) influences[ b ] = t;\r\n\r\n};\r\n\r\nTHREE.MorphAnimMesh.prototype.clone = function ( object ) {\r\n\r\n\tif ( object === undefined ) object = new THREE.MorphAnimMesh( this.geometry, this.material );\r\n\r\n\tobject.duration = this.duration;\r\n\tobject.mirroredLoop = this.mirroredLoop;\r\n\tobject.time = this.time;\r\n\r\n\tobject.lastKeyframe = this.lastKeyframe;\r\n\tobject.currentKeyframe = this.currentKeyframe;\r\n\r\n\tobject.direction = this.direction;\r\n\tobject.directionBackwards = this.directionBackwards;\r\n\r\n\tTHREE.Mesh.prototype.clone.call( this, object );\r\n\r\n\treturn object;\r\n\r\n};\r\n\r\n// File:src/objects/LOD.js\r\n\r\n/**\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.LOD = function () {\r\n\r\n\tTHREE.Object3D.call( this );\r\n\r\n\tthis.objects = [];\r\n\r\n};\r\n\r\n\r\nTHREE.LOD.prototype = Object.create( THREE.Object3D.prototype );\r\nTHREE.LOD.prototype.constructor = THREE.LOD;\r\n\r\nTHREE.LOD.prototype.addLevel = function ( object, distance ) {\r\n\r\n\tif ( distance === undefined ) distance = 0;\r\n\r\n\tdistance = Math.abs( distance );\r\n\r\n\tfor ( var l = 0; l < this.objects.length; l ++ ) {\r\n\r\n\t\tif ( distance < this.objects[ l ].distance ) {\r\n\r\n\t\t\tbreak;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tthis.objects.splice( l, 0, { distance: distance, object: object } );\r\n\tthis.add( object );\r\n\r\n};\r\n\r\nTHREE.LOD.prototype.getObjectForDistance = function ( distance ) {\r\n\r\n\tfor ( var i = 1, l = this.objects.length; i < l; i ++ ) {\r\n\r\n\t\tif ( distance < this.objects[ i ].distance ) {\r\n\r\n\t\t\tbreak;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\treturn this.objects[ i - 1 ].object;\r\n\r\n};\r\n\r\nTHREE.LOD.prototype.raycast = ( function () {\r\n\r\n\tvar matrixPosition = new THREE.Vector3();\r\n\r\n\treturn function ( raycaster, intersects ) {\r\n\r\n\t\tmatrixPosition.setFromMatrixPosition( this.matrixWorld );\r\n\r\n\t\tvar distance = raycaster.ray.origin.distanceTo( matrixPosition );\r\n\r\n\t\tthis.getObjectForDistance( distance ).raycast( raycaster, intersects );\r\n\r\n\t};\r\n\r\n}() );\r\n\r\nTHREE.LOD.prototype.update = function () {\r\n\r\n\tvar v1 = new THREE.Vector3();\r\n\tvar v2 = new THREE.Vector3();\r\n\r\n\treturn function ( camera ) {\r\n\r\n\t\tif ( this.objects.length > 1 ) {\r\n\r\n\t\t\tv1.setFromMatrixPosition( camera.matrixWorld );\r\n\t\t\tv2.setFromMatrixPosition( this.matrixWorld );\r\n\r\n\t\t\tvar distance = v1.distanceTo( v2 );\r\n\r\n\t\t\tthis.objects[ 0 ].object.visible = true;\r\n\r\n\t\t\tfor ( var i = 1, l = this.objects.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tif ( distance >= this.objects[ i ].distance ) {\r\n\r\n\t\t\t\t\tthis.objects[ i - 1 ].object.visible = false;\r\n\t\t\t\t\tthis.objects[ i     ].object.visible = true;\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfor ( ; i < l; i ++ ) {\r\n\r\n\t\t\t\tthis.objects[ i ].object.visible = false;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n}();\r\n\r\nTHREE.LOD.prototype.clone = function ( object ) {\r\n\r\n\tif ( object === undefined ) object = new THREE.LOD();\r\n\r\n\tTHREE.Object3D.prototype.clone.call( this, object );\r\n\r\n\tfor ( var i = 0, l = this.objects.length; i < l; i ++ ) {\r\n\t\tvar x = this.objects[ i ].object.clone();\r\n\t\tx.visible = i === 0;\r\n\t\tobject.addLevel( x, this.objects[ i ].distance );\r\n\t}\r\n\r\n\treturn object;\r\n\r\n};\r\n\r\n// File:src/objects/Sprite.js\r\n\r\n/**\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.Sprite = ( function () {\r\n\r\n\tvar indices = new Uint16Array( [ 0, 1, 2,  0, 2, 3 ] );\r\n\tvar vertices = new Float32Array( [ - 0.5, - 0.5, 0,   0.5, - 0.5, 0,   0.5, 0.5, 0,   - 0.5, 0.5, 0 ] );\r\n\tvar uvs = new Float32Array( [ 0, 0,   1, 0,   1, 1,   0, 1 ] );\r\n\r\n\tvar geometry = new THREE.BufferGeometry();\r\n\tgeometry.addAttribute( 'index', new THREE.BufferAttribute( indices, 1 ) );\r\n\tgeometry.addAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );\r\n\tgeometry.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ) );\r\n\r\n\treturn function ( material ) {\r\n\r\n\t\tTHREE.Object3D.call( this );\r\n\r\n\t\tthis.type = 'Sprite';\r\n\r\n\t\tthis.geometry = geometry;\r\n\t\tthis.material = ( material !== undefined ) ? material : new THREE.SpriteMaterial();\r\n\r\n\t};\r\n\r\n} )();\r\n\r\nTHREE.Sprite.prototype = Object.create( THREE.Object3D.prototype );\r\nTHREE.Sprite.prototype.constructor = THREE.Sprite;\r\n\r\nTHREE.Sprite.prototype.raycast = ( function () {\r\n\r\n\tvar matrixPosition = new THREE.Vector3();\r\n\r\n\treturn function ( raycaster, intersects ) {\r\n\r\n\t\tmatrixPosition.setFromMatrixPosition( this.matrixWorld );\r\n\r\n\t\tvar distance = raycaster.ray.distanceToPoint( matrixPosition );\r\n\r\n\t\tif ( distance > this.scale.x ) {\r\n\r\n\t\t\treturn;\r\n\r\n\t\t}\r\n\r\n\t\tintersects.push( {\r\n\r\n\t\t\tdistance: distance,\r\n\t\t\tpoint: this.position,\r\n\t\t\tface: null,\r\n\t\t\tobject: this\r\n\r\n\t\t} );\r\n\r\n\t};\r\n\r\n}() );\r\n\r\nTHREE.Sprite.prototype.clone = function ( object ) {\r\n\r\n\tif ( object === undefined ) object = new THREE.Sprite( this.material );\r\n\r\n\tTHREE.Object3D.prototype.clone.call( this, object );\r\n\r\n\treturn object;\r\n\r\n};\r\n\r\n// Backwards compatibility\r\n\r\nTHREE.Particle = THREE.Sprite;\r\n\r\n// File:src/objects/LensFlare.js\r\n\r\n/**\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.LensFlare = function ( texture, size, distance, blending, color ) {\r\n\r\n\tTHREE.Object3D.call( this );\r\n\r\n\tthis.lensFlares = [];\r\n\r\n\tthis.positionScreen = new THREE.Vector3();\r\n\tthis.customUpdateCallback = undefined;\r\n\r\n\tif ( texture !== undefined ) {\r\n\r\n\t\tthis.add( texture, size, distance, blending, color );\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.LensFlare.prototype = Object.create( THREE.Object3D.prototype );\r\nTHREE.LensFlare.prototype.constructor = THREE.LensFlare;\r\n\r\n\r\n/*\r\n * Add: adds another flare\r\n */\r\n\r\nTHREE.LensFlare.prototype.add = function ( texture, size, distance, blending, color, opacity ) {\r\n\r\n\tif ( size === undefined ) size = - 1;\r\n\tif ( distance === undefined ) distance = 0;\r\n\tif ( opacity === undefined ) opacity = 1;\r\n\tif ( color === undefined ) color = new THREE.Color( 0xffffff );\r\n\tif ( blending === undefined ) blending = THREE.NormalBlending;\r\n\r\n\tdistance = Math.min( distance, Math.max( 0, distance ) );\r\n\r\n\tthis.lensFlares.push( {\r\n\t\ttexture: texture, \t\t\t// THREE.Texture\r\n\t\tsize: size, \t\t\t\t// size in pixels (-1 = use texture.width)\r\n\t\tdistance: distance, \t\t// distance (0-1) from light source (0=at light source)\r\n\t\tx: 0, y: 0, z: 0,\t\t\t// screen position (-1 => 1) z = 0 is ontop z = 1 is back\r\n\t\tscale: 1, \t\t\t\t\t// scale\r\n\t\trotation: 1, \t\t\t\t// rotation\r\n\t\topacity: opacity,\t\t\t// opacity\r\n\t\tcolor: color,\t\t\t\t// color\r\n\t\tblending: blending\t\t\t// blending\r\n\t} );\r\n\r\n};\r\n\r\n/*\r\n * Update lens flares update positions on all flares based on the screen position\r\n * Set myLensFlare.customUpdateCallback to alter the flares in your project specific way.\r\n */\r\n\r\nTHREE.LensFlare.prototype.updateLensFlares = function () {\r\n\r\n\tvar f, fl = this.lensFlares.length;\r\n\tvar flare;\r\n\tvar vecX = - this.positionScreen.x * 2;\r\n\tvar vecY = - this.positionScreen.y * 2;\r\n\r\n\tfor ( f = 0; f < fl; f ++ ) {\r\n\r\n\t\tflare = this.lensFlares[ f ];\r\n\r\n\t\tflare.x = this.positionScreen.x + vecX * flare.distance;\r\n\t\tflare.y = this.positionScreen.y + vecY * flare.distance;\r\n\r\n\t\tflare.wantedRotation = flare.x * Math.PI * 0.25;\r\n\t\tflare.rotation += ( flare.wantedRotation - flare.rotation ) * 0.25;\r\n\r\n\t}\r\n\r\n};\r\n\r\n\r\n// File:src/scenes/Scene.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.Scene = function () {\r\n\r\n\tTHREE.Object3D.call( this );\r\n\r\n\tthis.type = 'Scene';\r\n\r\n\tthis.fog = null;\r\n\tthis.overrideMaterial = null;\r\n\r\n\tthis.autoUpdate = true; // checked by the renderer\r\n\r\n};\r\n\r\nTHREE.Scene.prototype = Object.create( THREE.Object3D.prototype );\r\nTHREE.Scene.prototype.constructor = THREE.Scene;\r\n\r\nTHREE.Scene.prototype.clone = function ( object ) {\r\n\r\n\tif ( object === undefined ) object = new THREE.Scene();\r\n\r\n\tTHREE.Object3D.prototype.clone.call( this, object );\r\n\r\n\tif ( this.fog !== null ) object.fog = this.fog.clone();\r\n\tif ( this.overrideMaterial !== null ) object.overrideMaterial = this.overrideMaterial.clone();\r\n\r\n\tobject.autoUpdate = this.autoUpdate;\r\n\tobject.matrixAutoUpdate = this.matrixAutoUpdate;\r\n\r\n\treturn object;\r\n\r\n};\r\n\r\n// File:src/scenes/Fog.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.Fog = function ( color, near, far ) {\r\n\r\n\tthis.name = '';\r\n\r\n\tthis.color = new THREE.Color( color );\r\n\r\n\tthis.near = ( near !== undefined ) ? near : 1;\r\n\tthis.far = ( far !== undefined ) ? far : 1000;\r\n\r\n};\r\n\r\nTHREE.Fog.prototype.clone = function () {\r\n\r\n\treturn new THREE.Fog( this.color.getHex(), this.near, this.far );\r\n\r\n};\r\n\r\n// File:src/scenes/FogExp2.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.FogExp2 = function ( color, density ) {\r\n\r\n\tthis.name = '';\r\n\r\n\tthis.color = new THREE.Color( color );\r\n\tthis.density = ( density !== undefined ) ? density : 0.00025;\r\n\r\n};\r\n\r\nTHREE.FogExp2.prototype.clone = function () {\r\n\r\n\treturn new THREE.FogExp2( this.color.getHex(), this.density );\r\n\r\n};\r\n\r\n// File:src/renderers/shaders/ShaderChunk.js\r\n\r\nTHREE.ShaderChunk = {};\r\n\r\n// File:src/renderers/shaders/ShaderChunk/common.glsl\r\n\r\nTHREE.ShaderChunk[ 'common'] = \"#define PI 3.14159\\n#define PI2 6.28318\\n#define RECIPROCAL_PI2 0.15915494\\n#define LOG2 1.442695\\n#define EPSILON 1e-6\\n\\nfloat square( in float a ) { return a*a; }\\nvec2  square( in vec2 a )  { return vec2( a.x*a.x, a.y*a.y ); }\\nvec3  square( in vec3 a )  { return vec3( a.x*a.x, a.y*a.y, a.z*a.z ); }\\nvec4  square( in vec4 a )  { return vec4( a.x*a.x, a.y*a.y, a.z*a.z, a.w*a.w ); }\\nfloat saturate( in float a ) { return clamp( a, 0.0, 1.0 ); }\\nvec2  saturate( in vec2 a )  { return clamp( a, 0.0, 1.0 ); }\\nvec3  saturate( in vec3 a )  { return clamp( a, 0.0, 1.0 ); }\\nvec4  saturate( in vec4 a )  { return clamp( a, 0.0, 1.0 ); }\\nfloat average( in float a ) { return a; }\\nfloat average( in vec2 a )  { return ( a.x + a.y) * 0.5; }\\nfloat average( in vec3 a )  { return ( a.x + a.y + a.z) / 3.0; }\\nfloat average( in vec4 a )  { return ( a.x + a.y + a.z + a.w) * 0.25; }\\nfloat whiteCompliment( in float a ) { return saturate( 1.0 - a ); }\\nvec2  whiteCompliment( in vec2 a )  { return saturate( vec2(1.0) - a ); }\\nvec3  whiteCompliment( in vec3 a )  { return saturate( vec3(1.0) - a ); }\\nvec4  whiteCompliment( in vec4 a )  { return saturate( vec4(1.0) - a ); }\\nvec3 transformDirection( in vec3 normal, in mat4 matrix ) {\\n\treturn normalize( ( matrix * vec4( normal, 0.0 ) ).xyz );\\n}\\n// http://en.wikibooks.org/wiki/GLSL_Programming/Applying_Matrix_Transformations\\nvec3 inverseTransformDirection( in vec3 normal, in mat4 matrix ) {\\n\treturn normalize( ( vec4( normal, 0.0 ) * matrix ).xyz );\\n}\\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal) {\\n\tfloat distance = dot( planeNormal, point-pointOnPlane );\\n\treturn point - distance * planeNormal;\\n}\\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\\n}\\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\\n\treturn pointOnLine + lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) );\\n}\\nfloat calcLightAttenuation( float lightDistance, float cutoffDistance, float decayExponent ) {\\n\tif ( decayExponent > 0.0 ) {\\n\t  return pow( saturate( 1.0 - lightDistance / cutoffDistance ), decayExponent );\\n\t}\\n\treturn 1.0;\\n}\\n\\nvec3 inputToLinear( in vec3 a ) {\\n#ifdef GAMMA_INPUT\\n\treturn pow( a, vec3( float( GAMMA_FACTOR ) ) );\\n#else\\n\treturn a;\\n#endif\\n}\\nvec3 linearToOutput( in vec3 a ) {\\n#ifdef GAMMA_OUTPUT\\n\treturn pow( a, vec3( 1.0 / float( GAMMA_FACTOR ) ) );\\n#else\\n\treturn a;\\n#endif\\n}\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/alphatest_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'alphatest_fragment'] = \"#ifdef ALPHATEST\\n\\n\tif ( diffuseColor.a < ALPHATEST ) discard;\\n\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/lights_lambert_vertex.glsl\r\n\r\nTHREE.ShaderChunk[ 'lights_lambert_vertex'] = \"vLightFront = vec3( 0.0 );\\n\\n#ifdef DOUBLE_SIDED\\n\\n\tvLightBack = vec3( 0.0 );\\n\\n#endif\\n\\ntransformedNormal = normalize( transformedNormal );\\n\\n#if MAX_DIR_LIGHTS > 0\\n\\nfor( int i = 0; i < MAX_DIR_LIGHTS; i ++ ) {\\n\\n\tvec3 dirVector = transformDirection( directionalLightDirection[ i ], viewMatrix );\\n\\n\tfloat dotProduct = dot( transformedNormal, dirVector );\\n\tvec3 directionalLightWeighting = vec3( max( dotProduct, 0.0 ) );\\n\\n\t#ifdef DOUBLE_SIDED\\n\\n\t\tvec3 directionalLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );\\n\\n\t\t#ifdef WRAP_AROUND\\n\\n\t\t\tvec3 directionalLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );\\n\\n\t\t#endif\\n\\n\t#endif\\n\\n\t#ifdef WRAP_AROUND\\n\\n\t\tvec3 directionalLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );\\n\t\tdirectionalLightWeighting = mix( directionalLightWeighting, directionalLightWeightingHalf, wrapRGB );\\n\\n\t\t#ifdef DOUBLE_SIDED\\n\\n\t\t\tdirectionalLightWeightingBack = mix( directionalLightWeightingBack, directionalLightWeightingHalfBack, wrapRGB );\\n\\n\t\t#endif\\n\\n\t#endif\\n\\n\tvLightFront += directionalLightColor[ i ] * directionalLightWeighting;\\n\\n\t#ifdef DOUBLE_SIDED\\n\\n\t\tvLightBack += directionalLightColor[ i ] * directionalLightWeightingBack;\\n\\n\t#endif\\n\\n}\\n\\n#endif\\n\\n#if MAX_POINT_LIGHTS > 0\\n\\n\tfor( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {\\n\\n\t\tvec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );\\n\t\tvec3 lVector = lPosition.xyz - mvPosition.xyz;\\n\\n\t\tfloat attenuation = calcLightAttenuation( length( lVector ), pointLightDistance[ i ], pointLightDecay[ i ] );\\n\\n\t\tlVector = normalize( lVector );\\n\t\tfloat dotProduct = dot( transformedNormal, lVector );\\n\\n\t\tvec3 pointLightWeighting = vec3( max( dotProduct, 0.0 ) );\\n\\n\t\t#ifdef DOUBLE_SIDED\\n\\n\t\t\tvec3 pointLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );\\n\\n\t\t\t#ifdef WRAP_AROUND\\n\\n\t\t\t\tvec3 pointLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );\\n\\n\t\t\t#endif\\n\\n\t\t#endif\\n\\n\t\t#ifdef WRAP_AROUND\\n\\n\t\t\tvec3 pointLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );\\n\t\t\tpointLightWeighting = mix( pointLightWeighting, pointLightWeightingHalf, wrapRGB );\\n\\n\t\t\t#ifdef DOUBLE_SIDED\\n\\n\t\t\t\tpointLightWeightingBack = mix( pointLightWeightingBack, pointLightWeightingHalfBack, wrapRGB );\\n\\n\t\t\t#endif\\n\\n\t\t#endif\\n\\n\t\tvLightFront += pointLightColor[ i ] * pointLightWeighting * attenuation;\\n\\n\t\t#ifdef DOUBLE_SIDED\\n\\n\t\t\tvLightBack += pointLightColor[ i ] * pointLightWeightingBack * attenuation;\\n\\n\t\t#endif\\n\\n\t}\\n\\n#endif\\n\\n#if MAX_SPOT_LIGHTS > 0\\n\\n\tfor( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {\\n\\n\t\tvec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );\\n\t\tvec3 lVector = lPosition.xyz - mvPosition.xyz;\\n\\n\t\tfloat spotEffect = dot( spotLightDirection[ i ], normalize( spotLightPosition[ i ] - worldPosition.xyz ) );\\n\\n\t\tif ( spotEffect > spotLightAngleCos[ i ] ) {\\n\\n\t\t\tspotEffect = max( pow( max( spotEffect, 0.0 ), spotLightExponent[ i ] ), 0.0 );\\n\\n\t\t\tfloat attenuation = calcLightAttenuation( length( lVector ), spotLightDistance[ i ], spotLightDecay[ i ] );\\n\\n\t\t\tlVector = normalize( lVector );\\n\\n\t\t\tfloat dotProduct = dot( transformedNormal, lVector );\\n\t\t\tvec3 spotLightWeighting = vec3( max( dotProduct, 0.0 ) );\\n\\n\t\t\t#ifdef DOUBLE_SIDED\\n\\n\t\t\t\tvec3 spotLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );\\n\\n\t\t\t\t#ifdef WRAP_AROUND\\n\\n\t\t\t\t\tvec3 spotLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );\\n\\n\t\t\t\t#endif\\n\\n\t\t\t#endif\\n\\n\t\t\t#ifdef WRAP_AROUND\\n\\n\t\t\t\tvec3 spotLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );\\n\t\t\t\tspotLightWeighting = mix( spotLightWeighting, spotLightWeightingHalf, wrapRGB );\\n\\n\t\t\t\t#ifdef DOUBLE_SIDED\\n\\n\t\t\t\t\tspotLightWeightingBack = mix( spotLightWeightingBack, spotLightWeightingHalfBack, wrapRGB );\\n\\n\t\t\t\t#endif\\n\\n\t\t\t#endif\\n\\n\t\t\tvLightFront += spotLightColor[ i ] * spotLightWeighting * attenuation * spotEffect;\\n\\n\t\t\t#ifdef DOUBLE_SIDED\\n\\n\t\t\t\tvLightBack += spotLightColor[ i ] * spotLightWeightingBack * attenuation * spotEffect;\\n\\n\t\t\t#endif\\n\\n\t\t}\\n\\n\t}\\n\\n#endif\\n\\n#if MAX_HEMI_LIGHTS > 0\\n\\n\tfor( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {\\n\\n\t\tvec3 lVector = transformDirection( hemisphereLightDirection[ i ], viewMatrix );\\n\\n\t\tfloat dotProduct = dot( transformedNormal, lVector );\\n\\n\t\tfloat hemiDiffuseWeight = 0.5 * dotProduct + 0.5;\\n\t\tfloat hemiDiffuseWeightBack = -0.5 * dotProduct + 0.5;\\n\\n\t\tvLightFront += mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );\\n\\n\t\t#ifdef DOUBLE_SIDED\\n\\n\t\t\tvLightBack += mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeightBack );\\n\\n\t\t#endif\\n\\n\t}\\n\\n#endif\\n\\nvLightFront += ambientLightColor;\\n\\n#ifdef DOUBLE_SIDED\\n\\n\tvLightBack += ambientLightColor;\\n\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/map_particle_pars_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'map_particle_pars_fragment'] = \"#ifdef USE_MAP\\n\\n\tuniform vec4 offsetRepeat;\\n\tuniform sampler2D map;\\n\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/default_vertex.glsl\r\n\r\nTHREE.ShaderChunk[ 'default_vertex'] = \"#ifdef USE_SKINNING\\n\\n\tvec4 mvPosition = modelViewMatrix * skinned;\\n\\n#elif defined( USE_MORPHTARGETS )\\n\\n\tvec4 mvPosition = modelViewMatrix * vec4( morphed, 1.0 );\\n\\n#else\\n\\n\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\\n\\n#endif\\n\\ngl_Position = projectionMatrix * mvPosition;\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/map_pars_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'map_pars_fragment'] = \"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP )\\n\\n\tvarying vec2 vUv;\\n\\n#endif\\n\\n#ifdef USE_MAP\\n\\n\tuniform sampler2D map;\\n\\n#endif\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/skinnormal_vertex.glsl\r\n\r\nTHREE.ShaderChunk[ 'skinnormal_vertex'] = \"#ifdef USE_SKINNING\\n\\n\tmat4 skinMatrix = mat4( 0.0 );\\n\tskinMatrix += skinWeight.x * boneMatX;\\n\tskinMatrix += skinWeight.y * boneMatY;\\n\tskinMatrix += skinWeight.z * boneMatZ;\\n\tskinMatrix += skinWeight.w * boneMatW;\\n\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\\n\\n\t#ifdef USE_MORPHNORMALS\\n\\n\tvec4 skinnedNormal = skinMatrix * vec4( morphedNormal, 0.0 );\\n\\n\t#else\\n\\n\tvec4 skinnedNormal = skinMatrix * vec4( normal, 0.0 );\\n\\n\t#endif\\n\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/logdepthbuf_pars_vertex.glsl\r\n\r\nTHREE.ShaderChunk[ 'logdepthbuf_pars_vertex'] = \"#ifdef USE_LOGDEPTHBUF\\n\\n\t#ifdef USE_LOGDEPTHBUF_EXT\\n\\n\t\tvarying float vFragDepth;\\n\\n\t#endif\\n\\n\tuniform float logDepthBufFC;\\n\\n#endif\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/lightmap_pars_vertex.glsl\r\n\r\nTHREE.ShaderChunk[ 'lightmap_pars_vertex'] = \"#ifdef USE_LIGHTMAP\\n\\n\tvarying vec2 vUv2;\\n\\n#endif\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/lights_phong_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'lights_phong_fragment'] = \"#ifndef FLAT_SHADED\\n\\n\tvec3 normal = normalize( vNormal );\\n\\n\t#ifdef DOUBLE_SIDED\\n\\n\t\tnormal = normal * ( -1.0 + 2.0 * float( gl_FrontFacing ) );\\n\\n\t#endif\\n\\n#else\\n\\n\tvec3 fdx = dFdx( vViewPosition );\\n\tvec3 fdy = dFdy( vViewPosition );\\n\tvec3 normal = normalize( cross( fdx, fdy ) );\\n\\n#endif\\n\\nvec3 viewPosition = normalize( vViewPosition );\\n\\n#ifdef USE_NORMALMAP\\n\\n\tnormal = perturbNormal2Arb( -vViewPosition, normal );\\n\\n#elif defined( USE_BUMPMAP )\\n\\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\\n\\n#endif\\n\\nvec3 totalDiffuseLight = vec3( 0.0 );\\nvec3 totalSpecularLight = vec3( 0.0 );\\n\\n#if MAX_POINT_LIGHTS > 0\\n\\n\tfor ( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {\\n\\n\t\tvec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );\\n\t\tvec3 lVector = lPosition.xyz + vViewPosition.xyz;\\n\\n\t\tfloat attenuation = calcLightAttenuation( length( lVector ), pointLightDistance[ i ], pointLightDecay[ i ] );\\n\\n\t\tlVector = normalize( lVector );\\n\\n\t\t// diffuse\\n\\n\t\tfloat dotProduct = dot( normal, lVector );\\n\\n\t\t#ifdef WRAP_AROUND\\n\\n\t\t\tfloat pointDiffuseWeightFull = max( dotProduct, 0.0 );\\n\t\t\tfloat pointDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );\\n\\n\t\t\tvec3 pointDiffuseWeight = mix( vec3( pointDiffuseWeightFull ), vec3( pointDiffuseWeightHalf ), wrapRGB );\\n\\n\t\t#else\\n\\n\t\t\tfloat pointDiffuseWeight = max( dotProduct, 0.0 );\\n\\n\t\t#endif\\n\\n\t\ttotalDiffuseLight += pointLightColor[ i ] * pointDiffuseWeight * attenuation;\\n\\n\t\t\t\t// specular\\n\\n\t\tvec3 pointHalfVector = normalize( lVector + viewPosition );\\n\t\tfloat pointDotNormalHalf = max( dot( normal, pointHalfVector ), 0.0 );\\n\t\tfloat pointSpecularWeight = specularStrength * max( pow( pointDotNormalHalf, shininess ), 0.0 );\\n\\n\t\tfloat specularNormalization = ( shininess + 2.0 ) / 8.0;\\n\\n\t\tvec3 schlick = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( lVector, pointHalfVector ), 0.0 ), 5.0 );\\n\t\ttotalSpecularLight += schlick * pointLightColor[ i ] * pointSpecularWeight * pointDiffuseWeight * attenuation * specularNormalization;\\n\\n\t}\\n\\n#endif\\n\\n#if MAX_SPOT_LIGHTS > 0\\n\\n\tfor ( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {\\n\\n\t\tvec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );\\n\t\tvec3 lVector = lPosition.xyz + vViewPosition.xyz;\\n\\n\t\tfloat attenuation = calcLightAttenuation( length( lVector ), spotLightDistance[ i ], spotLightDecay[ i ] );\\n\\n\t\tlVector = normalize( lVector );\\n\\n\t\tfloat spotEffect = dot( spotLightDirection[ i ], normalize( spotLightPosition[ i ] - vWorldPosition ) );\\n\\n\t\tif ( spotEffect > spotLightAngleCos[ i ] ) {\\n\\n\t\t\tspotEffect = max( pow( max( spotEffect, 0.0 ), spotLightExponent[ i ] ), 0.0 );\\n\\n\t\t\t// diffuse\\n\\n\t\t\tfloat dotProduct = dot( normal, lVector );\\n\\n\t\t\t#ifdef WRAP_AROUND\\n\\n\t\t\t\tfloat spotDiffuseWeightFull = max( dotProduct, 0.0 );\\n\t\t\t\tfloat spotDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );\\n\\n\t\t\t\tvec3 spotDiffuseWeight = mix( vec3( spotDiffuseWeightFull ), vec3( spotDiffuseWeightHalf ), wrapRGB );\\n\\n\t\t\t#else\\n\\n\t\t\t\tfloat spotDiffuseWeight = max( dotProduct, 0.0 );\\n\\n\t\t\t#endif\\n\\n\t\t\ttotalDiffuseLight += spotLightColor[ i ] * spotDiffuseWeight * attenuation * spotEffect;\\n\\n\t\t\t// specular\\n\\n\t\t\tvec3 spotHalfVector = normalize( lVector + viewPosition );\\n\t\t\tfloat spotDotNormalHalf = max( dot( normal, spotHalfVector ), 0.0 );\\n\t\t\tfloat spotSpecularWeight = specularStrength * max( pow( spotDotNormalHalf, shininess ), 0.0 );\\n\\n\t\t\tfloat specularNormalization = ( shininess + 2.0 ) / 8.0;\\n\\n\t\t\tvec3 schlick = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( lVector, spotHalfVector ), 0.0 ), 5.0 );\\n\t\t\ttotalSpecularLight += schlick * spotLightColor[ i ] * spotSpecularWeight * spotDiffuseWeight * attenuation * specularNormalization * spotEffect;\\n\\n\t\t}\\n\\n\t}\\n\\n#endif\\n\\n#if MAX_DIR_LIGHTS > 0\\n\\n\tfor( int i = 0; i < MAX_DIR_LIGHTS; i ++ ) {\\n\\n\t\tvec3 dirVector = transformDirection( directionalLightDirection[ i ], viewMatrix );\\n\\n\t\t// diffuse\\n\\n\t\tfloat dotProduct = dot( normal, dirVector );\\n\\n\t\t#ifdef WRAP_AROUND\\n\\n\t\t\tfloat dirDiffuseWeightFull = max( dotProduct, 0.0 );\\n\t\t\tfloat dirDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );\\n\\n\t\t\tvec3 dirDiffuseWeight = mix( vec3( dirDiffuseWeightFull ), vec3( dirDiffuseWeightHalf ), wrapRGB );\\n\\n\t\t#else\\n\\n\t\t\tfloat dirDiffuseWeight = max( dotProduct, 0.0 );\\n\\n\t\t#endif\\n\\n\t\ttotalDiffuseLight += directionalLightColor[ i ] * dirDiffuseWeight;\\n\\n\t\t// specular\\n\\n\t\tvec3 dirHalfVector = normalize( dirVector + viewPosition );\\n\t\tfloat dirDotNormalHalf = max( dot( normal, dirHalfVector ), 0.0 );\\n\t\tfloat dirSpecularWeight = specularStrength * max( pow( dirDotNormalHalf, shininess ), 0.0 );\\n\\n\t\t/*\\n\t\t// fresnel term from skin shader\\n\t\tconst float F0 = 0.128;\\n\\n\t\tfloat base = 1.0 - dot( viewPosition, dirHalfVector );\\n\t\tfloat exponential = pow( base, 5.0 );\\n\\n\t\tfloat fresnel = exponential + F0 * ( 1.0 - exponential );\\n\t\t*/\\n\\n\t\t/*\\n\t\t// fresnel term from fresnel shader\\n\t\tconst float mFresnelBias = 0.08;\\n\t\tconst float mFresnelScale = 0.3;\\n\t\tconst float mFresnelPower = 5.0;\\n\\n\t\tfloat fresnel = mFresnelBias + mFresnelScale * pow( 1.0 + dot( normalize( -viewPosition ), normal ), mFresnelPower );\\n\t\t*/\\n\\n\t\tfloat specularNormalization = ( shininess + 2.0 ) / 8.0;\\n\\n\t\t// \t\tdirSpecular += specular * directionalLightColor[ i ] * dirSpecularWeight * dirDiffuseWeight * specularNormalization * fresnel;\\n\\n\t\tvec3 schlick = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( dirVector, dirHalfVector ), 0.0 ), 5.0 );\\n\t\ttotalSpecularLight += schlick * directionalLightColor[ i ] * dirSpecularWeight * dirDiffuseWeight * specularNormalization;\\n\\n\\n\t}\\n\\n#endif\\n\\n#if MAX_HEMI_LIGHTS > 0\\n\\n\tfor( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {\\n\\n\t\tvec3 lVector = transformDirection( hemisphereLightDirection[ i ], viewMatrix );\\n\\n\t\t// diffuse\\n\\n\t\tfloat dotProduct = dot( normal, lVector );\\n\t\tfloat hemiDiffuseWeight = 0.5 * dotProduct + 0.5;\\n\\n\t\tvec3 hemiColor = mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );\\n\\n\t\ttotalDiffuseLight += hemiColor;\\n\\n\t\t// specular (sky light)\\n\\n\t\tvec3 hemiHalfVectorSky = normalize( lVector + viewPosition );\\n\t\tfloat hemiDotNormalHalfSky = 0.5 * dot( normal, hemiHalfVectorSky ) + 0.5;\\n\t\tfloat hemiSpecularWeightSky = specularStrength * max( pow( max( hemiDotNormalHalfSky, 0.0 ), shininess ), 0.0 );\\n\\n\t\t// specular (ground light)\\n\\n\t\tvec3 lVectorGround = -lVector;\\n\\n\t\tvec3 hemiHalfVectorGround = normalize( lVectorGround + viewPosition );\\n\t\tfloat hemiDotNormalHalfGround = 0.5 * dot( normal, hemiHalfVectorGround ) + 0.5;\\n\t\tfloat hemiSpecularWeightGround = specularStrength * max( pow( max( hemiDotNormalHalfGround, 0.0 ), shininess ), 0.0 );\\n\\n\t\tfloat dotProductGround = dot( normal, lVectorGround );\\n\\n\t\tfloat specularNormalization = ( shininess + 2.0 ) / 8.0;\\n\\n\t\tvec3 schlickSky = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( lVector, hemiHalfVectorSky ), 0.0 ), 5.0 );\\n\t\tvec3 schlickGround = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( lVectorGround, hemiHalfVectorGround ), 0.0 ), 5.0 );\\n\t\ttotalSpecularLight += hemiColor * specularNormalization * ( schlickSky * hemiSpecularWeightSky * max( dotProduct, 0.0 ) + schlickGround * hemiSpecularWeightGround * max( dotProductGround, 0.0 ) );\\n\\n\t}\\n\\n#endif\\n\\n#ifdef METAL\\n\\n\toutgoingLight += diffuseColor.rgb * ( totalDiffuseLight + ambientLightColor ) * specular + totalSpecularLight + emissive;\\n\\n#else\\n\\n\toutgoingLight += diffuseColor.rgb * ( totalDiffuseLight + ambientLightColor ) + totalSpecularLight + emissive;\\n\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/fog_pars_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'fog_pars_fragment'] = \"#ifdef USE_FOG\\n\\n\tuniform vec3 fogColor;\\n\\n\t#ifdef FOG_EXP2\\n\\n\t\tuniform float fogDensity;\\n\\n\t#else\\n\\n\t\tuniform float fogNear;\\n\t\tuniform float fogFar;\\n\t#endif\\n\\n#endif\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/morphnormal_vertex.glsl\r\n\r\nTHREE.ShaderChunk[ 'morphnormal_vertex'] = \"#ifdef USE_MORPHNORMALS\\n\\n\tvec3 morphedNormal = vec3( 0.0 );\\n\\n\tmorphedNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\\n\tmorphedNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\\n\tmorphedNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\\n\tmorphedNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\\n\\n\tmorphedNormal += normal;\\n\\n#endif\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/envmap_pars_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'envmap_pars_fragment'] = \"#ifdef USE_ENVMAP\\n\\n\tuniform float reflectivity;\\n\t#ifdef ENVMAP_TYPE_CUBE\\n\t\tuniform samplerCube envMap;\\n\t#else\\n\t\tuniform sampler2D envMap;\\n\t#endif\\n\tuniform float flipEnvMap;\\n\\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\\n\\n\t\tuniform float refractionRatio;\\n\\n\t#else\\n\\n\t\tvarying vec3 vReflect;\\n\\n\t#endif\\n\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/logdepthbuf_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'logdepthbuf_fragment'] = \"#if defined(USE_LOGDEPTHBUF) && defined(USE_LOGDEPTHBUF_EXT)\\n\\n\tgl_FragDepthEXT = log2(vFragDepth) * logDepthBufFC * 0.5;\\n\\n#endif\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/normalmap_pars_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'normalmap_pars_fragment'] = \"#ifdef USE_NORMALMAP\\n\\n\tuniform sampler2D normalMap;\\n\tuniform vec2 normalScale;\\n\\n\t// Per-Pixel Tangent Space Normal Mapping\\n\t// http://hacksoflife.blogspot.ch/2009/11/per-pixel-tangent-space-normal-mapping.html\\n\\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\\n\\n\t\tvec3 q0 = dFdx( eye_pos.xyz );\\n\t\tvec3 q1 = dFdy( eye_pos.xyz );\\n\t\tvec2 st0 = dFdx( vUv.st );\\n\t\tvec2 st1 = dFdy( vUv.st );\\n\\n\t\tvec3 S = normalize( q0 * st1.t - q1 * st0.t );\\n\t\tvec3 T = normalize( -q0 * st1.s + q1 * st0.s );\\n\t\tvec3 N = normalize( surf_norm );\\n\\n\t\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\\n\t\tmapN.xy = normalScale * mapN.xy;\\n\t\tmat3 tsn = mat3( S, T, N );\\n\t\treturn normalize( tsn * mapN );\\n\\n\t}\\n\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/lights_phong_pars_vertex.glsl\r\n\r\nTHREE.ShaderChunk[ 'lights_phong_pars_vertex'] = \"#if MAX_SPOT_LIGHTS > 0 || defined( USE_BUMPMAP ) || defined( USE_ENVMAP )\\n\\n\tvarying vec3 vWorldPosition;\\n\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/lightmap_pars_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'lightmap_pars_fragment'] = \"#ifdef USE_LIGHTMAP\\n\\n\tvarying vec2 vUv2;\\n\tuniform sampler2D lightMap;\\n\\n#endif\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/shadowmap_vertex.glsl\r\n\r\nTHREE.ShaderChunk[ 'shadowmap_vertex'] = \"#ifdef USE_SHADOWMAP\\n\\n\tfor( int i = 0; i < MAX_SHADOWS; i ++ ) {\\n\\n\t\tvShadowCoord[ i ] = shadowMatrix[ i ] * worldPosition;\\n\\n\t}\\n\\n#endif\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/lights_phong_vertex.glsl\r\n\r\nTHREE.ShaderChunk[ 'lights_phong_vertex'] = \"#if MAX_SPOT_LIGHTS > 0 || defined( USE_BUMPMAP ) || defined( USE_ENVMAP )\\n\\n\tvWorldPosition = worldPosition.xyz;\\n\\n#endif\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/map_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'map_fragment'] = \"#ifdef USE_MAP\\n\\n\tvec4 texelColor = texture2D( map, vUv );\\n\\n\ttexelColor.xyz = inputToLinear( texelColor.xyz );\\n\\n\tdiffuseColor *= texelColor;\\n\\n#endif\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/lightmap_vertex.glsl\r\n\r\nTHREE.ShaderChunk[ 'lightmap_vertex'] = \"#ifdef USE_LIGHTMAP\\n\\n\tvUv2 = uv2;\\n\\n#endif\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/map_particle_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'map_particle_fragment'] = \"#ifdef USE_MAP\\n\\n\tdiffuseColor *= texture2D( map, vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y ) * offsetRepeat.zw + offsetRepeat.xy );\\n\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/color_pars_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'color_pars_fragment'] = \"#ifdef USE_COLOR\\n\\n\tvarying vec3 vColor;\\n\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/color_vertex.glsl\r\n\r\nTHREE.ShaderChunk[ 'color_vertex'] = \"#ifdef USE_COLOR\\n\\n\tvColor.xyz = inputToLinear( color.xyz );\\n\\n#endif\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/skinning_vertex.glsl\r\n\r\nTHREE.ShaderChunk[ 'skinning_vertex'] = \"#ifdef USE_SKINNING\\n\\n\t#ifdef USE_MORPHTARGETS\\n\\n\tvec4 skinVertex = bindMatrix * vec4( morphed, 1.0 );\\n\\n\t#else\\n\\n\tvec4 skinVertex = bindMatrix * vec4( position, 1.0 );\\n\\n\t#endif\\n\\n\tvec4 skinned = vec4( 0.0 );\\n\tskinned += boneMatX * skinVertex * skinWeight.x;\\n\tskinned += boneMatY * skinVertex * skinWeight.y;\\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\\n\tskinned += boneMatW * skinVertex * skinWeight.w;\\n\tskinned  = bindMatrixInverse * skinned;\\n\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/envmap_pars_vertex.glsl\r\n\r\nTHREE.ShaderChunk[ 'envmap_pars_vertex'] = \"#if defined( USE_ENVMAP ) && ! defined( USE_BUMPMAP ) && ! defined( USE_NORMALMAP ) && ! defined( PHONG )\\n\\n\tvarying vec3 vReflect;\\n\\n\tuniform float refractionRatio;\\n\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/linear_to_gamma_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'linear_to_gamma_fragment'] = \"\\n\toutgoingLight = linearToOutput( outgoingLight );\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/color_pars_vertex.glsl\r\n\r\nTHREE.ShaderChunk[ 'color_pars_vertex'] = \"#ifdef USE_COLOR\\n\\n\tvarying vec3 vColor;\\n\\n#endif\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/lights_lambert_pars_vertex.glsl\r\n\r\nTHREE.ShaderChunk[ 'lights_lambert_pars_vertex'] = \"uniform vec3 ambientLightColor;\\n\\n#if MAX_DIR_LIGHTS > 0\\n\\n\tuniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];\\n\tuniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];\\n\\n#endif\\n\\n#if MAX_HEMI_LIGHTS > 0\\n\\n\tuniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];\\n\tuniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];\\n\tuniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];\\n\\n#endif\\n\\n#if MAX_POINT_LIGHTS > 0\\n\\n\tuniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];\\n\tuniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\\n\tuniform float pointLightDistance[ MAX_POINT_LIGHTS ];\\n\tuniform float pointLightDecay[ MAX_POINT_LIGHTS ];\\n\\n#endif\\n\\n#if MAX_SPOT_LIGHTS > 0\\n\\n\tuniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];\\n\tuniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];\\n\tuniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];\\n\tuniform float spotLightDistance[ MAX_SPOT_LIGHTS ];\\n\tuniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];\\n\tuniform float spotLightExponent[ MAX_SPOT_LIGHTS ];\\n\tuniform float spotLightDecay[ MAX_SPOT_LIGHTS ];\\n\\n#endif\\n\\n#ifdef WRAP_AROUND\\n\\n\tuniform vec3 wrapRGB;\\n\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/map_pars_vertex.glsl\r\n\r\nTHREE.ShaderChunk[ 'map_pars_vertex'] = \"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP )\\n\\n\tvarying vec2 vUv;\\n\tuniform vec4 offsetRepeat;\\n\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/envmap_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'envmap_fragment'] = \"#ifdef USE_ENVMAP\\n\\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\\n\\n\t\tvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\\n\\n\t\t// Transforming Normal Vectors with the Inverse Transformation\\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\\n\\n\t\t#ifdef ENVMAP_MODE_REFLECTION\\n\\n\t\t\tvec3 reflectVec = reflect( cameraToVertex, worldNormal );\\n\\n\t\t#else\\n\\n\t\t\tvec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\\n\\n\t\t#endif\\n\\n\t#else\\n\\n\t\tvec3 reflectVec = vReflect;\\n\\n\t#endif\\n\\n\t#ifdef DOUBLE_SIDED\\n\t\tfloat flipNormal = ( -1.0 + 2.0 * float( gl_FrontFacing ) );\\n\t#else\\n\t\tfloat flipNormal = 1.0;\\n\t#endif\\n\\n\t#ifdef ENVMAP_TYPE_CUBE\\n\t\tvec4 envColor = textureCube( envMap, flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\\n\\n\t#elif defined( ENVMAP_TYPE_EQUIREC )\\n\t\tvec2 sampleUV;\\n\t\tsampleUV.y = saturate( flipNormal * reflectVec.y * 0.5 + 0.5 );\\n\t\tsampleUV.x = atan( flipNormal * reflectVec.z, flipNormal * reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\\n\t\tvec4 envColor = texture2D( envMap, sampleUV );\\n\\n\t#elif defined( ENVMAP_TYPE_SPHERE )\\n\t\tvec3 reflectView = flipNormal * normalize((viewMatrix * vec4( reflectVec, 0.0 )).xyz + vec3(0.0,0.0,1.0));\\n\t\tvec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\\n\t#endif\\n\\n\tenvColor.xyz = inputToLinear( envColor.xyz );\\n\\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\\n\\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\\n\\n\t#elif defined( ENVMAP_BLENDING_MIX )\\n\\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\\n\\n\t#elif defined( ENVMAP_BLENDING_ADD )\\n\\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\\n\\n\t#endif\\n\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/specularmap_pars_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'specularmap_pars_fragment'] = \"#ifdef USE_SPECULARMAP\\n\\n\tuniform sampler2D specularMap;\\n\\n#endif\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/logdepthbuf_vertex.glsl\r\n\r\nTHREE.ShaderChunk[ 'logdepthbuf_vertex'] = \"#ifdef USE_LOGDEPTHBUF\\n\\n\tgl_Position.z = log2(max( EPSILON, gl_Position.w + 1.0 )) * logDepthBufFC;\\n\\n\t#ifdef USE_LOGDEPTHBUF_EXT\\n\\n\t\tvFragDepth = 1.0 + gl_Position.w;\\n\\n#else\\n\\n\t\tgl_Position.z = (gl_Position.z - 1.0) * gl_Position.w;\\n\\n\t#endif\\n\\n#endif\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/morphtarget_pars_vertex.glsl\r\n\r\nTHREE.ShaderChunk[ 'morphtarget_pars_vertex'] = \"#ifdef USE_MORPHTARGETS\\n\\n\t#ifndef USE_MORPHNORMALS\\n\\n\tuniform float morphTargetInfluences[ 8 ];\\n\\n\t#else\\n\\n\tuniform float morphTargetInfluences[ 4 ];\\n\\n\t#endif\\n\\n#endif\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/specularmap_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'specularmap_fragment'] = \"float specularStrength;\\n\\n#ifdef USE_SPECULARMAP\\n\\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\\n\tspecularStrength = texelSpecular.r;\\n\\n#else\\n\\n\tspecularStrength = 1.0;\\n\\n#endif\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/fog_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'fog_fragment'] = \"#ifdef USE_FOG\\n\\n\t#ifdef USE_LOGDEPTHBUF_EXT\\n\\n\t\tfloat depth = gl_FragDepthEXT / gl_FragCoord.w;\\n\\n\t#else\\n\\n\t\tfloat depth = gl_FragCoord.z / gl_FragCoord.w;\\n\\n\t#endif\\n\\n\t#ifdef FOG_EXP2\\n\\n\t\tfloat fogFactor = exp2( - square( fogDensity ) * square( depth ) * LOG2 );\\n\t\tfogFactor = whiteCompliment( fogFactor );\\n\\n\t#else\\n\\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, depth );\\n\\n\t#endif\\n\t\\n\toutgoingLight = mix( outgoingLight, fogColor, fogFactor );\\n\\n#endif\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/bumpmap_pars_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'bumpmap_pars_fragment'] = \"#ifdef USE_BUMPMAP\\n\\n\tuniform sampler2D bumpMap;\\n\tuniform float bumpScale;\\n\\n\t// Derivative maps - bump mapping unparametrized surfaces by Morten Mikkelsen\\n\t// http://mmikkelsen3d.blogspot.sk/2011/07/derivative-maps.html\\n\\n\t// Evaluate the derivative of the height w.r.t. screen-space using forward differencing (listing 2)\\n\\n\tvec2 dHdxy_fwd() {\\n\\n\t\tvec2 dSTdx = dFdx( vUv );\\n\t\tvec2 dSTdy = dFdy( vUv );\\n\\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\\n\\n\t\treturn vec2( dBx, dBy );\\n\\n\t}\\n\\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\\n\\n\t\tvec3 vSigmaX = dFdx( surf_pos );\\n\t\tvec3 vSigmaY = dFdy( surf_pos );\\n\t\tvec3 vN = surf_norm;\t\t// normalized\\n\\n\t\tvec3 R1 = cross( vSigmaY, vN );\\n\t\tvec3 R2 = cross( vN, vSigmaX );\\n\\n\t\tfloat fDet = dot( vSigmaX, R1 );\\n\\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\\n\\n\t}\\n\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/defaultnormal_vertex.glsl\r\n\r\nTHREE.ShaderChunk[ 'defaultnormal_vertex'] = \"#ifdef USE_SKINNING\\n\\n\tvec3 objectNormal = skinnedNormal.xyz;\\n\\n#elif defined( USE_MORPHNORMALS )\\n\\n\tvec3 objectNormal = morphedNormal;\\n\\n#else\\n\\n\tvec3 objectNormal = normal;\\n\\n#endif\\n\\n#ifdef FLIP_SIDED\\n\\n\tobjectNormal = -objectNormal;\\n\\n#endif\\n\\nvec3 transformedNormal = normalMatrix * objectNormal;\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/lights_phong_pars_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'lights_phong_pars_fragment'] = \"uniform vec3 ambientLightColor;\\n\\n#if MAX_DIR_LIGHTS > 0\\n\\n\tuniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];\\n\tuniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];\\n\\n#endif\\n\\n#if MAX_HEMI_LIGHTS > 0\\n\\n\tuniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];\\n\tuniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];\\n\tuniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];\\n\\n#endif\\n\\n#if MAX_POINT_LIGHTS > 0\\n\\n\tuniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];\\n\\n\tuniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\\n\tuniform float pointLightDistance[ MAX_POINT_LIGHTS ];\\n\tuniform float pointLightDecay[ MAX_POINT_LIGHTS ];\\n\\n#endif\\n\\n#if MAX_SPOT_LIGHTS > 0\\n\\n\tuniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];\\n\tuniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];\\n\tuniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];\\n\tuniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];\\n\tuniform float spotLightExponent[ MAX_SPOT_LIGHTS ];\\n\tuniform float spotLightDistance[ MAX_SPOT_LIGHTS ];\\n\tuniform float spotLightDecay[ MAX_SPOT_LIGHTS ];\\n\\n#endif\\n\\n#if MAX_SPOT_LIGHTS > 0 || defined( USE_BUMPMAP ) || defined( USE_ENVMAP )\\n\\n\tvarying vec3 vWorldPosition;\\n\\n#endif\\n\\n#ifdef WRAP_AROUND\\n\\n\tuniform vec3 wrapRGB;\\n\\n#endif\\n\\nvarying vec3 vViewPosition;\\n\\n#ifndef FLAT_SHADED\\n\\n\tvarying vec3 vNormal;\\n\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/skinbase_vertex.glsl\r\n\r\nTHREE.ShaderChunk[ 'skinbase_vertex'] = \"#ifdef USE_SKINNING\\n\\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\\n\\n#endif\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/map_vertex.glsl\r\n\r\nTHREE.ShaderChunk[ 'map_vertex'] = \"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP )\\n\\n\tvUv = uv * offsetRepeat.zw + offsetRepeat.xy;\\n\\n#endif\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/lightmap_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'lightmap_fragment'] = \"#ifdef USE_LIGHTMAP\\n\\n\toutgoingLight *= diffuseColor.xyz * texture2D( lightMap, vUv2 ).xyz;\\n\\n#endif\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/shadowmap_pars_vertex.glsl\r\n\r\nTHREE.ShaderChunk[ 'shadowmap_pars_vertex'] = \"#ifdef USE_SHADOWMAP\\n\\n\tvarying vec4 vShadowCoord[ MAX_SHADOWS ];\\n\tuniform mat4 shadowMatrix[ MAX_SHADOWS ];\\n\\n#endif\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/color_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'color_fragment'] = \"#ifdef USE_COLOR\\n\\n\tdiffuseColor.rgb *= vColor;\\n\\n#endif\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/morphtarget_vertex.glsl\r\n\r\nTHREE.ShaderChunk[ 'morphtarget_vertex'] = \"#ifdef USE_MORPHTARGETS\\n\\n\tvec3 morphed = vec3( 0.0 );\\n\tmorphed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\\n\tmorphed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\\n\tmorphed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\\n\tmorphed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\\n\\n\t#ifndef USE_MORPHNORMALS\\n\\n\tmorphed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\\n\tmorphed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\\n\tmorphed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\\n\tmorphed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\\n\\n\t#endif\\n\\n\tmorphed += position;\\n\\n#endif\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/envmap_vertex.glsl\r\n\r\nTHREE.ShaderChunk[ 'envmap_vertex'] = \"#if defined( USE_ENVMAP ) && ! defined( USE_BUMPMAP ) && ! defined( USE_NORMALMAP ) && ! defined( PHONG )\\n\\n\tvec3 worldNormal = transformDirection( objectNormal, modelMatrix );\\n\\n\tvec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\\n\\n\t#ifdef ENVMAP_MODE_REFLECTION\\n\\n\t\tvReflect = reflect( cameraToVertex, worldNormal );\\n\\n\t#else\\n\\n\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\\n\\n\t#endif\\n\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/shadowmap_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'shadowmap_fragment'] = \"#ifdef USE_SHADOWMAP\\n\\n\t#ifdef SHADOWMAP_DEBUG\\n\\n\t\tvec3 frustumColors[3];\\n\t\tfrustumColors[0] = vec3( 1.0, 0.5, 0.0 );\\n\t\tfrustumColors[1] = vec3( 0.0, 1.0, 0.8 );\\n\t\tfrustumColors[2] = vec3( 0.0, 0.5, 1.0 );\\n\\n\t#endif\\n\\n\t#ifdef SHADOWMAP_CASCADE\\n\\n\t\tint inFrustumCount = 0;\\n\\n\t#endif\\n\\n\tfloat fDepth;\\n\tvec3 shadowColor = vec3( 1.0 );\\n\\n\tfor( int i = 0; i < MAX_SHADOWS; i ++ ) {\\n\\n\t\tvec3 shadowCoord = vShadowCoord[ i ].xyz / vShadowCoord[ i ].w;\\n\\n\t\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\\n\t\t\t\t// if ( all( something, something ) ) using this instead\\n\\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\\n\t\tbool inFrustum = all( inFrustumVec );\\n\\n\t\t\t\t// don't shadow pixels outside of light frustum\\n\t\t\t\t// use just first frustum (for cascades)\\n\t\t\t\t// don't shadow pixels behind far plane of light frustum\\n\\n\t\t#ifdef SHADOWMAP_CASCADE\\n\\n\t\t\tinFrustumCount += int( inFrustum );\\n\t\t\tbvec3 frustumTestVec = bvec3( inFrustum, inFrustumCount == 1, shadowCoord.z <= 1.0 );\\n\\n\t\t#else\\n\\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\\n\\n\t\t#endif\\n\\n\t\tbool frustumTest = all( frustumTestVec );\\n\\n\t\tif ( frustumTest ) {\\n\\n\t\t\tshadowCoord.z += shadowBias[ i ];\\n\\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\\n\\n\t\t\t\t\t\t// Percentage-close filtering\\n\t\t\t\t\t\t// (9 pixel kernel)\\n\t\t\t\t\t\t// http://fabiensanglard.net/shadowmappingPCF/\\n\\n\t\t\t\tfloat shadow = 0.0;\\n\\n\t\t/*\\n\t\t\t\t\t\t// nested loops breaks shader compiler / validator on some ATI cards when using OpenGL\\n\t\t\t\t\t\t// must enroll loop manually\\n\\n\t\t\t\tfor ( float y = -1.25; y <= 1.25; y += 1.25 )\\n\t\t\t\t\tfor ( float x = -1.25; x <= 1.25; x += 1.25 ) {\\n\\n\t\t\t\t\t\tvec4 rgbaDepth = texture2D( shadowMap[ i ], vec2( x * xPixelOffset, y * yPixelOffset ) + shadowCoord.xy );\\n\\n\t\t\t\t\t\t\t\t// doesn't seem to produce any noticeable visual difference compared to simple texture2D lookup\\n\t\t\t\t\t\t\t\t//vec4 rgbaDepth = texture2DProj( shadowMap[ i ], vec4( vShadowCoord[ i ].w * ( vec2( x * xPixelOffset, y * yPixelOffset ) + shadowCoord.xy ), 0.05, vShadowCoord[ i ].w ) );\\n\\n\t\t\t\t\t\tfloat fDepth = unpackDepth( rgbaDepth );\\n\\n\t\t\t\t\t\tif ( fDepth < shadowCoord.z )\\n\t\t\t\t\t\t\tshadow += 1.0;\\n\\n\t\t\t\t}\\n\\n\t\t\t\tshadow /= 9.0;\\n\\n\t\t*/\\n\\n\t\t\t\tconst float shadowDelta = 1.0 / 9.0;\\n\\n\t\t\t\tfloat xPixelOffset = 1.0 / shadowMapSize[ i ].x;\\n\t\t\t\tfloat yPixelOffset = 1.0 / shadowMapSize[ i ].y;\\n\\n\t\t\t\tfloat dx0 = -1.25 * xPixelOffset;\\n\t\t\t\tfloat dy0 = -1.25 * yPixelOffset;\\n\t\t\t\tfloat dx1 = 1.25 * xPixelOffset;\\n\t\t\t\tfloat dy1 = 1.25 * yPixelOffset;\\n\\n\t\t\t\tfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy0 ) ) );\\n\t\t\t\tif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\\n\\n\t\t\t\tfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy0 ) ) );\\n\t\t\t\tif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\\n\\n\t\t\t\tfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy0 ) ) );\\n\t\t\t\tif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\\n\\n\t\t\t\tfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, 0.0 ) ) );\\n\t\t\t\tif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\\n\\n\t\t\t\tfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy ) );\\n\t\t\t\tif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\\n\\n\t\t\t\tfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, 0.0 ) ) );\\n\t\t\t\tif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\\n\\n\t\t\t\tfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy1 ) ) );\\n\t\t\t\tif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\\n\\n\t\t\t\tfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy1 ) ) );\\n\t\t\t\tif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\\n\\n\t\t\t\tfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy1 ) ) );\\n\t\t\t\tif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\\n\\n\t\t\t\tshadowColor = shadowColor * vec3( ( 1.0 - shadowDarkness[ i ] * shadow ) );\\n\\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\\n\\n\t\t\t\t\t\t// Percentage-close filtering\\n\t\t\t\t\t\t// (9 pixel kernel)\\n\t\t\t\t\t\t// http://fabiensanglard.net/shadowmappingPCF/\\n\\n\t\t\t\tfloat shadow = 0.0;\\n\\n\t\t\t\tfloat xPixelOffset = 1.0 / shadowMapSize[ i ].x;\\n\t\t\t\tfloat yPixelOffset = 1.0 / shadowMapSize[ i ].y;\\n\\n\t\t\t\tfloat dx0 = -1.0 * xPixelOffset;\\n\t\t\t\tfloat dy0 = -1.0 * yPixelOffset;\\n\t\t\t\tfloat dx1 = 1.0 * xPixelOffset;\\n\t\t\t\tfloat dy1 = 1.0 * yPixelOffset;\\n\\n\t\t\t\tmat3 shadowKernel;\\n\t\t\t\tmat3 depthKernel;\\n\\n\t\t\t\tdepthKernel[0][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy0 ) ) );\\n\t\t\t\tdepthKernel[0][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, 0.0 ) ) );\\n\t\t\t\tdepthKernel[0][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy1 ) ) );\\n\t\t\t\tdepthKernel[1][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy0 ) ) );\\n\t\t\t\tdepthKernel[1][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy ) );\\n\t\t\t\tdepthKernel[1][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy1 ) ) );\\n\t\t\t\tdepthKernel[2][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy0 ) ) );\\n\t\t\t\tdepthKernel[2][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, 0.0 ) ) );\\n\t\t\t\tdepthKernel[2][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy1 ) ) );\\n\\n\t\t\t\tvec3 shadowZ = vec3( shadowCoord.z );\\n\t\t\t\tshadowKernel[0] = vec3(lessThan(depthKernel[0], shadowZ ));\\n\t\t\t\tshadowKernel[0] *= vec3(0.25);\\n\\n\t\t\t\tshadowKernel[1] = vec3(lessThan(depthKernel[1], shadowZ ));\\n\t\t\t\tshadowKernel[1] *= vec3(0.25);\\n\\n\t\t\t\tshadowKernel[2] = vec3(lessThan(depthKernel[2], shadowZ ));\\n\t\t\t\tshadowKernel[2] *= vec3(0.25);\\n\\n\t\t\t\tvec2 fractionalCoord = 1.0 - fract( shadowCoord.xy * shadowMapSize[i].xy );\\n\\n\t\t\t\tshadowKernel[0] = mix( shadowKernel[1], shadowKernel[0], fractionalCoord.x );\\n\t\t\t\tshadowKernel[1] = mix( shadowKernel[2], shadowKernel[1], fractionalCoord.x );\\n\\n\t\t\t\tvec4 shadowValues;\\n\t\t\t\tshadowValues.x = mix( shadowKernel[0][1], shadowKernel[0][0], fractionalCoord.y );\\n\t\t\t\tshadowValues.y = mix( shadowKernel[0][2], shadowKernel[0][1], fractionalCoord.y );\\n\t\t\t\tshadowValues.z = mix( shadowKernel[1][1], shadowKernel[1][0], fractionalCoord.y );\\n\t\t\t\tshadowValues.w = mix( shadowKernel[1][2], shadowKernel[1][1], fractionalCoord.y );\\n\\n\t\t\t\tshadow = dot( shadowValues, vec4( 1.0 ) );\\n\\n\t\t\t\tshadowColor = shadowColor * vec3( ( 1.0 - shadowDarkness[ i ] * shadow ) );\\n\\n\t\t\t#else\\n\\n\t\t\t\tvec4 rgbaDepth = texture2D( shadowMap[ i ], shadowCoord.xy );\\n\t\t\t\tfloat fDepth = unpackDepth( rgbaDepth );\\n\\n\t\t\t\tif ( fDepth < shadowCoord.z )\\n\\n\t\t// spot with multiple shadows is darker\\n\\n\t\t\t\t\tshadowColor = shadowColor * vec3( 1.0 - shadowDarkness[ i ] );\\n\\n\t\t// spot with multiple shadows has the same color as single shadow spot\\n\\n\t\t// \t\t\t\t\tshadowColor = min( shadowColor, vec3( shadowDarkness[ i ] ) );\\n\\n\t\t\t#endif\\n\\n\t\t}\\n\\n\\n\t\t#ifdef SHADOWMAP_DEBUG\\n\\n\t\t\t#ifdef SHADOWMAP_CASCADE\\n\\n\t\t\t\tif ( inFrustum && inFrustumCount == 1 ) outgoingLight *= frustumColors[ i ];\\n\\n\t\t\t#else\\n\\n\t\t\t\tif ( inFrustum ) outgoingLight *= frustumColors[ i ];\\n\\n\t\t\t#endif\\n\\n\t\t#endif\\n\\n\t}\\n\\n\t// NOTE: I am unsure if this is correct in linear space.  -bhouston, Dec 29, 2014\\n\tshadowColor = inputToLinear( shadowColor );\\n\\n\toutgoingLight = outgoingLight * shadowColor;\\n\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/worldpos_vertex.glsl\r\n\r\nTHREE.ShaderChunk[ 'worldpos_vertex'] = \"#if defined( USE_ENVMAP ) || defined( PHONG ) || defined( LAMBERT ) || defined ( USE_SHADOWMAP )\\n\\n\t#ifdef USE_SKINNING\\n\\n\t\tvec4 worldPosition = modelMatrix * skinned;\\n\\n\t#elif defined( USE_MORPHTARGETS )\\n\\n\t\tvec4 worldPosition = modelMatrix * vec4( morphed, 1.0 );\\n\\n\t#else\\n\\n\t\tvec4 worldPosition = modelMatrix * vec4( position, 1.0 );\\n\\n\t#endif\\n\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/shadowmap_pars_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'shadowmap_pars_fragment'] = \"#ifdef USE_SHADOWMAP\\n\\n\tuniform sampler2D shadowMap[ MAX_SHADOWS ];\\n\tuniform vec2 shadowMapSize[ MAX_SHADOWS ];\\n\\n\tuniform float shadowDarkness[ MAX_SHADOWS ];\\n\tuniform float shadowBias[ MAX_SHADOWS ];\\n\\n\tvarying vec4 vShadowCoord[ MAX_SHADOWS ];\\n\\n\tfloat unpackDepth( const in vec4 rgba_depth ) {\\n\\n\t\tconst vec4 bit_shift = vec4( 1.0 / ( 256.0 * 256.0 * 256.0 ), 1.0 / ( 256.0 * 256.0 ), 1.0 / 256.0, 1.0 );\\n\t\tfloat depth = dot( rgba_depth, bit_shift );\\n\t\treturn depth;\\n\\n\t}\\n\\n#endif\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/skinning_pars_vertex.glsl\r\n\r\nTHREE.ShaderChunk[ 'skinning_pars_vertex'] = \"#ifdef USE_SKINNING\\n\\n\tuniform mat4 bindMatrix;\\n\tuniform mat4 bindMatrixInverse;\\n\\n\t#ifdef BONE_TEXTURE\\n\\n\t\tuniform sampler2D boneTexture;\\n\t\tuniform int boneTextureWidth;\\n\t\tuniform int boneTextureHeight;\\n\\n\t\tmat4 getBoneMatrix( const in float i ) {\\n\\n\t\t\tfloat j = i * 4.0;\\n\t\t\tfloat x = mod( j, float( boneTextureWidth ) );\\n\t\t\tfloat y = floor( j / float( boneTextureWidth ) );\\n\\n\t\t\tfloat dx = 1.0 / float( boneTextureWidth );\\n\t\t\tfloat dy = 1.0 / float( boneTextureHeight );\\n\\n\t\t\ty = dy * ( y + 0.5 );\\n\\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\\n\\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\\n\\n\t\t\treturn bone;\\n\\n\t\t}\\n\\n\t#else\\n\\n\t\tuniform mat4 boneGlobalMatrices[ MAX_BONES ];\\n\\n\t\tmat4 getBoneMatrix( const in float i ) {\\n\\n\t\t\tmat4 bone = boneGlobalMatrices[ int(i) ];\\n\t\t\treturn bone;\\n\\n\t\t}\\n\\n\t#endif\\n\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/logdepthbuf_pars_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'logdepthbuf_pars_fragment'] = \"#ifdef USE_LOGDEPTHBUF\\n\\n\tuniform float logDepthBufFC;\\n\\n\t#ifdef USE_LOGDEPTHBUF_EXT\\n\\n\t\t#extension GL_EXT_frag_depth : enable\\n\t\tvarying float vFragDepth;\\n\\n\t#endif\\n\\n#endif\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/alphamap_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'alphamap_fragment'] = \"#ifdef USE_ALPHAMAP\\n\\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\\n\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/alphamap_pars_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'alphamap_pars_fragment'] = \"#ifdef USE_ALPHAMAP\\n\\n\tuniform sampler2D alphaMap;\\n\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/UniformsUtils.js\r\n\r\n/**\r\n * Uniform Utilities\r\n */\r\n\r\nTHREE.UniformsUtils = {\r\n\r\n\tmerge: function ( uniforms ) {\r\n\r\n\t\tvar merged = {};\r\n\r\n\t\tfor ( var u = 0; u < uniforms.length; u ++ ) {\r\n\r\n\t\t\tvar tmp = this.clone( uniforms[ u ] );\r\n\r\n\t\t\tfor ( var p in tmp ) {\r\n\r\n\t\t\t\tmerged[ p ] = tmp[ p ];\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn merged;\r\n\r\n\t},\r\n\r\n\tclone: function ( uniforms_src ) {\r\n\r\n\t\tvar uniforms_dst = {};\r\n\r\n\t\tfor ( var u in uniforms_src ) {\r\n\r\n\t\t\tuniforms_dst[ u ] = {};\r\n\r\n\t\t\tfor ( var p in uniforms_src[ u ] ) {\r\n\r\n\t\t\t\tvar parameter_src = uniforms_src[ u ][ p ];\r\n\r\n\t\t\t\tif ( parameter_src instanceof THREE.Color ||\r\n\t\t\t\t\t parameter_src instanceof THREE.Vector2 ||\r\n\t\t\t\t\t parameter_src instanceof THREE.Vector3 ||\r\n\t\t\t\t\t parameter_src instanceof THREE.Vector4 ||\r\n\t\t\t\t\t parameter_src instanceof THREE.Matrix4 ||\r\n\t\t\t\t\t parameter_src instanceof THREE.Texture ) {\r\n\r\n\t\t\t\t\tuniforms_dst[ u ][ p ] = parameter_src.clone();\r\n\r\n\t\t\t\t} else if ( parameter_src instanceof Array ) {\r\n\r\n\t\t\t\t\tuniforms_dst[ u ][ p ] = parameter_src.slice();\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tuniforms_dst[ u ][ p ] = parameter_src;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn uniforms_dst;\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/renderers/shaders/UniformsLib.js\r\n\r\n/**\r\n * Uniforms library for shared webgl shaders\r\n */\r\n\r\nTHREE.UniformsLib = {\r\n\r\n\tcommon: {\r\n\r\n\t\t\"diffuse\" : { type: \"c\", value: new THREE.Color( 0xeeeeee ) },\r\n\t\t\"opacity\" : { type: \"f\", value: 1.0 },\r\n\r\n\t\t\"map\" : { type: \"t\", value: null },\r\n\t\t\"offsetRepeat\" : { type: \"v4\", value: new THREE.Vector4( 0, 0, 1, 1 ) },\r\n\r\n\t\t\"lightMap\" : { type: \"t\", value: null },\r\n\t\t\"specularMap\" : { type: \"t\", value: null },\r\n\t\t\"alphaMap\" : { type: \"t\", value: null },\r\n\r\n\t\t\"envMap\" : { type: \"t\", value: null },\r\n\t\t\"flipEnvMap\" : { type: \"f\", value: - 1 },\r\n\t\t\"reflectivity\" : { type: \"f\", value: 1.0 },\r\n\t\t\"refractionRatio\" : { type: \"f\", value: 0.98 },\r\n\r\n\t\t\"morphTargetInfluences\" : { type: \"f\", value: 0 }\r\n\r\n\t},\r\n\r\n\tbump: {\r\n\r\n\t\t\"bumpMap\" : { type: \"t\", value: null },\r\n\t\t\"bumpScale\" : { type: \"f\", value: 1 }\r\n\r\n\t},\r\n\r\n\tnormalmap: {\r\n\r\n\t\t\"normalMap\" : { type: \"t\", value: null },\r\n\t\t\"normalScale\" : { type: \"v2\", value: new THREE.Vector2( 1, 1 ) }\r\n\t},\r\n\r\n\tfog : {\r\n\r\n\t\t\"fogDensity\" : { type: \"f\", value: 0.00025 },\r\n\t\t\"fogNear\" : { type: \"f\", value: 1 },\r\n\t\t\"fogFar\" : { type: \"f\", value: 2000 },\r\n\t\t\"fogColor\" : { type: \"c\", value: new THREE.Color( 0xffffff ) }\r\n\r\n\t},\r\n\r\n\tlights: {\r\n\r\n\t\t\"ambientLightColor\" : { type: \"fv\", value: [] },\r\n\r\n\t\t\"directionalLightDirection\" : { type: \"fv\", value: [] },\r\n\t\t\"directionalLightColor\" : { type: \"fv\", value: [] },\r\n\r\n\t\t\"hemisphereLightDirection\" : { type: \"fv\", value: [] },\r\n\t\t\"hemisphereLightSkyColor\" : { type: \"fv\", value: [] },\r\n\t\t\"hemisphereLightGroundColor\" : { type: \"fv\", value: [] },\r\n\r\n\t\t\"pointLightColor\" : { type: \"fv\", value: [] },\r\n\t\t\"pointLightPosition\" : { type: \"fv\", value: [] },\r\n\t\t\"pointLightDistance\" : { type: \"fv1\", value: [] },\r\n\t\t\"pointLightDecay\" : { type: \"fv1\", value: [] },\r\n\r\n\t\t\"spotLightColor\" : { type: \"fv\", value: [] },\r\n\t\t\"spotLightPosition\" : { type: \"fv\", value: [] },\r\n\t\t\"spotLightDirection\" : { type: \"fv\", value: [] },\r\n\t\t\"spotLightDistance\" : { type: \"fv1\", value: [] },\r\n\t\t\"spotLightAngleCos\" : { type: \"fv1\", value: [] },\r\n\t\t\"spotLightExponent\" : { type: \"fv1\", value: [] },\r\n\t\t\"spotLightDecay\" : { type: \"fv1\", value: [] }\r\n\r\n\t},\r\n\r\n\tparticle: {\r\n\r\n\t\t\"psColor\" : { type: \"c\", value: new THREE.Color( 0xeeeeee ) },\r\n\t\t\"opacity\" : { type: \"f\", value: 1.0 },\r\n\t\t\"size\" : { type: \"f\", value: 1.0 },\r\n\t\t\"scale\" : { type: \"f\", value: 1.0 },\r\n\t\t\"map\" : { type: \"t\", value: null },\r\n\t\t\"offsetRepeat\" : { type: \"v4\", value: new THREE.Vector4( 0, 0, 1, 1 ) },\r\n\r\n\t\t\"fogDensity\" : { type: \"f\", value: 0.00025 },\r\n\t\t\"fogNear\" : { type: \"f\", value: 1 },\r\n\t\t\"fogFar\" : { type: \"f\", value: 2000 },\r\n\t\t\"fogColor\" : { type: \"c\", value: new THREE.Color( 0xffffff ) }\r\n\r\n\t},\r\n\r\n\tshadowmap: {\r\n\r\n\t\t\"shadowMap\": { type: \"tv\", value: [] },\r\n\t\t\"shadowMapSize\": { type: \"v2v\", value: [] },\r\n\r\n\t\t\"shadowBias\" : { type: \"fv1\", value: [] },\r\n\t\t\"shadowDarkness\": { type: \"fv1\", value: [] },\r\n\r\n\t\t\"shadowMatrix\" : { type: \"m4v\", value: [] }\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/renderers/shaders/ShaderLib.js\r\n\r\n/**\r\n * Webgl Shader Library for three.js\r\n *\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author mikael emtinger / http://gomo.se/\r\n */\r\n\r\n\r\nTHREE.ShaderLib = {\r\n\r\n\t'basic': {\r\n\r\n\t\tuniforms: THREE.UniformsUtils.merge( [\r\n\r\n\t\t\tTHREE.UniformsLib[ \"common\" ],\r\n\t\t\tTHREE.UniformsLib[ \"fog\" ],\r\n\t\t\tTHREE.UniformsLib[ \"shadowmap\" ]\r\n\r\n\t\t] ),\r\n\r\n\t\tvertexShader: [\r\n\r\n\t\t\tTHREE.ShaderChunk[ \"common\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"map_pars_vertex\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"lightmap_pars_vertex\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"envmap_pars_vertex\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"color_pars_vertex\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"morphtarget_pars_vertex\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"skinning_pars_vertex\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"shadowmap_pars_vertex\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"logdepthbuf_pars_vertex\" ],\r\n\r\n\t\t\t\"void main() {\",\r\n\r\n\t\t\t\tTHREE.ShaderChunk[ \"map_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"lightmap_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"color_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"skinbase_vertex\" ],\r\n\r\n\t\t\t\"\t#ifdef USE_ENVMAP\",\r\n\r\n\t\t\t\tTHREE.ShaderChunk[ \"morphnormal_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"skinnormal_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"defaultnormal_vertex\" ],\r\n\r\n\t\t\t\"\t#endif\",\r\n\r\n\t\t\t\tTHREE.ShaderChunk[ \"morphtarget_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"skinning_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"default_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"logdepthbuf_vertex\" ],\r\n\r\n\t\t\t\tTHREE.ShaderChunk[ \"worldpos_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"envmap_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"shadowmap_vertex\" ],\r\n\r\n\t\t\t\"}\"\r\n\r\n\t\t].join(\"\\n\"),\r\n\r\n\t\tfragmentShader: [\r\n\r\n\t\t\t\"uniform vec3 diffuse;\",\r\n\t\t\t\"uniform float opacity;\",\r\n\r\n\t\t\tTHREE.ShaderChunk[ \"common\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"color_pars_fragment\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"map_pars_fragment\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"alphamap_pars_fragment\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"lightmap_pars_fragment\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"envmap_pars_fragment\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"fog_pars_fragment\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"shadowmap_pars_fragment\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"specularmap_pars_fragment\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"logdepthbuf_pars_fragment\" ],\r\n\r\n\t\t\t\"void main() {\",\r\n\r\n\t\t\t\"\tvec3 outgoingLight = vec3( 0.0 );\",\t// outgoing light does not have an alpha, the surface does\r\n\t\t\t\"\tvec4 diffuseColor = vec4( diffuse, opacity );\",\r\n\r\n\t\t\t\tTHREE.ShaderChunk[ \"logdepthbuf_fragment\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"map_fragment\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"color_fragment\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"alphamap_fragment\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"alphatest_fragment\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"specularmap_fragment\" ],\r\n\r\n\t\t\t\"\toutgoingLight = diffuseColor.rgb;\", // simple shader\r\n\r\n\t\t\t\tTHREE.ShaderChunk[ \"lightmap_fragment\" ],\t\t// TODO: Light map on an otherwise unlit surface doesn't make sense.\r\n\t\t\t\tTHREE.ShaderChunk[ \"envmap_fragment\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"shadowmap_fragment\" ],\t\t// TODO: Shadows on an otherwise unlit surface doesn't make sense.\r\n\r\n\t\t\t\tTHREE.ShaderChunk[ \"linear_to_gamma_fragment\" ],\r\n\r\n\t\t\t\tTHREE.ShaderChunk[ \"fog_fragment\" ],\r\n\r\n\t\t\t\"\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\",\t// TODO, this should be pre-multiplied to allow for bright highlights on very transparent objects\r\n\r\n\t\t\t\"}\"\r\n\r\n\t\t].join(\"\\n\")\r\n\r\n\t},\r\n\r\n\t'lambert': {\r\n\r\n\t\tuniforms: THREE.UniformsUtils.merge( [\r\n\r\n\t\t\tTHREE.UniformsLib[ \"common\" ],\r\n\t\t\tTHREE.UniformsLib[ \"fog\" ],\r\n\t\t\tTHREE.UniformsLib[ \"lights\" ],\r\n\t\t\tTHREE.UniformsLib[ \"shadowmap\" ],\r\n\r\n\t\t\t{\r\n\t\t\t\t\"emissive\" : { type: \"c\", value: new THREE.Color( 0x000000 ) },\r\n\t\t\t\t\"wrapRGB\"  : { type: \"v3\", value: new THREE.Vector3( 1, 1, 1 ) }\r\n\t\t\t}\r\n\r\n\t\t] ),\r\n\r\n\t\tvertexShader: [\r\n\r\n\t\t\t\"#define LAMBERT\",\r\n\r\n\t\t\t\"varying vec3 vLightFront;\",\r\n\r\n\t\t\t\"#ifdef DOUBLE_SIDED\",\r\n\r\n\t\t\t\"\tvarying vec3 vLightBack;\",\r\n\r\n\t\t\t\"#endif\",\r\n\r\n\t\t\tTHREE.ShaderChunk[ \"common\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"map_pars_vertex\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"lightmap_pars_vertex\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"envmap_pars_vertex\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"lights_lambert_pars_vertex\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"color_pars_vertex\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"morphtarget_pars_vertex\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"skinning_pars_vertex\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"shadowmap_pars_vertex\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"logdepthbuf_pars_vertex\" ],\r\n\r\n\t\t\t\"void main() {\",\r\n\r\n\t\t\t\tTHREE.ShaderChunk[ \"map_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"lightmap_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"color_vertex\" ],\r\n\r\n\t\t\t\tTHREE.ShaderChunk[ \"morphnormal_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"skinbase_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"skinnormal_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"defaultnormal_vertex\" ],\r\n\r\n\t\t\t\tTHREE.ShaderChunk[ \"morphtarget_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"skinning_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"default_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"logdepthbuf_vertex\" ],\r\n\r\n\t\t\t\tTHREE.ShaderChunk[ \"worldpos_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"envmap_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"lights_lambert_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"shadowmap_vertex\" ],\r\n\r\n\t\t\t\"}\"\r\n\r\n\t\t].join(\"\\n\"),\r\n\r\n\t\tfragmentShader: [\r\n\r\n\t\t\t\"uniform vec3 diffuse;\",\r\n\t\t\t\"uniform vec3 emissive;\",\r\n\t\t\t\"uniform float opacity;\",\r\n\r\n\t\t\t\"varying vec3 vLightFront;\",\r\n\r\n\t\t\t\"#ifdef DOUBLE_SIDED\",\r\n\r\n\t\t\t\"\tvarying vec3 vLightBack;\",\r\n\r\n\t\t\t\"#endif\",\r\n\r\n\t\t\tTHREE.ShaderChunk[ \"common\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"color_pars_fragment\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"map_pars_fragment\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"alphamap_pars_fragment\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"lightmap_pars_fragment\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"envmap_pars_fragment\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"fog_pars_fragment\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"shadowmap_pars_fragment\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"specularmap_pars_fragment\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"logdepthbuf_pars_fragment\" ],\r\n\r\n\t\t\t\"void main() {\",\r\n\r\n\t\t\t\"\tvec3 outgoingLight = vec3( 0.0 );\",\t// outgoing light does not have an alpha, the surface does\r\n\t\t\t\"\tvec4 diffuseColor = vec4( diffuse, opacity );\",\r\n\r\n\t\t\t\tTHREE.ShaderChunk[ \"logdepthbuf_fragment\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"map_fragment\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"color_fragment\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"alphamap_fragment\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"alphatest_fragment\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"specularmap_fragment\" ],\r\n\r\n\t\t\t\"\t#ifdef DOUBLE_SIDED\",\r\n\r\n\t\t\t\t\t//\"float isFront = float( gl_FrontFacing );\",\r\n\t\t\t\t\t//\"gl_FragColor.xyz *= isFront * vLightFront + ( 1.0 - isFront ) * vLightBack;\",\r\n\r\n\t\t\t\"\t\tif ( gl_FrontFacing )\",\r\n\t\t\t\"\t\t\toutgoingLight += diffuseColor.rgb * vLightFront + emissive;\",\r\n\t\t\t\"\t\telse\",\r\n\t\t\t\"\t\t\toutgoingLight += diffuseColor.rgb * vLightBack + emissive;\",\r\n\r\n\t\t\t\"\t#else\",\r\n\r\n\t\t\t\"\t\toutgoingLight += diffuseColor.rgb * vLightFront + emissive;\",\r\n\r\n\t\t\t\"\t#endif\",\r\n\r\n\t\t\t\tTHREE.ShaderChunk[ \"lightmap_fragment\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"envmap_fragment\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"shadowmap_fragment\" ],\r\n\r\n\t\t\t\tTHREE.ShaderChunk[ \"linear_to_gamma_fragment\" ],\r\n\r\n\t\t\t\tTHREE.ShaderChunk[ \"fog_fragment\" ],\r\n\r\n\t\t\t\"\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\",\t// TODO, this should be pre-multiplied to allow for bright highlights on very transparent objects\r\n\r\n\t\t\t\"}\"\r\n\r\n\t\t].join(\"\\n\")\r\n\r\n\t},\r\n\r\n\t'phong': {\r\n\r\n\t\tuniforms: THREE.UniformsUtils.merge( [\r\n\r\n\t\t\tTHREE.UniformsLib[ \"common\" ],\r\n\t\t\tTHREE.UniformsLib[ \"bump\" ],\r\n\t\t\tTHREE.UniformsLib[ \"normalmap\" ],\r\n\t\t\tTHREE.UniformsLib[ \"fog\" ],\r\n\t\t\tTHREE.UniformsLib[ \"lights\" ],\r\n\t\t\tTHREE.UniformsLib[ \"shadowmap\" ],\r\n\r\n\t\t\t{\r\n\t\t\t\t\"emissive\" : { type: \"c\", value: new THREE.Color( 0x000000 ) },\r\n\t\t\t\t\"specular\" : { type: \"c\", value: new THREE.Color( 0x111111 ) },\r\n\t\t\t\t\"shininess\": { type: \"f\", value: 30 },\r\n\t\t\t\t\"wrapRGB\"  : { type: \"v3\", value: new THREE.Vector3( 1, 1, 1 ) }\r\n\t\t\t}\r\n\r\n\t\t] ),\r\n\r\n\t\tvertexShader: [\r\n\r\n\t\t\t\"#define PHONG\",\r\n\r\n\t\t\t\"varying vec3 vViewPosition;\",\r\n\r\n\t\t\t\"#ifndef FLAT_SHADED\",\r\n\r\n\t\t\t\"\tvarying vec3 vNormal;\",\r\n\r\n\t\t\t\"#endif\",\r\n\r\n\t\t\tTHREE.ShaderChunk[ \"common\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"map_pars_vertex\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"lightmap_pars_vertex\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"envmap_pars_vertex\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"lights_phong_pars_vertex\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"color_pars_vertex\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"morphtarget_pars_vertex\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"skinning_pars_vertex\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"shadowmap_pars_vertex\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"logdepthbuf_pars_vertex\" ],\r\n\r\n\t\t\t\"void main() {\",\r\n\r\n\t\t\t\tTHREE.ShaderChunk[ \"map_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"lightmap_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"color_vertex\" ],\r\n\r\n\t\t\t\tTHREE.ShaderChunk[ \"morphnormal_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"skinbase_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"skinnormal_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"defaultnormal_vertex\" ],\r\n\r\n\t\t\t\"#ifndef FLAT_SHADED\", // Normal computed with derivatives when FLAT_SHADED\r\n\r\n\t\t\t\"\tvNormal = normalize( transformedNormal );\",\r\n\r\n\t\t\t\"#endif\",\r\n\r\n\t\t\t\tTHREE.ShaderChunk[ \"morphtarget_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"skinning_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"default_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"logdepthbuf_vertex\" ],\r\n\r\n\t\t\t\"\tvViewPosition = -mvPosition.xyz;\",\r\n\r\n\t\t\t\tTHREE.ShaderChunk[ \"worldpos_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"envmap_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"lights_phong_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"shadowmap_vertex\" ],\r\n\r\n\t\t\t\"}\"\r\n\r\n\t\t].join(\"\\n\"),\r\n\r\n\t\tfragmentShader: [\r\n\r\n\t\t\t\"#define PHONG\",\r\n\r\n\t\t\t\"uniform vec3 diffuse;\",\r\n\t\t\t\"uniform vec3 emissive;\",\r\n\t\t\t\"uniform vec3 specular;\",\r\n\t\t\t\"uniform float shininess;\",\r\n\t\t\t\"uniform float opacity;\",\r\n\r\n\t\t\tTHREE.ShaderChunk[ \"common\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"color_pars_fragment\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"map_pars_fragment\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"alphamap_pars_fragment\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"lightmap_pars_fragment\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"envmap_pars_fragment\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"fog_pars_fragment\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"lights_phong_pars_fragment\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"shadowmap_pars_fragment\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"bumpmap_pars_fragment\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"normalmap_pars_fragment\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"specularmap_pars_fragment\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"logdepthbuf_pars_fragment\" ],\r\n\r\n\t\t\t\"void main() {\",\r\n\r\n\t\t\t\"\tvec3 outgoingLight = vec3( 0.0 );\",\t// outgoing light does not have an alpha, the surface does\r\n\t\t\t\"\tvec4 diffuseColor = vec4( diffuse, opacity );\",\r\n\r\n\t\t\t\tTHREE.ShaderChunk[ \"logdepthbuf_fragment\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"map_fragment\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"color_fragment\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"alphamap_fragment\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"alphatest_fragment\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"specularmap_fragment\" ],\r\n\r\n\t\t\t\tTHREE.ShaderChunk[ \"lights_phong_fragment\" ],\r\n\r\n\t\t\t\tTHREE.ShaderChunk[ \"lightmap_fragment\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"envmap_fragment\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"shadowmap_fragment\" ],\r\n\r\n\t\t\t\tTHREE.ShaderChunk[ \"linear_to_gamma_fragment\" ],\r\n\r\n\t\t\t\tTHREE.ShaderChunk[ \"fog_fragment\" ],\r\n\r\n\t\t\t\"\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\",\t// TODO, this should be pre-multiplied to allow for bright highlights on very transparent objects\r\n\r\n\t\t\t\"}\"\r\n\r\n\t\t].join(\"\\n\")\r\n\r\n\t},\r\n\r\n\t'particle_basic': {\r\n\r\n\t\tuniforms: THREE.UniformsUtils.merge( [\r\n\r\n\t\t\tTHREE.UniformsLib[ \"particle\" ],\r\n\t\t\tTHREE.UniformsLib[ \"shadowmap\" ]\r\n\r\n\t\t] ),\r\n\r\n\t\tvertexShader: [\r\n\r\n\t\t\t\"uniform float size;\",\r\n\t\t\t\"uniform float scale;\",\r\n\r\n\t\t\tTHREE.ShaderChunk[ \"common\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"color_pars_vertex\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"shadowmap_pars_vertex\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"logdepthbuf_pars_vertex\" ],\r\n\r\n\t\t\t\"void main() {\",\r\n\r\n\t\t\t\tTHREE.ShaderChunk[ \"color_vertex\" ],\r\n\r\n\t\t\t\"\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\",\r\n\r\n\t\t\t\"\t#ifdef USE_SIZEATTENUATION\",\r\n\t\t\t\"\t\tgl_PointSize = size * ( scale / length( mvPosition.xyz ) );\",\r\n\t\t\t\"\t#else\",\r\n\t\t\t\"\t\tgl_PointSize = size;\",\r\n\t\t\t\"\t#endif\",\r\n\r\n\t\t\t\"\tgl_Position = projectionMatrix * mvPosition;\",\r\n\r\n\t\t\t\tTHREE.ShaderChunk[ \"logdepthbuf_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"worldpos_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"shadowmap_vertex\" ],\r\n\r\n\t\t\t\"}\"\r\n\r\n\t\t].join(\"\\n\"),\r\n\r\n\t\tfragmentShader: [\r\n\r\n\t\t\t\"uniform vec3 psColor;\",\r\n\t\t\t\"uniform float opacity;\",\r\n\r\n\t\t\tTHREE.ShaderChunk[ \"common\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"color_pars_fragment\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"map_particle_pars_fragment\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"fog_pars_fragment\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"shadowmap_pars_fragment\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"logdepthbuf_pars_fragment\" ],\r\n\r\n\t\t\t\"void main() {\",\r\n\r\n\t\t\t\"\tvec3 outgoingLight = vec3( 0.0 );\",\t// outgoing light does not have an alpha, the surface does\r\n\t\t\t\"\tvec4 diffuseColor = vec4( psColor, opacity );\",\r\n\r\n\t\t\t\tTHREE.ShaderChunk[ \"logdepthbuf_fragment\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"map_particle_fragment\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"color_fragment\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"alphatest_fragment\" ],\r\n\r\n\t\t\t\"\toutgoingLight = diffuseColor.rgb;\", // simple shader\r\n\r\n\t\t\t\tTHREE.ShaderChunk[ \"shadowmap_fragment\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"fog_fragment\" ],\r\n\r\n\t\t\t\"\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\",\t// TODO, this should be pre-multiplied to allow for bright highlights on very transparent objects\r\n\r\n\t\t\t\"}\"\r\n\r\n\t\t].join(\"\\n\")\r\n\r\n\t},\r\n\r\n\t'dashed': {\r\n\r\n\t\tuniforms: THREE.UniformsUtils.merge( [\r\n\r\n\t\t\tTHREE.UniformsLib[ \"common\" ],\r\n\t\t\tTHREE.UniformsLib[ \"fog\" ],\r\n\r\n\t\t\t{\r\n\t\t\t\t\"scale\"    : { type: \"f\", value: 1 },\r\n\t\t\t\t\"dashSize\" : { type: \"f\", value: 1 },\r\n\t\t\t\t\"totalSize\": { type: \"f\", value: 2 }\r\n\t\t\t}\r\n\r\n\t\t] ),\r\n\r\n\t\tvertexShader: [\r\n\r\n\t\t\t\"uniform float scale;\",\r\n\t\t\t\"attribute float lineDistance;\",\r\n\r\n\t\t\t\"varying float vLineDistance;\",\r\n\r\n\t\t\tTHREE.ShaderChunk[ \"common\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"color_pars_vertex\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"logdepthbuf_pars_vertex\" ],\r\n\r\n\t\t\t\"void main() {\",\r\n\r\n\t\t\t\tTHREE.ShaderChunk[ \"color_vertex\" ],\r\n\r\n\t\t\t\"\tvLineDistance = scale * lineDistance;\",\r\n\r\n\t\t\t\"\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\",\r\n\t\t\t\"\tgl_Position = projectionMatrix * mvPosition;\",\r\n\r\n\t\t\t\tTHREE.ShaderChunk[ \"logdepthbuf_vertex\" ],\r\n\r\n\t\t\t\"}\"\r\n\r\n\t\t].join(\"\\n\"),\r\n\r\n\t\tfragmentShader: [\r\n\r\n\t\t\t\"uniform vec3 diffuse;\",\r\n\t\t\t\"uniform float opacity;\",\r\n\r\n\t\t\t\"uniform float dashSize;\",\r\n\t\t\t\"uniform float totalSize;\",\r\n\r\n\t\t\t\"varying float vLineDistance;\",\r\n\r\n\t\t\tTHREE.ShaderChunk[ \"common\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"color_pars_fragment\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"fog_pars_fragment\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"logdepthbuf_pars_fragment\" ],\r\n\r\n\t\t\t\"void main() {\",\r\n\r\n\t\t\t\"\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\",\r\n\r\n\t\t\t\"\t\tdiscard;\",\r\n\r\n\t\t\t\"\t}\",\r\n\r\n\t\t\t\"\tvec3 outgoingLight = vec3( 0.0 );\",\t// outgoing light does not have an alpha, the surface does\r\n\t\t\t\"\tvec4 diffuseColor = vec4( diffuse, opacity );\",\r\n\r\n\t\t\t\tTHREE.ShaderChunk[ \"logdepthbuf_fragment\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"color_fragment\" ],\r\n\r\n\t\t\t\"\toutgoingLight = diffuseColor.rgb;\", // simple shader\r\n\r\n\t\t\t\tTHREE.ShaderChunk[ \"fog_fragment\" ],\r\n\r\n\t\t\t\"\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\",\t// TODO, this should be pre-multiplied to allow for bright highlights on very transparent objects\r\n\r\n\t\t\t\"}\"\r\n\r\n\t\t].join(\"\\n\")\r\n\r\n\t},\r\n\r\n\t'depth': {\r\n\r\n\t\tuniforms: {\r\n\r\n\t\t\t\"mNear\": { type: \"f\", value: 1.0 },\r\n\t\t\t\"mFar\" : { type: \"f\", value: 2000.0 },\r\n\t\t\t\"opacity\" : { type: \"f\", value: 1.0 }\r\n\r\n\t\t},\r\n\r\n\t\tvertexShader: [\r\n\r\n\t\t\tTHREE.ShaderChunk[ \"common\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"morphtarget_pars_vertex\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"logdepthbuf_pars_vertex\" ],\r\n\r\n\t\t\t\"void main() {\",\r\n\r\n\t\t\t\tTHREE.ShaderChunk[ \"morphtarget_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"default_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"logdepthbuf_vertex\" ],\r\n\r\n\t\t\t\"}\"\r\n\r\n\t\t].join(\"\\n\"),\r\n\r\n\t\tfragmentShader: [\r\n\r\n\t\t\t\"uniform float mNear;\",\r\n\t\t\t\"uniform float mFar;\",\r\n\t\t\t\"uniform float opacity;\",\r\n\r\n\t\t\tTHREE.ShaderChunk[ \"common\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"logdepthbuf_pars_fragment\" ],\r\n\r\n\t\t\t\"void main() {\",\r\n\r\n\t\t\t\tTHREE.ShaderChunk[ \"logdepthbuf_fragment\" ],\r\n\r\n\t\t\t\"\t#ifdef USE_LOGDEPTHBUF_EXT\",\r\n\r\n\t\t\t\"\t\tfloat depth = gl_FragDepthEXT / gl_FragCoord.w;\",\r\n\r\n\t\t\t\"\t#else\",\r\n\r\n\t\t\t\"\t\tfloat depth = gl_FragCoord.z / gl_FragCoord.w;\",\r\n\r\n\t\t\t\"\t#endif\",\r\n\r\n\t\t\t\"\tfloat color = 1.0 - smoothstep( mNear, mFar, depth );\",\r\n\t\t\t\"\tgl_FragColor = vec4( vec3( color ), opacity );\",   // TODO, this should be pre-multiplied to allow for bright highlights on very transparent objects\r\n\r\n\t\t\t\"}\"\r\n\r\n\t\t].join(\"\\n\")\r\n\r\n\t},\r\n\r\n\t'normal': {\r\n\r\n\t\tuniforms: {\r\n\r\n\t\t\t\"opacity\" : { type: \"f\", value: 1.0 }\r\n\r\n\t\t},\r\n\r\n\t\tvertexShader: [\r\n\r\n\t\t\t\"varying vec3 vNormal;\",\r\n\r\n\t\t\tTHREE.ShaderChunk[ \"common\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"morphtarget_pars_vertex\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"logdepthbuf_pars_vertex\" ],\r\n\r\n\t\t\t\"void main() {\",\r\n\r\n\t\t\t\"\tvNormal = normalize( normalMatrix * normal );\",\r\n\r\n\t\t\t\tTHREE.ShaderChunk[ \"morphtarget_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"default_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"logdepthbuf_vertex\" ],\r\n\r\n\t\t\t\"}\"\r\n\r\n\t\t].join(\"\\n\"),\r\n\r\n\t\tfragmentShader: [\r\n\r\n\t\t\t\"uniform float opacity;\",\r\n\t\t\t\"varying vec3 vNormal;\",\r\n\r\n\t\t\tTHREE.ShaderChunk[ \"common\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"logdepthbuf_pars_fragment\" ],\r\n\r\n\t\t\t\"void main() {\",\r\n\r\n\t\t\t\"\tgl_FragColor = vec4( 0.5 * normalize( vNormal ) + 0.5, opacity );\",\r\n\r\n\t\t\t\tTHREE.ShaderChunk[ \"logdepthbuf_fragment\" ],\r\n\r\n\t\t\t\"}\"\r\n\r\n\t\t].join(\"\\n\")\r\n\r\n\t},\r\n\r\n\t/* -------------------------------------------------------------------------\r\n\t//\tCube map shader\r\n\t ------------------------------------------------------------------------- */\r\n\r\n\t'cube': {\r\n\r\n\t\tuniforms: { \"tCube\": { type: \"t\", value: null },\r\n\t\t\t\t\t\"tFlip\": { type: \"f\", value: - 1 } },\r\n\r\n\t\tvertexShader: [\r\n\r\n\t\t\t\"varying vec3 vWorldPosition;\",\r\n\r\n\t\t\tTHREE.ShaderChunk[ \"common\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"logdepthbuf_pars_vertex\" ],\r\n\r\n\t\t\t\"void main() {\",\r\n\r\n\t\t\t\"\tvWorldPosition = transformDirection( position, modelMatrix );\",\r\n\r\n\t\t\t\"\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\r\n\r\n\t\t\t\tTHREE.ShaderChunk[ \"logdepthbuf_vertex\" ],\r\n\r\n\t\t\t\"}\"\r\n\r\n\t\t].join(\"\\n\"),\r\n\r\n\t\tfragmentShader: [\r\n\r\n\t\t\t\"uniform samplerCube tCube;\",\r\n\t\t\t\"uniform float tFlip;\",\r\n\r\n\t\t\t\"varying vec3 vWorldPosition;\",\r\n\r\n\t\t\tTHREE.ShaderChunk[ \"common\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"logdepthbuf_pars_fragment\" ],\r\n\r\n\t\t\t\"void main() {\",\r\n\r\n\t\t\t\"\tgl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );\",\r\n\r\n\t\t\t\tTHREE.ShaderChunk[ \"logdepthbuf_fragment\" ],\r\n\r\n\t\t\t\"}\"\r\n\r\n\t\t].join(\"\\n\")\r\n\r\n\t},\r\n\r\n\t/* -------------------------------------------------------------------------\r\n\t//\tCube map shader\r\n\t ------------------------------------------------------------------------- */\r\n\r\n\t'equirect': {\r\n\r\n\t\tuniforms: { \"tEquirect\": { type: \"t\", value: null },\r\n\t\t\t\t\t\"tFlip\": { type: \"f\", value: - 1 } },\r\n\r\n\t\tvertexShader: [\r\n\r\n\t\t\t\"varying vec3 vWorldPosition;\",\r\n\r\n\t\t\tTHREE.ShaderChunk[ \"common\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"logdepthbuf_pars_vertex\" ],\r\n\r\n\t\t\t\"void main() {\",\r\n\r\n\t\t\t\"\tvWorldPosition = transformDirection( position, modelMatrix );\",\r\n\r\n\t\t\t\"\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\r\n\r\n\t\t\t\tTHREE.ShaderChunk[ \"logdepthbuf_vertex\" ],\r\n\r\n\t\t\t\"}\"\r\n\r\n\t\t].join(\"\\n\"),\r\n\r\n\t\tfragmentShader: [\r\n\r\n\t\t\t\"uniform sampler2D tEquirect;\",\r\n\t\t\t\"uniform float tFlip;\",\r\n\r\n\t\t\t\"varying vec3 vWorldPosition;\",\r\n\r\n\t\t\tTHREE.ShaderChunk[ \"common\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"logdepthbuf_pars_fragment\" ],\r\n\r\n\t\t\t\"void main() {\",\r\n\r\n\t\t\t\t// \"\tgl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );\",\r\n\t\t\t\t\"vec3 direction = normalize( vWorldPosition );\",\r\n\t\t\t\t\"vec2 sampleUV;\",\r\n\t\t\t\t\"sampleUV.y = saturate( tFlip * direction.y * -0.5 + 0.5 );\",\r\n\t\t\t\t\"sampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\",\r\n\t\t\t\t\"gl_FragColor = texture2D( tEquirect, sampleUV );\",\r\n\r\n\t\t\t\tTHREE.ShaderChunk[ \"logdepthbuf_fragment\" ],\r\n\r\n\t\t\t\"}\"\r\n\r\n\t\t].join(\"\\n\")\r\n\r\n\t},\r\n\r\n\t/* Depth encoding into RGBA texture\r\n\t *\r\n\t * based on SpiderGL shadow map example\r\n\t * http://spidergl.org/example.php?id=6\r\n\t *\r\n\t * originally from\r\n\t * http://www.gamedev.net/topic/442138-packing-a-float-into-a-a8r8g8b8-texture-shader/page__whichpage__1%25EF%25BF%25BD\r\n\t *\r\n\t * see also\r\n\t * http://aras-p.info/blog/2009/07/30/encoding-floats-to-rgba-the-final/\r\n\t */\r\n\r\n\t'depthRGBA': {\r\n\r\n\t\tuniforms: {},\r\n\r\n\t\tvertexShader: [\r\n\r\n\t\t\tTHREE.ShaderChunk[ \"common\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"morphtarget_pars_vertex\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"skinning_pars_vertex\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"logdepthbuf_pars_vertex\" ],\r\n\r\n\t\t\t\"void main() {\",\r\n\r\n\t\t\t\tTHREE.ShaderChunk[ \"skinbase_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"morphtarget_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"skinning_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"default_vertex\" ],\r\n\t\t\t\tTHREE.ShaderChunk[ \"logdepthbuf_vertex\" ],\r\n\r\n\t\t\t\"}\"\r\n\r\n\t\t].join(\"\\n\"),\r\n\r\n\t\tfragmentShader: [\r\n\r\n\t\t\tTHREE.ShaderChunk[ \"common\" ],\r\n\t\t\tTHREE.ShaderChunk[ \"logdepthbuf_pars_fragment\" ],\r\n\r\n\t\t\t\"vec4 pack_depth( const in float depth ) {\",\r\n\r\n\t\t\t\"\tconst vec4 bit_shift = vec4( 256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0 );\",\r\n\t\t\t\"\tconst vec4 bit_mask = vec4( 0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0 );\",\r\n\t\t\t\"\tvec4 res = mod( depth * bit_shift * vec4( 255 ), vec4( 256 ) ) / vec4( 255 );\", // \"\tvec4 res = fract( depth * bit_shift );\",\r\n\t\t\t\"\tres -= res.xxyz * bit_mask;\",\r\n\t\t\t\"\treturn res;\",\r\n\r\n\t\t\t\"}\",\r\n\r\n\t\t\t\"void main() {\",\r\n\r\n\t\t\t\tTHREE.ShaderChunk[ \"logdepthbuf_fragment\" ],\r\n\r\n\t\t\t\"\t#ifdef USE_LOGDEPTHBUF_EXT\",\r\n\r\n\t\t\t\"\t\tgl_FragData[ 0 ] = pack_depth( gl_FragDepthEXT );\",\r\n\r\n\t\t\t\"\t#else\",\r\n\r\n\t\t\t\"\t\tgl_FragData[ 0 ] = pack_depth( gl_FragCoord.z );\",\r\n\r\n\t\t\t\"\t#endif\",\r\n\r\n\t\t\t\t//\"gl_FragData[ 0 ] = pack_depth( gl_FragCoord.z / gl_FragCoord.w );\",\r\n\t\t\t\t//\"float z = ( ( gl_FragCoord.z / gl_FragCoord.w ) - 3.0 ) / ( 4000.0 - 3.0 );\",\r\n\t\t\t\t//\"gl_FragData[ 0 ] = pack_depth( z );\",\r\n\t\t\t\t//\"gl_FragData[ 0 ] = vec4( z, z, z, 1.0 );\",\r\n\r\n\t\t\t\"}\"\r\n\r\n\t\t].join(\"\\n\")\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/renderers/WebGLRenderer.js\r\n\r\n/**\r\n * @author supereggbert / http://www.paulbrunt.co.uk/\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author szimek / https://github.com/szimek/\r\n */\r\n\r\nTHREE.WebGLRenderer = function ( parameters ) {\r\n\r\n\tconsole.log( 'THREE.WebGLRenderer', THREE.REVISION );\r\n\r\n\tparameters = parameters || {};\r\n\r\n\tvar _canvas = parameters.canvas !== undefined ? parameters.canvas : document.createElement( 'canvas' ),\r\n\t_context = parameters.context !== undefined ? parameters.context : null,\r\n\r\n\tpixelRatio = 1,\r\n\r\n\t_precision = parameters.precision !== undefined ? parameters.precision : 'highp',\r\n\r\n\t_alpha = parameters.alpha !== undefined ? parameters.alpha : false,\r\n\t_depth = parameters.depth !== undefined ? parameters.depth : true,\r\n\t_stencil = parameters.stencil !== undefined ? parameters.stencil : true,\r\n\t_antialias = parameters.antialias !== undefined ? parameters.antialias : false,\r\n\t_premultipliedAlpha = parameters.premultipliedAlpha !== undefined ? parameters.premultipliedAlpha : true,\r\n\t_preserveDrawingBuffer = parameters.preserveDrawingBuffer !== undefined ? parameters.preserveDrawingBuffer : false,\r\n\t_logarithmicDepthBuffer = parameters.logarithmicDepthBuffer !== undefined ? parameters.logarithmicDepthBuffer : false,\r\n\r\n\t_clearColor = new THREE.Color( 0x000000 ),\r\n\t_clearAlpha = 0;\r\n\r\n\tvar lights = [];\r\n\r\n\tvar _webglObjects = {};\r\n\tvar _webglObjectsImmediate = [];\r\n\r\n\tvar opaqueObjects = [];\r\n\tvar transparentObjects = [];\r\n\r\n\tvar sprites = [];\r\n\tvar lensFlares = [];\r\n\r\n\t// public properties\r\n\r\n\tthis.domElement = _canvas;\r\n\tthis.context = null;\r\n\r\n\t// clearing\r\n\r\n\tthis.autoClear = true;\r\n\tthis.autoClearColor = true;\r\n\tthis.autoClearDepth = true;\r\n\tthis.autoClearStencil = true;\r\n\r\n\t// scene graph\r\n\r\n\tthis.sortObjects = true;\r\n\r\n\t// physically based shading\r\n\r\n\tthis.gammaFactor = 2.0;\t// for backwards compatibility\r\n\tthis.gammaInput = false;\r\n\tthis.gammaOutput = false;\r\n\r\n\t// shadow map\r\n\r\n\tthis.shadowMapEnabled = false;\r\n\tthis.shadowMapType = THREE.PCFShadowMap;\r\n\tthis.shadowMapCullFace = THREE.CullFaceFront;\r\n\tthis.shadowMapDebug = false;\r\n\tthis.shadowMapCascade = false;\r\n\r\n\t// morphs\r\n\r\n\tthis.maxMorphTargets = 8;\r\n\tthis.maxMorphNormals = 4;\r\n\r\n\t// flags\r\n\r\n\tthis.autoScaleCubemaps = true;\r\n\r\n\t// info\r\n\r\n\tthis.info = {\r\n\r\n\t\tmemory: {\r\n\r\n\t\t\tprograms: 0,\r\n\t\t\tgeometries: 0,\r\n\t\t\ttextures: 0\r\n\r\n\t\t},\r\n\r\n\t\trender: {\r\n\r\n\t\t\tcalls: 0,\r\n\t\t\tvertices: 0,\r\n\t\t\tfaces: 0,\r\n\t\t\tpoints: 0\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\t// internal properties\r\n\r\n\tvar _this = this,\r\n\r\n\t_programs = [],\r\n\r\n\t// internal state cache\r\n\r\n\t_currentProgram = null,\r\n\t_currentFramebuffer = null,\r\n\t_currentMaterialId = - 1,\r\n\t_currentGeometryProgram = '',\r\n\t_currentCamera = null,\r\n\r\n\t_usedTextureUnits = 0,\r\n\r\n\t_viewportX = 0,\r\n\t_viewportY = 0,\r\n\t_viewportWidth = _canvas.width,\r\n\t_viewportHeight = _canvas.height,\r\n\t_currentWidth = 0,\r\n\t_currentHeight = 0,\r\n\r\n\t// frustum\r\n\r\n\t_frustum = new THREE.Frustum(),\r\n\r\n\t // camera matrices cache\r\n\r\n\t_projScreenMatrix = new THREE.Matrix4(),\r\n\r\n\t_vector3 = new THREE.Vector3(),\r\n\r\n\t// light arrays cache\r\n\r\n\t_direction = new THREE.Vector3(),\r\n\r\n\t_lightsNeedUpdate = true,\r\n\r\n\t_lights = {\r\n\r\n\t\tambient: [ 0, 0, 0 ],\r\n\t\tdirectional: { length: 0, colors:[], positions: [] },\r\n\t\tpoint: { length: 0, colors: [], positions: [], distances: [], decays: [] },\r\n\t\tspot: { length: 0, colors: [], positions: [], distances: [], directions: [], anglesCos: [], exponents: [], decays: [] },\r\n\t\themi: { length: 0, skyColors: [], groundColors: [], positions: [] }\r\n\r\n\t};\r\n\r\n\t// initialize\r\n\r\n\tvar _gl;\r\n\r\n\ttry {\r\n\r\n\t\tvar attributes = {\r\n\t\t\talpha: _alpha,\r\n\t\t\tdepth: _depth,\r\n\t\t\tstencil: _stencil,\r\n\t\t\tantialias: _antialias,\r\n\t\t\tpremultipliedAlpha: _premultipliedAlpha,\r\n\t\t\tpreserveDrawingBuffer: _preserveDrawingBuffer\r\n\t\t};\r\n\r\n\t\t_gl = _context || _canvas.getContext( 'webgl', attributes ) || _canvas.getContext( 'experimental-webgl', attributes );\r\n\r\n\t\tif ( _gl === null ) {\r\n\r\n\t\t\tif ( _canvas.getContext( 'webgl') !== null ) {\r\n\r\n\t\t\t\tthrow 'Error creating WebGL context with your selected attributes.';\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tthrow 'Error creating WebGL context.';\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t_canvas.addEventListener( 'webglcontextlost', function ( event ) {\r\n\r\n\t\t\tevent.preventDefault();\r\n\r\n\t\t\tresetGLState();\r\n\t\t\tsetDefaultGLState();\r\n\r\n\t\t\t_webglObjects = {};\r\n\r\n\t\t}, false);\r\n\r\n\t} catch ( error ) {\r\n\r\n\t\tTHREE.error( 'THREE.WebGLRenderer: ' + error );\r\n\r\n\t}\r\n\r\n\tvar state = new THREE.WebGLState( _gl, paramThreeToGL );\r\n\r\n\tif ( _gl.getShaderPrecisionFormat === undefined ) {\r\n\r\n\t\t_gl.getShaderPrecisionFormat = function () {\r\n\r\n\t\t\treturn {\r\n\t\t\t\t'rangeMin': 1,\r\n\t\t\t\t'rangeMax': 1,\r\n\t\t\t\t'precision': 1\r\n\t\t\t};\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tvar extensions = new THREE.WebGLExtensions( _gl );\r\n\r\n\textensions.get( 'OES_texture_float' );\r\n\textensions.get( 'OES_texture_float_linear' );\r\n\textensions.get( 'OES_texture_half_float' );\r\n\textensions.get( 'OES_texture_half_float_linear' );\r\n\textensions.get( 'OES_standard_derivatives' );\r\n\r\n\tif ( _logarithmicDepthBuffer ) {\r\n\r\n\t\textensions.get( 'EXT_frag_depth' );\r\n\r\n\t}\r\n\r\n\t//\r\n\r\n\tvar glClearColor = function ( r, g, b, a ) {\r\n\r\n\t\tif ( _premultipliedAlpha === true ) {\r\n\r\n\t\t\tr *= a; g *= a; b *= a;\r\n\r\n\t\t}\r\n\r\n\t\t_gl.clearColor( r, g, b, a );\r\n\r\n\t};\r\n\r\n\tvar setDefaultGLState = function () {\r\n\r\n\t\t_gl.clearColor( 0, 0, 0, 1 );\r\n\t\t_gl.clearDepth( 1 );\r\n\t\t_gl.clearStencil( 0 );\r\n\r\n\t\t_gl.enable( _gl.DEPTH_TEST );\r\n\t\t_gl.depthFunc( _gl.LEQUAL );\r\n\r\n\t\t_gl.frontFace( _gl.CCW );\r\n\t\t_gl.cullFace( _gl.BACK );\r\n\t\t_gl.enable( _gl.CULL_FACE );\r\n\r\n\t\t_gl.enable( _gl.BLEND );\r\n\t\t_gl.blendEquation( _gl.FUNC_ADD );\r\n\t\t_gl.blendFunc( _gl.SRC_ALPHA, _gl.ONE_MINUS_SRC_ALPHA );\r\n\r\n\t\t_gl.viewport( _viewportX, _viewportY, _viewportWidth, _viewportHeight );\r\n\r\n\t\tglClearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );\r\n\r\n\t};\r\n\r\n\tvar resetGLState = function () {\r\n\r\n\t\t_currentProgram = null;\r\n\t\t_currentCamera = null;\r\n\r\n\t\t_currentGeometryProgram = '';\r\n\t\t_currentMaterialId = - 1;\r\n\r\n\t\t_lightsNeedUpdate = true;\r\n\r\n\t\tstate.reset();\r\n\r\n\t};\r\n\r\n\tsetDefaultGLState();\r\n\r\n\tthis.context = _gl;\r\n\tthis.state = state;\r\n\r\n\t// GPU capabilities\r\n\r\n\tvar _maxTextures = _gl.getParameter( _gl.MAX_TEXTURE_IMAGE_UNITS );\r\n\tvar _maxVertexTextures = _gl.getParameter( _gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS );\r\n\tvar _maxTextureSize = _gl.getParameter( _gl.MAX_TEXTURE_SIZE );\r\n\tvar _maxCubemapSize = _gl.getParameter( _gl.MAX_CUBE_MAP_TEXTURE_SIZE );\r\n\r\n\tvar _supportsVertexTextures = _maxVertexTextures > 0;\r\n\tvar _supportsBoneTextures = _supportsVertexTextures && extensions.get( 'OES_texture_float' );\r\n\r\n\t//\r\n\r\n\tvar _vertexShaderPrecisionHighpFloat = _gl.getShaderPrecisionFormat( _gl.VERTEX_SHADER, _gl.HIGH_FLOAT );\r\n\tvar _vertexShaderPrecisionMediumpFloat = _gl.getShaderPrecisionFormat( _gl.VERTEX_SHADER, _gl.MEDIUM_FLOAT );\r\n\r\n\tvar _fragmentShaderPrecisionHighpFloat = _gl.getShaderPrecisionFormat( _gl.FRAGMENT_SHADER, _gl.HIGH_FLOAT );\r\n\tvar _fragmentShaderPrecisionMediumpFloat = _gl.getShaderPrecisionFormat( _gl.FRAGMENT_SHADER, _gl.MEDIUM_FLOAT );\r\n\r\n\tvar getCompressedTextureFormats = ( function () {\r\n\r\n\t\tvar array;\r\n\r\n\t\treturn function () {\r\n\r\n\t\t\tif ( array !== undefined ) {\r\n\r\n\t\t\t\treturn array;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tarray = [];\r\n\r\n\t\t\tif ( extensions.get( 'WEBGL_compressed_texture_pvrtc' ) || extensions.get( 'WEBGL_compressed_texture_s3tc' ) ) {\r\n\r\n\t\t\t\tvar formats = _gl.getParameter( _gl.COMPRESSED_TEXTURE_FORMATS );\r\n\r\n\t\t\t\tfor ( var i = 0; i < formats.length; i ++ ) {\r\n\r\n\t\t\t\t\tarray.push( formats[ i ] );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn array;\r\n\r\n\t\t};\r\n\r\n\t} )();\r\n\r\n\t// clamp precision to maximum available\r\n\r\n\tvar highpAvailable = _vertexShaderPrecisionHighpFloat.precision > 0 && _fragmentShaderPrecisionHighpFloat.precision > 0;\r\n\tvar mediumpAvailable = _vertexShaderPrecisionMediumpFloat.precision > 0 && _fragmentShaderPrecisionMediumpFloat.precision > 0;\r\n\r\n\tif ( _precision === 'highp' && ! highpAvailable ) {\r\n\r\n\t\tif ( mediumpAvailable ) {\r\n\r\n\t\t\t_precision = 'mediump';\r\n\t\t\tTHREE.warn( 'THREE.WebGLRenderer: highp not supported, using mediump.' );\r\n\r\n\t\t} else {\r\n\r\n\t\t\t_precision = 'lowp';\r\n\t\t\tTHREE.warn( 'THREE.WebGLRenderer: highp and mediump not supported, using lowp.' );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tif ( _precision === 'mediump' && ! mediumpAvailable ) {\r\n\r\n\t\t_precision = 'lowp';\r\n\t\tTHREE.warn( 'THREE.WebGLRenderer: mediump not supported, using lowp.' );\r\n\r\n\t}\r\n\r\n\t// Plugins\r\n\r\n\tvar shadowMapPlugin = new THREE.ShadowMapPlugin( this, lights, _webglObjects, _webglObjectsImmediate );\r\n\r\n\tvar spritePlugin = new THREE.SpritePlugin( this, sprites );\r\n\tvar lensFlarePlugin = new THREE.LensFlarePlugin( this, lensFlares );\r\n\r\n\t// API\r\n\r\n\tthis.getContext = function () {\r\n\r\n\t\treturn _gl;\r\n\r\n\t};\r\n\r\n\tthis.forceContextLoss = function () {\r\n\r\n\t\textensions.get( 'WEBGL_lose_context' ).loseContext();\r\n\r\n\t};\r\n\r\n\tthis.supportsVertexTextures = function () {\r\n\r\n\t\treturn _supportsVertexTextures;\r\n\r\n\t};\r\n\r\n\tthis.supportsFloatTextures = function () {\r\n\r\n\t\treturn extensions.get( 'OES_texture_float' );\r\n\r\n\t};\r\n\r\n\tthis.supportsHalfFloatTextures = function () {\r\n\r\n\t\treturn extensions.get( 'OES_texture_half_float' );\r\n\r\n\t};\r\n\r\n\tthis.supportsStandardDerivatives = function () {\r\n\r\n\t\treturn extensions.get( 'OES_standard_derivatives' );\r\n\r\n\t};\r\n\r\n\tthis.supportsCompressedTextureS3TC = function () {\r\n\r\n\t\treturn extensions.get( 'WEBGL_compressed_texture_s3tc' );\r\n\r\n\t};\r\n\r\n\tthis.supportsCompressedTexturePVRTC = function () {\r\n\r\n\t\treturn extensions.get( 'WEBGL_compressed_texture_pvrtc' );\r\n\r\n\t};\r\n\r\n\tthis.supportsBlendMinMax = function () {\r\n\r\n\t\treturn extensions.get( 'EXT_blend_minmax' );\r\n\r\n\t};\r\n\r\n\tthis.getMaxAnisotropy = ( function () {\r\n\r\n\t\tvar value;\r\n\r\n\t\treturn function () {\r\n\r\n\t\t\tif ( value !== undefined ) {\r\n\r\n\t\t\t\treturn value;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar extension = extensions.get( 'EXT_texture_filter_anisotropic' );\r\n\r\n\t\t\tvalue = extension !== null ? _gl.getParameter( extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT ) : 0;\r\n\r\n\t\t\treturn value;\r\n\r\n\t\t}\r\n\r\n\t} )();\r\n\r\n\tthis.getPrecision = function () {\r\n\r\n\t\treturn _precision;\r\n\r\n\t};\r\n\r\n\tthis.getPixelRatio = function () {\r\n\r\n\t\treturn pixelRatio;\r\n\r\n\t};\r\n\r\n\tthis.setPixelRatio = function ( value ) {\r\n\r\n\t\tpixelRatio = value;\r\n\r\n\t};\r\n\r\n\tthis.setSize = function ( width, height, updateStyle ) {\r\n\r\n\t\t_canvas.width = width * pixelRatio;\r\n\t\t_canvas.height = height * pixelRatio;\r\n\r\n\t\tif ( updateStyle !== false ) {\r\n\r\n\t\t\t_canvas.style.width = width + 'px';\r\n\t\t\t_canvas.style.height = height + 'px';\r\n\r\n\t\t}\r\n\r\n\t\tthis.setViewport( 0, 0, width, height );\r\n\r\n\t};\r\n\r\n\tthis.setViewport = function ( x, y, width, height ) {\r\n\r\n\t\t_viewportX = x * pixelRatio;\r\n\t\t_viewportY = y * pixelRatio;\r\n\r\n\t\t_viewportWidth = width * pixelRatio;\r\n\t\t_viewportHeight = height * pixelRatio;\r\n\r\n\t\t_gl.viewport( _viewportX, _viewportY, _viewportWidth, _viewportHeight );\r\n\r\n\t};\r\n\r\n\tthis.setScissor = function ( x, y, width, height ) {\r\n\r\n\t\t_gl.scissor(\r\n\t\t\tx * pixelRatio,\r\n\t\t\ty * pixelRatio,\r\n\t\t\twidth * pixelRatio,\r\n\t\t\theight * pixelRatio\r\n\t\t);\r\n\r\n\t};\r\n\r\n\tthis.enableScissorTest = function ( enable ) {\r\n\r\n\t\tenable ? _gl.enable( _gl.SCISSOR_TEST ) : _gl.disable( _gl.SCISSOR_TEST );\r\n\r\n\t};\r\n\r\n\t// Clearing\r\n\r\n\tthis.getClearColor = function () {\r\n\r\n\t\treturn _clearColor;\r\n\r\n\t};\r\n\r\n\tthis.setClearColor = function ( color, alpha ) {\r\n\r\n\t\t_clearColor.set( color );\r\n\r\n\t\t_clearAlpha = alpha !== undefined ? alpha : 1;\r\n\r\n\t\tglClearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );\r\n\r\n\t};\r\n\r\n\tthis.getClearAlpha = function () {\r\n\r\n\t\treturn _clearAlpha;\r\n\r\n\t};\r\n\r\n\tthis.setClearAlpha = function ( alpha ) {\r\n\r\n\t\t_clearAlpha = alpha;\r\n\r\n\t\tglClearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );\r\n\r\n\t};\r\n\r\n\tthis.clear = function ( color, depth, stencil ) {\r\n\r\n\t\tvar bits = 0;\r\n\r\n\t\tif ( color === undefined || color ) bits |= _gl.COLOR_BUFFER_BIT;\r\n\t\tif ( depth === undefined || depth ) bits |= _gl.DEPTH_BUFFER_BIT;\r\n\t\tif ( stencil === undefined || stencil ) bits |= _gl.STENCIL_BUFFER_BIT;\r\n\r\n\t\t_gl.clear( bits );\r\n\r\n\t};\r\n\r\n\tthis.clearColor = function () {\r\n\r\n\t\t_gl.clear( _gl.COLOR_BUFFER_BIT );\r\n\r\n\t};\r\n\r\n\tthis.clearDepth = function () {\r\n\r\n\t\t_gl.clear( _gl.DEPTH_BUFFER_BIT );\r\n\r\n\t};\r\n\r\n\tthis.clearStencil = function () {\r\n\r\n\t\t_gl.clear( _gl.STENCIL_BUFFER_BIT );\r\n\r\n\t};\r\n\r\n\tthis.clearTarget = function ( renderTarget, color, depth, stencil ) {\r\n\r\n\t\tthis.setRenderTarget( renderTarget );\r\n\t\tthis.clear( color, depth, stencil );\r\n\r\n\t};\r\n\r\n\t// Reset\r\n\r\n\tthis.resetGLState = resetGLState;\r\n\r\n\t// Buffer allocation\r\n\r\n\tfunction createParticleBuffers ( geometry ) {\r\n\r\n\t\tgeometry.__webglVertexBuffer = _gl.createBuffer();\r\n\t\tgeometry.__webglColorBuffer = _gl.createBuffer();\r\n\r\n\t\t_this.info.memory.geometries ++;\r\n\r\n\t};\r\n\r\n\tfunction createLineBuffers ( geometry ) {\r\n\r\n\t\tgeometry.__webglVertexBuffer = _gl.createBuffer();\r\n\t\tgeometry.__webglColorBuffer = _gl.createBuffer();\r\n\t\tgeometry.__webglLineDistanceBuffer = _gl.createBuffer();\r\n\r\n\t\t_this.info.memory.geometries ++;\r\n\r\n\t};\r\n\r\n\tfunction createMeshBuffers ( geometryGroup ) {\r\n\r\n\t\tgeometryGroup.__webglVertexBuffer = _gl.createBuffer();\r\n\t\tgeometryGroup.__webglNormalBuffer = _gl.createBuffer();\r\n\t\tgeometryGroup.__webglTangentBuffer = _gl.createBuffer();\r\n\t\tgeometryGroup.__webglColorBuffer = _gl.createBuffer();\r\n\t\tgeometryGroup.__webglUVBuffer = _gl.createBuffer();\r\n\t\tgeometryGroup.__webglUV2Buffer = _gl.createBuffer();\r\n\r\n\t\tgeometryGroup.__webglSkinIndicesBuffer = _gl.createBuffer();\r\n\t\tgeometryGroup.__webglSkinWeightsBuffer = _gl.createBuffer();\r\n\r\n\t\tgeometryGroup.__webglFaceBuffer = _gl.createBuffer();\r\n\t\tgeometryGroup.__webglLineBuffer = _gl.createBuffer();\r\n\r\n\t\tvar numMorphTargets = geometryGroup.numMorphTargets;\r\n\r\n\t\tif ( numMorphTargets ) {\r\n\r\n\t\t\tgeometryGroup.__webglMorphTargetsBuffers = [];\r\n\r\n\t\t\tfor ( var m = 0, ml = numMorphTargets; m < ml; m ++ ) {\r\n\r\n\t\t\t\tgeometryGroup.__webglMorphTargetsBuffers.push( _gl.createBuffer() );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tvar numMorphNormals = geometryGroup.numMorphNormals;\r\n\r\n\t\tif ( numMorphNormals ) {\r\n\r\n\t\t\tgeometryGroup.__webglMorphNormalsBuffers = [];\r\n\r\n\t\t\tfor ( var m = 0, ml = numMorphNormals; m < ml; m ++ ) {\r\n\r\n\t\t\t\tgeometryGroup.__webglMorphNormalsBuffers.push( _gl.createBuffer() );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t_this.info.memory.geometries ++;\r\n\r\n\t};\r\n\r\n\t// Events\r\n\r\n\tvar onObjectRemoved = function ( event ) {\r\n\r\n\t\tvar object = event.target;\r\n\r\n\t\tobject.traverse( function ( child ) {\r\n\r\n\t\t\tchild.removeEventListener( 'remove', onObjectRemoved );\r\n\r\n\t\t\tremoveObject( child );\r\n\r\n\t\t} );\r\n\r\n\t};\r\n\r\n\tvar onGeometryDispose = function ( event ) {\r\n\r\n\t\tvar geometry = event.target;\r\n\r\n\t\tgeometry.removeEventListener( 'dispose', onGeometryDispose );\r\n\r\n\t\tdeallocateGeometry( geometry );\r\n\r\n\t};\r\n\r\n\tvar onTextureDispose = function ( event ) {\r\n\r\n\t\tvar texture = event.target;\r\n\r\n\t\ttexture.removeEventListener( 'dispose', onTextureDispose );\r\n\r\n\t\tdeallocateTexture( texture );\r\n\r\n\t\t_this.info.memory.textures --;\r\n\r\n\r\n\t};\r\n\r\n\tvar onRenderTargetDispose = function ( event ) {\r\n\r\n\t\tvar renderTarget = event.target;\r\n\r\n\t\trenderTarget.removeEventListener( 'dispose', onRenderTargetDispose );\r\n\r\n\t\tdeallocateRenderTarget( renderTarget );\r\n\r\n\t\t_this.info.memory.textures --;\r\n\r\n\t};\r\n\r\n\tvar onMaterialDispose = function ( event ) {\r\n\r\n\t\tvar material = event.target;\r\n\r\n\t\tmaterial.removeEventListener( 'dispose', onMaterialDispose );\r\n\r\n\t\tdeallocateMaterial( material );\r\n\r\n\t};\r\n\r\n\t// Buffer deallocation\r\n\r\n\tvar deleteBuffers = function ( geometry ) {\r\n\r\n\t\tvar buffers = [\r\n\t\t\t'__webglVertexBuffer',\r\n\t\t\t'__webglNormalBuffer',\r\n\t\t\t'__webglTangentBuffer',\r\n\t\t\t'__webglColorBuffer',\r\n\t\t\t'__webglUVBuffer',\r\n\t\t\t'__webglUV2Buffer',\r\n\r\n\t\t\t'__webglSkinIndicesBuffer',\r\n\t\t\t'__webglSkinWeightsBuffer',\r\n\r\n\t\t\t'__webglFaceBuffer',\r\n\t\t\t'__webglLineBuffer',\r\n\r\n\t\t\t'__webglLineDistanceBuffer'\r\n\t\t];\r\n\r\n\t\tfor ( var i = 0, l = buffers.length; i < l; i ++ ) {\r\n\r\n\t\t\tvar name = buffers[ i ];\r\n\r\n\t\t\tif ( geometry[ name ] !== undefined ) {\r\n\r\n\t\t\t\t_gl.deleteBuffer( geometry[ name ] );\r\n\r\n\t\t\t\tdelete geometry[ name ];\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// custom attributes\r\n\r\n\t\tif ( geometry.__webglCustomAttributesList !== undefined ) {\r\n\r\n\t\t\tfor ( var name in geometry.__webglCustomAttributesList ) {\r\n\r\n\t\t\t\t_gl.deleteBuffer( geometry.__webglCustomAttributesList[ name ].buffer );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tdelete geometry.__webglCustomAttributesList;\r\n\r\n\t\t}\r\n\r\n\t\t_this.info.memory.geometries --;\r\n\r\n\t};\r\n\r\n\tvar deallocateGeometry = function ( geometry ) {\r\n\r\n\t\tdelete geometry.__webglInit;\r\n\r\n\t\tif ( geometry instanceof THREE.BufferGeometry ) {\r\n\r\n\t\t\tfor ( var name in geometry.attributes ) {\r\n\r\n\t\t\t\tvar attribute = geometry.attributes[ name ];\r\n\r\n\t\t\t\tif ( attribute.buffer !== undefined ) {\r\n\r\n\t\t\t\t\t_gl.deleteBuffer( attribute.buffer );\r\n\r\n\t\t\t\t\tdelete attribute.buffer;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\t_this.info.memory.geometries --;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tvar geometryGroupsList = geometryGroups[ geometry.id ];\r\n\r\n\t\t\tif ( geometryGroupsList !== undefined ) {\r\n\r\n\t\t\t\tfor ( var i = 0, l = geometryGroupsList.length; i < l; i ++ ) {\r\n\r\n\t\t\t\t\tvar geometryGroup = geometryGroupsList[ i ];\r\n\r\n\t\t\t\t\tif ( geometryGroup.numMorphTargets !== undefined ) {\r\n\r\n\t\t\t\t\t\tfor ( var m = 0, ml = geometryGroup.numMorphTargets; m < ml; m ++ ) {\r\n\r\n\t\t\t\t\t\t\t_gl.deleteBuffer( geometryGroup.__webglMorphTargetsBuffers[ m ] );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tdelete geometryGroup.__webglMorphTargetsBuffers;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif ( geometryGroup.numMorphNormals !== undefined ) {\r\n\r\n\t\t\t\t\t\tfor ( var m = 0, ml = geometryGroup.numMorphNormals; m < ml; m ++ ) {\r\n\r\n\t\t\t\t\t\t\t_gl.deleteBuffer( geometryGroup.__webglMorphNormalsBuffers[ m ] );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tdelete geometryGroup.__webglMorphNormalsBuffers;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tdeleteBuffers( geometryGroup );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tdelete geometryGroups[ geometry.id ];\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tdeleteBuffers( geometry );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// TOFIX: Workaround for deleted geometry being currently bound\r\n\r\n\t\t_currentGeometryProgram = '';\r\n\r\n\t};\r\n\r\n\tvar deallocateTexture = function ( texture ) {\r\n\r\n\t\tif ( texture.image && texture.image.__webglTextureCube ) {\r\n\r\n\t\t\t// cube texture\r\n\r\n\t\t\t_gl.deleteTexture( texture.image.__webglTextureCube );\r\n\r\n\t\t\tdelete texture.image.__webglTextureCube;\r\n\r\n\t\t} else {\r\n\r\n\t\t\t// 2D texture\r\n\r\n\t\t\tif ( texture.__webglInit === undefined ) return;\r\n\r\n\t\t\t_gl.deleteTexture( texture.__webglTexture );\r\n\r\n\t\t\tdelete texture.__webglTexture;\r\n\t\t\tdelete texture.__webglInit;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tvar deallocateRenderTarget = function ( renderTarget ) {\r\n\r\n\t\tif ( ! renderTarget || renderTarget.__webglTexture === undefined ) return;\r\n\r\n\t\t_gl.deleteTexture( renderTarget.__webglTexture );\r\n\r\n\t\tdelete renderTarget.__webglTexture;\r\n\r\n\t\tif ( renderTarget instanceof THREE.WebGLRenderTargetCube ) {\r\n\r\n\t\t\tfor ( var i = 0; i < 6; i ++ ) {\r\n\r\n\t\t\t\t_gl.deleteFramebuffer( renderTarget.__webglFramebuffer[ i ] );\r\n\t\t\t\t_gl.deleteRenderbuffer( renderTarget.__webglRenderbuffer[ i ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\t_gl.deleteFramebuffer( renderTarget.__webglFramebuffer );\r\n\t\t\t_gl.deleteRenderbuffer( renderTarget.__webglRenderbuffer );\r\n\r\n\t\t}\r\n\r\n\t\tdelete renderTarget.__webglFramebuffer;\r\n\t\tdelete renderTarget.__webglRenderbuffer;\r\n\r\n\t};\r\n\r\n\tvar deallocateMaterial = function ( material ) {\r\n\r\n\t\tvar program = material.program.program;\r\n\r\n\t\tif ( program === undefined ) return;\r\n\r\n\t\tmaterial.program = undefined;\r\n\r\n\t\t// only deallocate GL program if this was the last use of shared program\r\n\t\t// assumed there is only single copy of any program in the _programs list\r\n\t\t// (that's how it's constructed)\r\n\r\n\t\tvar i, il, programInfo;\r\n\t\tvar deleteProgram = false;\r\n\r\n\t\tfor ( i = 0, il = _programs.length; i < il; i ++ ) {\r\n\r\n\t\t\tprogramInfo = _programs[ i ];\r\n\r\n\t\t\tif ( programInfo.program === program ) {\r\n\r\n\t\t\t\tprogramInfo.usedTimes --;\r\n\r\n\t\t\t\tif ( programInfo.usedTimes === 0 ) {\r\n\r\n\t\t\t\t\tdeleteProgram = true;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tbreak;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( deleteProgram === true ) {\r\n\r\n\t\t\t// avoid using array.splice, this is costlier than creating new array from scratch\r\n\r\n\t\t\tvar newPrograms = [];\r\n\r\n\t\t\tfor ( i = 0, il = _programs.length; i < il; i ++ ) {\r\n\r\n\t\t\t\tprogramInfo = _programs[ i ];\r\n\r\n\t\t\t\tif ( programInfo.program !== program ) {\r\n\r\n\t\t\t\t\tnewPrograms.push( programInfo );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\t_programs = newPrograms;\r\n\r\n\t\t\t_gl.deleteProgram( program );\r\n\r\n\t\t\t_this.info.memory.programs --;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\t// Buffer initialization\r\n\r\n\tfunction initCustomAttributes ( object ) {\r\n\r\n\t\tvar geometry = object.geometry;\r\n\t\tvar material = object.material;\r\n\r\n\t\tvar nvertices = geometry.vertices.length;\r\n\r\n\t\tif ( material.attributes ) {\r\n\r\n\t\t\tif ( geometry.__webglCustomAttributesList === undefined ) {\r\n\r\n\t\t\t\tgeometry.__webglCustomAttributesList = [];\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfor ( var name in material.attributes ) {\r\n\r\n\t\t\t\tvar attribute = material.attributes[ name ];\r\n\r\n\t\t\t\tif ( ! attribute.__webglInitialized || attribute.createUniqueBuffers ) {\r\n\r\n\t\t\t\t\tattribute.__webglInitialized = true;\r\n\r\n\t\t\t\t\tvar size = 1;   // \"f\" and \"i\"\r\n\r\n\t\t\t\t\tif ( attribute.type === 'v2' ) size = 2;\r\n\t\t\t\t\telse if ( attribute.type === 'v3' ) size = 3;\r\n\t\t\t\t\telse if ( attribute.type === 'v4' ) size = 4;\r\n\t\t\t\t\telse if ( attribute.type === 'c'  ) size = 3;\r\n\r\n\t\t\t\t\tattribute.size = size;\r\n\r\n\t\t\t\t\tattribute.array = new Float32Array( nvertices * size );\r\n\r\n\t\t\t\t\tattribute.buffer = _gl.createBuffer();\r\n\t\t\t\t\tattribute.buffer.belongsToAttribute = name;\r\n\r\n\t\t\t\t\tattribute.needsUpdate = true;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tgeometry.__webglCustomAttributesList.push( attribute );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tfunction initParticleBuffers ( geometry, object ) {\r\n\r\n\t\tvar nvertices = geometry.vertices.length;\r\n\r\n\t\tgeometry.__vertexArray = new Float32Array( nvertices * 3 );\r\n\t\tgeometry.__colorArray = new Float32Array( nvertices * 3 );\r\n\r\n\t\tgeometry.__webglParticleCount = nvertices;\r\n\r\n\t\tinitCustomAttributes( object );\r\n\r\n\t};\r\n\r\n\tfunction initLineBuffers ( geometry, object ) {\r\n\r\n\t\tvar nvertices = geometry.vertices.length;\r\n\r\n\t\tgeometry.__vertexArray = new Float32Array( nvertices * 3 );\r\n\t\tgeometry.__colorArray = new Float32Array( nvertices * 3 );\r\n\t\tgeometry.__lineDistanceArray = new Float32Array( nvertices * 1 );\r\n\r\n\t\tgeometry.__webglLineCount = nvertices;\r\n\r\n\t\tinitCustomAttributes( object );\r\n\r\n\t};\r\n\r\n\tfunction initMeshBuffers ( geometryGroup, object ) {\r\n\r\n\t\tvar geometry = object.geometry,\r\n\t\t\tfaces3 = geometryGroup.faces3,\r\n\r\n\t\t\tnvertices = faces3.length * 3,\r\n\t\t\tntris     = faces3.length * 1,\r\n\t\t\tnlines    = faces3.length * 3,\r\n\r\n\t\t\tmaterial = getBufferMaterial( object, geometryGroup );\r\n\r\n\t\tgeometryGroup.__vertexArray = new Float32Array( nvertices * 3 );\r\n\t\tgeometryGroup.__normalArray = new Float32Array( nvertices * 3 );\r\n\t\tgeometryGroup.__colorArray = new Float32Array( nvertices * 3 );\r\n\t\tgeometryGroup.__uvArray = new Float32Array( nvertices * 2 );\r\n\r\n\t\tif ( geometry.faceVertexUvs.length > 1 ) {\r\n\r\n\t\t\tgeometryGroup.__uv2Array = new Float32Array( nvertices * 2 );\r\n\r\n\t\t}\r\n\r\n\t\tif ( geometry.hasTangents ) {\r\n\r\n\t\t\tgeometryGroup.__tangentArray = new Float32Array( nvertices * 4 );\r\n\r\n\t\t}\r\n\r\n\t\tif ( object.geometry.skinWeights.length && object.geometry.skinIndices.length ) {\r\n\r\n\t\t\tgeometryGroup.__skinIndexArray = new Float32Array( nvertices * 4 );\r\n\t\t\tgeometryGroup.__skinWeightArray = new Float32Array( nvertices * 4 );\r\n\r\n\t\t}\r\n\r\n\t\tvar UintArray = extensions.get( 'OES_element_index_uint' ) !== null && ntris > 21845 ? Uint32Array : Uint16Array; // 65535 / 3\r\n\r\n\t\tgeometryGroup.__typeArray = UintArray;\r\n\t\tgeometryGroup.__faceArray = new UintArray( ntris * 3 );\r\n\t\tgeometryGroup.__lineArray = new UintArray( nlines * 2 );\r\n\r\n\t\tvar numMorphTargets = geometryGroup.numMorphTargets;\r\n\r\n\t\tif ( numMorphTargets ) {\r\n\r\n\t\t\tgeometryGroup.__morphTargetsArrays = [];\r\n\r\n\t\t\tfor ( var m = 0, ml = numMorphTargets; m < ml; m ++ ) {\r\n\r\n\t\t\t\tgeometryGroup.__morphTargetsArrays.push( new Float32Array( nvertices * 3 ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tvar numMorphNormals = geometryGroup.numMorphNormals;\r\n\r\n\t\tif ( numMorphNormals ) {\r\n\r\n\t\t\tgeometryGroup.__morphNormalsArrays = [];\r\n\r\n\t\t\tfor ( var m = 0, ml = numMorphNormals; m < ml; m ++ ) {\r\n\r\n\t\t\t\tgeometryGroup.__morphNormalsArrays.push( new Float32Array( nvertices * 3 ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tgeometryGroup.__webglFaceCount = ntris * 3;\r\n\t\tgeometryGroup.__webglLineCount = nlines * 2;\r\n\r\n\r\n\t\t// custom attributes\r\n\r\n\t\tif ( material.attributes ) {\r\n\r\n\t\t\tif ( geometryGroup.__webglCustomAttributesList === undefined ) {\r\n\r\n\t\t\t\tgeometryGroup.__webglCustomAttributesList = [];\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfor ( var name in material.attributes ) {\r\n\r\n\t\t\t\t// Do a shallow copy of the attribute object so different geometryGroup chunks use different\r\n\t\t\t\t// attribute buffers which are correctly indexed in the setMeshBuffers function\r\n\r\n\t\t\t\tvar originalAttribute = material.attributes[ name ];\r\n\r\n\t\t\t\tvar attribute = {};\r\n\r\n\t\t\t\tfor ( var property in originalAttribute ) {\r\n\r\n\t\t\t\t\tattribute[ property ] = originalAttribute[ property ];\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( ! attribute.__webglInitialized || attribute.createUniqueBuffers ) {\r\n\r\n\t\t\t\t\tattribute.__webglInitialized = true;\r\n\r\n\t\t\t\t\tvar size = 1;   // \"f\" and \"i\"\r\n\r\n\t\t\t\t\tif ( attribute.type === 'v2' ) size = 2;\r\n\t\t\t\t\telse if ( attribute.type === 'v3' ) size = 3;\r\n\t\t\t\t\telse if ( attribute.type === 'v4' ) size = 4;\r\n\t\t\t\t\telse if ( attribute.type === 'c'  ) size = 3;\r\n\r\n\t\t\t\t\tattribute.size = size;\r\n\r\n\t\t\t\t\tattribute.array = new Float32Array( nvertices * size );\r\n\r\n\t\t\t\t\tattribute.buffer = _gl.createBuffer();\r\n\t\t\t\t\tattribute.buffer.belongsToAttribute = name;\r\n\r\n\t\t\t\t\toriginalAttribute.needsUpdate = true;\r\n\t\t\t\t\tattribute.__original = originalAttribute;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tgeometryGroup.__webglCustomAttributesList.push( attribute );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tgeometryGroup.__inittedArrays = true;\r\n\r\n\t};\r\n\r\n\tfunction getBufferMaterial( object, geometryGroup ) {\r\n\r\n\t\treturn object.material instanceof THREE.MeshFaceMaterial\r\n\t\t\t ? object.material.materials[ geometryGroup.materialIndex ]\r\n\t\t\t : object.material;\r\n\r\n\t}\r\n\r\n\tfunction materialNeedsFaceNormals ( material ) {\r\n\r\n\t\treturn material instanceof THREE.MeshPhongMaterial === false && material.shading === THREE.FlatShading;\r\n\r\n\t}\r\n\r\n\t// Buffer setting\r\n\r\n\tfunction setParticleBuffers ( geometry, hint, object ) {\r\n\r\n\t\tvar v, c, vertex, offset, color,\r\n\r\n\t\tvertices = geometry.vertices,\r\n\t\tvl = vertices.length,\r\n\r\n\t\tcolors = geometry.colors,\r\n\t\tcl = colors.length,\r\n\r\n\t\tvertexArray = geometry.__vertexArray,\r\n\t\tcolorArray = geometry.__colorArray,\r\n\r\n\t\tdirtyVertices = geometry.verticesNeedUpdate,\r\n\t\tdirtyColors = geometry.colorsNeedUpdate,\r\n\r\n\t\tcustomAttributes = geometry.__webglCustomAttributesList,\r\n\t\ti, il,\r\n\t\tca, cal, value,\r\n\t\tcustomAttribute;\r\n\r\n\t\tif ( dirtyVertices ) {\r\n\r\n\t\t\tfor ( v = 0; v < vl; v ++ ) {\r\n\r\n\t\t\t\tvertex = vertices[ v ];\r\n\r\n\t\t\t\toffset = v * 3;\r\n\r\n\t\t\t\tvertexArray[ offset ]     = vertex.x;\r\n\t\t\t\tvertexArray[ offset + 1 ] = vertex.y;\r\n\t\t\t\tvertexArray[ offset + 2 ] = vertex.z;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometry.__webglVertexBuffer );\r\n\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, vertexArray, hint );\r\n\r\n\t\t}\r\n\r\n\t\tif ( dirtyColors ) {\r\n\r\n\t\t\tfor ( c = 0; c < cl; c ++ ) {\r\n\r\n\t\t\t\tcolor = colors[ c ];\r\n\r\n\t\t\t\toffset = c * 3;\r\n\r\n\t\t\t\tcolorArray[ offset ]     = color.r;\r\n\t\t\t\tcolorArray[ offset + 1 ] = color.g;\r\n\t\t\t\tcolorArray[ offset + 2 ] = color.b;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometry.__webglColorBuffer );\r\n\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, colorArray, hint );\r\n\r\n\t\t}\r\n\r\n\t\tif ( customAttributes ) {\r\n\r\n\t\t\tfor ( i = 0, il = customAttributes.length; i < il; i ++ ) {\r\n\r\n\t\t\t\tcustomAttribute = customAttributes[ i ];\r\n\r\n\t\t\t\tif ( customAttribute.needsUpdate && ( customAttribute.boundTo === undefined ||  customAttribute.boundTo === 'vertices' ) ) {\r\n\r\n\t\t\t\t\tcal = customAttribute.value.length;\r\n\r\n\t\t\t\t\toffset = 0;\r\n\r\n\t\t\t\t\tif ( customAttribute.size === 1 ) {\r\n\r\n\t\t\t\t\t\tfor ( ca = 0; ca < cal; ca ++ ) {\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ ca ] = customAttribute.value[ ca ];\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t} else if ( customAttribute.size === 2 ) {\r\n\r\n\t\t\t\t\t\tfor ( ca = 0; ca < cal; ca ++ ) {\r\n\r\n\t\t\t\t\t\t\tvalue = customAttribute.value[ ca ];\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset ]   = value.x;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset + 1 ] = value.y;\r\n\r\n\t\t\t\t\t\t\toffset += 2;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t} else if ( customAttribute.size === 3 ) {\r\n\r\n\t\t\t\t\t\tif ( customAttribute.type === 'c' ) {\r\n\r\n\t\t\t\t\t\t\tfor ( ca = 0; ca < cal; ca ++ ) {\r\n\r\n\t\t\t\t\t\t\t\tvalue = customAttribute.value[ ca ];\r\n\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset ]   = value.r;\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset + 1 ] = value.g;\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset + 2 ] = value.b;\r\n\r\n\t\t\t\t\t\t\t\toffset += 3;\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\tfor ( ca = 0; ca < cal; ca ++ ) {\r\n\r\n\t\t\t\t\t\t\t\tvalue = customAttribute.value[ ca ];\r\n\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset ]   = value.x;\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset + 1 ] = value.y;\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset + 2 ] = value.z;\r\n\r\n\t\t\t\t\t\t\t\toffset += 3;\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t} else if ( customAttribute.size === 4 ) {\r\n\r\n\t\t\t\t\t\tfor ( ca = 0; ca < cal; ca ++ ) {\r\n\r\n\t\t\t\t\t\t\tvalue = customAttribute.value[ ca ];\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset ]      = value.x;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset + 1  ] = value.y;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset + 2  ] = value.z;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset + 3  ] = value.w;\r\n\r\n\t\t\t\t\t\t\toffset += 4;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, customAttribute.buffer );\r\n\t\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, customAttribute.array, hint );\r\n\r\n\t\t\t\tcustomAttribute.needsUpdate = false;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction setLineBuffers ( geometry, hint ) {\r\n\r\n\t\tvar v, c, d, vertex, offset, color,\r\n\r\n\t\tvertices = geometry.vertices,\r\n\t\tcolors = geometry.colors,\r\n\t\tlineDistances = geometry.lineDistances,\r\n\r\n\t\tvl = vertices.length,\r\n\t\tcl = colors.length,\r\n\t\tdl = lineDistances.length,\r\n\r\n\t\tvertexArray = geometry.__vertexArray,\r\n\t\tcolorArray = geometry.__colorArray,\r\n\t\tlineDistanceArray = geometry.__lineDistanceArray,\r\n\r\n\t\tdirtyVertices = geometry.verticesNeedUpdate,\r\n\t\tdirtyColors = geometry.colorsNeedUpdate,\r\n\t\tdirtyLineDistances = geometry.lineDistancesNeedUpdate,\r\n\r\n\t\tcustomAttributes = geometry.__webglCustomAttributesList,\r\n\r\n\t\ti, il,\r\n\t\tca, cal, value,\r\n\t\tcustomAttribute;\r\n\r\n\t\tif ( dirtyVertices ) {\r\n\r\n\t\t\tfor ( v = 0; v < vl; v ++ ) {\r\n\r\n\t\t\t\tvertex = vertices[ v ];\r\n\r\n\t\t\t\toffset = v * 3;\r\n\r\n\t\t\t\tvertexArray[ offset ]     = vertex.x;\r\n\t\t\t\tvertexArray[ offset + 1 ] = vertex.y;\r\n\t\t\t\tvertexArray[ offset + 2 ] = vertex.z;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometry.__webglVertexBuffer );\r\n\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, vertexArray, hint );\r\n\r\n\t\t}\r\n\r\n\t\tif ( dirtyColors ) {\r\n\r\n\t\t\tfor ( c = 0; c < cl; c ++ ) {\r\n\r\n\t\t\t\tcolor = colors[ c ];\r\n\r\n\t\t\t\toffset = c * 3;\r\n\r\n\t\t\t\tcolorArray[ offset ]     = color.r;\r\n\t\t\t\tcolorArray[ offset + 1 ] = color.g;\r\n\t\t\t\tcolorArray[ offset + 2 ] = color.b;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometry.__webglColorBuffer );\r\n\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, colorArray, hint );\r\n\r\n\t\t}\r\n\r\n\t\tif ( dirtyLineDistances ) {\r\n\r\n\t\t\tfor ( d = 0; d < dl; d ++ ) {\r\n\r\n\t\t\t\tlineDistanceArray[ d ] = lineDistances[ d ];\r\n\r\n\t\t\t}\r\n\r\n\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometry.__webglLineDistanceBuffer );\r\n\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, lineDistanceArray, hint );\r\n\r\n\t\t}\r\n\r\n\t\tif ( customAttributes ) {\r\n\r\n\t\t\tfor ( i = 0, il = customAttributes.length; i < il; i ++ ) {\r\n\r\n\t\t\t\tcustomAttribute = customAttributes[ i ];\r\n\r\n\t\t\t\tif ( customAttribute.needsUpdate && ( customAttribute.boundTo === undefined || customAttribute.boundTo === 'vertices' ) ) {\r\n\r\n\t\t\t\t\toffset = 0;\r\n\r\n\t\t\t\t\tcal = customAttribute.value.length;\r\n\r\n\t\t\t\t\tif ( customAttribute.size === 1 ) {\r\n\r\n\t\t\t\t\t\tfor ( ca = 0; ca < cal; ca ++ ) {\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ ca ] = customAttribute.value[ ca ];\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t} else if ( customAttribute.size === 2 ) {\r\n\r\n\t\t\t\t\t\tfor ( ca = 0; ca < cal; ca ++ ) {\r\n\r\n\t\t\t\t\t\t\tvalue = customAttribute.value[ ca ];\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset ]   = value.x;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset + 1 ] = value.y;\r\n\r\n\t\t\t\t\t\t\toffset += 2;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t} else if ( customAttribute.size === 3 ) {\r\n\r\n\t\t\t\t\t\tif ( customAttribute.type === 'c' ) {\r\n\r\n\t\t\t\t\t\t\tfor ( ca = 0; ca < cal; ca ++ ) {\r\n\r\n\t\t\t\t\t\t\t\tvalue = customAttribute.value[ ca ];\r\n\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset ]   = value.r;\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset + 1 ] = value.g;\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset + 2 ] = value.b;\r\n\r\n\t\t\t\t\t\t\t\toffset += 3;\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\tfor ( ca = 0; ca < cal; ca ++ ) {\r\n\r\n\t\t\t\t\t\t\t\tvalue = customAttribute.value[ ca ];\r\n\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset ]   = value.x;\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset + 1 ] = value.y;\r\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset + 2 ] = value.z;\r\n\r\n\t\t\t\t\t\t\t\toffset += 3;\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t} else if ( customAttribute.size === 4 ) {\r\n\r\n\t\t\t\t\t\tfor ( ca = 0; ca < cal; ca ++ ) {\r\n\r\n\t\t\t\t\t\t\tvalue = customAttribute.value[ ca ];\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset ]    = value.x;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset + 1  ] = value.y;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset + 2  ] = value.z;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset + 3  ] = value.w;\r\n\r\n\t\t\t\t\t\t\toffset += 4;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, customAttribute.buffer );\r\n\t\t\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, customAttribute.array, hint );\r\n\r\n\t\t\t\t\tcustomAttribute.needsUpdate = false;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction setMeshBuffers( geometryGroup, object, hint, dispose, material ) {\r\n\r\n\t\tif ( ! geometryGroup.__inittedArrays ) {\r\n\r\n\t\t\treturn;\r\n\r\n\t\t}\r\n\r\n\t\tvar needsFaceNormals = materialNeedsFaceNormals( material );\r\n\r\n\t\tvar f, fl, fi, face,\r\n\t\tvertexNormals, faceNormal,\r\n\t\tvertexColors, faceColor,\r\n\t\tvertexTangents,\r\n\t\tuv, uv2, v1, v2, v3, t1, t2, t3, n1, n2, n3,\r\n\t\tc1, c2, c3,\r\n\t\tsw1, sw2, sw3,\r\n\t\tsi1, si2, si3,\r\n\t\ti, il,\r\n\t\tvn, uvi, uv2i,\r\n\t\tvk, vkl, vka,\r\n\t\tnka, chf, faceVertexNormals,\r\n\r\n\t\tvertexIndex = 0,\r\n\r\n\t\toffset = 0,\r\n\t\toffset_uv = 0,\r\n\t\toffset_uv2 = 0,\r\n\t\toffset_face = 0,\r\n\t\toffset_normal = 0,\r\n\t\toffset_tangent = 0,\r\n\t\toffset_line = 0,\r\n\t\toffset_color = 0,\r\n\t\toffset_skin = 0,\r\n\t\toffset_morphTarget = 0,\r\n\t\toffset_custom = 0,\r\n\r\n\t\tvalue,\r\n\r\n\t\tvertexArray = geometryGroup.__vertexArray,\r\n\t\tuvArray = geometryGroup.__uvArray,\r\n\t\tuv2Array = geometryGroup.__uv2Array,\r\n\t\tnormalArray = geometryGroup.__normalArray,\r\n\t\ttangentArray = geometryGroup.__tangentArray,\r\n\t\tcolorArray = geometryGroup.__colorArray,\r\n\r\n\t\tskinIndexArray = geometryGroup.__skinIndexArray,\r\n\t\tskinWeightArray = geometryGroup.__skinWeightArray,\r\n\r\n\t\tmorphTargetsArrays = geometryGroup.__morphTargetsArrays,\r\n\t\tmorphNormalsArrays = geometryGroup.__morphNormalsArrays,\r\n\r\n\t\tcustomAttributes = geometryGroup.__webglCustomAttributesList,\r\n\t\tcustomAttribute,\r\n\r\n\t\tfaceArray = geometryGroup.__faceArray,\r\n\t\tlineArray = geometryGroup.__lineArray,\r\n\r\n\t\tgeometry = object.geometry, // this is shared for all chunks\r\n\r\n\t\tdirtyVertices = geometry.verticesNeedUpdate,\r\n\t\tdirtyElements = geometry.elementsNeedUpdate,\r\n\t\tdirtyUvs = geometry.uvsNeedUpdate,\r\n\t\tdirtyNormals = geometry.normalsNeedUpdate,\r\n\t\tdirtyTangents = geometry.tangentsNeedUpdate,\r\n\t\tdirtyColors = geometry.colorsNeedUpdate,\r\n\t\tdirtyMorphTargets = geometry.morphTargetsNeedUpdate,\r\n\r\n\t\tvertices = geometry.vertices,\r\n\t\tchunk_faces3 = geometryGroup.faces3,\r\n\t\tobj_faces = geometry.faces,\r\n\r\n\t\tobj_uvs  = geometry.faceVertexUvs[ 0 ],\r\n\t\tobj_uvs2 = geometry.faceVertexUvs[ 1 ],\r\n\r\n\t\tobj_skinIndices = geometry.skinIndices,\r\n\t\tobj_skinWeights = geometry.skinWeights,\r\n\r\n\t\tmorphTargets = geometry.morphTargets,\r\n\t\tmorphNormals = geometry.morphNormals;\r\n\r\n\t\tif ( dirtyVertices ) {\r\n\r\n\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\r\n\r\n\t\t\t\tface = obj_faces[ chunk_faces3[ f ] ];\r\n\r\n\t\t\t\tv1 = vertices[ face.a ];\r\n\t\t\t\tv2 = vertices[ face.b ];\r\n\t\t\t\tv3 = vertices[ face.c ];\r\n\r\n\t\t\t\tvertexArray[ offset ]     = v1.x;\r\n\t\t\t\tvertexArray[ offset + 1 ] = v1.y;\r\n\t\t\t\tvertexArray[ offset + 2 ] = v1.z;\r\n\r\n\t\t\t\tvertexArray[ offset + 3 ] = v2.x;\r\n\t\t\t\tvertexArray[ offset + 4 ] = v2.y;\r\n\t\t\t\tvertexArray[ offset + 5 ] = v2.z;\r\n\r\n\t\t\t\tvertexArray[ offset + 6 ] = v3.x;\r\n\t\t\t\tvertexArray[ offset + 7 ] = v3.y;\r\n\t\t\t\tvertexArray[ offset + 8 ] = v3.z;\r\n\r\n\t\t\t\toffset += 9;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglVertexBuffer );\r\n\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, vertexArray, hint );\r\n\r\n\t\t}\r\n\r\n\t\tif ( dirtyMorphTargets ) {\r\n\r\n\t\t\tfor ( vk = 0, vkl = morphTargets.length; vk < vkl; vk ++ ) {\r\n\r\n\t\t\t\toffset_morphTarget = 0;\r\n\r\n\t\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\r\n\r\n\t\t\t\t\tchf = chunk_faces3[ f ];\r\n\t\t\t\t\tface = obj_faces[ chf ];\r\n\r\n\t\t\t\t\t// morph positions\r\n\r\n\t\t\t\t\tv1 = morphTargets[ vk ].vertices[ face.a ];\r\n\t\t\t\t\tv2 = morphTargets[ vk ].vertices[ face.b ];\r\n\t\t\t\t\tv3 = morphTargets[ vk ].vertices[ face.c ];\r\n\r\n\t\t\t\t\tvka = morphTargetsArrays[ vk ];\r\n\r\n\t\t\t\t\tvka[ offset_morphTarget ]     = v1.x;\r\n\t\t\t\t\tvka[ offset_morphTarget + 1 ] = v1.y;\r\n\t\t\t\t\tvka[ offset_morphTarget + 2 ] = v1.z;\r\n\r\n\t\t\t\t\tvka[ offset_morphTarget + 3 ] = v2.x;\r\n\t\t\t\t\tvka[ offset_morphTarget + 4 ] = v2.y;\r\n\t\t\t\t\tvka[ offset_morphTarget + 5 ] = v2.z;\r\n\r\n\t\t\t\t\tvka[ offset_morphTarget + 6 ] = v3.x;\r\n\t\t\t\t\tvka[ offset_morphTarget + 7 ] = v3.y;\r\n\t\t\t\t\tvka[ offset_morphTarget + 8 ] = v3.z;\r\n\r\n\t\t\t\t\t// morph normals\r\n\r\n\t\t\t\t\tif ( material.morphNormals ) {\r\n\r\n\t\t\t\t\t\tif ( needsFaceNormals ) {\r\n\r\n\t\t\t\t\t\t\tn1 = morphNormals[ vk ].faceNormals[ chf ];\r\n\t\t\t\t\t\t\tn2 = n1;\r\n\t\t\t\t\t\t\tn3 = n1;\r\n\r\n\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\tfaceVertexNormals = morphNormals[ vk ].vertexNormals[ chf ];\r\n\r\n\t\t\t\t\t\t\tn1 = faceVertexNormals.a;\r\n\t\t\t\t\t\t\tn2 = faceVertexNormals.b;\r\n\t\t\t\t\t\t\tn3 = faceVertexNormals.c;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tnka = morphNormalsArrays[ vk ];\r\n\r\n\t\t\t\t\t\tnka[ offset_morphTarget ]     = n1.x;\r\n\t\t\t\t\t\tnka[ offset_morphTarget + 1 ] = n1.y;\r\n\t\t\t\t\t\tnka[ offset_morphTarget + 2 ] = n1.z;\r\n\r\n\t\t\t\t\t\tnka[ offset_morphTarget + 3 ] = n2.x;\r\n\t\t\t\t\t\tnka[ offset_morphTarget + 4 ] = n2.y;\r\n\t\t\t\t\t\tnka[ offset_morphTarget + 5 ] = n2.z;\r\n\r\n\t\t\t\t\t\tnka[ offset_morphTarget + 6 ] = n3.x;\r\n\t\t\t\t\t\tnka[ offset_morphTarget + 7 ] = n3.y;\r\n\t\t\t\t\t\tnka[ offset_morphTarget + 8 ] = n3.z;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t//\r\n\r\n\t\t\t\t\toffset_morphTarget += 9;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglMorphTargetsBuffers[ vk ] );\r\n\t\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, morphTargetsArrays[ vk ], hint );\r\n\r\n\t\t\t\tif ( material.morphNormals ) {\r\n\r\n\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglMorphNormalsBuffers[ vk ] );\r\n\t\t\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, morphNormalsArrays[ vk ], hint );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( obj_skinWeights.length ) {\r\n\r\n\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\r\n\r\n\t\t\t\tface = obj_faces[ chunk_faces3[ f ] ];\r\n\r\n\t\t\t\t// weights\r\n\r\n\t\t\t\tsw1 = obj_skinWeights[ face.a ];\r\n\t\t\t\tsw2 = obj_skinWeights[ face.b ];\r\n\t\t\t\tsw3 = obj_skinWeights[ face.c ];\r\n\r\n\t\t\t\tskinWeightArray[ offset_skin ]     = sw1.x;\r\n\t\t\t\tskinWeightArray[ offset_skin + 1 ] = sw1.y;\r\n\t\t\t\tskinWeightArray[ offset_skin + 2 ] = sw1.z;\r\n\t\t\t\tskinWeightArray[ offset_skin + 3 ] = sw1.w;\r\n\r\n\t\t\t\tskinWeightArray[ offset_skin + 4 ] = sw2.x;\r\n\t\t\t\tskinWeightArray[ offset_skin + 5 ] = sw2.y;\r\n\t\t\t\tskinWeightArray[ offset_skin + 6 ] = sw2.z;\r\n\t\t\t\tskinWeightArray[ offset_skin + 7 ] = sw2.w;\r\n\r\n\t\t\t\tskinWeightArray[ offset_skin + 8 ]  = sw3.x;\r\n\t\t\t\tskinWeightArray[ offset_skin + 9 ]  = sw3.y;\r\n\t\t\t\tskinWeightArray[ offset_skin + 10 ] = sw3.z;\r\n\t\t\t\tskinWeightArray[ offset_skin + 11 ] = sw3.w;\r\n\r\n\t\t\t\t// indices\r\n\r\n\t\t\t\tsi1 = obj_skinIndices[ face.a ];\r\n\t\t\t\tsi2 = obj_skinIndices[ face.b ];\r\n\t\t\t\tsi3 = obj_skinIndices[ face.c ];\r\n\r\n\t\t\t\tskinIndexArray[ offset_skin ]     = si1.x;\r\n\t\t\t\tskinIndexArray[ offset_skin + 1 ] = si1.y;\r\n\t\t\t\tskinIndexArray[ offset_skin + 2 ] = si1.z;\r\n\t\t\t\tskinIndexArray[ offset_skin + 3 ] = si1.w;\r\n\r\n\t\t\t\tskinIndexArray[ offset_skin + 4 ] = si2.x;\r\n\t\t\t\tskinIndexArray[ offset_skin + 5 ] = si2.y;\r\n\t\t\t\tskinIndexArray[ offset_skin + 6 ] = si2.z;\r\n\t\t\t\tskinIndexArray[ offset_skin + 7 ] = si2.w;\r\n\r\n\t\t\t\tskinIndexArray[ offset_skin + 8 ]  = si3.x;\r\n\t\t\t\tskinIndexArray[ offset_skin + 9 ]  = si3.y;\r\n\t\t\t\tskinIndexArray[ offset_skin + 10 ] = si3.z;\r\n\t\t\t\tskinIndexArray[ offset_skin + 11 ] = si3.w;\r\n\r\n\t\t\t\toffset_skin += 12;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( offset_skin > 0 ) {\r\n\r\n\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglSkinIndicesBuffer );\r\n\t\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, skinIndexArray, hint );\r\n\r\n\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglSkinWeightsBuffer );\r\n\t\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, skinWeightArray, hint );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( dirtyColors ) {\r\n\r\n\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\r\n\r\n\t\t\t\tface = obj_faces[ chunk_faces3[ f ] ];\r\n\r\n\t\t\t\tvertexColors = face.vertexColors;\r\n\t\t\t\tfaceColor = face.color;\r\n\r\n\t\t\t\tif ( vertexColors.length === 3 && material.vertexColors === THREE.VertexColors ) {\r\n\r\n\t\t\t\t\tc1 = vertexColors[ 0 ];\r\n\t\t\t\t\tc2 = vertexColors[ 1 ];\r\n\t\t\t\t\tc3 = vertexColors[ 2 ];\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tc1 = faceColor;\r\n\t\t\t\t\tc2 = faceColor;\r\n\t\t\t\t\tc3 = faceColor;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tcolorArray[ offset_color ]     = c1.r;\r\n\t\t\t\tcolorArray[ offset_color + 1 ] = c1.g;\r\n\t\t\t\tcolorArray[ offset_color + 2 ] = c1.b;\r\n\r\n\t\t\t\tcolorArray[ offset_color + 3 ] = c2.r;\r\n\t\t\t\tcolorArray[ offset_color + 4 ] = c2.g;\r\n\t\t\t\tcolorArray[ offset_color + 5 ] = c2.b;\r\n\r\n\t\t\t\tcolorArray[ offset_color + 6 ] = c3.r;\r\n\t\t\t\tcolorArray[ offset_color + 7 ] = c3.g;\r\n\t\t\t\tcolorArray[ offset_color + 8 ] = c3.b;\r\n\r\n\t\t\t\toffset_color += 9;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( offset_color > 0 ) {\r\n\r\n\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglColorBuffer );\r\n\t\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, colorArray, hint );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( dirtyTangents && geometry.hasTangents ) {\r\n\r\n\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\r\n\r\n\t\t\t\tface = obj_faces[ chunk_faces3[ f ] ];\r\n\r\n\t\t\t\tvertexTangents = face.vertexTangents;\r\n\r\n\t\t\t\tt1 = vertexTangents[ 0 ];\r\n\t\t\t\tt2 = vertexTangents[ 1 ];\r\n\t\t\t\tt3 = vertexTangents[ 2 ];\r\n\r\n\t\t\t\ttangentArray[ offset_tangent ]     = t1.x;\r\n\t\t\t\ttangentArray[ offset_tangent + 1 ] = t1.y;\r\n\t\t\t\ttangentArray[ offset_tangent + 2 ] = t1.z;\r\n\t\t\t\ttangentArray[ offset_tangent + 3 ] = t1.w;\r\n\r\n\t\t\t\ttangentArray[ offset_tangent + 4 ] = t2.x;\r\n\t\t\t\ttangentArray[ offset_tangent + 5 ] = t2.y;\r\n\t\t\t\ttangentArray[ offset_tangent + 6 ] = t2.z;\r\n\t\t\t\ttangentArray[ offset_tangent + 7 ] = t2.w;\r\n\r\n\t\t\t\ttangentArray[ offset_tangent + 8 ]  = t3.x;\r\n\t\t\t\ttangentArray[ offset_tangent + 9 ]  = t3.y;\r\n\t\t\t\ttangentArray[ offset_tangent + 10 ] = t3.z;\r\n\t\t\t\ttangentArray[ offset_tangent + 11 ] = t3.w;\r\n\r\n\t\t\t\toffset_tangent += 12;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglTangentBuffer );\r\n\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, tangentArray, hint );\r\n\r\n\t\t}\r\n\r\n\t\tif ( dirtyNormals ) {\r\n\r\n\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\r\n\r\n\t\t\t\tface = obj_faces[ chunk_faces3[ f ] ];\r\n\r\n\t\t\t\tvertexNormals = face.vertexNormals;\r\n\t\t\t\tfaceNormal = face.normal;\r\n\r\n\t\t\t\tif ( vertexNormals.length === 3 && needsFaceNormals === false ) {\r\n\r\n\t\t\t\t\tfor ( i = 0; i < 3; i ++ ) {\r\n\r\n\t\t\t\t\t\tvn = vertexNormals[ i ];\r\n\r\n\t\t\t\t\t\tnormalArray[ offset_normal ]     = vn.x;\r\n\t\t\t\t\t\tnormalArray[ offset_normal + 1 ] = vn.y;\r\n\t\t\t\t\t\tnormalArray[ offset_normal + 2 ] = vn.z;\r\n\r\n\t\t\t\t\t\toffset_normal += 3;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tfor ( i = 0; i < 3; i ++ ) {\r\n\r\n\t\t\t\t\t\tnormalArray[ offset_normal ]     = faceNormal.x;\r\n\t\t\t\t\t\tnormalArray[ offset_normal + 1 ] = faceNormal.y;\r\n\t\t\t\t\t\tnormalArray[ offset_normal + 2 ] = faceNormal.z;\r\n\r\n\t\t\t\t\t\toffset_normal += 3;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglNormalBuffer );\r\n\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, normalArray, hint );\r\n\r\n\t\t}\r\n\r\n\t\tif ( dirtyUvs && obj_uvs ) {\r\n\r\n\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\r\n\r\n\t\t\t\tfi = chunk_faces3[ f ];\r\n\r\n\t\t\t\tuv = obj_uvs[ fi ];\r\n\r\n\t\t\t\tif ( uv === undefined ) continue;\r\n\r\n\t\t\t\tfor ( i = 0; i < 3; i ++ ) {\r\n\r\n\t\t\t\t\tuvi = uv[ i ];\r\n\r\n\t\t\t\t\tuvArray[ offset_uv ]     = uvi.x;\r\n\t\t\t\t\tuvArray[ offset_uv + 1 ] = uvi.y;\r\n\r\n\t\t\t\t\toffset_uv += 2;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( offset_uv > 0 ) {\r\n\r\n\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglUVBuffer );\r\n\t\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, uvArray, hint );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( dirtyUvs && obj_uvs2 ) {\r\n\r\n\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\r\n\r\n\t\t\t\tfi = chunk_faces3[ f ];\r\n\r\n\t\t\t\tuv2 = obj_uvs2[ fi ];\r\n\r\n\t\t\t\tif ( uv2 === undefined ) continue;\r\n\r\n\t\t\t\tfor ( i = 0; i < 3; i ++ ) {\r\n\r\n\t\t\t\t\tuv2i = uv2[ i ];\r\n\r\n\t\t\t\t\tuv2Array[ offset_uv2 ]     = uv2i.x;\r\n\t\t\t\t\tuv2Array[ offset_uv2 + 1 ] = uv2i.y;\r\n\r\n\t\t\t\t\toffset_uv2 += 2;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( offset_uv2 > 0 ) {\r\n\r\n\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglUV2Buffer );\r\n\t\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, uv2Array, hint );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( dirtyElements ) {\r\n\r\n\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\r\n\r\n\t\t\t\tfaceArray[ offset_face ]   = vertexIndex;\r\n\t\t\t\tfaceArray[ offset_face + 1 ] = vertexIndex + 1;\r\n\t\t\t\tfaceArray[ offset_face + 2 ] = vertexIndex + 2;\r\n\r\n\t\t\t\toffset_face += 3;\r\n\r\n\t\t\t\tlineArray[ offset_line ]     = vertexIndex;\r\n\t\t\t\tlineArray[ offset_line + 1 ] = vertexIndex + 1;\r\n\r\n\t\t\t\tlineArray[ offset_line + 2 ] = vertexIndex;\r\n\t\t\t\tlineArray[ offset_line + 3 ] = vertexIndex + 2;\r\n\r\n\t\t\t\tlineArray[ offset_line + 4 ] = vertexIndex + 1;\r\n\t\t\t\tlineArray[ offset_line + 5 ] = vertexIndex + 2;\r\n\r\n\t\t\t\toffset_line += 6;\r\n\r\n\t\t\t\tvertexIndex += 3;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, geometryGroup.__webglFaceBuffer );\r\n\t\t\t_gl.bufferData( _gl.ELEMENT_ARRAY_BUFFER, faceArray, hint );\r\n\r\n\t\t\t_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, geometryGroup.__webglLineBuffer );\r\n\t\t\t_gl.bufferData( _gl.ELEMENT_ARRAY_BUFFER, lineArray, hint );\r\n\r\n\t\t}\r\n\r\n\t\tif ( customAttributes ) {\r\n\r\n\t\t\tfor ( i = 0, il = customAttributes.length; i < il; i ++ ) {\r\n\r\n\t\t\t\tcustomAttribute = customAttributes[ i ];\r\n\r\n\t\t\t\tif ( ! customAttribute.__original.needsUpdate ) continue;\r\n\r\n\t\t\t\toffset_custom = 0;\r\n\r\n\t\t\t\tif ( customAttribute.size === 1 ) {\r\n\r\n\t\t\t\t\tif ( customAttribute.boundTo === undefined || customAttribute.boundTo === 'vertices' ) {\r\n\r\n\t\t\t\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\r\n\r\n\t\t\t\t\t\t\tface = obj_faces[ chunk_faces3[ f ] ];\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom ]     = customAttribute.value[ face.a ];\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 1 ] = customAttribute.value[ face.b ];\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 2 ] = customAttribute.value[ face.c ];\r\n\r\n\t\t\t\t\t\t\toffset_custom += 3;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t} else if ( customAttribute.boundTo === 'faces' ) {\r\n\r\n\t\t\t\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\r\n\r\n\t\t\t\t\t\t\tvalue = customAttribute.value[ chunk_faces3[ f ] ];\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom ]     = value;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 1 ] = value;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 2 ] = value;\r\n\r\n\t\t\t\t\t\t\toffset_custom += 3;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} else if ( customAttribute.size === 2 ) {\r\n\r\n\t\t\t\t\tif ( customAttribute.boundTo === undefined || customAttribute.boundTo === 'vertices' ) {\r\n\r\n\t\t\t\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\r\n\r\n\t\t\t\t\t\t\tface = obj_faces[ chunk_faces3[ f ] ];\r\n\r\n\t\t\t\t\t\t\tv1 = customAttribute.value[ face.a ];\r\n\t\t\t\t\t\t\tv2 = customAttribute.value[ face.b ];\r\n\t\t\t\t\t\t\tv3 = customAttribute.value[ face.c ];\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom ]     = v1.x;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 1 ] = v1.y;\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 2 ] = v2.x;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 3 ] = v2.y;\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 4 ] = v3.x;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 5 ] = v3.y;\r\n\r\n\t\t\t\t\t\t\toffset_custom += 6;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t} else if ( customAttribute.boundTo === 'faces' ) {\r\n\r\n\t\t\t\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\r\n\r\n\t\t\t\t\t\t\tvalue = customAttribute.value[ chunk_faces3[ f ] ];\r\n\r\n\t\t\t\t\t\t\tv1 = value;\r\n\t\t\t\t\t\t\tv2 = value;\r\n\t\t\t\t\t\t\tv3 = value;\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom ]     = v1.x;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 1 ] = v1.y;\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 2 ] = v2.x;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 3 ] = v2.y;\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 4 ] = v3.x;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 5 ] = v3.y;\r\n\r\n\t\t\t\t\t\t\toffset_custom += 6;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} else if ( customAttribute.size === 3 ) {\r\n\r\n\t\t\t\t\tvar pp;\r\n\r\n\t\t\t\t\tif ( customAttribute.type === 'c' ) {\r\n\r\n\t\t\t\t\t\tpp = [ 'r', 'g', 'b' ];\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tpp = [ 'x', 'y', 'z' ];\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif ( customAttribute.boundTo === undefined || customAttribute.boundTo === 'vertices' ) {\r\n\r\n\t\t\t\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\r\n\r\n\t\t\t\t\t\t\tface = obj_faces[ chunk_faces3[ f ] ];\r\n\r\n\t\t\t\t\t\t\tv1 = customAttribute.value[ face.a ];\r\n\t\t\t\t\t\t\tv2 = customAttribute.value[ face.b ];\r\n\t\t\t\t\t\t\tv3 = customAttribute.value[ face.c ];\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom ]     = v1[ pp[ 0 ] ];\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 1 ] = v1[ pp[ 1 ] ];\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 2 ] = v1[ pp[ 2 ] ];\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 3 ] = v2[ pp[ 0 ] ];\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 4 ] = v2[ pp[ 1 ] ];\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 5 ] = v2[ pp[ 2 ] ];\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 6 ] = v3[ pp[ 0 ] ];\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 7 ] = v3[ pp[ 1 ] ];\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 8 ] = v3[ pp[ 2 ] ];\r\n\r\n\t\t\t\t\t\t\toffset_custom += 9;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t} else if ( customAttribute.boundTo === 'faces' ) {\r\n\r\n\t\t\t\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\r\n\r\n\t\t\t\t\t\t\tvalue = customAttribute.value[ chunk_faces3[ f ] ];\r\n\r\n\t\t\t\t\t\t\tv1 = value;\r\n\t\t\t\t\t\t\tv2 = value;\r\n\t\t\t\t\t\t\tv3 = value;\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom ]     = v1[ pp[ 0 ] ];\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 1 ] = v1[ pp[ 1 ] ];\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 2 ] = v1[ pp[ 2 ] ];\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 3 ] = v2[ pp[ 0 ] ];\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 4 ] = v2[ pp[ 1 ] ];\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 5 ] = v2[ pp[ 2 ] ];\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 6 ] = v3[ pp[ 0 ] ];\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 7 ] = v3[ pp[ 1 ] ];\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 8 ] = v3[ pp[ 2 ] ];\r\n\r\n\t\t\t\t\t\t\toffset_custom += 9;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t} else if ( customAttribute.boundTo === 'faceVertices' ) {\r\n\r\n\t\t\t\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\r\n\r\n\t\t\t\t\t\t\tvalue = customAttribute.value[ chunk_faces3[ f ] ];\r\n\r\n\t\t\t\t\t\t\tv1 = value[ 0 ];\r\n\t\t\t\t\t\t\tv2 = value[ 1 ];\r\n\t\t\t\t\t\t\tv3 = value[ 2 ];\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom ]     = v1[ pp[ 0 ] ];\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 1 ] = v1[ pp[ 1 ] ];\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 2 ] = v1[ pp[ 2 ] ];\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 3 ] = v2[ pp[ 0 ] ];\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 4 ] = v2[ pp[ 1 ] ];\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 5 ] = v2[ pp[ 2 ] ];\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 6 ] = v3[ pp[ 0 ] ];\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 7 ] = v3[ pp[ 1 ] ];\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 8 ] = v3[ pp[ 2 ] ];\r\n\r\n\t\t\t\t\t\t\toffset_custom += 9;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} else if ( customAttribute.size === 4 ) {\r\n\r\n\t\t\t\t\tif ( customAttribute.boundTo === undefined || customAttribute.boundTo === 'vertices' ) {\r\n\r\n\t\t\t\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\r\n\r\n\t\t\t\t\t\t\tface = obj_faces[ chunk_faces3[ f ] ];\r\n\r\n\t\t\t\t\t\t\tv1 = customAttribute.value[ face.a ];\r\n\t\t\t\t\t\t\tv2 = customAttribute.value[ face.b ];\r\n\t\t\t\t\t\t\tv3 = customAttribute.value[ face.c ];\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom  ]   = v1.x;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 1  ] = v1.y;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 2  ] = v1.z;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 3  ] = v1.w;\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 4  ] = v2.x;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 5  ] = v2.y;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 6  ] = v2.z;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 7  ] = v2.w;\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 8  ] = v3.x;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 9  ] = v3.y;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 10 ] = v3.z;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 11 ] = v3.w;\r\n\r\n\t\t\t\t\t\t\toffset_custom += 12;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t} else if ( customAttribute.boundTo === 'faces' ) {\r\n\r\n\t\t\t\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\r\n\r\n\t\t\t\t\t\t\tvalue = customAttribute.value[ chunk_faces3[ f ] ];\r\n\r\n\t\t\t\t\t\t\tv1 = value;\r\n\t\t\t\t\t\t\tv2 = value;\r\n\t\t\t\t\t\t\tv3 = value;\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom  ]   = v1.x;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 1  ] = v1.y;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 2  ] = v1.z;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 3  ] = v1.w;\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 4  ] = v2.x;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 5  ] = v2.y;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 6  ] = v2.z;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 7  ] = v2.w;\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 8  ] = v3.x;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 9  ] = v3.y;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 10 ] = v3.z;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 11 ] = v3.w;\r\n\r\n\t\t\t\t\t\t\toffset_custom += 12;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t} else if ( customAttribute.boundTo === 'faceVertices' ) {\r\n\r\n\t\t\t\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\r\n\r\n\t\t\t\t\t\t\tvalue = customAttribute.value[ chunk_faces3[ f ] ];\r\n\r\n\t\t\t\t\t\t\tv1 = value[ 0 ];\r\n\t\t\t\t\t\t\tv2 = value[ 1 ];\r\n\t\t\t\t\t\t\tv3 = value[ 2 ];\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom  ]   = v1.x;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 1  ] = v1.y;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 2  ] = v1.z;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 3  ] = v1.w;\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 4  ] = v2.x;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 5  ] = v2.y;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 6  ] = v2.z;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 7  ] = v2.w;\r\n\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 8  ] = v3.x;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 9  ] = v3.y;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 10 ] = v3.z;\r\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 11 ] = v3.w;\r\n\r\n\t\t\t\t\t\t\toffset_custom += 12;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, customAttribute.buffer );\r\n\t\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, customAttribute.array, hint );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( dispose ) {\r\n\r\n\t\t\tdelete geometryGroup.__inittedArrays;\r\n\t\t\tdelete geometryGroup.__colorArray;\r\n\t\t\tdelete geometryGroup.__normalArray;\r\n\t\t\tdelete geometryGroup.__tangentArray;\r\n\t\t\tdelete geometryGroup.__uvArray;\r\n\t\t\tdelete geometryGroup.__uv2Array;\r\n\t\t\tdelete geometryGroup.__faceArray;\r\n\t\t\tdelete geometryGroup.__vertexArray;\r\n\t\t\tdelete geometryGroup.__lineArray;\r\n\t\t\tdelete geometryGroup.__skinIndexArray;\r\n\t\t\tdelete geometryGroup.__skinWeightArray;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\t// Buffer rendering\r\n\r\n\tthis.renderBufferImmediate = function ( object, program, material ) {\r\n\r\n\t\tstate.initAttributes();\r\n\r\n\t\tif ( object.hasPositions && ! object.__webglVertexBuffer ) object.__webglVertexBuffer = _gl.createBuffer();\r\n\t\tif ( object.hasNormals && ! object.__webglNormalBuffer ) object.__webglNormalBuffer = _gl.createBuffer();\r\n\t\tif ( object.hasUvs && ! object.__webglUvBuffer ) object.__webglUvBuffer = _gl.createBuffer();\r\n\t\tif ( object.hasColors && ! object.__webglColorBuffer ) object.__webglColorBuffer = _gl.createBuffer();\r\n\r\n\t\tif ( object.hasPositions ) {\r\n\r\n\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, object.__webglVertexBuffer );\r\n\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, object.positionArray, _gl.DYNAMIC_DRAW );\r\n\r\n\t\t\tstate.enableAttribute( program.attributes.position );\r\n\r\n\t\t\t_gl.vertexAttribPointer( program.attributes.position, 3, _gl.FLOAT, false, 0, 0 );\r\n\r\n\t\t}\r\n\r\n\t\tif ( object.hasNormals ) {\r\n\r\n\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, object.__webglNormalBuffer );\r\n\r\n\t\t\tif ( material instanceof THREE.MeshPhongMaterial === false &&\r\n\t\t\t\t   material.shading === THREE.FlatShading ) {\r\n\r\n\t\t\t\tvar nx, ny, nz,\r\n\t\t\t\t\tnax, nbx, ncx, nay, nby, ncy, naz, nbz, ncz,\r\n\t\t\t\t\tnormalArray,\r\n\t\t\t\t\ti, il = object.count * 3;\r\n\r\n\t\t\t\tfor ( i = 0; i < il; i += 9 ) {\r\n\r\n\t\t\t\t\tnormalArray = object.normalArray;\r\n\r\n\t\t\t\t\tnax  = normalArray[ i ];\r\n\t\t\t\t\tnay  = normalArray[ i + 1 ];\r\n\t\t\t\t\tnaz  = normalArray[ i + 2 ];\r\n\r\n\t\t\t\t\tnbx  = normalArray[ i + 3 ];\r\n\t\t\t\t\tnby  = normalArray[ i + 4 ];\r\n\t\t\t\t\tnbz  = normalArray[ i + 5 ];\r\n\r\n\t\t\t\t\tncx  = normalArray[ i + 6 ];\r\n\t\t\t\t\tncy  = normalArray[ i + 7 ];\r\n\t\t\t\t\tncz  = normalArray[ i + 8 ];\r\n\r\n\t\t\t\t\tnx = ( nax + nbx + ncx ) / 3;\r\n\t\t\t\t\tny = ( nay + nby + ncy ) / 3;\r\n\t\t\t\t\tnz = ( naz + nbz + ncz ) / 3;\r\n\r\n\t\t\t\t\tnormalArray[ i ]   = nx;\r\n\t\t\t\t\tnormalArray[ i + 1 ] = ny;\r\n\t\t\t\t\tnormalArray[ i + 2 ] = nz;\r\n\r\n\t\t\t\t\tnormalArray[ i + 3 ] = nx;\r\n\t\t\t\t\tnormalArray[ i + 4 ] = ny;\r\n\t\t\t\t\tnormalArray[ i + 5 ] = nz;\r\n\r\n\t\t\t\t\tnormalArray[ i + 6 ] = nx;\r\n\t\t\t\t\tnormalArray[ i + 7 ] = ny;\r\n\t\t\t\t\tnormalArray[ i + 8 ] = nz;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, object.normalArray, _gl.DYNAMIC_DRAW );\r\n\r\n\t\t\tstate.enableAttribute( program.attributes.normal );\r\n\r\n\t\t\t_gl.vertexAttribPointer( program.attributes.normal, 3, _gl.FLOAT, false, 0, 0 );\r\n\r\n\t\t}\r\n\r\n\t\tif ( object.hasUvs && material.map ) {\r\n\r\n\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, object.__webglUvBuffer );\r\n\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, object.uvArray, _gl.DYNAMIC_DRAW );\r\n\r\n\t\t\tstate.enableAttribute( program.attributes.uv );\r\n\r\n\t\t\t_gl.vertexAttribPointer( program.attributes.uv, 2, _gl.FLOAT, false, 0, 0 );\r\n\r\n\t\t}\r\n\r\n\t\tif ( object.hasColors && material.vertexColors !== THREE.NoColors ) {\r\n\r\n\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, object.__webglColorBuffer );\r\n\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, object.colorArray, _gl.DYNAMIC_DRAW );\r\n\r\n\t\t\tstate.enableAttribute( program.attributes.color );\r\n\r\n\t\t\t_gl.vertexAttribPointer( program.attributes.color, 3, _gl.FLOAT, false, 0, 0 );\r\n\r\n\t\t}\r\n\r\n\t\tstate.disableUnusedAttributes();\r\n\r\n\t\t_gl.drawArrays( _gl.TRIANGLES, 0, object.count );\r\n\r\n\t\tobject.count = 0;\r\n\r\n\t};\r\n\r\n\tfunction setupVertexAttributes( material, program, geometry, startIndex ) {\r\n\r\n\t\tvar geometryAttributes = geometry.attributes;\r\n\r\n\t\tvar programAttributes = program.attributes;\r\n\t\tvar programAttributesKeys = program.attributesKeys;\r\n\r\n\t\tfor ( var i = 0, l = programAttributesKeys.length; i < l; i ++ ) {\r\n\r\n\t\t\tvar key = programAttributesKeys[ i ];\r\n\t\t\tvar programAttribute = programAttributes[ key ];\r\n\r\n\t\t\tif ( programAttribute >= 0 ) {\r\n\r\n\t\t\t\tvar geometryAttribute = geometryAttributes[ key ];\r\n\r\n\t\t\t\tif ( geometryAttribute !== undefined ) {\r\n\r\n\t\t\t\t\tvar size = geometryAttribute.itemSize;\r\n\r\n\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryAttribute.buffer );\r\n\r\n\t\t\t\t\tstate.enableAttribute( programAttribute );\r\n\r\n\t\t\t\t\t_gl.vertexAttribPointer( programAttribute, size, _gl.FLOAT, false, 0, startIndex * size * 4 ); // 4 bytes per Float32\r\n\r\n\t\t\t\t} else if ( material.defaultAttributeValues !== undefined ) {\r\n\r\n\t\t\t\t\tif ( material.defaultAttributeValues[ key ].length === 2 ) {\r\n\r\n\t\t\t\t\t\t_gl.vertexAttrib2fv( programAttribute, material.defaultAttributeValues[ key ] );\r\n\r\n\t\t\t\t\t} else if ( material.defaultAttributeValues[ key ].length === 3 ) {\r\n\r\n\t\t\t\t\t\t_gl.vertexAttrib3fv( programAttribute, material.defaultAttributeValues[ key ] );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tstate.disableUnusedAttributes();\r\n\r\n\t}\r\n\r\n\tthis.renderBufferDirect = function ( camera, lights, fog, material, geometry, object ) {\r\n\r\n\t\tif ( material.visible === false ) return;\r\n\r\n\t\tupdateObject( object );\r\n\r\n\t\tvar program = setProgram( camera, lights, fog, material, object );\r\n\r\n\t\tvar updateBuffers = false,\r\n\t\t\twireframeBit = material.wireframe ? 1 : 0,\r\n\t\t\tgeometryProgram = 'direct_' + geometry.id + '_' + program.id + '_' + wireframeBit;\r\n\r\n\t\tif ( geometryProgram !== _currentGeometryProgram ) {\r\n\r\n\t\t\t_currentGeometryProgram = geometryProgram;\r\n\t\t\tupdateBuffers = true;\r\n\r\n\t\t}\r\n\r\n\t\tif ( updateBuffers ) {\r\n\r\n\t\t\tstate.initAttributes();\r\n\r\n\t\t}\r\n\r\n\t\t// render mesh\r\n\r\n\t\tif ( object instanceof THREE.Mesh ) {\r\n\r\n\t\t\tvar mode = material.wireframe === true ? _gl.LINES : _gl.TRIANGLES;\r\n\r\n\t\t\tvar index = geometry.attributes.index;\r\n\r\n\t\t\tif ( index ) {\r\n\r\n\t\t\t\t// indexed triangles\r\n\r\n\t\t\t\tvar type, size;\r\n\r\n\t\t\t\tif ( index.array instanceof Uint32Array && extensions.get( 'OES_element_index_uint' ) ) {\r\n\r\n\t\t\t\t\ttype = _gl.UNSIGNED_INT;\r\n\t\t\t\t\tsize = 4;\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\ttype = _gl.UNSIGNED_SHORT;\r\n\t\t\t\t\tsize = 2;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tvar offsets = geometry.offsets;\r\n\r\n\t\t\t\tif ( offsets.length === 0 ) {\r\n\r\n\t\t\t\t\tif ( updateBuffers ) {\r\n\r\n\t\t\t\t\t\tsetupVertexAttributes( material, program, geometry, 0 );\r\n\t\t\t\t\t\t_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, index.buffer );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t_gl.drawElements( mode, index.array.length, type, 0 );\r\n\r\n\t\t\t\t\t_this.info.render.calls ++;\r\n\t\t\t\t\t_this.info.render.vertices += index.array.length; // not really true, here vertices can be shared\r\n\t\t\t\t\t_this.info.render.faces += index.array.length / 3;\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\t// if there is more than 1 chunk\r\n\t\t\t\t\t// must set attribute pointers to use new offsets for each chunk\r\n\t\t\t\t\t// even if geometry and materials didn't change\r\n\r\n\t\t\t\t\tupdateBuffers = true;\r\n\r\n\t\t\t\t\tfor ( var i = 0, il = offsets.length; i < il; i ++ ) {\r\n\r\n\t\t\t\t\t\tvar startIndex = offsets[ i ].index;\r\n\r\n\t\t\t\t\t\tif ( updateBuffers ) {\r\n\r\n\t\t\t\t\t\t\tsetupVertexAttributes( material, program, geometry, startIndex );\r\n\t\t\t\t\t\t\t_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, index.buffer );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// render indexed triangles\r\n\r\n\t\t\t\t\t\t_gl.drawElements( mode, offsets[ i ].count, type, offsets[ i ].start * size );\r\n\r\n\t\t\t\t\t\t_this.info.render.calls ++;\r\n\t\t\t\t\t\t_this.info.render.vertices += offsets[ i ].count; // not really true, here vertices can be shared\r\n\t\t\t\t\t\t_this.info.render.faces += offsets[ i ].count / 3;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t// non-indexed triangles\r\n\r\n\t\t\t\tif ( updateBuffers ) {\r\n\r\n\t\t\t\t\tsetupVertexAttributes( material, program, geometry, 0 );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tvar position = geometry.attributes[ 'position' ];\r\n\r\n\t\t\t\t// render non-indexed triangles\r\n\r\n\t\t\t\t_gl.drawArrays( mode, 0, position.array.length / position.itemSize );\r\n\r\n\t\t\t\t_this.info.render.calls ++;\r\n\t\t\t\t_this.info.render.vertices += position.array.length / position.itemSize;\r\n\t\t\t\t_this.info.render.faces += position.array.length / ( 3 * position.itemSize );\r\n\r\n\t\t\t}\r\n\r\n\t\t} else if ( object instanceof THREE.PointCloud ) {\r\n\r\n\t\t\t// render particles\r\n\r\n\t\t\tvar mode = _gl.POINTS;\r\n\r\n\t\t\tvar index = geometry.attributes.index;\r\n\r\n\t\t\tif ( index ) {\r\n\r\n\t\t\t\t// indexed points\r\n\r\n\t\t\t\tvar type, size;\r\n\r\n\t\t\t\tif ( index.array instanceof Uint32Array && extensions.get( 'OES_element_index_uint' ) ) {\r\n\r\n\t\t\t\t\ttype = _gl.UNSIGNED_INT;\r\n\t\t\t\t\tsize = 4;\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\ttype = _gl.UNSIGNED_SHORT;\r\n\t\t\t\t\tsize = 2;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tvar offsets = geometry.offsets;\r\n\r\n\t\t\t\tif ( offsets.length === 0 ) {\r\n\r\n\t\t\t\t\tif ( updateBuffers ) {\r\n\r\n\t\t\t\t\t\tsetupVertexAttributes( material, program, geometry, 0 );\r\n\t\t\t\t\t\t_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, index.buffer );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t_gl.drawElements( mode, index.array.length, type, 0);\r\n\r\n\t\t\t\t\t_this.info.render.calls ++;\r\n\t\t\t\t\t_this.info.render.points += index.array.length;\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\t// if there is more than 1 chunk\r\n\t\t\t\t\t// must set attribute pointers to use new offsets for each chunk\r\n\t\t\t\t\t// even if geometry and materials didn't change\r\n\r\n\t\t\t\t\tif ( offsets.length > 1 ) updateBuffers = true;\r\n\r\n\t\t\t\t\tfor ( var i = 0, il = offsets.length; i < il; i ++ ) {\r\n\r\n\t\t\t\t\t\tvar startIndex = offsets[ i ].index;\r\n\r\n\t\t\t\t\t\tif ( updateBuffers ) {\r\n\r\n\t\t\t\t\t\t\tsetupVertexAttributes( material, program, geometry, startIndex );\r\n\t\t\t\t\t\t\t_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, index.buffer );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// render indexed points\r\n\r\n\t\t\t\t\t\t_gl.drawElements( mode, offsets[ i ].count, type, offsets[ i ].start * size );\r\n\r\n\t\t\t\t\t\t_this.info.render.calls ++;\r\n\t\t\t\t\t\t_this.info.render.points += offsets[ i ].count;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t// non-indexed points\r\n\r\n\t\t\t\tif ( updateBuffers ) {\r\n\r\n\t\t\t\t\tsetupVertexAttributes( material, program, geometry, 0 );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tvar position = geometry.attributes.position;\r\n\t\t\t\tvar offsets = geometry.offsets;\r\n\r\n\t\t\t\tif ( offsets.length === 0 ) {\r\n\r\n\t\t\t\t\t_gl.drawArrays( mode, 0, position.array.length / 3 );\r\n\r\n\t\t\t\t\t_this.info.render.calls ++;\r\n\t\t\t\t\t_this.info.render.points += position.array.length / 3;\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tfor ( var i = 0, il = offsets.length; i < il; i ++ ) {\r\n\r\n\t\t\t\t\t\t_gl.drawArrays( mode, offsets[ i ].index, offsets[ i ].count );\r\n\r\n\t\t\t\t\t\t_this.info.render.calls ++;\r\n\t\t\t\t\t\t_this.info.render.points += offsets[ i ].count;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t} else if ( object instanceof THREE.Line ) {\r\n\r\n\t\t\tvar mode = ( object.mode === THREE.LineStrip ) ? _gl.LINE_STRIP : _gl.LINES;\r\n\r\n\t\t\tstate.setLineWidth( material.linewidth * pixelRatio );\r\n\r\n\t\t\tvar index = geometry.attributes.index;\r\n\r\n\t\t\tif ( index ) {\r\n\r\n\t\t\t\t// indexed lines\r\n\r\n\t\t\t\tvar type, size;\r\n\r\n\t\t\t\tif ( index.array instanceof Uint32Array ) {\r\n\r\n\t\t\t\t\ttype = _gl.UNSIGNED_INT;\r\n\t\t\t\t\tsize = 4;\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\ttype = _gl.UNSIGNED_SHORT;\r\n\t\t\t\t\tsize = 2;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tvar offsets = geometry.offsets;\r\n\r\n\t\t\t\tif ( offsets.length === 0 ) {\r\n\r\n\t\t\t\t\tif ( updateBuffers ) {\r\n\r\n\t\t\t\t\t\tsetupVertexAttributes( material, program, geometry, 0 );\r\n\t\t\t\t\t\t_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, index.buffer );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t_gl.drawElements( mode, index.array.length, type, 0 ); // 2 bytes per Uint16Array\r\n\r\n\t\t\t\t\t_this.info.render.calls ++;\r\n\t\t\t\t\t_this.info.render.vertices += index.array.length; // not really true, here vertices can be shared\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\t// if there is more than 1 chunk\r\n\t\t\t\t\t// must set attribute pointers to use new offsets for each chunk\r\n\t\t\t\t\t// even if geometry and materials didn't change\r\n\r\n\t\t\t\t\tif ( offsets.length > 1 ) updateBuffers = true;\r\n\r\n\t\t\t\t\tfor ( var i = 0, il = offsets.length; i < il; i ++ ) {\r\n\r\n\t\t\t\t\t\tvar startIndex = offsets[ i ].index;\r\n\r\n\t\t\t\t\t\tif ( updateBuffers ) {\r\n\r\n\t\t\t\t\t\t\tsetupVertexAttributes( material, program, geometry, startIndex );\r\n\t\t\t\t\t\t\t_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, index.buffer );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// render indexed lines\r\n\r\n\t\t\t\t\t\t_gl.drawElements( mode, offsets[ i ].count, type, offsets[ i ].start * size ); // 2 bytes per Uint16Array\r\n\r\n\t\t\t\t\t\t_this.info.render.calls ++;\r\n\t\t\t\t\t\t_this.info.render.vertices += offsets[ i ].count; // not really true, here vertices can be shared\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t// non-indexed lines\r\n\r\n\t\t\t\tif ( updateBuffers ) {\r\n\r\n\t\t\t\t\tsetupVertexAttributes( material, program, geometry, 0 );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tvar position = geometry.attributes.position;\r\n\t\t\t\tvar offsets = geometry.offsets;\r\n\r\n\t\t\t\tif ( offsets.length === 0 ) {\r\n\r\n\t\t\t\t\t_gl.drawArrays( mode, 0, position.array.length / 3 );\r\n\r\n\t\t\t\t\t_this.info.render.calls ++;\r\n\t\t\t\t\t_this.info.render.vertices += position.array.length / 3;\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tfor ( var i = 0, il = offsets.length; i < il; i ++ ) {\r\n\r\n\t\t\t\t\t\t_gl.drawArrays( mode, offsets[ i ].index, offsets[ i ].count );\r\n\r\n\t\t\t\t\t\t_this.info.render.calls ++;\r\n\t\t\t\t\t\t_this.info.render.vertices += offsets[ i ].count;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tthis.renderBuffer = function ( camera, lights, fog, material, geometryGroup, object ) {\r\n\r\n\t\tif ( material.visible === false ) return;\r\n\r\n\t\tupdateObject( object );\r\n\r\n\t\tvar program = setProgram( camera, lights, fog, material, object );\r\n\r\n\t\tvar attributes = program.attributes;\r\n\r\n\t\tvar updateBuffers = false,\r\n\t\t\twireframeBit = material.wireframe ? 1 : 0,\r\n\t\t\tgeometryProgram = geometryGroup.id + '_' + program.id + '_' + wireframeBit;\r\n\r\n\t\tif ( geometryProgram !== _currentGeometryProgram ) {\r\n\r\n\t\t\t_currentGeometryProgram = geometryProgram;\r\n\t\t\tupdateBuffers = true;\r\n\r\n\t\t}\r\n\r\n\t\tif ( updateBuffers ) {\r\n\r\n\t\t\tstate.initAttributes();\r\n\r\n\t\t}\r\n\r\n\t\t// vertices\r\n\r\n\t\tif ( ! material.morphTargets && attributes.position >= 0 ) {\r\n\r\n\t\t\tif ( updateBuffers ) {\r\n\r\n\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglVertexBuffer );\r\n\r\n\t\t\t\tstate.enableAttribute( attributes.position );\r\n\r\n\t\t\t\t_gl.vertexAttribPointer( attributes.position, 3, _gl.FLOAT, false, 0, 0 );\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\tif ( object.morphTargetBase ) {\r\n\r\n\t\t\t\tsetupMorphTargets( material, geometryGroup, object );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\r\n\t\tif ( updateBuffers ) {\r\n\r\n\t\t\t// custom attributes\r\n\r\n\t\t\t// Use the per-geometryGroup custom attribute arrays which are setup in initMeshBuffers\r\n\r\n\t\t\tif ( geometryGroup.__webglCustomAttributesList ) {\r\n\r\n\t\t\t\tfor ( var i = 0, il = geometryGroup.__webglCustomAttributesList.length; i < il; i ++ ) {\r\n\r\n\t\t\t\t\tvar attribute = geometryGroup.__webglCustomAttributesList[ i ];\r\n\r\n\t\t\t\t\tif ( attributes[ attribute.buffer.belongsToAttribute ] >= 0 ) {\r\n\r\n\t\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, attribute.buffer );\r\n\r\n\t\t\t\t\t\tstate.enableAttribute( attributes[ attribute.buffer.belongsToAttribute ] );\r\n\r\n\t\t\t\t\t\t_gl.vertexAttribPointer( attributes[ attribute.buffer.belongsToAttribute ], attribute.size, _gl.FLOAT, false, 0, 0 );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\r\n\t\t\t// colors\r\n\r\n\t\t\tif ( attributes.color >= 0 ) {\r\n\r\n\t\t\t\tif ( object.geometry.colors.length > 0 || object.geometry.faces.length > 0 ) {\r\n\r\n\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglColorBuffer );\r\n\r\n\t\t\t\t\tstate.enableAttribute( attributes.color );\r\n\r\n\t\t\t\t\t_gl.vertexAttribPointer( attributes.color, 3, _gl.FLOAT, false, 0, 0 );\r\n\r\n\t\t\t\t} else if ( material.defaultAttributeValues !== undefined ) {\r\n\r\n\r\n\t\t\t\t\t_gl.vertexAttrib3fv( attributes.color, material.defaultAttributeValues.color );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// normals\r\n\r\n\t\t\tif ( attributes.normal >= 0 ) {\r\n\r\n\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglNormalBuffer );\r\n\r\n\t\t\t\tstate.enableAttribute( attributes.normal );\r\n\r\n\t\t\t\t_gl.vertexAttribPointer( attributes.normal, 3, _gl.FLOAT, false, 0, 0 );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// tangents\r\n\r\n\t\t\tif ( attributes.tangent >= 0 ) {\r\n\r\n\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglTangentBuffer );\r\n\r\n\t\t\t\tstate.enableAttribute( attributes.tangent );\r\n\r\n\t\t\t\t_gl.vertexAttribPointer( attributes.tangent, 4, _gl.FLOAT, false, 0, 0 );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// uvs\r\n\r\n\t\t\tif ( attributes.uv >= 0 ) {\r\n\r\n\t\t\t\tif ( object.geometry.faceVertexUvs[ 0 ] ) {\r\n\r\n\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglUVBuffer );\r\n\r\n\t\t\t\t\tstate.enableAttribute( attributes.uv );\r\n\r\n\t\t\t\t\t_gl.vertexAttribPointer( attributes.uv, 2, _gl.FLOAT, false, 0, 0 );\r\n\r\n\t\t\t\t} else if ( material.defaultAttributeValues !== undefined ) {\r\n\r\n\r\n\t\t\t\t\t_gl.vertexAttrib2fv( attributes.uv, material.defaultAttributeValues.uv );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( attributes.uv2 >= 0 ) {\r\n\r\n\t\t\t\tif ( object.geometry.faceVertexUvs[ 1 ] ) {\r\n\r\n\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglUV2Buffer );\r\n\r\n\t\t\t\t\tstate.enableAttribute( attributes.uv2 );\r\n\r\n\t\t\t\t\t_gl.vertexAttribPointer( attributes.uv2, 2, _gl.FLOAT, false, 0, 0 );\r\n\r\n\t\t\t\t} else if ( material.defaultAttributeValues !== undefined ) {\r\n\r\n\r\n\t\t\t\t\t_gl.vertexAttrib2fv( attributes.uv2, material.defaultAttributeValues.uv2 );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( material.skinning &&\r\n\t\t\t\t attributes.skinIndex >= 0 && attributes.skinWeight >= 0 ) {\r\n\r\n\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglSkinIndicesBuffer );\r\n\r\n\t\t\t\tstate.enableAttribute( attributes.skinIndex );\r\n\r\n\t\t\t\t_gl.vertexAttribPointer( attributes.skinIndex, 4, _gl.FLOAT, false, 0, 0 );\r\n\r\n\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglSkinWeightsBuffer );\r\n\r\n\t\t\t\tstate.enableAttribute( attributes.skinWeight );\r\n\r\n\t\t\t\t_gl.vertexAttribPointer( attributes.skinWeight, 4, _gl.FLOAT, false, 0, 0 );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// line distances\r\n\r\n\t\t\tif ( attributes.lineDistance >= 0 ) {\r\n\r\n\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglLineDistanceBuffer );\r\n\r\n\t\t\t\tstate.enableAttribute( attributes.lineDistance );\r\n\r\n\t\t\t\t_gl.vertexAttribPointer( attributes.lineDistance, 1, _gl.FLOAT, false, 0, 0 );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tstate.disableUnusedAttributes();\r\n\r\n\t\t// render mesh\r\n\r\n\t\tif ( object instanceof THREE.Mesh ) {\r\n\r\n\t\t\tvar type = geometryGroup.__typeArray === Uint32Array ? _gl.UNSIGNED_INT : _gl.UNSIGNED_SHORT;\r\n\r\n\t\t\t// wireframe\r\n\r\n\t\t\tif ( material.wireframe ) {\r\n\r\n\t\t\t\tstate.setLineWidth( material.wireframeLinewidth * pixelRatio );\r\n\r\n\t\t\t\tif ( updateBuffers ) _gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, geometryGroup.__webglLineBuffer );\r\n\t\t\t\t_gl.drawElements( _gl.LINES, geometryGroup.__webglLineCount, type, 0 );\r\n\r\n\t\t\t// triangles\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tif ( updateBuffers ) _gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, geometryGroup.__webglFaceBuffer );\r\n\t\t\t\t_gl.drawElements( _gl.TRIANGLES, geometryGroup.__webglFaceCount, type, 0 );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t_this.info.render.calls ++;\r\n\t\t\t_this.info.render.vertices += geometryGroup.__webglFaceCount;\r\n\t\t\t_this.info.render.faces += geometryGroup.__webglFaceCount / 3;\r\n\r\n\t\t// render lines\r\n\r\n\t\t} else if ( object instanceof THREE.Line ) {\r\n\r\n\t\t\tvar mode = ( object.mode === THREE.LineStrip ) ? _gl.LINE_STRIP : _gl.LINES;\r\n\r\n\t\t\tstate.setLineWidth( material.linewidth * pixelRatio );\r\n\r\n\t\t\t_gl.drawArrays( mode, 0, geometryGroup.__webglLineCount );\r\n\r\n\t\t\t_this.info.render.calls ++;\r\n\r\n\t\t// render particles\r\n\r\n\t\t} else if ( object instanceof THREE.PointCloud ) {\r\n\r\n\t\t\t_gl.drawArrays( _gl.POINTS, 0, geometryGroup.__webglParticleCount );\r\n\r\n\t\t\t_this.info.render.calls ++;\r\n\t\t\t_this.info.render.points += geometryGroup.__webglParticleCount;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tfunction setupMorphTargets ( material, geometryGroup, object ) {\r\n\r\n\t\t// set base\r\n\r\n\t\tvar attributes = material.program.attributes;\r\n\r\n\t\tif ( object.morphTargetBase !== - 1 && attributes.position >= 0 ) {\r\n\r\n\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglMorphTargetsBuffers[ object.morphTargetBase ] );\r\n\r\n\t\t\tstate.enableAttribute( attributes.position );\r\n\r\n\t\t\t_gl.vertexAttribPointer( attributes.position, 3, _gl.FLOAT, false, 0, 0 );\r\n\r\n\t\t} else if ( attributes.position >= 0 ) {\r\n\r\n\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglVertexBuffer );\r\n\r\n\t\t\tstate.enableAttribute( attributes.position );\r\n\r\n\t\t\t_gl.vertexAttribPointer( attributes.position, 3, _gl.FLOAT, false, 0, 0 );\r\n\r\n\t\t}\r\n\r\n\t\tif ( object.morphTargetForcedOrder.length ) {\r\n\r\n\t\t\t// set forced order\r\n\r\n\t\t\tvar m = 0;\r\n\t\t\tvar order = object.morphTargetForcedOrder;\r\n\t\t\tvar influences = object.morphTargetInfluences;\r\n\r\n\t\t\tvar attribute;\r\n\r\n\t\t\twhile ( m < material.numSupportedMorphTargets && m < order.length ) {\r\n\r\n\t\t\t\tattribute = attributes[ 'morphTarget' + m ];\r\n\r\n\t\t\t\tif ( attribute >= 0 ) {\r\n\r\n\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglMorphTargetsBuffers[ order[ m ] ] );\r\n\r\n\t\t\t\t\tstate.enableAttribute( attribute );\r\n\r\n\t\t\t\t\t_gl.vertexAttribPointer( attribute, 3, _gl.FLOAT, false, 0, 0 );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tattribute = attributes[ 'morphNormal' + m ];\r\n\r\n\t\t\t\tif ( attribute >= 0 && material.morphNormals ) {\r\n\r\n\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglMorphNormalsBuffers[ order[ m ] ] );\r\n\r\n\t\t\t\t\tstate.enableAttribute( attribute );\r\n\r\n\t\t\t\t\t_gl.vertexAttribPointer( attribute, 3, _gl.FLOAT, false, 0, 0 );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tobject.__webglMorphTargetInfluences[ m ] = influences[ order[ m ] ];\r\n\r\n\t\t\t\tm ++;\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\t// find the most influencing\r\n\r\n\t\t\tvar activeInfluenceIndices = [];\r\n\t\t\tvar influences = object.morphTargetInfluences;\r\n\t\t\tvar morphTargets = object.geometry.morphTargets;\r\n\r\n\t\t\tif ( influences.length > morphTargets.length ) {\r\n\r\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: Influences array is bigger than morphTargets array.' );\r\n\t\t\t\tinfluences.length = morphTargets.length;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfor ( var i = 0, il = influences.length; i < il; i ++ ) {\r\n\r\n\t\t\t\tvar influence = influences[ i ];\r\n\r\n\t\t\t\tactiveInfluenceIndices.push( [ influence, i ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( activeInfluenceIndices.length > material.numSupportedMorphTargets ) {\r\n\r\n\t\t\t\tactiveInfluenceIndices.sort( numericalSort );\r\n\t\t\t\tactiveInfluenceIndices.length = material.numSupportedMorphTargets;\r\n\r\n\t\t\t} else if ( activeInfluenceIndices.length > material.numSupportedMorphNormals ) {\r\n\r\n\t\t\t\tactiveInfluenceIndices.sort( numericalSort );\r\n\r\n\t\t\t} else if ( activeInfluenceIndices.length === 0 ) {\r\n\r\n\t\t\t\tactiveInfluenceIndices.push( [ 0, 0 ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar attribute;\r\n\r\n\t\t\tfor ( var m = 0, ml = material.numSupportedMorphTargets; m < ml; m ++ ) {\r\n\r\n\t\t\t\tif ( activeInfluenceIndices[ m ] ) {\r\n\r\n\t\t\t\t\tvar influenceIndex = activeInfluenceIndices[ m ][ 1 ];\r\n\r\n\t\t\t\t\tattribute = attributes[ 'morphTarget' + m ];\r\n\r\n\t\t\t\t\tif ( attribute >= 0 ) {\r\n\r\n\t\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglMorphTargetsBuffers[ influenceIndex ] );\r\n\r\n\t\t\t\t\t\tstate.enableAttribute( attribute );\r\n\r\n\t\t\t\t\t\t_gl.vertexAttribPointer( attribute, 3, _gl.FLOAT, false, 0, 0 );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tattribute = attributes[ 'morphNormal' + m ];\r\n\r\n\t\t\t\t\tif ( attribute >= 0 && material.morphNormals ) {\r\n\r\n\t\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglMorphNormalsBuffers[ influenceIndex ] );\r\n\r\n\t\t\t\t\t\tstate.enableAttribute( attribute );\r\n\r\n\t\t\t\t\t\t_gl.vertexAttribPointer( attribute, 3, _gl.FLOAT, false, 0, 0 );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tobject.__webglMorphTargetInfluences[ m ] = influences[ influenceIndex ];\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\t/*\r\n\t\t\t\t\t_gl.vertexAttribPointer( attributes[ \"morphTarget\" + m ], 3, _gl.FLOAT, false, 0, 0 );\r\n\r\n\t\t\t\t\tif ( material.morphNormals ) {\r\n\r\n\t\t\t\t\t\t_gl.vertexAttribPointer( attributes[ \"morphNormal\" + m ], 3, _gl.FLOAT, false, 0, 0 );\r\n\r\n\t\t\t\t\t}\r\n\t\t\t\t\t*/\r\n\r\n\t\t\t\t\tobject.__webglMorphTargetInfluences[ m ] = 0;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// load updated influences uniform\r\n\r\n\t\tif ( material.program.uniforms.morphTargetInfluences !== null ) {\r\n\r\n\t\t\t_gl.uniform1fv( material.program.uniforms.morphTargetInfluences, object.__webglMorphTargetInfluences );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// Sorting\r\n\r\n\tfunction painterSortStable ( a, b ) {\r\n\r\n\t\tif ( a.object.renderOrder !== b.object.renderOrder ) {\r\n\r\n\t\t\treturn a.object.renderOrder - b.object.renderOrder;\r\n\r\n\t\t} else if ( a.material.id !== b.material.id ) {\r\n\r\n\t\t\treturn a.material.id - b.material.id;\r\n\r\n\t\t} else if ( a.z !== b.z ) {\r\n\r\n\t\t\treturn a.z - b.z;\r\n\r\n\t\t} else {\r\n\r\n\t\t\treturn a.id - b.id;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction reversePainterSortStable ( a, b ) {\r\n\r\n\t\tif ( a.object.renderOrder !== b.object.renderOrder ) {\r\n\r\n\t\t\treturn a.object.renderOrder - b.object.renderOrder;\r\n\r\n\t\t} if ( a.z !== b.z ) {\r\n\r\n\t\t\treturn b.z - a.z;\r\n\r\n\t\t} else {\r\n\r\n\t\t\treturn a.id - b.id;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction numericalSort ( a, b ) {\r\n\r\n\t\treturn b[ 0 ] - a[ 0 ];\r\n\r\n\t}\r\n\r\n\t// Rendering\r\n\r\n\tthis.render = function ( scene, camera, renderTarget, forceClear ) {\r\n\r\n\t\tif ( camera instanceof THREE.Camera === false ) {\r\n\r\n\t\t\tTHREE.error( 'THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.' );\r\n\t\t\treturn;\r\n\r\n\t\t}\r\n\r\n\t\tvar fog = scene.fog;\r\n\r\n\t\t// reset caching for this frame\r\n\r\n\t\t_currentGeometryProgram = '';\r\n\t\t_currentMaterialId = - 1;\r\n\t\t_currentCamera = null;\r\n\t\t_lightsNeedUpdate = true;\r\n\r\n\t\t// update scene graph\r\n\r\n\t\tif ( scene.autoUpdate === true ) scene.updateMatrixWorld();\r\n\r\n\t\t// update camera matrices and frustum\r\n\r\n\t\tif ( camera.parent === undefined ) camera.updateMatrixWorld();\r\n\r\n\t\t// update Skeleton objects\r\n\r\n\t\tscene.traverse( function ( object ) {\r\n\r\n\t\t\tif ( object instanceof THREE.SkinnedMesh ) {\r\n\r\n\t\t\t\tobject.skeleton.update();\r\n\r\n\t\t\t}\r\n\r\n\t\t} );\r\n\r\n\t\tcamera.matrixWorldInverse.getInverse( camera.matrixWorld );\r\n\r\n\t\t_projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );\r\n\t\t_frustum.setFromMatrix( _projScreenMatrix );\r\n\r\n\t\tlights.length = 0;\r\n\t\topaqueObjects.length = 0;\r\n\t\ttransparentObjects.length = 0;\r\n\r\n\t\tsprites.length = 0;\r\n\t\tlensFlares.length = 0;\r\n\r\n\t\tprojectObject( scene );\r\n\r\n\t\tif ( _this.sortObjects === true ) {\r\n\r\n\t\t\topaqueObjects.sort( painterSortStable );\r\n\t\t\ttransparentObjects.sort( reversePainterSortStable );\r\n\r\n\t\t}\r\n\r\n\t\t// custom render plugins (pre pass)\r\n\r\n\t\tshadowMapPlugin.render( scene, camera );\r\n\r\n\t\t//\r\n\r\n\t\t_this.info.render.calls = 0;\r\n\t\t_this.info.render.vertices = 0;\r\n\t\t_this.info.render.faces = 0;\r\n\t\t_this.info.render.points = 0;\r\n\r\n\t\tthis.setRenderTarget( renderTarget );\r\n\r\n\t\tif ( this.autoClear || forceClear ) {\r\n\r\n\t\t\tthis.clear( this.autoClearColor, this.autoClearDepth, this.autoClearStencil );\r\n\r\n\t\t}\r\n\r\n\t\t// set matrices for immediate objects\r\n\r\n\t\tfor ( var i = 0, il = _webglObjectsImmediate.length; i < il; i ++ ) {\r\n\r\n\t\t\tvar webglObject = _webglObjectsImmediate[ i ];\r\n\t\t\tvar object = webglObject.object;\r\n\r\n\t\t\tif ( object.visible ) {\r\n\r\n\t\t\t\tsetupMatrices( object, camera );\r\n\r\n\t\t\t\tunrollImmediateBufferMaterial( webglObject );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( scene.overrideMaterial ) {\r\n\r\n\t\t\tvar overrideMaterial = scene.overrideMaterial;\r\n\r\n\t\t\tsetMaterial( overrideMaterial );\r\n\r\n\t\t\trenderObjects( opaqueObjects, camera, lights, fog, overrideMaterial );\r\n\t\t\trenderObjects( transparentObjects, camera, lights, fog, overrideMaterial );\r\n\t\t\trenderObjectsImmediate( _webglObjectsImmediate, '', camera, lights, fog, overrideMaterial );\r\n\r\n\t\t} else {\r\n\r\n\t\t\t// opaque pass (front-to-back order)\r\n\r\n\t\t\tstate.setBlending( THREE.NoBlending );\r\n\r\n\t\t\trenderObjects( opaqueObjects, camera, lights, fog, null );\r\n\t\t\trenderObjectsImmediate( _webglObjectsImmediate, 'opaque', camera, lights, fog, null );\r\n\r\n\t\t\t// transparent pass (back-to-front order)\r\n\r\n\t\t\trenderObjects( transparentObjects, camera, lights, fog, null );\r\n\t\t\trenderObjectsImmediate( _webglObjectsImmediate, 'transparent', camera, lights, fog, null );\r\n\r\n\t\t}\r\n\r\n\t\t// custom render plugins (post pass)\r\n\r\n\t\tspritePlugin.render( scene, camera );\r\n\t\tlensFlarePlugin.render( scene, camera, _currentWidth, _currentHeight );\r\n\r\n\t\t// Generate mipmap if we're using any kind of mipmap filtering\r\n\r\n\t\tif ( renderTarget && renderTarget.generateMipmaps && renderTarget.minFilter !== THREE.NearestFilter && renderTarget.minFilter !== THREE.LinearFilter ) {\r\n\r\n\t\t\tupdateRenderTargetMipmap( renderTarget );\r\n\r\n\t\t}\r\n\r\n\t\t// Ensure depth buffer writing is enabled so it can be cleared on next render\r\n\r\n\t\tstate.setDepthTest( true );\r\n\t\tstate.setDepthWrite( true );\r\n\t\tstate.setColorWrite( true );\r\n\r\n\t\t// _gl.finish();\r\n\r\n\t};\r\n\r\n\tfunction projectObject( object ) {\r\n\r\n\t\tif ( object.visible === false ) return;\r\n\r\n\t\tif ( object instanceof THREE.Scene || object instanceof THREE.Group ) {\r\n\r\n\t\t\t// skip\r\n\r\n\t\t} else {\r\n\r\n\t\t\tinitObject( object );\r\n\r\n\t\t\tif ( object instanceof THREE.Light ) {\r\n\r\n\t\t\t\tlights.push( object );\r\n\r\n\t\t\t} else if ( object instanceof THREE.Sprite ) {\r\n\r\n\t\t\t\tsprites.push( object );\r\n\r\n\t\t\t} else if ( object instanceof THREE.LensFlare ) {\r\n\r\n\t\t\t\tlensFlares.push( object );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tvar webglObjects = _webglObjects[ object.id ];\r\n\r\n\t\t\t\tif ( webglObjects && ( object.frustumCulled === false || _frustum.intersectsObject( object ) === true ) ) {\r\n\r\n\t\t\t\t\tfor ( var i = 0, l = webglObjects.length; i < l; i ++ ) {\r\n\r\n\t\t\t\t\t\tvar webglObject = webglObjects[ i ];\r\n\r\n\t\t\t\t\t\tunrollBufferMaterial( webglObject );\r\n\r\n\t\t\t\t\t\twebglObject.render = true;\r\n\r\n\t\t\t\t\t\tif ( _this.sortObjects === true ) {\r\n\r\n\t\t\t\t\t\t\t_vector3.setFromMatrixPosition( object.matrixWorld );\r\n\t\t\t\t\t\t\t_vector3.applyProjection( _projScreenMatrix );\r\n\r\n\t\t\t\t\t\t\twebglObject.z = _vector3.z;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tfor ( var i = 0, l = object.children.length; i < l; i ++ ) {\r\n\r\n\t\t\tprojectObject( object.children[ i ] );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction renderObjects( renderList, camera, lights, fog, overrideMaterial ) {\r\n\r\n\t\tvar material;\r\n\r\n\t\tfor ( var i = 0, l = renderList.length; i < l; i ++ ) {\r\n\r\n\t\t\tvar webglObject = renderList[ i ];\r\n\r\n\t\t\tvar object = webglObject.object;\r\n\t\t\tvar buffer = webglObject.buffer;\r\n\r\n\t\t\tsetupMatrices( object, camera );\r\n\r\n\t\t\tif ( overrideMaterial ) {\r\n\r\n\t\t\t\tmaterial = overrideMaterial;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tmaterial = webglObject.material;\r\n\r\n\t\t\t\tif ( ! material ) continue;\r\n\r\n\t\t\t\tsetMaterial( material );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t_this.setMaterialFaces( material );\r\n\r\n\t\t\tif ( buffer instanceof THREE.BufferGeometry ) {\r\n\r\n\t\t\t\t_this.renderBufferDirect( camera, lights, fog, material, buffer, object );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t_this.renderBuffer( camera, lights, fog, material, buffer, object );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction renderObjectsImmediate ( renderList, materialType, camera, lights, fog, overrideMaterial ) {\r\n\r\n\t\tvar material;\r\n\r\n\t\tfor ( var i = 0, l = renderList.length; i < l; i ++ ) {\r\n\r\n\t\t\tvar webglObject = renderList[ i ];\r\n\t\t\tvar object = webglObject.object;\r\n\r\n\t\t\tif ( object.visible ) {\r\n\r\n\t\t\t\tif ( overrideMaterial ) {\r\n\r\n\t\t\t\t\tmaterial = overrideMaterial;\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tmaterial = webglObject[ materialType ];\r\n\r\n\t\t\t\t\tif ( ! material ) continue;\r\n\r\n\t\t\t\t\tsetMaterial( material );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t_this.renderImmediateObject( camera, lights, fog, material, object );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tthis.renderImmediateObject = function ( camera, lights, fog, material, object ) {\r\n\r\n\t\tvar program = setProgram( camera, lights, fog, material, object );\r\n\r\n\t\t_currentGeometryProgram = '';\r\n\r\n\t\t_this.setMaterialFaces( material );\r\n\r\n\t\tif ( object.immediateRenderCallback ) {\r\n\r\n\t\t\tobject.immediateRenderCallback( program, _gl, _frustum );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tobject.render( function ( object ) { _this.renderBufferImmediate( object, program, material ); } );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tfunction unrollImmediateBufferMaterial ( globject ) {\r\n\r\n\t\tvar object = globject.object,\r\n\t\t\tmaterial = object.material;\r\n\r\n\t\tif ( material.transparent ) {\r\n\r\n\t\t\tglobject.transparent = material;\r\n\t\t\tglobject.opaque = null;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tglobject.opaque = material;\r\n\t\t\tglobject.transparent = null;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction unrollBufferMaterial ( globject ) {\r\n\r\n\t\tvar object = globject.object;\r\n\t\tvar buffer = globject.buffer;\r\n\r\n\t\tvar geometry = object.geometry;\r\n\t\tvar material = object.material;\r\n\r\n\t\tif ( material instanceof THREE.MeshFaceMaterial ) {\r\n\r\n\t\t\tvar materialIndex = geometry instanceof THREE.BufferGeometry ? 0 : buffer.materialIndex;\r\n\r\n\t\t\tmaterial = material.materials[ materialIndex ];\r\n\r\n\t\t\tglobject.material = material;\r\n\r\n\t\t\tif ( material.transparent ) {\r\n\r\n\t\t\t\ttransparentObjects.push( globject );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\topaqueObjects.push( globject );\r\n\r\n\t\t\t}\r\n\r\n\t\t} else if ( material ) {\r\n\r\n\t\t\tglobject.material = material;\r\n\r\n\t\t\tif ( material.transparent ) {\r\n\r\n\t\t\t\ttransparentObjects.push( globject );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\topaqueObjects.push( globject );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction initObject( object ) {\r\n\r\n\t\tif ( object.__webglInit === undefined ) {\r\n\r\n\t\t\tobject.__webglInit = true;\r\n\t\t\tobject._modelViewMatrix = new THREE.Matrix4();\r\n\t\t\tobject._normalMatrix = new THREE.Matrix3();\r\n\r\n\t\t\tobject.addEventListener( 'removed', onObjectRemoved );\r\n\r\n\t\t}\r\n\r\n\t\tvar geometry = object.geometry;\r\n\r\n\t\tif ( geometry === undefined ) {\r\n\r\n\t\t\t// ImmediateRenderObject\r\n\r\n\t\t} else if ( geometry.__webglInit === undefined ) {\r\n\r\n\t\t\tgeometry.__webglInit = true;\r\n\t\t\tgeometry.addEventListener( 'dispose', onGeometryDispose );\r\n\r\n\t\t\tif ( geometry instanceof THREE.BufferGeometry ) {\r\n\r\n\t\t\t\t_this.info.memory.geometries ++;\r\n\r\n\t\t\t} else if ( object instanceof THREE.Mesh ) {\r\n\r\n\t\t\t\tinitGeometryGroups( object, geometry );\r\n\r\n\t\t\t} else if ( object instanceof THREE.Line ) {\r\n\r\n\t\t\t\tif ( geometry.__webglVertexBuffer === undefined ) {\r\n\r\n\t\t\t\t\tcreateLineBuffers( geometry );\r\n\t\t\t\t\tinitLineBuffers( geometry, object );\r\n\r\n\t\t\t\t\tgeometry.verticesNeedUpdate = true;\r\n\t\t\t\t\tgeometry.colorsNeedUpdate = true;\r\n\t\t\t\t\tgeometry.lineDistancesNeedUpdate = true;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else if ( object instanceof THREE.PointCloud ) {\r\n\r\n\t\t\t\tif ( geometry.__webglVertexBuffer === undefined ) {\r\n\r\n\t\t\t\t\tcreateParticleBuffers( geometry );\r\n\t\t\t\t\tinitParticleBuffers( geometry, object );\r\n\r\n\t\t\t\t\tgeometry.verticesNeedUpdate = true;\r\n\t\t\t\t\tgeometry.colorsNeedUpdate = true;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( object.__webglActive === undefined) {\r\n\r\n\t\t\tobject.__webglActive = true;\r\n\r\n\t\t\tif ( object instanceof THREE.Mesh ) {\r\n\r\n\t\t\t\tif ( geometry instanceof THREE.BufferGeometry ) {\r\n\r\n\t\t\t\t\taddBuffer( _webglObjects, geometry, object );\r\n\r\n\t\t\t\t} else if ( geometry instanceof THREE.Geometry ) {\r\n\r\n\t\t\t\t\tvar geometryGroupsList = geometryGroups[ geometry.id ];\r\n\r\n\t\t\t\t\tfor ( var i = 0,l = geometryGroupsList.length; i < l; i ++ ) {\r\n\r\n\t\t\t\t\t\taddBuffer( _webglObjects, geometryGroupsList[ i ], object );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else if ( object instanceof THREE.Line || object instanceof THREE.PointCloud ) {\r\n\r\n\t\t\t\taddBuffer( _webglObjects, geometry, object );\r\n\r\n\t\t\t} else if ( object instanceof THREE.ImmediateRenderObject || object.immediateRenderCallback ) {\r\n\r\n\t\t\t\taddBufferImmediate( _webglObjectsImmediate, object );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// Geometry splitting\r\n\r\n\tvar geometryGroups = {};\r\n\tvar geometryGroupCounter = 0;\r\n\r\n\tfunction makeGroups( geometry, usesFaceMaterial ) {\r\n\r\n\t\tvar maxVerticesInGroup = extensions.get( 'OES_element_index_uint' ) ? 4294967296 : 65535;\r\n\r\n\t\tvar groupHash, hash_map = {};\r\n\r\n\t\tvar numMorphTargets = geometry.morphTargets.length;\r\n\t\tvar numMorphNormals = geometry.morphNormals.length;\r\n\r\n\t\tvar group;\r\n\t\tvar groups = {};\r\n\t\tvar groupsList = [];\r\n\r\n\t\tfor ( var f = 0, fl = geometry.faces.length; f < fl; f ++ ) {\r\n\r\n\t\t\tvar face = geometry.faces[ f ];\r\n\t\t\tvar materialIndex = usesFaceMaterial ? face.materialIndex : 0;\r\n\r\n\t\t\tif ( ! ( materialIndex in hash_map ) ) {\r\n\r\n\t\t\t\thash_map[ materialIndex ] = { hash: materialIndex, counter: 0 };\r\n\r\n\t\t\t}\r\n\r\n\t\t\tgroupHash = hash_map[ materialIndex ].hash + '_' + hash_map[ materialIndex ].counter;\r\n\r\n\t\t\tif ( ! ( groupHash in groups ) ) {\r\n\r\n\t\t\t\tgroup = {\r\n\t\t\t\t\tid: geometryGroupCounter ++,\r\n\t\t\t\t\tfaces3: [],\r\n\t\t\t\t\tmaterialIndex: materialIndex,\r\n\t\t\t\t\tvertices: 0,\r\n\t\t\t\t\tnumMorphTargets: numMorphTargets,\r\n\t\t\t\t\tnumMorphNormals: numMorphNormals\r\n\t\t\t\t};\r\n\r\n\t\t\t\tgroups[ groupHash ] = group;\r\n\t\t\t\tgroupsList.push( group );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( groups[ groupHash ].vertices + 3 > maxVerticesInGroup ) {\r\n\r\n\t\t\t\thash_map[ materialIndex ].counter += 1;\r\n\t\t\t\tgroupHash = hash_map[ materialIndex ].hash + '_' + hash_map[ materialIndex ].counter;\r\n\r\n\t\t\t\tif ( ! ( groupHash in groups ) ) {\r\n\r\n\t\t\t\t\tgroup = {\r\n\t\t\t\t\t\tid: geometryGroupCounter ++,\r\n\t\t\t\t\t\tfaces3: [],\r\n\t\t\t\t\t\tmaterialIndex: materialIndex,\r\n\t\t\t\t\t\tvertices: 0,\r\n\t\t\t\t\t\tnumMorphTargets: numMorphTargets,\r\n\t\t\t\t\t\tnumMorphNormals: numMorphNormals\r\n\t\t\t\t\t};\r\n\r\n\t\t\t\t\tgroups[ groupHash ] = group;\r\n\t\t\t\t\tgroupsList.push( group );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tgroups[ groupHash ].faces3.push( f );\r\n\t\t\tgroups[ groupHash ].vertices += 3;\r\n\r\n\t\t}\r\n\r\n\t\treturn groupsList;\r\n\r\n\t}\r\n\r\n\tfunction initGeometryGroups( object, geometry ) {\r\n\r\n\t\tvar material = object.material, addBuffers = false;\r\n\r\n\t\tif ( geometryGroups[ geometry.id ] === undefined || geometry.groupsNeedUpdate === true ) {\r\n\r\n\t\t\tdelete _webglObjects[ object.id ];\r\n\r\n\t\t\tgeometryGroups[ geometry.id ] = makeGroups( geometry, material instanceof THREE.MeshFaceMaterial );\r\n\r\n\t\t\tgeometry.groupsNeedUpdate = false;\r\n\r\n\t\t}\r\n\r\n\t\tvar geometryGroupsList = geometryGroups[ geometry.id ];\r\n\r\n\t\t// create separate VBOs per geometry chunk\r\n\r\n\t\tfor ( var i = 0, il = geometryGroupsList.length; i < il; i ++ ) {\r\n\r\n\t\t\tvar geometryGroup = geometryGroupsList[ i ];\r\n\r\n\t\t\t// initialise VBO on the first access\r\n\r\n\t\t\tif ( geometryGroup.__webglVertexBuffer === undefined ) {\r\n\r\n\t\t\t\tcreateMeshBuffers( geometryGroup );\r\n\t\t\t\tinitMeshBuffers( geometryGroup, object );\r\n\r\n\t\t\t\tgeometry.verticesNeedUpdate = true;\r\n\t\t\t\tgeometry.morphTargetsNeedUpdate = true;\r\n\t\t\t\tgeometry.elementsNeedUpdate = true;\r\n\t\t\t\tgeometry.uvsNeedUpdate = true;\r\n\t\t\t\tgeometry.normalsNeedUpdate = true;\r\n\t\t\t\tgeometry.tangentsNeedUpdate = true;\r\n\t\t\t\tgeometry.colorsNeedUpdate = true;\r\n\r\n\t\t\t\taddBuffers = true;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\taddBuffers = false;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( addBuffers || object.__webglActive === undefined ) {\r\n\r\n\t\t\t\taddBuffer( _webglObjects, geometryGroup, object );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tobject.__webglActive = true;\r\n\r\n\t}\r\n\r\n\tfunction addBuffer( objlist, buffer, object ) {\r\n\r\n\t\tvar id = object.id;\r\n\t\tobjlist[id] = objlist[id] || [];\r\n\t\tobjlist[id].push(\r\n\t\t\t{\r\n\t\t\t\tid: id,\r\n\t\t\t\tbuffer: buffer,\r\n\t\t\t\tobject: object,\r\n\t\t\t\tmaterial: null,\r\n\t\t\t\tz: 0\r\n\t\t\t}\r\n\t\t);\r\n\r\n\t};\r\n\r\n\tfunction addBufferImmediate( objlist, object ) {\r\n\r\n\t\tobjlist.push(\r\n\t\t\t{\r\n\t\t\t\tid: null,\r\n\t\t\t\tobject: object,\r\n\t\t\t\topaque: null,\r\n\t\t\t\ttransparent: null,\r\n\t\t\t\tz: 0\r\n\t\t\t}\r\n\t\t);\r\n\r\n\t};\r\n\r\n\t// Objects updates\r\n\r\n\tfunction updateObject( object ) {\r\n\r\n\t\tvar geometry = object.geometry;\r\n\r\n\t\tif ( geometry instanceof THREE.BufferGeometry ) {\r\n\r\n\t\t\tvar attributes = geometry.attributes;\r\n\t\t\tvar attributesKeys = geometry.attributesKeys;\r\n\r\n\t\t\tfor ( var i = 0, l = attributesKeys.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tvar key = attributesKeys[ i ];\r\n\t\t\t\tvar attribute = attributes[ key ];\r\n\t\t\t\tvar bufferType = ( key === 'index' ) ? _gl.ELEMENT_ARRAY_BUFFER : _gl.ARRAY_BUFFER;\r\n\r\n\t\t\t\tif ( attribute.buffer === undefined ) {\r\n\r\n\t\t\t\t\tattribute.buffer = _gl.createBuffer();\r\n\t\t\t\t\t_gl.bindBuffer( bufferType, attribute.buffer );\r\n\t\t\t\t\t_gl.bufferData( bufferType, attribute.array, ( attribute instanceof THREE.DynamicBufferAttribute ) ? _gl.DYNAMIC_DRAW : _gl.STATIC_DRAW );\r\n\r\n\t\t\t\t\tattribute.needsUpdate = false;\r\n\r\n\t\t\t\t} else if ( attribute.needsUpdate === true ) {\r\n\r\n\t\t\t\t\t_gl.bindBuffer( bufferType, attribute.buffer );\r\n\r\n\t\t\t\t\tif ( attribute.updateRange === undefined || attribute.updateRange.count === -1 ) { // Not using update ranges\r\n\r\n\t\t\t\t\t\t_gl.bufferSubData( bufferType, 0, attribute.array );\r\n\r\n\t\t\t\t\t} else if ( attribute.updateRange.count === 0 ) {\r\n\r\n\t\t\t\t\t\tconsole.error( 'THREE.WebGLRenderer.updateObject: using updateRange for THREE.DynamicBufferAttribute and marked as needsUpdate but count is 0, ensure you are using set methods or updating manually.' );\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t_gl.bufferSubData( bufferType, attribute.updateRange.offset * attribute.array.BYTES_PER_ELEMENT,\r\n\t\t\t\t\t\t\t\t\t\t   attribute.array.subarray( attribute.updateRange.offset, attribute.updateRange.offset + attribute.updateRange.count ) );\r\n\r\n\t\t\t\t\t\tattribute.updateRange.count = 0; // reset range\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tattribute.needsUpdate = false;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t} else if ( object instanceof THREE.Mesh ) {\r\n\r\n\t\t\t// check all geometry groups\r\n\r\n\t\t\tif ( geometry.groupsNeedUpdate === true ) {\r\n\r\n\t\t\t\tinitGeometryGroups( object, geometry );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar geometryGroupsList = geometryGroups[ geometry.id ];\r\n\r\n\t\t\tfor ( var i = 0, il = geometryGroupsList.length; i < il; i ++ ) {\r\n\r\n\t\t\t\tvar geometryGroup = geometryGroupsList[ i ];\r\n\t\t\t\tvar material = getBufferMaterial( object, geometryGroup );\r\n\r\n\t\t\t\tvar customAttributesDirty = material.attributes && areCustomAttributesDirty( material );\r\n\r\n\t\t\t\tif ( geometry.verticesNeedUpdate || geometry.morphTargetsNeedUpdate || geometry.elementsNeedUpdate ||\r\n\t\t\t\t\t geometry.uvsNeedUpdate || geometry.normalsNeedUpdate ||\r\n\t\t\t\t\t geometry.colorsNeedUpdate || geometry.tangentsNeedUpdate || customAttributesDirty ) {\r\n\r\n\t\t\t\t\tsetMeshBuffers( geometryGroup, object, _gl.DYNAMIC_DRAW, ! geometry.dynamic, material );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tgeometry.verticesNeedUpdate = false;\r\n\t\t\tgeometry.morphTargetsNeedUpdate = false;\r\n\t\t\tgeometry.elementsNeedUpdate = false;\r\n\t\t\tgeometry.uvsNeedUpdate = false;\r\n\t\t\tgeometry.normalsNeedUpdate = false;\r\n\t\t\tgeometry.colorsNeedUpdate = false;\r\n\t\t\tgeometry.tangentsNeedUpdate = false;\r\n\r\n\t\t\tmaterial.attributes && clearCustomAttributes( material );\r\n\r\n\t\t} else if ( object instanceof THREE.Line ) {\r\n\r\n\t\t\tvar material = getBufferMaterial( object, geometry );\r\n\t\t\tvar customAttributesDirty = material.attributes && areCustomAttributesDirty( material );\r\n\r\n\t\t\tif ( geometry.verticesNeedUpdate || geometry.colorsNeedUpdate || geometry.lineDistancesNeedUpdate || customAttributesDirty ) {\r\n\r\n\t\t\t\tsetLineBuffers( geometry, _gl.DYNAMIC_DRAW );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tgeometry.verticesNeedUpdate = false;\r\n\t\t\tgeometry.colorsNeedUpdate = false;\r\n\t\t\tgeometry.lineDistancesNeedUpdate = false;\r\n\r\n\t\t\tmaterial.attributes && clearCustomAttributes( material );\r\n\r\n\t\t} else if ( object instanceof THREE.PointCloud ) {\r\n\r\n\t\t\tvar material = getBufferMaterial( object, geometry );\r\n\t\t\tvar customAttributesDirty = material.attributes && areCustomAttributesDirty( material );\r\n\r\n\t\t\tif ( geometry.verticesNeedUpdate || geometry.colorsNeedUpdate || customAttributesDirty ) {\r\n\r\n\t\t\t\tsetParticleBuffers( geometry, _gl.DYNAMIC_DRAW, object );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tgeometry.verticesNeedUpdate = false;\r\n\t\t\tgeometry.colorsNeedUpdate = false;\r\n\r\n\t\t\tmaterial.attributes && clearCustomAttributes( material );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// Objects updates - custom attributes check\r\n\r\n\tfunction areCustomAttributesDirty( material ) {\r\n\r\n\t\tfor ( var name in material.attributes ) {\r\n\r\n\t\t\tif ( material.attributes[ name ].needsUpdate ) return true;\r\n\r\n\t\t}\r\n\r\n\t\treturn false;\r\n\r\n\t}\r\n\r\n\tfunction clearCustomAttributes( material ) {\r\n\r\n\t\tfor ( var name in material.attributes ) {\r\n\r\n\t\t\tmaterial.attributes[ name ].needsUpdate = false;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// Objects removal\r\n\r\n\tfunction removeObject( object ) {\r\n\r\n\t\tif ( object instanceof THREE.Mesh  ||\r\n\t\t\t object instanceof THREE.PointCloud ||\r\n\t\t\t object instanceof THREE.Line ) {\r\n\r\n\t\t\tdelete _webglObjects[ object.id ];\r\n\r\n\t\t} else if ( object instanceof THREE.ImmediateRenderObject || object.immediateRenderCallback ) {\r\n\r\n\t\t\tremoveInstances( _webglObjectsImmediate, object );\r\n\r\n\t\t}\r\n\r\n\t\tdelete object.__webglInit;\r\n\t\tdelete object._modelViewMatrix;\r\n\t\tdelete object._normalMatrix;\r\n\r\n\t\tdelete object.__webglActive;\r\n\r\n\t}\r\n\r\n\tfunction removeInstances( objlist, object ) {\r\n\r\n\t\tfor ( var o = objlist.length - 1; o >= 0; o -- ) {\r\n\r\n\t\t\tif ( objlist[ o ].object === object ) {\r\n\r\n\t\t\t\tobjlist.splice( o, 1 );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// Materials\r\n\r\n\tvar shaderIDs = {\r\n\t\tMeshDepthMaterial: 'depth',\r\n\t\tMeshNormalMaterial: 'normal',\r\n\t\tMeshBasicMaterial: 'basic',\r\n\t\tMeshLambertMaterial: 'lambert',\r\n\t\tMeshPhongMaterial: 'phong',\r\n\t\tLineBasicMaterial: 'basic',\r\n\t\tLineDashedMaterial: 'dashed',\r\n\t\tPointCloudMaterial: 'particle_basic'\r\n\t};\r\n\r\n\tfunction initMaterial( material, lights, fog, object ) {\r\n\r\n\t\tmaterial.addEventListener( 'dispose', onMaterialDispose );\r\n\r\n\t\tvar shaderID = shaderIDs[ material.type ];\r\n\r\n\t\tif ( shaderID ) {\r\n\r\n\t\t\tvar shader = THREE.ShaderLib[ shaderID ];\r\n\r\n\t\t\tmaterial.__webglShader = {\r\n\t\t\t\tuniforms: THREE.UniformsUtils.clone( shader.uniforms ),\r\n\t\t\t\tvertexShader: shader.vertexShader,\r\n\t\t\t\tfragmentShader: shader.fragmentShader\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\tmaterial.__webglShader = {\r\n\t\t\t\tuniforms: material.uniforms,\r\n\t\t\t\tvertexShader: material.vertexShader,\r\n\t\t\t\tfragmentShader: material.fragmentShader\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// heuristics to create shader parameters according to lights in the scene\r\n\t\t// (not to blow over maxLights budget)\r\n\r\n\t\tvar maxLightCount = allocateLights( lights );\r\n\t\tvar maxShadows = allocateShadows( lights );\r\n\t\tvar maxBones = allocateBones( object );\r\n\r\n\t\tvar parameters = {\r\n\r\n\t\t\tprecision: _precision,\r\n\t\t\tsupportsVertexTextures: _supportsVertexTextures,\r\n\r\n\t\t\tmap: !! material.map,\r\n\t\t\tenvMap: !! material.envMap,\r\n\t\t\tenvMapMode: material.envMap && material.envMap.mapping,\r\n\t\t\tlightMap: !! material.lightMap,\r\n\t\t\tbumpMap: !! material.bumpMap,\r\n\t\t\tnormalMap: !! material.normalMap,\r\n\t\t\tspecularMap: !! material.specularMap,\r\n\t\t\talphaMap: !! material.alphaMap,\r\n\r\n\t\t\tcombine: material.combine,\r\n\r\n\t\t\tvertexColors: material.vertexColors,\r\n\r\n\t\t\tfog: fog,\r\n\t\t\tuseFog: material.fog,\r\n\t\t\tfogExp: fog instanceof THREE.FogExp2,\r\n\r\n\t\t\tflatShading: material.shading === THREE.FlatShading,\r\n\r\n\t\t\tsizeAttenuation: material.sizeAttenuation,\r\n\t\t\tlogarithmicDepthBuffer: _logarithmicDepthBuffer,\r\n\r\n\t\t\tskinning: material.skinning,\r\n\t\t\tmaxBones: maxBones,\r\n\t\t\tuseVertexTexture: _supportsBoneTextures && object && object.skeleton && object.skeleton.useVertexTexture,\r\n\r\n\t\t\tmorphTargets: material.morphTargets,\r\n\t\t\tmorphNormals: material.morphNormals,\r\n\t\t\tmaxMorphTargets: _this.maxMorphTargets,\r\n\t\t\tmaxMorphNormals: _this.maxMorphNormals,\r\n\r\n\t\t\tmaxDirLights: maxLightCount.directional,\r\n\t\t\tmaxPointLights: maxLightCount.point,\r\n\t\t\tmaxSpotLights: maxLightCount.spot,\r\n\t\t\tmaxHemiLights: maxLightCount.hemi,\r\n\r\n\t\t\tmaxShadows: maxShadows,\r\n\t\t\tshadowMapEnabled: _this.shadowMapEnabled && object.receiveShadow && maxShadows > 0,\r\n\t\t\tshadowMapType: _this.shadowMapType,\r\n\t\t\tshadowMapDebug: _this.shadowMapDebug,\r\n\t\t\tshadowMapCascade: _this.shadowMapCascade,\r\n\r\n\t\t\talphaTest: material.alphaTest,\r\n\t\t\tmetal: material.metal,\r\n\t\t\twrapAround: material.wrapAround,\r\n\t\t\tdoubleSided: material.side === THREE.DoubleSide,\r\n\t\t\tflipSided: material.side === THREE.BackSide\r\n\r\n\t\t};\r\n\r\n\t\t// Generate code\r\n\r\n\t\tvar chunks = [];\r\n\r\n\t\tif ( shaderID ) {\r\n\r\n\t\t\tchunks.push( shaderID );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tchunks.push( material.fragmentShader );\r\n\t\t\tchunks.push( material.vertexShader );\r\n\r\n\t\t}\r\n\r\n\t\tif ( material.defines !== undefined ) {\r\n\r\n\t\t\tfor ( var name in material.defines ) {\r\n\r\n\t\t\t\tchunks.push( name );\r\n\t\t\t\tchunks.push( material.defines[ name ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tfor ( var name in parameters ) {\r\n\r\n\t\t\tchunks.push( name );\r\n\t\t\tchunks.push( parameters[ name ] );\r\n\r\n\t\t}\r\n\r\n\t\tvar code = chunks.join();\r\n\r\n\t\tvar program;\r\n\r\n\t\t// Check if code has been already compiled\r\n\r\n\t\tfor ( var p = 0, pl = _programs.length; p < pl; p ++ ) {\r\n\r\n\t\t\tvar programInfo = _programs[ p ];\r\n\r\n\t\t\tif ( programInfo.code === code ) {\r\n\r\n\t\t\t\tprogram = programInfo;\r\n\t\t\t\tprogram.usedTimes ++;\r\n\r\n\t\t\t\tbreak;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( program === undefined ) {\r\n\r\n\t\t\tprogram = new THREE.WebGLProgram( _this, code, material, parameters );\r\n\t\t\t_programs.push( program );\r\n\r\n\t\t\t_this.info.memory.programs = _programs.length;\r\n\r\n\t\t}\r\n\r\n\t\tmaterial.program = program;\r\n\r\n\t\tvar attributes = program.attributes;\r\n\r\n\t\tif ( material.morphTargets ) {\r\n\r\n\t\t\tmaterial.numSupportedMorphTargets = 0;\r\n\r\n\t\t\tvar id, base = 'morphTarget';\r\n\r\n\t\t\tfor ( var i = 0; i < _this.maxMorphTargets; i ++ ) {\r\n\r\n\t\t\t\tid = base + i;\r\n\r\n\t\t\t\tif ( attributes[ id ] >= 0 ) {\r\n\r\n\t\t\t\t\tmaterial.numSupportedMorphTargets ++;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( material.morphNormals ) {\r\n\r\n\t\t\tmaterial.numSupportedMorphNormals = 0;\r\n\r\n\t\t\tvar id, base = 'morphNormal';\r\n\r\n\t\t\tfor ( i = 0; i < _this.maxMorphNormals; i ++ ) {\r\n\r\n\t\t\t\tid = base + i;\r\n\r\n\t\t\t\tif ( attributes[ id ] >= 0 ) {\r\n\r\n\t\t\t\t\tmaterial.numSupportedMorphNormals ++;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tmaterial.uniformsList = [];\r\n\r\n\t\tfor ( var u in material.__webglShader.uniforms ) {\r\n\r\n\t\t\tvar location = material.program.uniforms[ u ];\r\n\r\n\t\t\tif ( location ) {\r\n\t\t\t\tmaterial.uniformsList.push( [ material.__webglShader.uniforms[ u ], location ] );\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction setMaterial( material ) {\r\n\r\n\t\tif ( material.transparent === true ) {\r\n\r\n\t\t\tstate.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tstate.setBlending( THREE.NoBlending );\r\n\r\n\t\t}\r\n\r\n\t\tstate.setDepthTest( material.depthTest );\r\n\t\tstate.setDepthWrite( material.depthWrite );\r\n\t\tstate.setColorWrite( material.colorWrite );\r\n\t\tstate.setPolygonOffset( material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits );\r\n\r\n\t}\r\n\r\n\tfunction setProgram( camera, lights, fog, material, object ) {\r\n\r\n\t\t_usedTextureUnits = 0;\r\n\r\n\t\tif ( material.needsUpdate ) {\r\n\r\n\t\t\tif ( material.program ) deallocateMaterial( material );\r\n\r\n\t\t\tinitMaterial( material, lights, fog, object );\r\n\t\t\tmaterial.needsUpdate = false;\r\n\r\n\t\t}\r\n\r\n\t\tif ( material.morphTargets ) {\r\n\r\n\t\t\tif ( ! object.__webglMorphTargetInfluences ) {\r\n\r\n\t\t\t\tobject.__webglMorphTargetInfluences = new Float32Array( _this.maxMorphTargets );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tvar refreshProgram = false;\r\n\t\tvar refreshMaterial = false;\r\n\t\tvar refreshLights = false;\r\n\r\n\t\tvar program = material.program,\r\n\t\t\tp_uniforms = program.uniforms,\r\n\t\t\tm_uniforms = material.__webglShader.uniforms;\r\n\r\n\t\tif ( program.id !== _currentProgram ) {\r\n\r\n\t\t\t_gl.useProgram( program.program );\r\n\t\t\t_currentProgram = program.id;\r\n\r\n\t\t\trefreshProgram = true;\r\n\t\t\trefreshMaterial = true;\r\n\t\t\trefreshLights = true;\r\n\r\n\t\t}\r\n\r\n\t\tif ( material.id !== _currentMaterialId ) {\r\n\r\n\t\t\tif ( _currentMaterialId === -1 ) refreshLights = true;\r\n\t\t\t_currentMaterialId = material.id;\r\n\r\n\t\t\trefreshMaterial = true;\r\n\r\n\t\t}\r\n\r\n\t\tif ( refreshProgram || camera !== _currentCamera ) {\r\n\r\n\t\t\t_gl.uniformMatrix4fv( p_uniforms.projectionMatrix, false, camera.projectionMatrix.elements );\r\n\r\n\t\t\tif ( _logarithmicDepthBuffer ) {\r\n\r\n\t\t\t\t_gl.uniform1f( p_uniforms.logDepthBufFC, 2.0 / ( Math.log( camera.far + 1.0 ) / Math.LN2 ) );\r\n\r\n\t\t\t}\r\n\r\n\r\n\t\t\tif ( camera !== _currentCamera ) _currentCamera = camera;\r\n\r\n\t\t\t// load material specific uniforms\r\n\t\t\t// (shader material also gets them for the sake of genericity)\r\n\r\n\t\t\tif ( material instanceof THREE.ShaderMaterial ||\r\n\t\t\t\t material instanceof THREE.MeshPhongMaterial ||\r\n\t\t\t\t material.envMap ) {\r\n\r\n\t\t\t\tif ( p_uniforms.cameraPosition !== null ) {\r\n\r\n\t\t\t\t\t_vector3.setFromMatrixPosition( camera.matrixWorld );\r\n\t\t\t\t\t_gl.uniform3f( p_uniforms.cameraPosition, _vector3.x, _vector3.y, _vector3.z );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( material instanceof THREE.MeshPhongMaterial ||\r\n\t\t\t\t material instanceof THREE.MeshLambertMaterial ||\r\n\t\t\t\t material instanceof THREE.MeshBasicMaterial ||\r\n\t\t\t\t material instanceof THREE.ShaderMaterial ||\r\n\t\t\t\t material.skinning ) {\r\n\r\n\t\t\t\tif ( p_uniforms.viewMatrix !== null ) {\r\n\r\n\t\t\t\t\t_gl.uniformMatrix4fv( p_uniforms.viewMatrix, false, camera.matrixWorldInverse.elements );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// skinning uniforms must be set even if material didn't change\r\n\t\t// auto-setting of texture unit for bone texture must go before other textures\r\n\t\t// not sure why, but otherwise weird things happen\r\n\r\n\t\tif ( material.skinning ) {\r\n\r\n\t\t\tif ( object.bindMatrix && p_uniforms.bindMatrix !== null ) {\r\n\r\n\t\t\t\t_gl.uniformMatrix4fv( p_uniforms.bindMatrix, false, object.bindMatrix.elements );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( object.bindMatrixInverse && p_uniforms.bindMatrixInverse !== null ) {\r\n\r\n\t\t\t\t_gl.uniformMatrix4fv( p_uniforms.bindMatrixInverse, false, object.bindMatrixInverse.elements );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( _supportsBoneTextures && object.skeleton && object.skeleton.useVertexTexture ) {\r\n\r\n\t\t\t\tif ( p_uniforms.boneTexture !== null ) {\r\n\r\n\t\t\t\t\tvar textureUnit = getTextureUnit();\r\n\r\n\t\t\t\t\t_gl.uniform1i( p_uniforms.boneTexture, textureUnit );\r\n\t\t\t\t\t_this.setTexture( object.skeleton.boneTexture, textureUnit );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( p_uniforms.boneTextureWidth !== null ) {\r\n\r\n\t\t\t\t\t_gl.uniform1i( p_uniforms.boneTextureWidth, object.skeleton.boneTextureWidth );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( p_uniforms.boneTextureHeight !== null ) {\r\n\r\n\t\t\t\t\t_gl.uniform1i( p_uniforms.boneTextureHeight, object.skeleton.boneTextureHeight );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else if ( object.skeleton && object.skeleton.boneMatrices ) {\r\n\r\n\t\t\t\tif ( p_uniforms.boneGlobalMatrices !== null ) {\r\n\r\n\t\t\t\t\t_gl.uniformMatrix4fv( p_uniforms.boneGlobalMatrices, false, object.skeleton.boneMatrices );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( refreshMaterial ) {\r\n\r\n\t\t\t// refresh uniforms common to several materials\r\n\r\n\t\t\tif ( fog && material.fog ) {\r\n\r\n\t\t\t\trefreshUniformsFog( m_uniforms, fog );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( material instanceof THREE.MeshPhongMaterial ||\r\n\t\t\t\t material instanceof THREE.MeshLambertMaterial ||\r\n\t\t\t\t material.lights ) {\r\n\r\n\t\t\t\tif ( _lightsNeedUpdate ) {\r\n\r\n\t\t\t\t\trefreshLights = true;\r\n\t\t\t\t\tsetupLights( lights );\r\n\t\t\t\t\t_lightsNeedUpdate = false;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( refreshLights ) {\r\n\t\t\t\t\trefreshUniformsLights( m_uniforms, _lights );\r\n\t\t\t\t\tmarkUniformsLightsNeedsUpdate( m_uniforms, true );\r\n\t\t\t\t} else {\r\n\t\t\t\t\tmarkUniformsLightsNeedsUpdate( m_uniforms, false );\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( material instanceof THREE.MeshBasicMaterial ||\r\n\t\t\t\t material instanceof THREE.MeshLambertMaterial ||\r\n\t\t\t\t material instanceof THREE.MeshPhongMaterial ) {\r\n\r\n\t\t\t\trefreshUniformsCommon( m_uniforms, material );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// refresh single material specific uniforms\r\n\r\n\t\t\tif ( material instanceof THREE.LineBasicMaterial ) {\r\n\r\n\t\t\t\trefreshUniformsLine( m_uniforms, material );\r\n\r\n\t\t\t} else if ( material instanceof THREE.LineDashedMaterial ) {\r\n\r\n\t\t\t\trefreshUniformsLine( m_uniforms, material );\r\n\t\t\t\trefreshUniformsDash( m_uniforms, material );\r\n\r\n\t\t\t} else if ( material instanceof THREE.PointCloudMaterial ) {\r\n\r\n\t\t\t\trefreshUniformsParticle( m_uniforms, material );\r\n\r\n\t\t\t} else if ( material instanceof THREE.MeshPhongMaterial ) {\r\n\r\n\t\t\t\trefreshUniformsPhong( m_uniforms, material );\r\n\r\n\t\t\t} else if ( material instanceof THREE.MeshLambertMaterial ) {\r\n\r\n\t\t\t\trefreshUniformsLambert( m_uniforms, material );\r\n\r\n\t\t\t} else if ( material instanceof THREE.MeshDepthMaterial ) {\r\n\r\n\t\t\t\tm_uniforms.mNear.value = camera.near;\r\n\t\t\t\tm_uniforms.mFar.value = camera.far;\r\n\t\t\t\tm_uniforms.opacity.value = material.opacity;\r\n\r\n\t\t\t} else if ( material instanceof THREE.MeshNormalMaterial ) {\r\n\r\n\t\t\t\tm_uniforms.opacity.value = material.opacity;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( object.receiveShadow && ! material._shadowPass ) {\r\n\r\n\t\t\t\trefreshUniformsShadow( m_uniforms, lights );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// load common uniforms\r\n\r\n\t\t\tloadUniformsGeneric( material.uniformsList );\r\n\r\n\t\t}\r\n\r\n\t\tloadUniformsMatrices( p_uniforms, object );\r\n\r\n\t\tif ( p_uniforms.modelMatrix !== null ) {\r\n\r\n\t\t\t_gl.uniformMatrix4fv( p_uniforms.modelMatrix, false, object.matrixWorld.elements );\r\n\r\n\t\t}\r\n\r\n\t\treturn program;\r\n\r\n\t}\r\n\r\n\t// Uniforms (refresh uniforms objects)\r\n\r\n\tfunction refreshUniformsCommon ( uniforms, material ) {\r\n\r\n\t\tuniforms.opacity.value = material.opacity;\r\n\r\n\t\tuniforms.diffuse.value = material.color;\r\n\r\n\t\tuniforms.map.value = material.map;\r\n\t\tuniforms.lightMap.value = material.lightMap;\r\n\t\tuniforms.specularMap.value = material.specularMap;\r\n\t\tuniforms.alphaMap.value = material.alphaMap;\r\n\r\n\t\tif ( material.bumpMap ) {\r\n\r\n\t\t\tuniforms.bumpMap.value = material.bumpMap;\r\n\t\t\tuniforms.bumpScale.value = material.bumpScale;\r\n\r\n\t\t}\r\n\r\n\t\tif ( material.normalMap ) {\r\n\r\n\t\t\tuniforms.normalMap.value = material.normalMap;\r\n\t\t\tuniforms.normalScale.value.copy( material.normalScale );\r\n\r\n\t\t}\r\n\r\n\t\t// uv repeat and offset setting priorities\r\n\t\t//  1. color map\r\n\t\t//  2. specular map\r\n\t\t//  3. normal map\r\n\t\t//  4. bump map\r\n\t\t//  5. alpha map\r\n\r\n\t\tvar uvScaleMap;\r\n\r\n\t\tif ( material.map ) {\r\n\r\n\t\t\tuvScaleMap = material.map;\r\n\r\n\t\t} else if ( material.specularMap ) {\r\n\r\n\t\t\tuvScaleMap = material.specularMap;\r\n\r\n\t\t} else if ( material.normalMap ) {\r\n\r\n\t\t\tuvScaleMap = material.normalMap;\r\n\r\n\t\t} else if ( material.bumpMap ) {\r\n\r\n\t\t\tuvScaleMap = material.bumpMap;\r\n\r\n\t\t} else if ( material.alphaMap ) {\r\n\r\n\t\t\tuvScaleMap = material.alphaMap;\r\n\r\n\t\t}\r\n\r\n\t\tif ( uvScaleMap !== undefined ) {\r\n\r\n\t\t\tvar offset = uvScaleMap.offset;\r\n\t\t\tvar repeat = uvScaleMap.repeat;\r\n\r\n\t\t\tuniforms.offsetRepeat.value.set( offset.x, offset.y, repeat.x, repeat.y );\r\n\r\n\t\t}\r\n\r\n\t\tuniforms.envMap.value = material.envMap;\r\n\t\tuniforms.flipEnvMap.value = ( material.envMap instanceof THREE.WebGLRenderTargetCube ) ? 1 : - 1;\r\n\r\n\t\tuniforms.reflectivity.value = material.reflectivity;\r\n\t\tuniforms.refractionRatio.value = material.refractionRatio;\r\n\r\n\t}\r\n\r\n\tfunction refreshUniformsLine ( uniforms, material ) {\r\n\r\n\t\tuniforms.diffuse.value = material.color;\r\n\t\tuniforms.opacity.value = material.opacity;\r\n\r\n\t}\r\n\r\n\tfunction refreshUniformsDash ( uniforms, material ) {\r\n\r\n\t\tuniforms.dashSize.value = material.dashSize;\r\n\t\tuniforms.totalSize.value = material.dashSize + material.gapSize;\r\n\t\tuniforms.scale.value = material.scale;\r\n\r\n\t}\r\n\r\n\tfunction refreshUniformsParticle ( uniforms, material ) {\r\n\r\n\t\tuniforms.psColor.value = material.color;\r\n\t\tuniforms.opacity.value = material.opacity;\r\n\t\tuniforms.size.value = material.size;\r\n\t\tuniforms.scale.value = _canvas.height / 2.0; // TODO: Cache this.\r\n\r\n\t\tuniforms.map.value = material.map;\r\n\r\n\t\tif ( material.map !== null ) {\r\n\r\n\t\t\tvar offset = material.map.offset;\r\n\t\t\tvar repeat = material.map.repeat;\r\n\r\n\t\t\tuniforms.offsetRepeat.value.set( offset.x, offset.y, repeat.x, repeat.y );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction refreshUniformsFog ( uniforms, fog ) {\r\n\r\n\t\tuniforms.fogColor.value = fog.color;\r\n\r\n\t\tif ( fog instanceof THREE.Fog ) {\r\n\r\n\t\t\tuniforms.fogNear.value = fog.near;\r\n\t\t\tuniforms.fogFar.value = fog.far;\r\n\r\n\t\t} else if ( fog instanceof THREE.FogExp2 ) {\r\n\r\n\t\t\tuniforms.fogDensity.value = fog.density;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction refreshUniformsPhong ( uniforms, material ) {\r\n\r\n\t\tuniforms.shininess.value = material.shininess;\r\n\r\n\t\tuniforms.emissive.value = material.emissive;\r\n\t\tuniforms.specular.value = material.specular;\r\n\r\n\t\tif ( material.wrapAround ) {\r\n\r\n\t\t\tuniforms.wrapRGB.value.copy( material.wrapRGB );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction refreshUniformsLambert ( uniforms, material ) {\r\n\r\n\t\tuniforms.emissive.value = material.emissive;\r\n\r\n\t\tif ( material.wrapAround ) {\r\n\r\n\t\t\tuniforms.wrapRGB.value.copy( material.wrapRGB );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction refreshUniformsLights ( uniforms, lights ) {\r\n\r\n\t\tuniforms.ambientLightColor.value = lights.ambient;\r\n\r\n\t\tuniforms.directionalLightColor.value = lights.directional.colors;\r\n\t\tuniforms.directionalLightDirection.value = lights.directional.positions;\r\n\r\n\t\tuniforms.pointLightColor.value = lights.point.colors;\r\n\t\tuniforms.pointLightPosition.value = lights.point.positions;\r\n\t\tuniforms.pointLightDistance.value = lights.point.distances;\r\n\t\tuniforms.pointLightDecay.value = lights.point.decays;\r\n\r\n\t\tuniforms.spotLightColor.value = lights.spot.colors;\r\n\t\tuniforms.spotLightPosition.value = lights.spot.positions;\r\n\t\tuniforms.spotLightDistance.value = lights.spot.distances;\r\n\t\tuniforms.spotLightDirection.value = lights.spot.directions;\r\n\t\tuniforms.spotLightAngleCos.value = lights.spot.anglesCos;\r\n\t\tuniforms.spotLightExponent.value = lights.spot.exponents;\r\n\t\tuniforms.spotLightDecay.value = lights.spot.decays;\r\n\r\n\t\tuniforms.hemisphereLightSkyColor.value = lights.hemi.skyColors;\r\n\t\tuniforms.hemisphereLightGroundColor.value = lights.hemi.groundColors;\r\n\t\tuniforms.hemisphereLightDirection.value = lights.hemi.positions;\r\n\r\n\t}\r\n\r\n\t// If uniforms are marked as clean, they don't need to be loaded to the GPU.\r\n\r\n\tfunction markUniformsLightsNeedsUpdate ( uniforms, value ) {\r\n\r\n\t\tuniforms.ambientLightColor.needsUpdate = value;\r\n\r\n\t\tuniforms.directionalLightColor.needsUpdate = value;\r\n\t\tuniforms.directionalLightDirection.needsUpdate = value;\r\n\r\n\t\tuniforms.pointLightColor.needsUpdate = value;\r\n\t\tuniforms.pointLightPosition.needsUpdate = value;\r\n\t\tuniforms.pointLightDistance.needsUpdate = value;\r\n\t\tuniforms.pointLightDecay.needsUpdate = value;\r\n\r\n\t\tuniforms.spotLightColor.needsUpdate = value;\r\n\t\tuniforms.spotLightPosition.needsUpdate = value;\r\n\t\tuniforms.spotLightDistance.needsUpdate = value;\r\n\t\tuniforms.spotLightDirection.needsUpdate = value;\r\n\t\tuniforms.spotLightAngleCos.needsUpdate = value;\r\n\t\tuniforms.spotLightExponent.needsUpdate = value;\r\n\t\tuniforms.spotLightDecay.needsUpdate = value;\r\n\r\n\t\tuniforms.hemisphereLightSkyColor.needsUpdate = value;\r\n\t\tuniforms.hemisphereLightGroundColor.needsUpdate = value;\r\n\t\tuniforms.hemisphereLightDirection.needsUpdate = value;\r\n\r\n\t}\r\n\r\n\tfunction refreshUniformsShadow ( uniforms, lights ) {\r\n\r\n\t\tif ( uniforms.shadowMatrix ) {\r\n\r\n\t\t\tvar j = 0;\r\n\r\n\t\t\tfor ( var i = 0, il = lights.length; i < il; i ++ ) {\r\n\r\n\t\t\t\tvar light = lights[ i ];\r\n\r\n\t\t\t\tif ( ! light.castShadow ) continue;\r\n\r\n\t\t\t\tif ( light instanceof THREE.SpotLight || ( light instanceof THREE.DirectionalLight && ! light.shadowCascade ) ) {\r\n\r\n\t\t\t\t\tuniforms.shadowMap.value[ j ] = light.shadowMap;\r\n\t\t\t\t\tuniforms.shadowMapSize.value[ j ] = light.shadowMapSize;\r\n\r\n\t\t\t\t\tuniforms.shadowMatrix.value[ j ] = light.shadowMatrix;\r\n\r\n\t\t\t\t\tuniforms.shadowDarkness.value[ j ] = light.shadowDarkness;\r\n\t\t\t\t\tuniforms.shadowBias.value[ j ] = light.shadowBias;\r\n\r\n\t\t\t\t\tj ++;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// Uniforms (load to GPU)\r\n\r\n\tfunction loadUniformsMatrices ( uniforms, object ) {\r\n\r\n\t\t_gl.uniformMatrix4fv( uniforms.modelViewMatrix, false, object._modelViewMatrix.elements );\r\n\r\n\t\tif ( uniforms.normalMatrix ) {\r\n\r\n\t\t\t_gl.uniformMatrix3fv( uniforms.normalMatrix, false, object._normalMatrix.elements );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction getTextureUnit() {\r\n\r\n\t\tvar textureUnit = _usedTextureUnits;\r\n\r\n\t\tif ( textureUnit >= _maxTextures ) {\r\n\r\n\t\t\tTHREE.warn( 'WebGLRenderer: trying to use ' + textureUnit + ' texture units while this GPU supports only ' + _maxTextures );\r\n\r\n\t\t}\r\n\r\n\t\t_usedTextureUnits += 1;\r\n\r\n\t\treturn textureUnit;\r\n\r\n\t}\r\n\r\n\tfunction loadUniformsGeneric ( uniforms ) {\r\n\r\n\t\tvar texture, textureUnit, offset;\r\n\r\n\t\tfor ( var j = 0, jl = uniforms.length; j < jl; j ++ ) {\r\n\r\n\t\t\tvar uniform = uniforms[ j ][ 0 ];\r\n\r\n\t\t\t// needsUpdate property is not added to all uniforms.\r\n\t\t\tif ( uniform.needsUpdate === false ) continue;\r\n\r\n\t\t\tvar type = uniform.type;\r\n\t\t\tvar value = uniform.value;\r\n\t\t\tvar location = uniforms[ j ][ 1 ];\r\n\r\n\t\t\tswitch ( type ) {\r\n\r\n\t\t\t\tcase '1i':\r\n\t\t\t\t\t_gl.uniform1i( location, value );\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase '1f':\r\n\t\t\t\t\t_gl.uniform1f( location, value );\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase '2f':\r\n\t\t\t\t\t_gl.uniform2f( location, value[ 0 ], value[ 1 ] );\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase '3f':\r\n\t\t\t\t\t_gl.uniform3f( location, value[ 0 ], value[ 1 ], value[ 2 ] );\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase '4f':\r\n\t\t\t\t\t_gl.uniform4f( location, value[ 0 ], value[ 1 ], value[ 2 ], value[ 3 ] );\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase '1iv':\r\n\t\t\t\t\t_gl.uniform1iv( location, value );\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase '3iv':\r\n\t\t\t\t\t_gl.uniform3iv( location, value );\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase '1fv':\r\n\t\t\t\t\t_gl.uniform1fv( location, value );\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase '2fv':\r\n\t\t\t\t\t_gl.uniform2fv( location, value );\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase '3fv':\r\n\t\t\t\t\t_gl.uniform3fv( location, value );\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase '4fv':\r\n\t\t\t\t\t_gl.uniform4fv( location, value );\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'Matrix3fv':\r\n\t\t\t\t\t_gl.uniformMatrix3fv( location, false, value );\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'Matrix4fv':\r\n\t\t\t\t\t_gl.uniformMatrix4fv( location, false, value );\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t//\r\n\r\n\t\t\t\tcase 'i':\r\n\r\n\t\t\t\t\t// single integer\r\n\t\t\t\t\t_gl.uniform1i( location, value );\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'f':\r\n\r\n\t\t\t\t\t// single float\r\n\t\t\t\t\t_gl.uniform1f( location, value );\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'v2':\r\n\r\n\t\t\t\t\t// single THREE.Vector2\r\n\t\t\t\t\t_gl.uniform2f( location, value.x, value.y );\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'v3':\r\n\r\n\t\t\t\t\t// single THREE.Vector3\r\n\t\t\t\t\t_gl.uniform3f( location, value.x, value.y, value.z );\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'v4':\r\n\r\n\t\t\t\t\t// single THREE.Vector4\r\n\t\t\t\t\t_gl.uniform4f( location, value.x, value.y, value.z, value.w );\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'c':\r\n\r\n\t\t\t\t\t// single THREE.Color\r\n\t\t\t\t\t_gl.uniform3f( location, value.r, value.g, value.b );\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'iv1':\r\n\r\n\t\t\t\t\t// flat array of integers (JS or typed array)\r\n\t\t\t\t\t_gl.uniform1iv( location, value );\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'iv':\r\n\r\n\t\t\t\t\t// flat array of integers with 3 x N size (JS or typed array)\r\n\t\t\t\t\t_gl.uniform3iv( location, value );\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'fv1':\r\n\r\n\t\t\t\t\t// flat array of floats (JS or typed array)\r\n\t\t\t\t\t_gl.uniform1fv( location, value );\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'fv':\r\n\r\n\t\t\t\t\t// flat array of floats with 3 x N size (JS or typed array)\r\n\t\t\t\t\t_gl.uniform3fv( location, value );\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'v2v':\r\n\r\n\t\t\t\t\t// array of THREE.Vector2\r\n\r\n\t\t\t\t\tif ( uniform._array === undefined ) {\r\n\r\n\t\t\t\t\t\tuniform._array = new Float32Array( 2 * value.length );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tfor ( var i = 0, il = value.length; i < il; i ++ ) {\r\n\r\n\t\t\t\t\t\toffset = i * 2;\r\n\r\n\t\t\t\t\t\tuniform._array[ offset ]   = value[ i ].x;\r\n\t\t\t\t\t\tuniform._array[ offset + 1 ] = value[ i ].y;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t_gl.uniform2fv( location, uniform._array );\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'v3v':\r\n\r\n\t\t\t\t\t// array of THREE.Vector3\r\n\r\n\t\t\t\t\tif ( uniform._array === undefined ) {\r\n\r\n\t\t\t\t\t\tuniform._array = new Float32Array( 3 * value.length );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tfor ( var i = 0, il = value.length; i < il; i ++ ) {\r\n\r\n\t\t\t\t\t\toffset = i * 3;\r\n\r\n\t\t\t\t\t\tuniform._array[ offset ]   = value[ i ].x;\r\n\t\t\t\t\t\tuniform._array[ offset + 1 ] = value[ i ].y;\r\n\t\t\t\t\t\tuniform._array[ offset + 2 ] = value[ i ].z;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t_gl.uniform3fv( location, uniform._array );\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'v4v':\r\n\r\n\t\t\t\t\t// array of THREE.Vector4\r\n\r\n\t\t\t\t\tif ( uniform._array === undefined ) {\r\n\r\n\t\t\t\t\t\tuniform._array = new Float32Array( 4 * value.length );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tfor ( var i = 0, il = value.length; i < il; i ++ ) {\r\n\r\n\t\t\t\t\t\toffset = i * 4;\r\n\r\n\t\t\t\t\t\tuniform._array[ offset ]   = value[ i ].x;\r\n\t\t\t\t\t\tuniform._array[ offset + 1 ] = value[ i ].y;\r\n\t\t\t\t\t\tuniform._array[ offset + 2 ] = value[ i ].z;\r\n\t\t\t\t\t\tuniform._array[ offset + 3 ] = value[ i ].w;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t_gl.uniform4fv( location, uniform._array );\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'm3':\r\n\r\n\t\t\t\t\t// single THREE.Matrix3\r\n\t\t\t\t\t_gl.uniformMatrix3fv( location, false, value.elements );\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'm3v':\r\n\r\n\t\t\t\t\t// array of THREE.Matrix3\r\n\r\n\t\t\t\t\tif ( uniform._array === undefined ) {\r\n\r\n\t\t\t\t\t\tuniform._array = new Float32Array( 9 * value.length );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tfor ( var i = 0, il = value.length; i < il; i ++ ) {\r\n\r\n\t\t\t\t\t\tvalue[ i ].flattenToArrayOffset( uniform._array, i * 9 );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t_gl.uniformMatrix3fv( location, false, uniform._array );\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'm4':\r\n\r\n\t\t\t\t\t// single THREE.Matrix4\r\n\t\t\t\t\t_gl.uniformMatrix4fv( location, false, value.elements );\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'm4v':\r\n\r\n\t\t\t\t\t// array of THREE.Matrix4\r\n\r\n\t\t\t\t\tif ( uniform._array === undefined ) {\r\n\r\n\t\t\t\t\t\tuniform._array = new Float32Array( 16 * value.length );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tfor ( var i = 0, il = value.length; i < il; i ++ ) {\r\n\r\n\t\t\t\t\t\tvalue[ i ].flattenToArrayOffset( uniform._array, i * 16 );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t_gl.uniformMatrix4fv( location, false, uniform._array );\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 't':\r\n\r\n\t\t\t\t\t// single THREE.Texture (2d or cube)\r\n\r\n\t\t\t\t\ttexture = value;\r\n\t\t\t\t\ttextureUnit = getTextureUnit();\r\n\r\n\t\t\t\t\t_gl.uniform1i( location, textureUnit );\r\n\r\n\t\t\t\t\tif ( ! texture ) continue;\r\n\r\n\t\t\t\t\tif ( texture instanceof THREE.CubeTexture ||\r\n\t\t\t\t\t   ( texture.image instanceof Array && texture.image.length === 6 ) ) { // CompressedTexture can have Array in image :/\r\n\r\n\t\t\t\t\t\tsetCubeTexture( texture, textureUnit );\r\n\r\n\t\t\t\t\t} else if ( texture instanceof THREE.WebGLRenderTargetCube ) {\r\n\r\n\t\t\t\t\t\tsetCubeTextureDynamic( texture, textureUnit );\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t_this.setTexture( texture, textureUnit );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'tv':\r\n\r\n\t\t\t\t\t// array of THREE.Texture (2d)\r\n\r\n\t\t\t\t\tif ( uniform._array === undefined ) {\r\n\r\n\t\t\t\t\t\tuniform._array = [];\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tfor ( var i = 0, il = uniform.value.length; i < il; i ++ ) {\r\n\r\n\t\t\t\t\t\tuniform._array[ i ] = getTextureUnit();\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t_gl.uniform1iv( location, uniform._array );\r\n\r\n\t\t\t\t\tfor ( var i = 0, il = uniform.value.length; i < il; i ++ ) {\r\n\r\n\t\t\t\t\t\ttexture = uniform.value[ i ];\r\n\t\t\t\t\t\ttextureUnit = uniform._array[ i ];\r\n\r\n\t\t\t\t\t\tif ( ! texture ) continue;\r\n\r\n\t\t\t\t\t\t_this.setTexture( texture, textureUnit );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tdefault:\r\n\r\n\t\t\t\t\tTHREE.warn( 'THREE.WebGLRenderer: Unknown uniform type: ' + type );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction setupMatrices ( object, camera ) {\r\n\r\n\t\tobject._modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );\r\n\t\tobject._normalMatrix.getNormalMatrix( object._modelViewMatrix );\r\n\r\n\t}\r\n\r\n\tfunction setColorLinear( array, offset, color, intensity ) {\r\n\r\n\t\tarray[ offset ]     = color.r * intensity;\r\n\t\tarray[ offset + 1 ] = color.g * intensity;\r\n\t\tarray[ offset + 2 ] = color.b * intensity;\r\n\r\n\t}\r\n\r\n\tfunction setupLights ( lights ) {\r\n\r\n\t\tvar l, ll, light,\r\n\t\tr = 0, g = 0, b = 0,\r\n\t\tcolor, skyColor, groundColor,\r\n\t\tintensity,\r\n\t\tdistance,\r\n\r\n\t\tzlights = _lights,\r\n\r\n\t\tdirColors = zlights.directional.colors,\r\n\t\tdirPositions = zlights.directional.positions,\r\n\r\n\t\tpointColors = zlights.point.colors,\r\n\t\tpointPositions = zlights.point.positions,\r\n\t\tpointDistances = zlights.point.distances,\r\n\t\tpointDecays = zlights.point.decays,\r\n\r\n\t\tspotColors = zlights.spot.colors,\r\n\t\tspotPositions = zlights.spot.positions,\r\n\t\tspotDistances = zlights.spot.distances,\r\n\t\tspotDirections = zlights.spot.directions,\r\n\t\tspotAnglesCos = zlights.spot.anglesCos,\r\n\t\tspotExponents = zlights.spot.exponents,\r\n\t\tspotDecays = zlights.spot.decays,\r\n\r\n\t\themiSkyColors = zlights.hemi.skyColors,\r\n\t\themiGroundColors = zlights.hemi.groundColors,\r\n\t\themiPositions = zlights.hemi.positions,\r\n\r\n\t\tdirLength = 0,\r\n\t\tpointLength = 0,\r\n\t\tspotLength = 0,\r\n\t\themiLength = 0,\r\n\r\n\t\tdirCount = 0,\r\n\t\tpointCount = 0,\r\n\t\tspotCount = 0,\r\n\t\themiCount = 0,\r\n\r\n\t\tdirOffset = 0,\r\n\t\tpointOffset = 0,\r\n\t\tspotOffset = 0,\r\n\t\themiOffset = 0;\r\n\r\n\t\tfor ( l = 0, ll = lights.length; l < ll; l ++ ) {\r\n\r\n\t\t\tlight = lights[ l ];\r\n\r\n\t\t\tif ( light.onlyShadow ) continue;\r\n\r\n\t\t\tcolor = light.color;\r\n\t\t\tintensity = light.intensity;\r\n\t\t\tdistance = light.distance;\r\n\r\n\t\t\tif ( light instanceof THREE.AmbientLight ) {\r\n\r\n\t\t\t\tif ( ! light.visible ) continue;\r\n\r\n\t\t\t\tr += color.r;\r\n\t\t\t\tg += color.g;\r\n\t\t\t\tb += color.b;\r\n\r\n\t\t\t} else if ( light instanceof THREE.DirectionalLight ) {\r\n\r\n\t\t\t\tdirCount += 1;\r\n\r\n\t\t\t\tif ( ! light.visible ) continue;\r\n\r\n\t\t\t\t_direction.setFromMatrixPosition( light.matrixWorld );\r\n\t\t\t\t_vector3.setFromMatrixPosition( light.target.matrixWorld );\r\n\t\t\t\t_direction.sub( _vector3 );\r\n\t\t\t\t_direction.normalize();\r\n\r\n\t\t\t\tdirOffset = dirLength * 3;\r\n\r\n\t\t\t\tdirPositions[ dirOffset ]     = _direction.x;\r\n\t\t\t\tdirPositions[ dirOffset + 1 ] = _direction.y;\r\n\t\t\t\tdirPositions[ dirOffset + 2 ] = _direction.z;\r\n\r\n\t\t\t\tsetColorLinear( dirColors, dirOffset, color, intensity );\r\n\r\n\t\t\t\tdirLength += 1;\r\n\r\n\t\t\t} else if ( light instanceof THREE.PointLight ) {\r\n\r\n\t\t\t\tpointCount += 1;\r\n\r\n\t\t\t\tif ( ! light.visible ) continue;\r\n\r\n\t\t\t\tpointOffset = pointLength * 3;\r\n\r\n\t\t\t\tsetColorLinear( pointColors, pointOffset, color, intensity );\r\n\r\n\t\t\t\t_vector3.setFromMatrixPosition( light.matrixWorld );\r\n\r\n\t\t\t\tpointPositions[ pointOffset ]     = _vector3.x;\r\n\t\t\t\tpointPositions[ pointOffset + 1 ] = _vector3.y;\r\n\t\t\t\tpointPositions[ pointOffset + 2 ] = _vector3.z;\r\n\r\n\t\t\t\t// distance is 0 if decay is 0, because there is no attenuation at all.\r\n\t\t\t\tpointDistances[ pointLength ] = distance;\r\n\t\t\t\tpointDecays[ pointLength ] = ( light.distance === 0 ) ? 0.0 : light.decay;\r\n\r\n\t\t\t\tpointLength += 1;\r\n\r\n\t\t\t} else if ( light instanceof THREE.SpotLight ) {\r\n\r\n\t\t\t\tspotCount += 1;\r\n\r\n\t\t\t\tif ( ! light.visible ) continue;\r\n\r\n\t\t\t\tspotOffset = spotLength * 3;\r\n\r\n\t\t\t\tsetColorLinear( spotColors, spotOffset, color, intensity );\r\n\r\n\t\t\t\t_direction.setFromMatrixPosition( light.matrixWorld );\r\n\r\n\t\t\t\tspotPositions[ spotOffset ]     = _direction.x;\r\n\t\t\t\tspotPositions[ spotOffset + 1 ] = _direction.y;\r\n\t\t\t\tspotPositions[ spotOffset + 2 ] = _direction.z;\r\n\r\n\t\t\t\tspotDistances[ spotLength ] = distance;\r\n\r\n\t\t\t\t_vector3.setFromMatrixPosition( light.target.matrixWorld );\r\n\t\t\t\t_direction.sub( _vector3 );\r\n\t\t\t\t_direction.normalize();\r\n\r\n\t\t\t\tspotDirections[ spotOffset ]     = _direction.x;\r\n\t\t\t\tspotDirections[ spotOffset + 1 ] = _direction.y;\r\n\t\t\t\tspotDirections[ spotOffset + 2 ] = _direction.z;\r\n\r\n\t\t\t\tspotAnglesCos[ spotLength ] = Math.cos( light.angle );\r\n\t\t\t\tspotExponents[ spotLength ] = light.exponent;\r\n\t\t\t\tspotDecays[ spotLength ] = ( light.distance === 0 ) ? 0.0 : light.decay;\r\n\r\n\t\t\t\tspotLength += 1;\r\n\r\n\t\t\t} else if ( light instanceof THREE.HemisphereLight ) {\r\n\r\n\t\t\t\themiCount += 1;\r\n\r\n\t\t\t\tif ( ! light.visible ) continue;\r\n\r\n\t\t\t\t_direction.setFromMatrixPosition( light.matrixWorld );\r\n\t\t\t\t_direction.normalize();\r\n\r\n\t\t\t\themiOffset = hemiLength * 3;\r\n\r\n\t\t\t\themiPositions[ hemiOffset ]     = _direction.x;\r\n\t\t\t\themiPositions[ hemiOffset + 1 ] = _direction.y;\r\n\t\t\t\themiPositions[ hemiOffset + 2 ] = _direction.z;\r\n\r\n\t\t\t\tskyColor = light.color;\r\n\t\t\t\tgroundColor = light.groundColor;\r\n\r\n\t\t\t\tsetColorLinear( hemiSkyColors, hemiOffset, skyColor, intensity );\r\n\t\t\t\tsetColorLinear( hemiGroundColors, hemiOffset, groundColor, intensity );\r\n\r\n\t\t\t\themiLength += 1;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// null eventual remains from removed lights\r\n\t\t// (this is to avoid if in shader)\r\n\r\n\t\tfor ( l = dirLength * 3, ll = Math.max( dirColors.length, dirCount * 3 ); l < ll; l ++ ) dirColors[ l ] = 0.0;\r\n\t\tfor ( l = pointLength * 3, ll = Math.max( pointColors.length, pointCount * 3 ); l < ll; l ++ ) pointColors[ l ] = 0.0;\r\n\t\tfor ( l = spotLength * 3, ll = Math.max( spotColors.length, spotCount * 3 ); l < ll; l ++ ) spotColors[ l ] = 0.0;\r\n\t\tfor ( l = hemiLength * 3, ll = Math.max( hemiSkyColors.length, hemiCount * 3 ); l < ll; l ++ ) hemiSkyColors[ l ] = 0.0;\r\n\t\tfor ( l = hemiLength * 3, ll = Math.max( hemiGroundColors.length, hemiCount * 3 ); l < ll; l ++ ) hemiGroundColors[ l ] = 0.0;\r\n\r\n\t\tzlights.directional.length = dirLength;\r\n\t\tzlights.point.length = pointLength;\r\n\t\tzlights.spot.length = spotLength;\r\n\t\tzlights.hemi.length = hemiLength;\r\n\r\n\t\tzlights.ambient[ 0 ] = r;\r\n\t\tzlights.ambient[ 1 ] = g;\r\n\t\tzlights.ambient[ 2 ] = b;\r\n\r\n\t}\r\n\r\n\t// GL state setting\r\n\r\n\tthis.setFaceCulling = function ( cullFace, frontFaceDirection ) {\r\n\r\n\t\tif ( cullFace === THREE.CullFaceNone ) {\r\n\r\n\t\t\t_gl.disable( _gl.CULL_FACE );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tif ( frontFaceDirection === THREE.FrontFaceDirectionCW ) {\r\n\r\n\t\t\t\t_gl.frontFace( _gl.CW );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t_gl.frontFace( _gl.CCW );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( cullFace === THREE.CullFaceBack ) {\r\n\r\n\t\t\t\t_gl.cullFace( _gl.BACK );\r\n\r\n\t\t\t} else if ( cullFace === THREE.CullFaceFront ) {\r\n\r\n\t\t\t\t_gl.cullFace( _gl.FRONT );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t_gl.cullFace( _gl.FRONT_AND_BACK );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t_gl.enable( _gl.CULL_FACE );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tthis.setMaterialFaces = function ( material ) {\r\n\r\n\t\tstate.setDoubleSided( material.side === THREE.DoubleSide );\r\n\t\tstate.setFlipSided( material.side === THREE.BackSide );\r\n\r\n\t};\r\n\r\n\t// Textures\r\n\r\n\tfunction setTextureParameters ( textureType, texture, isImagePowerOfTwo ) {\r\n\r\n\t\tvar extension;\r\n\r\n\t\tif ( isImagePowerOfTwo ) {\r\n\r\n\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, paramThreeToGL( texture.wrapS ) );\r\n\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, paramThreeToGL( texture.wrapT ) );\r\n\r\n\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, paramThreeToGL( texture.magFilter ) );\r\n\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, paramThreeToGL( texture.minFilter ) );\r\n\r\n\t\t} else {\r\n\r\n\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, _gl.CLAMP_TO_EDGE );\r\n\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, _gl.CLAMP_TO_EDGE );\r\n\r\n\t\t\tif ( texture.wrapS !== THREE.ClampToEdgeWrapping || texture.wrapT !== THREE.ClampToEdgeWrapping ) {\r\n\r\n\t\t\t\tTHREE.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping. ( ' + texture.sourceFile + ' )' );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, filterFallback( texture.magFilter ) );\r\n\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, filterFallback( texture.minFilter ) );\r\n\r\n\t\t\tif ( texture.minFilter !== THREE.NearestFilter && texture.minFilter !== THREE.LinearFilter ) {\r\n\r\n\t\t\t\tTHREE.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter. ( ' + texture.sourceFile + ' )' );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\textension = extensions.get( 'EXT_texture_filter_anisotropic' );\r\n\r\n\t\tif ( extension && texture.type !== THREE.FloatType && texture.type !== THREE.HalfFloatType ) {\r\n\r\n\t\t\tif ( texture.anisotropy > 1 || texture.__currentAnisotropy ) {\r\n\r\n\t\t\t\t_gl.texParameterf( textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min( texture.anisotropy, _this.getMaxAnisotropy() ) );\r\n\t\t\t\ttexture.__currentAnisotropy = texture.anisotropy;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tthis.uploadTexture = function ( texture ) {\r\n\r\n\t\tif ( texture.__webglInit === undefined ) {\r\n\r\n\t\t\ttexture.__webglInit = true;\r\n\r\n\t\t\ttexture.addEventListener( 'dispose', onTextureDispose );\r\n\r\n\t\t\ttexture.__webglTexture = _gl.createTexture();\r\n\r\n\t\t\t_this.info.memory.textures ++;\r\n\r\n\t\t}\r\n\r\n\t\t_gl.bindTexture( _gl.TEXTURE_2D, texture.__webglTexture );\r\n\r\n\t\t_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );\r\n\t\t_gl.pixelStorei( _gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha );\r\n\t\t_gl.pixelStorei( _gl.UNPACK_ALIGNMENT, texture.unpackAlignment );\r\n\r\n\t\ttexture.image = clampToMaxSize( texture.image, _maxTextureSize );\r\n\r\n\t\tvar image = texture.image,\r\n\t\tisImagePowerOfTwo = THREE.Math.isPowerOfTwo( image.width ) && THREE.Math.isPowerOfTwo( image.height ),\r\n\t\tglFormat = paramThreeToGL( texture.format ),\r\n\t\tglType = paramThreeToGL( texture.type );\r\n\r\n\t\tsetTextureParameters( _gl.TEXTURE_2D, texture, isImagePowerOfTwo );\r\n\r\n\t\tvar mipmap, mipmaps = texture.mipmaps;\r\n\r\n\t\tif ( texture instanceof THREE.DataTexture ) {\r\n\r\n\t\t\t// use manually created mipmaps if available\r\n\t\t\t// if there are no manual mipmaps\r\n\t\t\t// set 0 level mipmap and then use GL to generate other mipmap levels\r\n\r\n\t\t\tif ( mipmaps.length > 0 && isImagePowerOfTwo ) {\r\n\r\n\t\t\t\tfor ( var i = 0, il = mipmaps.length; i < il; i ++ ) {\r\n\r\n\t\t\t\t\tmipmap = mipmaps[ i ];\r\n\t\t\t\t\t_gl.texImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\ttexture.generateMipmaps = false;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t_gl.texImage2D( _gl.TEXTURE_2D, 0, glFormat, image.width, image.height, 0, glFormat, glType, image.data );\r\n\r\n\t\t\t}\r\n\r\n\t\t} else if ( texture instanceof THREE.CompressedTexture ) {\r\n\r\n\t\t\tfor ( var i = 0, il = mipmaps.length; i < il; i ++ ) {\r\n\r\n\t\t\t\tmipmap = mipmaps[ i ];\r\n\r\n\t\t\t\tif ( texture.format !== THREE.RGBAFormat && texture.format !== THREE.RGBFormat ) {\r\n\r\n\t\t\t\t\tif ( getCompressedTextureFormats().indexOf( glFormat ) > -1 ) {\r\n\r\n\t\t\t\t\t\t_gl.compressedTexImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, mipmap.data );\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tTHREE.warn( \"THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()\" );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\t_gl.texImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t} else { // regular Texture (image, video, canvas)\r\n\r\n\t\t\t// use manually created mipmaps if available\r\n\t\t\t// if there are no manual mipmaps\r\n\t\t\t// set 0 level mipmap and then use GL to generate other mipmap levels\r\n\r\n\t\t\tif ( mipmaps.length > 0 && isImagePowerOfTwo ) {\r\n\r\n\t\t\t\tfor ( var i = 0, il = mipmaps.length; i < il; i ++ ) {\r\n\r\n\t\t\t\t\tmipmap = mipmaps[ i ];\r\n\t\t\t\t\t_gl.texImage2D( _gl.TEXTURE_2D, i, glFormat, glFormat, glType, mipmap );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\ttexture.generateMipmaps = false;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t_gl.texImage2D( _gl.TEXTURE_2D, 0, glFormat, glFormat, glType, texture.image );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( texture.generateMipmaps && isImagePowerOfTwo ) _gl.generateMipmap( _gl.TEXTURE_2D );\r\n\r\n\t\ttexture.needsUpdate = false;\r\n\r\n\t\tif ( texture.onUpdate ) texture.onUpdate();\r\n\r\n\t};\r\n\r\n\tthis.setTexture = function ( texture, slot ) {\r\n\r\n\t\t_gl.activeTexture( _gl.TEXTURE0 + slot );\r\n\r\n\t\tif ( texture.needsUpdate ) {\r\n\r\n\t\t\t_this.uploadTexture( texture );\r\n\r\n\t\t} else {\r\n\r\n\t\t\t_gl.bindTexture( _gl.TEXTURE_2D, texture.__webglTexture );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tfunction clampToMaxSize ( image, maxSize ) {\r\n\r\n\t\tif ( image.width > maxSize || image.height > maxSize ) {\r\n\r\n\t\t\t// Warning: Scaling through the canvas will only work with images that use\r\n\t\t\t// premultiplied alpha.\r\n\r\n\t\t\tvar scale = maxSize / Math.max( image.width, image.height );\r\n\r\n\t\t\tvar canvas = document.createElement( 'canvas' );\r\n\t\t\tcanvas.width = Math.floor( image.width * scale );\r\n\t\t\tcanvas.height = Math.floor( image.height * scale );\r\n\r\n\t\t\tvar context = canvas.getContext( '2d' );\r\n\t\t\tcontext.drawImage( image, 0, 0, image.width, image.height, 0, 0, canvas.width, canvas.height );\r\n\r\n\t\t\tTHREE.warn( 'THREE.WebGLRenderer: image is too big (' + image.width + 'x' + image.height + '). Resized to ' + canvas.width + 'x' + canvas.height, image );\r\n\r\n\t\t\treturn canvas;\r\n\r\n\t\t}\r\n\r\n\t\treturn image;\r\n\r\n\t}\r\n\r\n\tfunction setCubeTexture ( texture, slot ) {\r\n\r\n\t\tif ( texture.image.length === 6 ) {\r\n\r\n\t\t\tif ( texture.needsUpdate ) {\r\n\r\n\t\t\t\tif ( ! texture.image.__webglTextureCube ) {\r\n\r\n\t\t\t\t\ttexture.addEventListener( 'dispose', onTextureDispose );\r\n\r\n\t\t\t\t\ttexture.image.__webglTextureCube = _gl.createTexture();\r\n\r\n\t\t\t\t\t_this.info.memory.textures ++;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t_gl.activeTexture( _gl.TEXTURE0 + slot );\r\n\t\t\t\t_gl.bindTexture( _gl.TEXTURE_CUBE_MAP, texture.image.__webglTextureCube );\r\n\r\n\t\t\t\t_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );\r\n\r\n\t\t\t\tvar isCompressed = texture instanceof THREE.CompressedTexture;\r\n\t\t\t\tvar isDataTexture = texture.image[ 0 ] instanceof THREE.DataTexture;\r\n\r\n\t\t\t\tvar cubeImage = [];\r\n\r\n\t\t\t\tfor ( var i = 0; i < 6; i ++ ) {\r\n\r\n\t\t\t\t\tif ( _this.autoScaleCubemaps && ! isCompressed && ! isDataTexture ) {\r\n\r\n\t\t\t\t\t\tcubeImage[ i ] = clampToMaxSize( texture.image[ i ], _maxCubemapSize );\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tcubeImage[ i ] = isDataTexture ? texture.image[ i ].image : texture.image[ i ];\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tvar image = cubeImage[ 0 ],\r\n\t\t\t\tisImagePowerOfTwo = THREE.Math.isPowerOfTwo( image.width ) && THREE.Math.isPowerOfTwo( image.height ),\r\n\t\t\t\tglFormat = paramThreeToGL( texture.format ),\r\n\t\t\t\tglType = paramThreeToGL( texture.type );\r\n\r\n\t\t\t\tsetTextureParameters( _gl.TEXTURE_CUBE_MAP, texture, isImagePowerOfTwo );\r\n\r\n\t\t\t\tfor ( var i = 0; i < 6; i ++ ) {\r\n\r\n\t\t\t\t\tif ( ! isCompressed ) {\r\n\r\n\t\t\t\t\t\tif ( isDataTexture ) {\r\n\r\n\t\t\t\t\t\t\t_gl.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, cubeImage[ i ].width, cubeImage[ i ].height, 0, glFormat, glType, cubeImage[ i ].data );\r\n\r\n\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\t_gl.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, glFormat, glType, cubeImage[ i ] );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tvar mipmap, mipmaps = cubeImage[ i ].mipmaps;\r\n\r\n\t\t\t\t\t\tfor ( var j = 0, jl = mipmaps.length; j < jl; j ++ ) {\r\n\r\n\t\t\t\t\t\t\tmipmap = mipmaps[ j ];\r\n\r\n\t\t\t\t\t\t\tif ( texture.format !== THREE.RGBAFormat && texture.format !== THREE.RGBFormat ) {\r\n\r\n\t\t\t\t\t\t\t\tif ( getCompressedTextureFormats().indexOf( glFormat ) > -1 ) {\r\n\r\n\t\t\t\t\t\t\t\t\t_gl.compressedTexImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, mipmap.data );\r\n\r\n\t\t\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\t\t\tTHREE.warn( \"THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setCubeTexture()\" );\r\n\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\t\t_gl.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( texture.generateMipmaps && isImagePowerOfTwo ) {\r\n\r\n\t\t\t\t\t_gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\ttexture.needsUpdate = false;\r\n\r\n\t\t\t\tif ( texture.onUpdate ) texture.onUpdate();\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t_gl.activeTexture( _gl.TEXTURE0 + slot );\r\n\t\t\t\t_gl.bindTexture( _gl.TEXTURE_CUBE_MAP, texture.image.__webglTextureCube );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction setCubeTextureDynamic ( texture, slot ) {\r\n\r\n\t\t_gl.activeTexture( _gl.TEXTURE0 + slot );\r\n\t\t_gl.bindTexture( _gl.TEXTURE_CUBE_MAP, texture.__webglTexture );\r\n\r\n\t}\r\n\r\n\t// Render targets\r\n\r\n\tfunction setupFrameBuffer ( framebuffer, renderTarget, textureTarget ) {\r\n\r\n\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );\r\n\t\t_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, textureTarget, renderTarget.__webglTexture, 0 );\r\n\r\n\t}\r\n\r\n\tfunction setupRenderBuffer ( renderbuffer, renderTarget  ) {\r\n\r\n\t\t_gl.bindRenderbuffer( _gl.RENDERBUFFER, renderbuffer );\r\n\r\n\t\tif ( renderTarget.depthBuffer && ! renderTarget.stencilBuffer ) {\r\n\r\n\t\t\t_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_COMPONENT16, renderTarget.width, renderTarget.height );\r\n\t\t\t_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );\r\n\r\n\t\t/* For some reason this is not working. Defaulting to RGBA4.\r\n\t\t} else if ( ! renderTarget.depthBuffer && renderTarget.stencilBuffer ) {\r\n\r\n\t\t\t_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.STENCIL_INDEX8, renderTarget.width, renderTarget.height );\r\n\t\t\t_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );\r\n\t\t*/\r\n\t\t} else if ( renderTarget.depthBuffer && renderTarget.stencilBuffer ) {\r\n\r\n\t\t\t_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_STENCIL, renderTarget.width, renderTarget.height );\r\n\t\t\t_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );\r\n\r\n\t\t} else {\r\n\r\n\t\t\t_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.RGBA4, renderTarget.width, renderTarget.height );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tthis.setRenderTarget = function ( renderTarget ) {\r\n\r\n\t\tvar isCube = ( renderTarget instanceof THREE.WebGLRenderTargetCube );\r\n\r\n\t\tif ( renderTarget && renderTarget.__webglFramebuffer === undefined ) {\r\n\r\n\t\t\tif ( renderTarget.depthBuffer === undefined ) renderTarget.depthBuffer = true;\r\n\t\t\tif ( renderTarget.stencilBuffer === undefined ) renderTarget.stencilBuffer = true;\r\n\r\n\t\t\trenderTarget.addEventListener( 'dispose', onRenderTargetDispose );\r\n\r\n\t\t\trenderTarget.__webglTexture = _gl.createTexture();\r\n\r\n\t\t\t_this.info.memory.textures ++;\r\n\r\n\t\t\t// Setup texture, create render and frame buffers\r\n\r\n\t\t\tvar isTargetPowerOfTwo = THREE.Math.isPowerOfTwo( renderTarget.width ) && THREE.Math.isPowerOfTwo( renderTarget.height ),\r\n\t\t\t\tglFormat = paramThreeToGL( renderTarget.format ),\r\n\t\t\t\tglType = paramThreeToGL( renderTarget.type );\r\n\r\n\t\t\tif ( isCube ) {\r\n\r\n\t\t\t\trenderTarget.__webglFramebuffer = [];\r\n\t\t\t\trenderTarget.__webglRenderbuffer = [];\r\n\r\n\t\t\t\t_gl.bindTexture( _gl.TEXTURE_CUBE_MAP, renderTarget.__webglTexture );\r\n\t\t\t\tsetTextureParameters( _gl.TEXTURE_CUBE_MAP, renderTarget, isTargetPowerOfTwo );\r\n\r\n\t\t\t\tfor ( var i = 0; i < 6; i ++ ) {\r\n\r\n\t\t\t\t\trenderTarget.__webglFramebuffer[ i ] = _gl.createFramebuffer();\r\n\t\t\t\t\trenderTarget.__webglRenderbuffer[ i ] = _gl.createRenderbuffer();\r\n\r\n\t\t\t\t\t_gl.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null );\r\n\r\n\t\t\t\t\tsetupFrameBuffer( renderTarget.__webglFramebuffer[ i ], renderTarget, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i );\r\n\t\t\t\t\tsetupRenderBuffer( renderTarget.__webglRenderbuffer[ i ], renderTarget );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( isTargetPowerOfTwo ) _gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\trenderTarget.__webglFramebuffer = _gl.createFramebuffer();\r\n\r\n\t\t\t\tif ( renderTarget.shareDepthFrom ) {\r\n\r\n\t\t\t\t\trenderTarget.__webglRenderbuffer = renderTarget.shareDepthFrom.__webglRenderbuffer;\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\trenderTarget.__webglRenderbuffer = _gl.createRenderbuffer();\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t_gl.bindTexture( _gl.TEXTURE_2D, renderTarget.__webglTexture );\r\n\t\t\t\tsetTextureParameters( _gl.TEXTURE_2D, renderTarget, isTargetPowerOfTwo );\r\n\r\n\t\t\t\t_gl.texImage2D( _gl.TEXTURE_2D, 0, glFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null );\r\n\r\n\t\t\t\tsetupFrameBuffer( renderTarget.__webglFramebuffer, renderTarget, _gl.TEXTURE_2D );\r\n\r\n\t\t\t\tif ( renderTarget.shareDepthFrom ) {\r\n\r\n\t\t\t\t\tif ( renderTarget.depthBuffer && ! renderTarget.stencilBuffer ) {\r\n\r\n\t\t\t\t\t\t_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderTarget.__webglRenderbuffer );\r\n\r\n\t\t\t\t\t} else if ( renderTarget.depthBuffer && renderTarget.stencilBuffer ) {\r\n\r\n\t\t\t\t\t\t_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderTarget.__webglRenderbuffer );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tsetupRenderBuffer( renderTarget.__webglRenderbuffer, renderTarget );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( isTargetPowerOfTwo ) _gl.generateMipmap( _gl.TEXTURE_2D );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// Release everything\r\n\r\n\t\t\tif ( isCube ) {\r\n\r\n\t\t\t\t_gl.bindTexture( _gl.TEXTURE_CUBE_MAP, null );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t_gl.bindTexture( _gl.TEXTURE_2D, null );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t_gl.bindRenderbuffer( _gl.RENDERBUFFER, null );\r\n\t\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, null );\r\n\r\n\t\t}\r\n\r\n\t\tvar framebuffer, width, height, vx, vy;\r\n\r\n\t\tif ( renderTarget ) {\r\n\r\n\t\t\tif ( isCube ) {\r\n\r\n\t\t\t\tframebuffer = renderTarget.__webglFramebuffer[ renderTarget.activeCubeFace ];\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tframebuffer = renderTarget.__webglFramebuffer;\r\n\r\n\t\t\t}\r\n\r\n\t\t\twidth = renderTarget.width;\r\n\t\t\theight = renderTarget.height;\r\n\r\n\t\t\tvx = 0;\r\n\t\t\tvy = 0;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tframebuffer = null;\r\n\r\n\t\t\twidth = _viewportWidth;\r\n\t\t\theight = _viewportHeight;\r\n\r\n\t\t\tvx = _viewportX;\r\n\t\t\tvy = _viewportY;\r\n\r\n\t\t}\r\n\r\n\t\tif ( framebuffer !== _currentFramebuffer ) {\r\n\r\n\t\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );\r\n\t\t\t_gl.viewport( vx, vy, width, height );\r\n\r\n\t\t\t_currentFramebuffer = framebuffer;\r\n\r\n\t\t}\r\n\r\n\t\t_currentWidth = width;\r\n\t\t_currentHeight = height;\r\n\r\n\t};\r\n\r\n\tthis.readRenderTargetPixels = function( renderTarget, x, y, width, height, buffer ) {\r\n\r\n\t\tif ( ! ( renderTarget instanceof THREE.WebGLRenderTarget ) ) {\r\n\r\n\t\t\tconsole.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.' );\r\n\t\t\treturn;\r\n\r\n\t\t}\r\n\r\n\t\tif ( renderTarget.__webglFramebuffer ) {\r\n\r\n\t\t\tif ( renderTarget.format !== THREE.RGBAFormat ) {\r\n\r\n\t\t\t\tconsole.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA format. readPixels can read only RGBA format.' );\r\n\t\t\t\treturn;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar restore = false;\r\n\r\n\t\t\tif ( renderTarget.__webglFramebuffer !== _currentFramebuffer ) {\r\n\r\n\t\t\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, renderTarget.__webglFramebuffer );\r\n\r\n\t\t\t\trestore = true;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( _gl.checkFramebufferStatus( _gl.FRAMEBUFFER ) === _gl.FRAMEBUFFER_COMPLETE ) {\r\n\r\n\t\t\t\t_gl.readPixels( x, y, width, height, _gl.RGBA, _gl.UNSIGNED_BYTE, buffer );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tconsole.error( 'THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.' );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( restore ) {\r\n\r\n\t\t\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, _currentFramebuffer );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tfunction updateRenderTargetMipmap ( renderTarget ) {\r\n\r\n\t\tif ( renderTarget instanceof THREE.WebGLRenderTargetCube ) {\r\n\r\n\t\t\t_gl.bindTexture( _gl.TEXTURE_CUBE_MAP, renderTarget.__webglTexture );\r\n\t\t\t_gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );\r\n\t\t\t_gl.bindTexture( _gl.TEXTURE_CUBE_MAP, null );\r\n\r\n\t\t} else {\r\n\r\n\t\t\t_gl.bindTexture( _gl.TEXTURE_2D, renderTarget.__webglTexture );\r\n\t\t\t_gl.generateMipmap( _gl.TEXTURE_2D );\r\n\t\t\t_gl.bindTexture( _gl.TEXTURE_2D, null );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// Fallback filters for non-power-of-2 textures\r\n\r\n\tfunction filterFallback ( f ) {\r\n\r\n\t\tif ( f === THREE.NearestFilter || f === THREE.NearestMipMapNearestFilter || f === THREE.NearestMipMapLinearFilter ) {\r\n\r\n\t\t\treturn _gl.NEAREST;\r\n\r\n\t\t}\r\n\r\n\t\treturn _gl.LINEAR;\r\n\r\n\t}\r\n\r\n\t// Map three.js constants to WebGL constants\r\n\r\n\tfunction paramThreeToGL ( p ) {\r\n\r\n\t\tvar extension;\r\n\r\n\t\tif ( p === THREE.RepeatWrapping ) return _gl.REPEAT;\r\n\t\tif ( p === THREE.ClampToEdgeWrapping ) return _gl.CLAMP_TO_EDGE;\r\n\t\tif ( p === THREE.MirroredRepeatWrapping ) return _gl.MIRRORED_REPEAT;\r\n\r\n\t\tif ( p === THREE.NearestFilter ) return _gl.NEAREST;\r\n\t\tif ( p === THREE.NearestMipMapNearestFilter ) return _gl.NEAREST_MIPMAP_NEAREST;\r\n\t\tif ( p === THREE.NearestMipMapLinearFilter ) return _gl.NEAREST_MIPMAP_LINEAR;\r\n\r\n\t\tif ( p === THREE.LinearFilter ) return _gl.LINEAR;\r\n\t\tif ( p === THREE.LinearMipMapNearestFilter ) return _gl.LINEAR_MIPMAP_NEAREST;\r\n\t\tif ( p === THREE.LinearMipMapLinearFilter ) return _gl.LINEAR_MIPMAP_LINEAR;\r\n\r\n\t\tif ( p === THREE.UnsignedByteType ) return _gl.UNSIGNED_BYTE;\r\n\t\tif ( p === THREE.UnsignedShort4444Type ) return _gl.UNSIGNED_SHORT_4_4_4_4;\r\n\t\tif ( p === THREE.UnsignedShort5551Type ) return _gl.UNSIGNED_SHORT_5_5_5_1;\r\n\t\tif ( p === THREE.UnsignedShort565Type ) return _gl.UNSIGNED_SHORT_5_6_5;\r\n\r\n\t\tif ( p === THREE.ByteType ) return _gl.BYTE;\r\n\t\tif ( p === THREE.ShortType ) return _gl.SHORT;\r\n\t\tif ( p === THREE.UnsignedShortType ) return _gl.UNSIGNED_SHORT;\r\n\t\tif ( p === THREE.IntType ) return _gl.INT;\r\n\t\tif ( p === THREE.UnsignedIntType ) return _gl.UNSIGNED_INT;\r\n\t\tif ( p === THREE.FloatType ) return _gl.FLOAT;\r\n\r\n\t\textension = extensions.get( 'OES_texture_half_float' );\r\n\r\n\t\tif ( extension !== null ) {\r\n\r\n\t\t\tif ( p === THREE.HalfFloatType ) return extension.HALF_FLOAT_OES;\r\n\r\n\t\t}\r\n\r\n\t\tif ( p === THREE.AlphaFormat ) return _gl.ALPHA;\r\n\t\tif ( p === THREE.RGBFormat ) return _gl.RGB;\r\n\t\tif ( p === THREE.RGBAFormat ) return _gl.RGBA;\r\n\t\tif ( p === THREE.LuminanceFormat ) return _gl.LUMINANCE;\r\n\t\tif ( p === THREE.LuminanceAlphaFormat ) return _gl.LUMINANCE_ALPHA;\r\n\r\n\t\tif ( p === THREE.AddEquation ) return _gl.FUNC_ADD;\r\n\t\tif ( p === THREE.SubtractEquation ) return _gl.FUNC_SUBTRACT;\r\n\t\tif ( p === THREE.ReverseSubtractEquation ) return _gl.FUNC_REVERSE_SUBTRACT;\r\n\r\n\t\tif ( p === THREE.ZeroFactor ) return _gl.ZERO;\r\n\t\tif ( p === THREE.OneFactor ) return _gl.ONE;\r\n\t\tif ( p === THREE.SrcColorFactor ) return _gl.SRC_COLOR;\r\n\t\tif ( p === THREE.OneMinusSrcColorFactor ) return _gl.ONE_MINUS_SRC_COLOR;\r\n\t\tif ( p === THREE.SrcAlphaFactor ) return _gl.SRC_ALPHA;\r\n\t\tif ( p === THREE.OneMinusSrcAlphaFactor ) return _gl.ONE_MINUS_SRC_ALPHA;\r\n\t\tif ( p === THREE.DstAlphaFactor ) return _gl.DST_ALPHA;\r\n\t\tif ( p === THREE.OneMinusDstAlphaFactor ) return _gl.ONE_MINUS_DST_ALPHA;\r\n\r\n\t\tif ( p === THREE.DstColorFactor ) return _gl.DST_COLOR;\r\n\t\tif ( p === THREE.OneMinusDstColorFactor ) return _gl.ONE_MINUS_DST_COLOR;\r\n\t\tif ( p === THREE.SrcAlphaSaturateFactor ) return _gl.SRC_ALPHA_SATURATE;\r\n\r\n\t\textension = extensions.get( 'WEBGL_compressed_texture_s3tc' );\r\n\r\n\t\tif ( extension !== null ) {\r\n\r\n\t\t\tif ( p === THREE.RGB_S3TC_DXT1_Format ) return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;\r\n\t\t\tif ( p === THREE.RGBA_S3TC_DXT1_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;\r\n\t\t\tif ( p === THREE.RGBA_S3TC_DXT3_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;\r\n\t\t\tif ( p === THREE.RGBA_S3TC_DXT5_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;\r\n\r\n\t\t}\r\n\r\n\t\textension = extensions.get( 'WEBGL_compressed_texture_pvrtc' );\r\n\r\n\t\tif ( extension !== null ) {\r\n\r\n\t\t\tif ( p === THREE.RGB_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;\r\n\t\t\tif ( p === THREE.RGB_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;\r\n\t\t\tif ( p === THREE.RGBA_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;\r\n\t\t\tif ( p === THREE.RGBA_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;\r\n\r\n\t\t}\r\n\r\n\t\textension = extensions.get( 'EXT_blend_minmax' );\r\n\r\n\t\tif ( extension !== null ) {\r\n\r\n\t\t\tif ( p === THREE.MinEquation ) return extension.MIN_EXT;\r\n\t\t\tif ( p === THREE.MaxEquation ) return extension.MAX_EXT;\r\n\r\n\t\t}\r\n\r\n\t\treturn 0;\r\n\r\n\t}\r\n\r\n\t// Allocations\r\n\r\n\tfunction allocateBones ( object ) {\r\n\r\n\t\tif ( _supportsBoneTextures && object && object.skeleton && object.skeleton.useVertexTexture ) {\r\n\r\n\t\t\treturn 1024;\r\n\r\n\t\t} else {\r\n\r\n\t\t\t// default for when object is not specified\r\n\t\t\t// ( for example when prebuilding shader\r\n\t\t\t//   to be used with multiple objects )\r\n\t\t\t//\r\n\t\t\t//  - leave some extra space for other uniforms\r\n\t\t\t//  - limit here is ANGLE's 254 max uniform vectors\r\n\t\t\t//    (up to 54 should be safe)\r\n\r\n\t\t\tvar nVertexUniforms = _gl.getParameter( _gl.MAX_VERTEX_UNIFORM_VECTORS );\r\n\t\t\tvar nVertexMatrices = Math.floor( ( nVertexUniforms - 20 ) / 4 );\r\n\r\n\t\t\tvar maxBones = nVertexMatrices;\r\n\r\n\t\t\tif ( object !== undefined && object instanceof THREE.SkinnedMesh ) {\r\n\r\n\t\t\t\tmaxBones = Math.min( object.skeleton.bones.length, maxBones );\r\n\r\n\t\t\t\tif ( maxBones < object.skeleton.bones.length ) {\r\n\r\n\t\t\t\t\tTHREE.warn( 'WebGLRenderer: too many bones - ' + object.skeleton.bones.length + ', this GPU supports just ' + maxBones + ' (try OpenGL instead of ANGLE)' );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn maxBones;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction allocateLights( lights ) {\r\n\r\n\t\tvar dirLights = 0;\r\n\t\tvar pointLights = 0;\r\n\t\tvar spotLights = 0;\r\n\t\tvar hemiLights = 0;\r\n\r\n\t\tfor ( var l = 0, ll = lights.length; l < ll; l ++ ) {\r\n\r\n\t\t\tvar light = lights[ l ];\r\n\r\n\t\t\tif ( light.onlyShadow || light.visible === false ) continue;\r\n\r\n\t\t\tif ( light instanceof THREE.DirectionalLight ) dirLights ++;\r\n\t\t\tif ( light instanceof THREE.PointLight ) pointLights ++;\r\n\t\t\tif ( light instanceof THREE.SpotLight ) spotLights ++;\r\n\t\t\tif ( light instanceof THREE.HemisphereLight ) hemiLights ++;\r\n\r\n\t\t}\r\n\r\n\t\treturn { 'directional': dirLights, 'point': pointLights, 'spot': spotLights, 'hemi': hemiLights };\r\n\r\n\t}\r\n\r\n\tfunction allocateShadows( lights ) {\r\n\r\n\t\tvar maxShadows = 0;\r\n\r\n\t\tfor ( var l = 0, ll = lights.length; l < ll; l ++ ) {\r\n\r\n\t\t\tvar light = lights[ l ];\r\n\r\n\t\t\tif ( ! light.castShadow ) continue;\r\n\r\n\t\t\tif ( light instanceof THREE.SpotLight ) maxShadows ++;\r\n\t\t\tif ( light instanceof THREE.DirectionalLight && ! light.shadowCascade ) maxShadows ++;\r\n\r\n\t\t}\r\n\r\n\t\treturn maxShadows;\r\n\r\n\t}\r\n\r\n\t// DEPRECATED\r\n\r\n\tthis.initMaterial = function () {\r\n\r\n\t\tTHREE.warn( 'THREE.WebGLRenderer: .initMaterial() has been removed.' );\r\n\r\n\t};\r\n\r\n\tthis.addPrePlugin = function () {\r\n\r\n\t\tTHREE.warn( 'THREE.WebGLRenderer: .addPrePlugin() has been removed.' );\r\n\r\n\t};\r\n\r\n\tthis.addPostPlugin = function () {\r\n\r\n\t\tTHREE.warn( 'THREE.WebGLRenderer: .addPostPlugin() has been removed.' );\r\n\r\n\t};\r\n\r\n\tthis.updateShadowMap = function () {\r\n\r\n\t\tTHREE.warn( 'THREE.WebGLRenderer: .updateShadowMap() has been removed.' );\r\n\r\n\t};\r\n\r\n};\r\n\r\n// File:src/renderers/WebGLRenderTarget.js\r\n\r\n/**\r\n * @author szimek / https://github.com/szimek/\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.WebGLRenderTarget = function ( width, height, options ) {\r\n\r\n\tthis.width = width;\r\n\tthis.height = height;\r\n\r\n\toptions = options || {};\r\n\r\n\tthis.wrapS = options.wrapS !== undefined ? options.wrapS : THREE.ClampToEdgeWrapping;\r\n\tthis.wrapT = options.wrapT !== undefined ? options.wrapT : THREE.ClampToEdgeWrapping;\r\n\r\n\tthis.magFilter = options.magFilter !== undefined ? options.magFilter : THREE.LinearFilter;\r\n\tthis.minFilter = options.minFilter !== undefined ? options.minFilter : THREE.LinearMipMapLinearFilter;\r\n\r\n\tthis.anisotropy = options.anisotropy !== undefined ? options.anisotropy : 1;\r\n\r\n\tthis.offset = new THREE.Vector2( 0, 0 );\r\n\tthis.repeat = new THREE.Vector2( 1, 1 );\r\n\r\n\tthis.format = options.format !== undefined ? options.format : THREE.RGBAFormat;\r\n\tthis.type = options.type !== undefined ? options.type : THREE.UnsignedByteType;\r\n\r\n\tthis.depthBuffer = options.depthBuffer !== undefined ? options.depthBuffer : true;\r\n\tthis.stencilBuffer = options.stencilBuffer !== undefined ? options.stencilBuffer : true;\r\n\r\n\tthis.generateMipmaps = true;\r\n\r\n\tthis.shareDepthFrom = options.shareDepthFrom !== undefined ? options.shareDepthFrom : null;\r\n\r\n};\r\n\r\nTHREE.WebGLRenderTarget.prototype = {\r\n\r\n\tconstructor: THREE.WebGLRenderTarget,\r\n\r\n\tsetSize: function ( width, height ) {\r\n\r\n\t\tthis.width = width;\r\n\t\tthis.height = height;\r\n\r\n\t},\r\n\r\n\tclone: function () {\r\n\r\n\t\tvar tmp = new THREE.WebGLRenderTarget( this.width, this.height );\r\n\r\n\t\ttmp.wrapS = this.wrapS;\r\n\t\ttmp.wrapT = this.wrapT;\r\n\r\n\t\ttmp.magFilter = this.magFilter;\r\n\t\ttmp.minFilter = this.minFilter;\r\n\r\n\t\ttmp.anisotropy = this.anisotropy;\r\n\r\n\t\ttmp.offset.copy( this.offset );\r\n\t\ttmp.repeat.copy( this.repeat );\r\n\r\n\t\ttmp.format = this.format;\r\n\t\ttmp.type = this.type;\r\n\r\n\t\ttmp.depthBuffer = this.depthBuffer;\r\n\t\ttmp.stencilBuffer = this.stencilBuffer;\r\n\r\n\t\ttmp.generateMipmaps = this.generateMipmaps;\r\n\r\n\t\ttmp.shareDepthFrom = this.shareDepthFrom;\r\n\r\n\t\treturn tmp;\r\n\r\n\t},\r\n\r\n\tdispose: function () {\r\n\r\n\t\tthis.dispatchEvent( { type: 'dispose' } );\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.EventDispatcher.prototype.apply( THREE.WebGLRenderTarget.prototype );\r\n\r\n// File:src/renderers/WebGLRenderTargetCube.js\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com\r\n */\r\n\r\nTHREE.WebGLRenderTargetCube = function ( width, height, options ) {\r\n\r\n\tTHREE.WebGLRenderTarget.call( this, width, height, options );\r\n\r\n\tthis.activeCubeFace = 0; // PX 0, NX 1, PY 2, NY 3, PZ 4, NZ 5\r\n\r\n};\r\n\r\nTHREE.WebGLRenderTargetCube.prototype = Object.create( THREE.WebGLRenderTarget.prototype );\r\nTHREE.WebGLRenderTargetCube.prototype.constructor = THREE.WebGLRenderTargetCube;\r\n\r\n// File:src/renderers/webgl/WebGLExtensions.js\r\n\r\n/**\r\n* @author mrdoob / http://mrdoob.com/\r\n*/\r\n\r\nTHREE.WebGLExtensions = function ( gl ) {\r\n\r\n\tvar extensions = {};\r\n\r\n\tthis.get = function ( name ) {\r\n\r\n\t\tif ( extensions[ name ] !== undefined ) {\r\n\r\n\t\t\treturn extensions[ name ];\r\n\r\n\t\t}\r\n\r\n\t\tvar extension;\r\n\r\n\t\tswitch ( name ) {\r\n\r\n\t\t\tcase 'EXT_texture_filter_anisotropic':\r\n\t\t\t\textension = gl.getExtension( 'EXT_texture_filter_anisotropic' ) || gl.getExtension( 'MOZ_EXT_texture_filter_anisotropic' ) || gl.getExtension( 'WEBKIT_EXT_texture_filter_anisotropic' );\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase 'WEBGL_compressed_texture_s3tc':\r\n\t\t\t\textension = gl.getExtension( 'WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'MOZ_WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_s3tc' );\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase 'WEBGL_compressed_texture_pvrtc':\r\n\t\t\t\textension = gl.getExtension( 'WEBGL_compressed_texture_pvrtc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_pvrtc' );\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tdefault:\r\n\t\t\t\textension = gl.getExtension( name );\r\n\r\n\t\t}\r\n\r\n\t\tif ( extension === null ) {\r\n\r\n\t\t\tTHREE.warn( 'THREE.WebGLRenderer: ' + name + ' extension not supported.' );\r\n\r\n\t\t}\r\n\r\n\t\textensions[ name ] = extension;\r\n\r\n\t\treturn extension;\r\n\r\n\t};\r\n\r\n};\r\n\r\n// File:src/renderers/webgl/WebGLProgram.js\r\n\r\nTHREE.WebGLProgram = ( function () {\r\n\r\n\tvar programIdCount = 0;\r\n\r\n\tvar generateDefines = function ( defines ) {\r\n\r\n\t\tvar value, chunk, chunks = [];\r\n\r\n\t\tfor ( var d in defines ) {\r\n\r\n\t\t\tvalue = defines[ d ];\r\n\t\t\tif ( value === false ) continue;\r\n\r\n\t\t\tchunk = '#define ' + d + ' ' + value;\r\n\t\t\tchunks.push( chunk );\r\n\r\n\t\t}\r\n\r\n\t\treturn chunks.join( '\\n' );\r\n\r\n\t};\r\n\r\n\tvar cacheUniformLocations = function ( gl, program, identifiers ) {\r\n\r\n\t\tvar uniforms = {};\r\n\r\n\t\tfor ( var i = 0, l = identifiers.length; i < l; i ++ ) {\r\n\r\n\t\t\tvar id = identifiers[ i ];\r\n\t\t\tuniforms[ id ] = gl.getUniformLocation( program, id );\r\n\r\n\t\t}\r\n\r\n\t\treturn uniforms;\r\n\r\n\t};\r\n\r\n\tvar cacheAttributeLocations = function ( gl, program, identifiers ) {\r\n\r\n\t\tvar attributes = {};\r\n\r\n\t\tfor ( var i = 0, l = identifiers.length; i < l; i ++ ) {\r\n\r\n\t\t\tvar id = identifiers[ i ];\r\n\t\t\tattributes[ id ] = gl.getAttribLocation( program, id );\r\n\r\n\t\t}\r\n\r\n\t\treturn attributes;\r\n\r\n\t};\r\n\r\n\treturn function ( renderer, code, material, parameters ) {\r\n\r\n\t\tvar _this = renderer;\r\n\t\tvar _gl = _this.context;\r\n\r\n\t\tvar defines = material.defines;\r\n\t\tvar uniforms = material.__webglShader.uniforms;\r\n\t\tvar attributes = material.attributes;\r\n\r\n\t\tvar vertexShader = material.__webglShader.vertexShader;\r\n\t\tvar fragmentShader = material.__webglShader.fragmentShader;\r\n\r\n\t\tvar index0AttributeName = material.index0AttributeName;\r\n\r\n\t\tif ( index0AttributeName === undefined && parameters.morphTargets === true ) {\r\n\r\n\t\t\t// programs with morphTargets displace position out of attribute 0\r\n\r\n\t\t\tindex0AttributeName = 'position';\r\n\r\n\t\t}\r\n\r\n\t\tvar shadowMapTypeDefine = 'SHADOWMAP_TYPE_BASIC';\r\n\r\n\t\tif ( parameters.shadowMapType === THREE.PCFShadowMap ) {\r\n\r\n\t\t\tshadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF';\r\n\r\n\t\t} else if ( parameters.shadowMapType === THREE.PCFSoftShadowMap ) {\r\n\r\n\t\t\tshadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF_SOFT';\r\n\r\n\t\t}\r\n\r\n\t\tvar envMapTypeDefine = 'ENVMAP_TYPE_CUBE';\r\n\t\tvar envMapModeDefine = 'ENVMAP_MODE_REFLECTION';\r\n\t\tvar envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';\r\n\r\n\t\tif ( parameters.envMap ) {\r\n\r\n\t\t\tswitch ( material.envMap.mapping ) {\r\n\r\n\t\t\t\tcase THREE.CubeReflectionMapping:\r\n\t\t\t\tcase THREE.CubeRefractionMapping:\r\n\t\t\t\t\tenvMapTypeDefine = 'ENVMAP_TYPE_CUBE';\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase THREE.EquirectangularReflectionMapping:\r\n\t\t\t\tcase THREE.EquirectangularRefractionMapping:\r\n\t\t\t\t\tenvMapTypeDefine = 'ENVMAP_TYPE_EQUIREC';\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase THREE.SphericalReflectionMapping:\r\n\t\t\t\t\tenvMapTypeDefine = 'ENVMAP_TYPE_SPHERE';\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tswitch ( material.envMap.mapping ) {\r\n\r\n\t\t\t\tcase THREE.CubeRefractionMapping:\r\n\t\t\t\tcase THREE.EquirectangularRefractionMapping:\r\n\t\t\t\t\tenvMapModeDefine = 'ENVMAP_MODE_REFRACTION';\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tswitch ( material.combine ) {\r\n\r\n\t\t\t\tcase THREE.MultiplyOperation:\r\n\t\t\t\t\tenvMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase THREE.MixOperation:\r\n\t\t\t\t\tenvMapBlendingDefine = 'ENVMAP_BLENDING_MIX';\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase THREE.AddOperation:\r\n\t\t\t\t\tenvMapBlendingDefine = 'ENVMAP_BLENDING_ADD';\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tvar gammaFactorDefine = ( renderer.gammaFactor > 0 ) ? renderer.gammaFactor : 1.0;\r\n\r\n\t\t// console.log( 'building new program ' );\r\n\r\n\t\t//\r\n\r\n\t\tvar customDefines = generateDefines( defines );\r\n\r\n\t\t//\r\n\r\n\t\tvar program = _gl.createProgram();\r\n\r\n\t\tvar prefix_vertex, prefix_fragment;\r\n\r\n\t\tif ( material instanceof THREE.RawShaderMaterial ) {\r\n\r\n\t\t\tprefix_vertex = '';\r\n\t\t\tprefix_fragment = '';\r\n\r\n\t\t} else {\r\n\r\n\t\t\tprefix_vertex = [\r\n\r\n\t\t\t\t'precision ' + parameters.precision + ' float;',\r\n\t\t\t\t'precision ' + parameters.precision + ' int;',\r\n\r\n\t\t\t\tcustomDefines,\r\n\r\n\t\t\t\tparameters.supportsVertexTextures ? '#define VERTEX_TEXTURES' : '',\r\n\r\n\t\t\t\t_this.gammaInput ? '#define GAMMA_INPUT' : '',\r\n\t\t\t\t_this.gammaOutput ? '#define GAMMA_OUTPUT' : '',\r\n\t\t\t\t'#define GAMMA_FACTOR ' + gammaFactorDefine,\r\n\r\n\t\t\t\t'#define MAX_DIR_LIGHTS ' + parameters.maxDirLights,\r\n\t\t\t\t'#define MAX_POINT_LIGHTS ' + parameters.maxPointLights,\r\n\t\t\t\t'#define MAX_SPOT_LIGHTS ' + parameters.maxSpotLights,\r\n\t\t\t\t'#define MAX_HEMI_LIGHTS ' + parameters.maxHemiLights,\r\n\r\n\t\t\t\t'#define MAX_SHADOWS ' + parameters.maxShadows,\r\n\r\n\t\t\t\t'#define MAX_BONES ' + parameters.maxBones,\r\n\r\n\t\t\t\tparameters.map ? '#define USE_MAP' : '',\r\n\t\t\t\tparameters.envMap ? '#define USE_ENVMAP' : '',\r\n\t\t\t\tparameters.envMap ? '#define ' + envMapModeDefine : '',\r\n\t\t\t\tparameters.lightMap ? '#define USE_LIGHTMAP' : '',\r\n\t\t\t\tparameters.bumpMap ? '#define USE_BUMPMAP' : '',\r\n\t\t\t\tparameters.normalMap ? '#define USE_NORMALMAP' : '',\r\n\t\t\t\tparameters.specularMap ? '#define USE_SPECULARMAP' : '',\r\n\t\t\t\tparameters.alphaMap ? '#define USE_ALPHAMAP' : '',\r\n\t\t\t\tparameters.vertexColors ? '#define USE_COLOR' : '',\r\n\r\n\t\t\t\tparameters.flatShading ? '#define FLAT_SHADED': '',\r\n\r\n\t\t\t\tparameters.skinning ? '#define USE_SKINNING' : '',\r\n\t\t\t\tparameters.useVertexTexture ? '#define BONE_TEXTURE' : '',\r\n\r\n\t\t\t\tparameters.morphTargets ? '#define USE_MORPHTARGETS' : '',\r\n\t\t\t\tparameters.morphNormals ? '#define USE_MORPHNORMALS' : '',\r\n\t\t\t\tparameters.wrapAround ? '#define WRAP_AROUND' : '',\r\n\t\t\t\tparameters.doubleSided ? '#define DOUBLE_SIDED' : '',\r\n\t\t\t\tparameters.flipSided ? '#define FLIP_SIDED' : '',\r\n\r\n\t\t\t\tparameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',\r\n\t\t\t\tparameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',\r\n\t\t\t\tparameters.shadowMapDebug ? '#define SHADOWMAP_DEBUG' : '',\r\n\t\t\t\tparameters.shadowMapCascade ? '#define SHADOWMAP_CASCADE' : '',\r\n\r\n\t\t\t\tparameters.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '',\r\n\r\n\t\t\t\tparameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',\r\n\t\t\t\t//_this._glExtensionFragDepth ? '#define USE_LOGDEPTHBUF_EXT' : '',\r\n\r\n\r\n\t\t\t\t'uniform mat4 modelMatrix;',\r\n\t\t\t\t'uniform mat4 modelViewMatrix;',\r\n\t\t\t\t'uniform mat4 projectionMatrix;',\r\n\t\t\t\t'uniform mat4 viewMatrix;',\r\n\t\t\t\t'uniform mat3 normalMatrix;',\r\n\t\t\t\t'uniform vec3 cameraPosition;',\r\n\r\n\t\t\t\t'attribute vec3 position;',\r\n\t\t\t\t'attribute vec3 normal;',\r\n\t\t\t\t'attribute vec2 uv;',\r\n\t\t\t\t'attribute vec2 uv2;',\r\n\r\n\t\t\t\t'#ifdef USE_COLOR',\r\n\r\n\t\t\t\t'\tattribute vec3 color;',\r\n\r\n\t\t\t\t'#endif',\r\n\r\n\t\t\t\t'#ifdef USE_MORPHTARGETS',\r\n\r\n\t\t\t\t'\tattribute vec3 morphTarget0;',\r\n\t\t\t\t'\tattribute vec3 morphTarget1;',\r\n\t\t\t\t'\tattribute vec3 morphTarget2;',\r\n\t\t\t\t'\tattribute vec3 morphTarget3;',\r\n\r\n\t\t\t\t'\t#ifdef USE_MORPHNORMALS',\r\n\r\n\t\t\t\t'\t\tattribute vec3 morphNormal0;',\r\n\t\t\t\t'\t\tattribute vec3 morphNormal1;',\r\n\t\t\t\t'\t\tattribute vec3 morphNormal2;',\r\n\t\t\t\t'\t\tattribute vec3 morphNormal3;',\r\n\r\n\t\t\t\t'\t#else',\r\n\r\n\t\t\t\t'\t\tattribute vec3 morphTarget4;',\r\n\t\t\t\t'\t\tattribute vec3 morphTarget5;',\r\n\t\t\t\t'\t\tattribute vec3 morphTarget6;',\r\n\t\t\t\t'\t\tattribute vec3 morphTarget7;',\r\n\r\n\t\t\t\t'\t#endif',\r\n\r\n\t\t\t\t'#endif',\r\n\r\n\t\t\t\t'#ifdef USE_SKINNING',\r\n\r\n\t\t\t\t'\tattribute vec4 skinIndex;',\r\n\t\t\t\t'\tattribute vec4 skinWeight;',\r\n\r\n\t\t\t\t'#endif',\r\n\r\n\t\t\t\t''\r\n\r\n\t\t\t].join( '\\n' );\r\n\r\n\t\t\tprefix_fragment = [\r\n\r\n\t\t\t\t'precision ' + parameters.precision + ' float;',\r\n\t\t\t\t'precision ' + parameters.precision + ' int;',\r\n\r\n\t\t\t\t( parameters.bumpMap || parameters.normalMap || parameters.flatShading ) ? '#extension GL_OES_standard_derivatives : enable' : '',\r\n\r\n\t\t\t\tcustomDefines,\r\n\r\n\t\t\t\t'#define MAX_DIR_LIGHTS ' + parameters.maxDirLights,\r\n\t\t\t\t'#define MAX_POINT_LIGHTS ' + parameters.maxPointLights,\r\n\t\t\t\t'#define MAX_SPOT_LIGHTS ' + parameters.maxSpotLights,\r\n\t\t\t\t'#define MAX_HEMI_LIGHTS ' + parameters.maxHemiLights,\r\n\r\n\t\t\t\t'#define MAX_SHADOWS ' + parameters.maxShadows,\r\n\r\n\t\t\t\tparameters.alphaTest ? '#define ALPHATEST ' + parameters.alphaTest : '',\r\n\r\n\t\t\t\t_this.gammaInput ? '#define GAMMA_INPUT' : '',\r\n\t\t\t\t_this.gammaOutput ? '#define GAMMA_OUTPUT' : '',\r\n\t\t\t\t'#define GAMMA_FACTOR ' + gammaFactorDefine,\r\n\r\n\t\t\t\t( parameters.useFog && parameters.fog ) ? '#define USE_FOG' : '',\r\n\t\t\t\t( parameters.useFog && parameters.fogExp ) ? '#define FOG_EXP2' : '',\r\n\r\n\t\t\t\tparameters.map ? '#define USE_MAP' : '',\r\n\t\t\t\tparameters.envMap ? '#define USE_ENVMAP' : '',\r\n\t\t\t\tparameters.envMap ? '#define ' + envMapTypeDefine : '',\r\n\t\t\t\tparameters.envMap ? '#define ' + envMapModeDefine : '',\r\n\t\t\t\tparameters.envMap ? '#define ' + envMapBlendingDefine : '',\r\n\t\t\t\tparameters.lightMap ? '#define USE_LIGHTMAP' : '',\r\n\t\t\t\tparameters.bumpMap ? '#define USE_BUMPMAP' : '',\r\n\t\t\t\tparameters.normalMap ? '#define USE_NORMALMAP' : '',\r\n\t\t\t\tparameters.specularMap ? '#define USE_SPECULARMAP' : '',\r\n\t\t\t\tparameters.alphaMap ? '#define USE_ALPHAMAP' : '',\r\n\t\t\t\tparameters.vertexColors ? '#define USE_COLOR' : '',\r\n\r\n\t\t\t\tparameters.flatShading ? '#define FLAT_SHADED': '',\r\n\r\n\t\t\t\tparameters.metal ? '#define METAL' : '',\r\n\t\t\t\tparameters.wrapAround ? '#define WRAP_AROUND' : '',\r\n\t\t\t\tparameters.doubleSided ? '#define DOUBLE_SIDED' : '',\r\n\t\t\t\tparameters.flipSided ? '#define FLIP_SIDED' : '',\r\n\r\n\t\t\t\tparameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',\r\n\t\t\t\tparameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',\r\n\t\t\t\tparameters.shadowMapDebug ? '#define SHADOWMAP_DEBUG' : '',\r\n\t\t\t\tparameters.shadowMapCascade ? '#define SHADOWMAP_CASCADE' : '',\r\n\r\n\t\t\t\tparameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',\r\n\t\t\t\t//_this._glExtensionFragDepth ? '#define USE_LOGDEPTHBUF_EXT' : '',\r\n\r\n\t\t\t\t'uniform mat4 viewMatrix;',\r\n\t\t\t\t'uniform vec3 cameraPosition;',\r\n\t\t\t\t''\r\n\r\n\t\t\t].join( '\\n' );\r\n\r\n\t\t}\r\n\r\n\t\tvar glVertexShader = new THREE.WebGLShader( _gl, _gl.VERTEX_SHADER, prefix_vertex + vertexShader );\r\n\t\tvar glFragmentShader = new THREE.WebGLShader( _gl, _gl.FRAGMENT_SHADER, prefix_fragment + fragmentShader );\r\n\r\n\t\t_gl.attachShader( program, glVertexShader );\r\n\t\t_gl.attachShader( program, glFragmentShader );\r\n\r\n\t\tif ( index0AttributeName !== undefined ) {\r\n\r\n\t\t\t// Force a particular attribute to index 0.\r\n\t\t\t// because potentially expensive emulation is done by browser if attribute 0 is disabled.\r\n\t\t\t// And, color, for example is often automatically bound to index 0 so disabling it\r\n\r\n\t\t\t_gl.bindAttribLocation( program, 0, index0AttributeName );\r\n\r\n\t\t}\r\n\r\n\t\t_gl.linkProgram( program );\r\n\r\n\t\tvar programLogInfo = _gl.getProgramInfoLog( program );\r\n\r\n\t\tif ( _gl.getProgramParameter( program, _gl.LINK_STATUS ) === false ) {\r\n\r\n\t\t\tTHREE.error( 'THREE.WebGLProgram: shader error: ' + _gl.getError(), 'gl.VALIDATE_STATUS', _gl.getProgramParameter( program, _gl.VALIDATE_STATUS ), 'gl.getPRogramInfoLog', programLogInfo );\r\n\r\n\t\t}\r\n\r\n\t\tif ( programLogInfo !== '' ) {\r\n\r\n\t\t\tTHREE.warn( 'THREE.WebGLProgram: gl.getProgramInfoLog()' + programLogInfo );\r\n\t\t\t// THREE.warn( _gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( glVertexShader ) );\r\n\t\t\t// THREE.warn( _gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( glFragmentShader ) );\r\n\r\n\t\t}\r\n\r\n\t\t// clean up\r\n\r\n\t\t_gl.deleteShader( glVertexShader );\r\n\t\t_gl.deleteShader( glFragmentShader );\r\n\r\n\t\t// cache uniform locations\r\n\r\n\t\tvar identifiers = [\r\n\r\n\t\t\t'viewMatrix',\r\n\t\t\t'modelViewMatrix',\r\n\t\t\t'projectionMatrix',\r\n\t\t\t'normalMatrix',\r\n\t\t\t'modelMatrix',\r\n\t\t\t'cameraPosition',\r\n\t\t\t'morphTargetInfluences',\r\n\t\t\t'bindMatrix',\r\n\t\t\t'bindMatrixInverse'\r\n\r\n\t\t];\r\n\r\n\t\tif ( parameters.useVertexTexture ) {\r\n\r\n\t\t\tidentifiers.push( 'boneTexture' );\r\n\t\t\tidentifiers.push( 'boneTextureWidth' );\r\n\t\t\tidentifiers.push( 'boneTextureHeight' );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tidentifiers.push( 'boneGlobalMatrices' );\r\n\r\n\t\t}\r\n\r\n\t\tif ( parameters.logarithmicDepthBuffer ) {\r\n\r\n\t\t\tidentifiers.push('logDepthBufFC');\r\n\r\n\t\t}\r\n\r\n\r\n\t\tfor ( var u in uniforms ) {\r\n\r\n\t\t\tidentifiers.push( u );\r\n\r\n\t\t}\r\n\r\n\t\tthis.uniforms = cacheUniformLocations( _gl, program, identifiers );\r\n\r\n\t\t// cache attributes locations\r\n\r\n\t\tidentifiers = [\r\n\r\n\t\t\t'position',\r\n\t\t\t'normal',\r\n\t\t\t'uv',\r\n\t\t\t'uv2',\r\n\t\t\t'tangent',\r\n\t\t\t'color',\r\n\t\t\t'skinIndex',\r\n\t\t\t'skinWeight',\r\n\t\t\t'lineDistance'\r\n\r\n\t\t];\r\n\r\n\t\tfor ( var i = 0; i < parameters.maxMorphTargets; i ++ ) {\r\n\r\n\t\t\tidentifiers.push( 'morphTarget' + i );\r\n\r\n\t\t}\r\n\r\n\t\tfor ( var i = 0; i < parameters.maxMorphNormals; i ++ ) {\r\n\r\n\t\t\tidentifiers.push( 'morphNormal' + i );\r\n\r\n\t\t}\r\n\r\n\t\tfor ( var a in attributes ) {\r\n\r\n\t\t\tidentifiers.push( a );\r\n\r\n\t\t}\r\n\r\n\t\tthis.attributes = cacheAttributeLocations( _gl, program, identifiers );\r\n\t\tthis.attributesKeys = Object.keys( this.attributes );\r\n\r\n\t\t//\r\n\r\n\t\tthis.id = programIdCount ++;\r\n\t\tthis.code = code;\r\n\t\tthis.usedTimes = 1;\r\n\t\tthis.program = program;\r\n\t\tthis.vertexShader = glVertexShader;\r\n\t\tthis.fragmentShader = glFragmentShader;\r\n\r\n\t\treturn this;\r\n\r\n\t};\r\n\r\n} )();\r\n\r\n// File:src/renderers/webgl/WebGLShader.js\r\n\r\nTHREE.WebGLShader = ( function () {\r\n\r\n\tvar addLineNumbers = function ( string ) {\r\n\r\n\t\tvar lines = string.split( '\\n' );\r\n\r\n\t\tfor ( var i = 0; i < lines.length; i ++ ) {\r\n\r\n\t\t\tlines[ i ] = ( i + 1 ) + ': ' + lines[ i ];\r\n\r\n\t\t}\r\n\r\n\t\treturn lines.join( '\\n' );\r\n\r\n\t};\r\n\r\n\treturn function ( gl, type, string ) {\r\n\r\n\t\tvar shader = gl.createShader( type ); \r\n\r\n\t\tgl.shaderSource( shader, string );\r\n\t\tgl.compileShader( shader );\r\n\r\n\t\tif ( gl.getShaderParameter( shader, gl.COMPILE_STATUS ) === false ) {\r\n\r\n\t\t\tTHREE.error( 'THREE.WebGLShader: Shader couldn\\'t compile.' );\r\n\r\n\t\t}\r\n\r\n\t\tif ( gl.getShaderInfoLog( shader ) !== '' ) {\r\n\r\n\t\t\tTHREE.warn( 'THREE.WebGLShader: gl.getShaderInfoLog()', gl.getShaderInfoLog( shader ), addLineNumbers( string ) );\r\n\r\n\t\t}\r\n\r\n\t\t// --enable-privileged-webgl-extension\r\n\t\t// console.log( type, gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( shader ) );\r\n\r\n\t\treturn shader;\r\n\r\n\t};\r\n\r\n} )();\r\n\r\n// File:src/renderers/webgl/WebGLState.js\r\n\r\n/**\r\n* @author mrdoob / http://mrdoob.com/\r\n*/\r\n\r\nTHREE.WebGLState = function ( gl, paramThreeToGL ) {\r\n\r\n\tvar newAttributes = new Uint8Array( 16 );\r\n\tvar enabledAttributes = new Uint8Array( 16 );\r\n\r\n\tvar currentBlending = null;\r\n\tvar currentBlendEquation = null;\r\n\tvar currentBlendSrc = null;\r\n\tvar currentBlendDst = null;\r\n\tvar currentBlendEquationAlpha = null;\r\n\tvar currentBlendSrcAlpha = null;\r\n\tvar currentBlendDstAlpha = null;\r\n\r\n\tvar currentDepthTest = null;\r\n\tvar currentDepthWrite = null;\r\n\r\n\tvar currentColorWrite = null;\r\n\r\n\tvar currentDoubleSided = null;\r\n\tvar currentFlipSided = null;\r\n\r\n\tvar currentLineWidth = null;\r\n\r\n\tvar currentPolygonOffset = null;\r\n\tvar currentPolygonOffsetFactor = null;\r\n\tvar currentPolygonOffsetUnits = null;\r\n\r\n\tthis.initAttributes = function () {\r\n\r\n\t\tfor ( var i = 0, l = newAttributes.length; i < l; i ++ ) {\r\n\r\n\t\t\tnewAttributes[ i ] = 0;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tthis.enableAttribute = function ( attribute ) {\r\n\r\n\t\tnewAttributes[ attribute ] = 1;\r\n\r\n\t\tif ( enabledAttributes[ attribute ] === 0 ) {\r\n\r\n\t\t\tgl.enableVertexAttribArray( attribute );\r\n\t\t\tenabledAttributes[ attribute ] = 1;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tthis.disableUnusedAttributes = function () {\r\n\r\n\t\tfor ( var i = 0, l = enabledAttributes.length; i < l; i ++ ) {\r\n\r\n\t\t\tif ( enabledAttributes[ i ] !== newAttributes[ i ] ) {\r\n\r\n\t\t\t\tgl.disableVertexAttribArray( i );\r\n\t\t\t\tenabledAttributes[ i ] = 0;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tthis.setBlending = function ( blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha ) {\r\n\r\n\t\tif ( blending !== currentBlending ) {\r\n\r\n\t\t\tif ( blending === THREE.NoBlending ) {\r\n\r\n\t\t\t\tgl.disable( gl.BLEND );\r\n\r\n\t\t\t} else if ( blending === THREE.AdditiveBlending ) {\r\n\r\n\t\t\t\tgl.enable( gl.BLEND );\r\n\t\t\t\tgl.blendEquation( gl.FUNC_ADD );\r\n\t\t\t\tgl.blendFunc( gl.SRC_ALPHA, gl.ONE );\r\n\r\n\t\t\t} else if ( blending === THREE.SubtractiveBlending ) {\r\n\r\n\t\t\t\t// TODO: Find blendFuncSeparate() combination\r\n\t\t\t\tgl.enable( gl.BLEND );\r\n\t\t\t\tgl.blendEquation( gl.FUNC_ADD );\r\n\t\t\t\tgl.blendFunc( gl.ZERO, gl.ONE_MINUS_SRC_COLOR );\r\n\r\n\t\t\t} else if ( blending === THREE.MultiplyBlending ) {\r\n\r\n\t\t\t\t// TODO: Find blendFuncSeparate() combination\r\n\t\t\t\tgl.enable( gl.BLEND );\r\n\t\t\t\tgl.blendEquation( gl.FUNC_ADD );\r\n\t\t\t\tgl.blendFunc( gl.ZERO, gl.SRC_COLOR );\r\n\r\n\t\t\t} else if ( blending === THREE.CustomBlending ) {\r\n\r\n\t\t\t\tgl.enable( gl.BLEND );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tgl.enable( gl.BLEND );\r\n\t\t\t\tgl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );\r\n\t\t\t\tgl.blendFuncSeparate( gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tcurrentBlending = blending;\r\n\r\n\t\t}\r\n\r\n\t\tif ( blending === THREE.CustomBlending ) {\r\n\r\n\t\t\tblendEquationAlpha = blendEquationAlpha || blendEquation;\r\n\t\t\tblendSrcAlpha = blendSrcAlpha || blendSrc;\r\n\t\t\tblendDstAlpha = blendDstAlpha || blendDst;\r\n\r\n\t\t\tif ( blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha ) {\r\n\r\n\t\t\t\tgl.blendEquationSeparate( paramThreeToGL( blendEquation ), paramThreeToGL( blendEquationAlpha ) );\r\n\r\n\t\t\t\tcurrentBlendEquation = blendEquation;\r\n\t\t\t\tcurrentBlendEquationAlpha = blendEquationAlpha;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha ) {\r\n\r\n\t\t\t\tgl.blendFuncSeparate( paramThreeToGL( blendSrc ), paramThreeToGL( blendDst ), paramThreeToGL( blendSrcAlpha ), paramThreeToGL( blendDstAlpha ) );\r\n\r\n\t\t\t\tcurrentBlendSrc = blendSrc;\r\n\t\t\t\tcurrentBlendDst = blendDst;\r\n\t\t\t\tcurrentBlendSrcAlpha = blendSrcAlpha;\r\n\t\t\t\tcurrentBlendDstAlpha = blendDstAlpha;\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\tcurrentBlendEquation = null;\r\n\t\t\tcurrentBlendSrc = null;\r\n\t\t\tcurrentBlendDst = null;\r\n\t\t\tcurrentBlendEquationAlpha = null;\r\n\t\t\tcurrentBlendSrcAlpha = null;\r\n\t\t\tcurrentBlendDstAlpha = null;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tthis.setDepthTest = function ( depthTest ) {\r\n\r\n\t\tif ( currentDepthTest !== depthTest ) {\r\n\r\n\t\t\tif ( depthTest ) {\r\n\r\n\t\t\t\tgl.enable( gl.DEPTH_TEST );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tgl.disable( gl.DEPTH_TEST );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tcurrentDepthTest = depthTest;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tthis.setDepthWrite = function ( depthWrite ) {\r\n\r\n\t\tif ( currentDepthWrite !== depthWrite ) {\r\n\r\n\t\t\tgl.depthMask( depthWrite );\r\n\t\t\tcurrentDepthWrite = depthWrite;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tthis.setColorWrite = function ( colorWrite ) {\r\n\r\n\t\tif ( currentColorWrite !== colorWrite ) {\r\n\r\n\t\t\tgl.colorMask( colorWrite, colorWrite, colorWrite, colorWrite );\r\n\t\t\tcurrentColorWrite = colorWrite;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tthis.setDoubleSided = function ( doubleSided ) {\r\n\r\n\t\tif ( currentDoubleSided !== doubleSided ) {\r\n\r\n\t\t\tif ( doubleSided ) {\r\n\r\n\t\t\t\tgl.disable( gl.CULL_FACE );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tgl.enable( gl.CULL_FACE );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tcurrentDoubleSided = doubleSided;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tthis.setFlipSided = function ( flipSided ) {\r\n\r\n\t\tif ( currentFlipSided !== flipSided ) {\r\n\r\n\t\t\tif ( flipSided ) {\r\n\r\n\t\t\t\tgl.frontFace( gl.CW );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tgl.frontFace( gl.CCW );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tcurrentFlipSided = flipSided;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tthis.setLineWidth = function ( width ) {\r\n\r\n\t\tif ( width !== currentLineWidth ) {\r\n\r\n\t\t\tgl.lineWidth( width );\r\n\r\n\t\t\tcurrentLineWidth = width;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tthis.setPolygonOffset = function ( polygonoffset, factor, units ) {\r\n\r\n\t\tif ( currentPolygonOffset !== polygonoffset ) {\r\n\r\n\t\t\tif ( polygonoffset ) {\r\n\r\n\t\t\t\tgl.enable( gl.POLYGON_OFFSET_FILL );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tgl.disable( gl.POLYGON_OFFSET_FILL );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tcurrentPolygonOffset = polygonoffset;\r\n\r\n\t\t}\r\n\r\n\t\tif ( polygonoffset && ( currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units ) ) {\r\n\r\n\t\t\tgl.polygonOffset( factor, units );\r\n\r\n\t\t\tcurrentPolygonOffsetFactor = factor;\r\n\t\t\tcurrentPolygonOffsetUnits = units;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tthis.reset = function () {\r\n\r\n\t\tfor ( var i = 0; i < enabledAttributes.length; i ++ ) {\r\n\r\n\t\t\tenabledAttributes[ i ] = 0;\r\n\r\n\t\t}\r\n\r\n\t\tcurrentBlending = null;\r\n\t\tcurrentDepthTest = null;\r\n\t\tcurrentDepthWrite = null;\r\n\t\tcurrentColorWrite = null;\r\n\t\tcurrentDoubleSided = null;\r\n\t\tcurrentFlipSided = null;\r\n\r\n\t};\r\n\r\n};\r\n\r\n// File:src/renderers/webgl/plugins/LensFlarePlugin.js\r\n\r\n/**\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.LensFlarePlugin = function ( renderer, flares ) {\r\n\r\n\tvar gl = renderer.context;\r\n\r\n\tvar vertexBuffer, elementBuffer;\r\n\tvar program, attributes, uniforms;\r\n\tvar hasVertexTexture;\r\n\r\n\tvar tempTexture, occlusionTexture;\r\n\r\n\tvar init = function () {\r\n\r\n\t\tvar vertices = new Float32Array( [\r\n\t\t\t-1, -1,  0, 0,\r\n\t\t\t 1, -1,  1, 0,\r\n\t\t\t 1,  1,  1, 1,\r\n\t\t\t-1,  1,  0, 1\r\n\t\t] );\r\n\r\n\t\tvar faces = new Uint16Array( [\r\n\t\t\t0, 1, 2,\r\n\t\t\t0, 2, 3\r\n\t\t] );\r\n\r\n\t\t// buffers\r\n\r\n\t\tvertexBuffer     = gl.createBuffer();\r\n\t\telementBuffer    = gl.createBuffer();\r\n\r\n\t\tgl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );\r\n\t\tgl.bufferData( gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW );\r\n\r\n\t\tgl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );\r\n\t\tgl.bufferData( gl.ELEMENT_ARRAY_BUFFER, faces, gl.STATIC_DRAW );\r\n\r\n\t\t// textures\r\n\r\n\t\ttempTexture      = gl.createTexture();\r\n\t\tocclusionTexture = gl.createTexture();\r\n\r\n\t\tgl.bindTexture( gl.TEXTURE_2D, tempTexture );\r\n\t\tgl.texImage2D( gl.TEXTURE_2D, 0, gl.RGB, 16, 16, 0, gl.RGB, gl.UNSIGNED_BYTE, null );\r\n\t\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE );\r\n\t\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE );\r\n\t\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST );\r\n\t\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST );\r\n\r\n\t\tgl.bindTexture( gl.TEXTURE_2D, occlusionTexture );\r\n\t\tgl.texImage2D( gl.TEXTURE_2D, 0, gl.RGBA, 16, 16, 0, gl.RGBA, gl.UNSIGNED_BYTE, null );\r\n\t\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE );\r\n\t\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE );\r\n\t\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST );\r\n\t\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST );\r\n\r\n\t\thasVertexTexture = gl.getParameter( gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS ) > 0;\r\n\r\n\t\tvar shader;\r\n\r\n\t\tif ( hasVertexTexture ) {\r\n\r\n\t\t\tshader = {\r\n\r\n\t\t\t\tvertexShader: [\r\n\r\n\t\t\t\t\t\"uniform lowp int renderType;\",\r\n\r\n\t\t\t\t\t\"uniform vec3 screenPosition;\",\r\n\t\t\t\t\t\"uniform vec2 scale;\",\r\n\t\t\t\t\t\"uniform float rotation;\",\r\n\r\n\t\t\t\t\t\"uniform sampler2D occlusionMap;\",\r\n\r\n\t\t\t\t\t\"attribute vec2 position;\",\r\n\t\t\t\t\t\"attribute vec2 uv;\",\r\n\r\n\t\t\t\t\t\"varying vec2 vUV;\",\r\n\t\t\t\t\t\"varying float vVisibility;\",\r\n\r\n\t\t\t\t\t\"void main() {\",\r\n\r\n\t\t\t\t\t\t\"vUV = uv;\",\r\n\r\n\t\t\t\t\t\t\"vec2 pos = position;\",\r\n\r\n\t\t\t\t\t\t\"if( renderType == 2 ) {\",\r\n\r\n\t\t\t\t\t\t\t\"vec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );\",\r\n\t\t\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );\",\r\n\t\t\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );\",\r\n\t\t\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );\",\r\n\t\t\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );\",\r\n\t\t\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );\",\r\n\t\t\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );\",\r\n\t\t\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );\",\r\n\t\t\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );\",\r\n\r\n\t\t\t\t\t\t\t\"vVisibility =        visibility.r / 9.0;\",\r\n\t\t\t\t\t\t\t\"vVisibility *= 1.0 - visibility.g / 9.0;\",\r\n\t\t\t\t\t\t\t\"vVisibility *=       visibility.b / 9.0;\",\r\n\t\t\t\t\t\t\t\"vVisibility *= 1.0 - visibility.a / 9.0;\",\r\n\r\n\t\t\t\t\t\t\t\"pos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;\",\r\n\t\t\t\t\t\t\t\"pos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;\",\r\n\r\n\t\t\t\t\t\t\"}\",\r\n\r\n\t\t\t\t\t\t\"gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );\",\r\n\r\n\t\t\t\t\t\"}\"\r\n\r\n\t\t\t\t].join( \"\\n\" ),\r\n\r\n\t\t\t\tfragmentShader: [\r\n\r\n\t\t\t\t\t\"uniform lowp int renderType;\",\r\n\r\n\t\t\t\t\t\"uniform sampler2D map;\",\r\n\t\t\t\t\t\"uniform float opacity;\",\r\n\t\t\t\t\t\"uniform vec3 color;\",\r\n\r\n\t\t\t\t\t\"varying vec2 vUV;\",\r\n\t\t\t\t\t\"varying float vVisibility;\",\r\n\r\n\t\t\t\t\t\"void main() {\",\r\n\r\n\t\t\t\t\t\t// pink square\r\n\r\n\t\t\t\t\t\t\"if( renderType == 0 ) {\",\r\n\r\n\t\t\t\t\t\t\t\"gl_FragColor = vec4( 1.0, 0.0, 1.0, 0.0 );\",\r\n\r\n\t\t\t\t\t\t// restore\r\n\r\n\t\t\t\t\t\t\"} else if( renderType == 1 ) {\",\r\n\r\n\t\t\t\t\t\t\t\"gl_FragColor = texture2D( map, vUV );\",\r\n\r\n\t\t\t\t\t\t// flare\r\n\r\n\t\t\t\t\t\t\"} else {\",\r\n\r\n\t\t\t\t\t\t\t\"vec4 texture = texture2D( map, vUV );\",\r\n\t\t\t\t\t\t\t\"texture.a *= opacity * vVisibility;\",\r\n\t\t\t\t\t\t\t\"gl_FragColor = texture;\",\r\n\t\t\t\t\t\t\t\"gl_FragColor.rgb *= color;\",\r\n\r\n\t\t\t\t\t\t\"}\",\r\n\r\n\t\t\t\t\t\"}\"\r\n\r\n\t\t\t\t].join( \"\\n\" )\r\n\r\n\t\t\t};\r\n\r\n\t\t} else {\r\n\r\n\t\t\tshader = {\r\n\r\n\t\t\t\tvertexShader: [\r\n\r\n\t\t\t\t\t\"uniform lowp int renderType;\",\r\n\r\n\t\t\t\t\t\"uniform vec3 screenPosition;\",\r\n\t\t\t\t\t\"uniform vec2 scale;\",\r\n\t\t\t\t\t\"uniform float rotation;\",\r\n\r\n\t\t\t\t\t\"attribute vec2 position;\",\r\n\t\t\t\t\t\"attribute vec2 uv;\",\r\n\r\n\t\t\t\t\t\"varying vec2 vUV;\",\r\n\r\n\t\t\t\t\t\"void main() {\",\r\n\r\n\t\t\t\t\t\t\"vUV = uv;\",\r\n\r\n\t\t\t\t\t\t\"vec2 pos = position;\",\r\n\r\n\t\t\t\t\t\t\"if( renderType == 2 ) {\",\r\n\r\n\t\t\t\t\t\t\t\"pos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;\",\r\n\t\t\t\t\t\t\t\"pos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;\",\r\n\r\n\t\t\t\t\t\t\"}\",\r\n\r\n\t\t\t\t\t\t\"gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );\",\r\n\r\n\t\t\t\t\t\"}\"\r\n\r\n\t\t\t\t].join( \"\\n\" ),\r\n\r\n\t\t\t\tfragmentShader: [\r\n\r\n\t\t\t\t\t\"precision mediump float;\",\r\n\r\n\t\t\t\t\t\"uniform lowp int renderType;\",\r\n\r\n\t\t\t\t\t\"uniform sampler2D map;\",\r\n\t\t\t\t\t\"uniform sampler2D occlusionMap;\",\r\n\t\t\t\t\t\"uniform float opacity;\",\r\n\t\t\t\t\t\"uniform vec3 color;\",\r\n\r\n\t\t\t\t\t\"varying vec2 vUV;\",\r\n\r\n\t\t\t\t\t\"void main() {\",\r\n\r\n\t\t\t\t\t\t// pink square\r\n\r\n\t\t\t\t\t\t\"if( renderType == 0 ) {\",\r\n\r\n\t\t\t\t\t\t\t\"gl_FragColor = vec4( texture2D( map, vUV ).rgb, 0.0 );\",\r\n\r\n\t\t\t\t\t\t// restore\r\n\r\n\t\t\t\t\t\t\"} else if( renderType == 1 ) {\",\r\n\r\n\t\t\t\t\t\t\t\"gl_FragColor = texture2D( map, vUV );\",\r\n\r\n\t\t\t\t\t\t// flare\r\n\r\n\t\t\t\t\t\t\"} else {\",\r\n\r\n\t\t\t\t\t\t\t\"float visibility = texture2D( occlusionMap, vec2( 0.5, 0.1 ) ).a;\",\r\n\t\t\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) ).a;\",\r\n\t\t\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) ).a;\",\r\n\t\t\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) ).a;\",\r\n\t\t\t\t\t\t\t\"visibility = ( 1.0 - visibility / 4.0 );\",\r\n\r\n\t\t\t\t\t\t\t\"vec4 texture = texture2D( map, vUV );\",\r\n\t\t\t\t\t\t\t\"texture.a *= opacity * visibility;\",\r\n\t\t\t\t\t\t\t\"gl_FragColor = texture;\",\r\n\t\t\t\t\t\t\t\"gl_FragColor.rgb *= color;\",\r\n\r\n\t\t\t\t\t\t\"}\",\r\n\r\n\t\t\t\t\t\"}\"\r\n\r\n\t\t\t\t].join( \"\\n\" )\r\n\r\n\t\t\t};\r\n\r\n\t\t}\r\n\r\n\t\tprogram = createProgram( shader );\r\n\r\n\t\tattributes = {\r\n\t\t\tvertex: gl.getAttribLocation ( program, \"position\" ),\r\n\t\t\tuv:     gl.getAttribLocation ( program, \"uv\" )\r\n\t\t}\r\n\r\n\t\tuniforms = {\r\n\t\t\trenderType:     gl.getUniformLocation( program, \"renderType\" ),\r\n\t\t\tmap:            gl.getUniformLocation( program, \"map\" ),\r\n\t\t\tocclusionMap:   gl.getUniformLocation( program, \"occlusionMap\" ),\r\n\t\t\topacity:        gl.getUniformLocation( program, \"opacity\" ),\r\n\t\t\tcolor:          gl.getUniformLocation( program, \"color\" ),\r\n\t\t\tscale:          gl.getUniformLocation( program, \"scale\" ),\r\n\t\t\trotation:       gl.getUniformLocation( program, \"rotation\" ),\r\n\t\t\tscreenPosition: gl.getUniformLocation( program, \"screenPosition\" )\r\n\t\t};\r\n\r\n\t};\r\n\r\n\t/*\r\n\t * Render lens flares\r\n\t * Method: renders 16x16 0xff00ff-colored points scattered over the light source area,\r\n\t *         reads these back and calculates occlusion.\r\n\t */\r\n\r\n\tthis.render = function ( scene, camera, viewportWidth, viewportHeight ) {\r\n\r\n\t\tif ( flares.length === 0 ) return;\r\n\r\n\t\tvar tempPosition = new THREE.Vector3();\r\n\r\n\t\tvar invAspect = viewportHeight / viewportWidth,\r\n\t\t\thalfViewportWidth = viewportWidth * 0.5,\r\n\t\t\thalfViewportHeight = viewportHeight * 0.5;\r\n\r\n\t\tvar size = 16 / viewportHeight,\r\n\t\t\tscale = new THREE.Vector2( size * invAspect, size );\r\n\r\n\t\tvar screenPosition = new THREE.Vector3( 1, 1, 0 ),\r\n\t\t\tscreenPositionPixels = new THREE.Vector2( 1, 1 );\r\n\r\n\t\tif ( program === undefined ) {\r\n\r\n\t\t\tinit();\r\n\r\n\t\t}\r\n\r\n\t\tgl.useProgram( program );\r\n\r\n\t\tgl.enableVertexAttribArray( attributes.vertex );\r\n\t\tgl.enableVertexAttribArray( attributes.uv );\r\n\r\n\t\t// loop through all lens flares to update their occlusion and positions\r\n\t\t// setup gl and common used attribs/unforms\r\n\r\n\t\tgl.uniform1i( uniforms.occlusionMap, 0 );\r\n\t\tgl.uniform1i( uniforms.map, 1 );\r\n\r\n\t\tgl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );\r\n\t\tgl.vertexAttribPointer( attributes.vertex, 2, gl.FLOAT, false, 2 * 8, 0 );\r\n\t\tgl.vertexAttribPointer( attributes.uv, 2, gl.FLOAT, false, 2 * 8, 8 );\r\n\r\n\t\tgl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );\r\n\r\n\t\tgl.disable( gl.CULL_FACE );\r\n\t\tgl.depthMask( false );\r\n\r\n\t\tfor ( var i = 0, l = flares.length; i < l; i ++ ) {\r\n\r\n\t\t\tsize = 16 / viewportHeight;\r\n\t\t\tscale.set( size * invAspect, size );\r\n\r\n\t\t\t// calc object screen position\r\n\r\n\t\t\tvar flare = flares[ i ];\r\n\r\n\t\t\ttempPosition.set( flare.matrixWorld.elements[12], flare.matrixWorld.elements[13], flare.matrixWorld.elements[14] );\r\n\r\n\t\t\ttempPosition.applyMatrix4( camera.matrixWorldInverse );\r\n\t\t\ttempPosition.applyProjection( camera.projectionMatrix );\r\n\r\n\t\t\t// setup arrays for gl programs\r\n\r\n\t\t\tscreenPosition.copy( tempPosition )\r\n\r\n\t\t\tscreenPositionPixels.x = screenPosition.x * halfViewportWidth + halfViewportWidth;\r\n\t\t\tscreenPositionPixels.y = screenPosition.y * halfViewportHeight + halfViewportHeight;\r\n\r\n\t\t\t// screen cull\r\n\r\n\t\t\tif ( hasVertexTexture || (\r\n\t\t\t\tscreenPositionPixels.x > 0 &&\r\n\t\t\t\tscreenPositionPixels.x < viewportWidth &&\r\n\t\t\t\tscreenPositionPixels.y > 0 &&\r\n\t\t\t\tscreenPositionPixels.y < viewportHeight ) ) {\r\n\r\n\t\t\t\t// save current RGB to temp texture\r\n\r\n\t\t\t\tgl.activeTexture( gl.TEXTURE1 );\r\n\t\t\t\tgl.bindTexture( gl.TEXTURE_2D, tempTexture );\r\n\t\t\t\tgl.copyTexImage2D( gl.TEXTURE_2D, 0, gl.RGB, screenPositionPixels.x - 8, screenPositionPixels.y - 8, 16, 16, 0 );\r\n\r\n\r\n\t\t\t\t// render pink quad\r\n\r\n\t\t\t\tgl.uniform1i( uniforms.renderType, 0 );\r\n\t\t\t\tgl.uniform2f( uniforms.scale, scale.x, scale.y );\r\n\t\t\t\tgl.uniform3f( uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z );\r\n\r\n\t\t\t\tgl.disable( gl.BLEND );\r\n\t\t\t\tgl.enable( gl.DEPTH_TEST );\r\n\r\n\t\t\t\tgl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );\r\n\r\n\r\n\t\t\t\t// copy result to occlusionMap\r\n\r\n\t\t\t\tgl.activeTexture( gl.TEXTURE0 );\r\n\t\t\t\tgl.bindTexture( gl.TEXTURE_2D, occlusionTexture );\r\n\t\t\t\tgl.copyTexImage2D( gl.TEXTURE_2D, 0, gl.RGBA, screenPositionPixels.x - 8, screenPositionPixels.y - 8, 16, 16, 0 );\r\n\r\n\r\n\t\t\t\t// restore graphics\r\n\r\n\t\t\t\tgl.uniform1i( uniforms.renderType, 1 );\r\n\t\t\t\tgl.disable( gl.DEPTH_TEST );\r\n\r\n\t\t\t\tgl.activeTexture( gl.TEXTURE1 );\r\n\t\t\t\tgl.bindTexture( gl.TEXTURE_2D, tempTexture );\r\n\t\t\t\tgl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );\r\n\r\n\r\n\t\t\t\t// update object positions\r\n\r\n\t\t\t\tflare.positionScreen.copy( screenPosition )\r\n\r\n\t\t\t\tif ( flare.customUpdateCallback ) {\r\n\r\n\t\t\t\t\tflare.customUpdateCallback( flare );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tflare.updateLensFlares();\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// render flares\r\n\r\n\t\t\t\tgl.uniform1i( uniforms.renderType, 2 );\r\n\t\t\t\tgl.enable( gl.BLEND );\r\n\r\n\t\t\t\tfor ( var j = 0, jl = flare.lensFlares.length; j < jl; j ++ ) {\r\n\r\n\t\t\t\t\tvar sprite = flare.lensFlares[ j ];\r\n\r\n\t\t\t\t\tif ( sprite.opacity > 0.001 && sprite.scale > 0.001 ) {\r\n\r\n\t\t\t\t\t\tscreenPosition.x = sprite.x;\r\n\t\t\t\t\t\tscreenPosition.y = sprite.y;\r\n\t\t\t\t\t\tscreenPosition.z = sprite.z;\r\n\r\n\t\t\t\t\t\tsize = sprite.size * sprite.scale / viewportHeight;\r\n\r\n\t\t\t\t\t\tscale.x = size * invAspect;\r\n\t\t\t\t\t\tscale.y = size;\r\n\r\n\t\t\t\t\t\tgl.uniform3f( uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z );\r\n\t\t\t\t\t\tgl.uniform2f( uniforms.scale, scale.x, scale.y );\r\n\t\t\t\t\t\tgl.uniform1f( uniforms.rotation, sprite.rotation );\r\n\r\n\t\t\t\t\t\tgl.uniform1f( uniforms.opacity, sprite.opacity );\r\n\t\t\t\t\t\tgl.uniform3f( uniforms.color, sprite.color.r, sprite.color.g, sprite.color.b );\r\n\r\n\t\t\t\t\t\trenderer.state.setBlending( sprite.blending, sprite.blendEquation, sprite.blendSrc, sprite.blendDst );\r\n\t\t\t\t\t\trenderer.setTexture( sprite.texture, 1 );\r\n\r\n\t\t\t\t\t\tgl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// restore gl\r\n\r\n\t\tgl.enable( gl.CULL_FACE );\r\n\t\tgl.enable( gl.DEPTH_TEST );\r\n\t\tgl.depthMask( true );\r\n\r\n\t\trenderer.resetGLState();\r\n\r\n\t};\r\n\r\n\tfunction createProgram ( shader ) {\r\n\r\n\t\tvar program = gl.createProgram();\r\n\r\n\t\tvar fragmentShader = gl.createShader( gl.FRAGMENT_SHADER );\r\n\t\tvar vertexShader = gl.createShader( gl.VERTEX_SHADER );\r\n\r\n\t\tvar prefix = \"precision \" + renderer.getPrecision() + \" float;\\n\";\r\n\r\n\t\tgl.shaderSource( fragmentShader, prefix + shader.fragmentShader );\r\n\t\tgl.shaderSource( vertexShader, prefix + shader.vertexShader );\r\n\r\n\t\tgl.compileShader( fragmentShader );\r\n\t\tgl.compileShader( vertexShader );\r\n\r\n\t\tgl.attachShader( program, fragmentShader );\r\n\t\tgl.attachShader( program, vertexShader );\r\n\r\n\t\tgl.linkProgram( program );\r\n\r\n\t\treturn program;\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/renderers/webgl/plugins/ShadowMapPlugin.js\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.ShadowMapPlugin = function ( _renderer, _lights, _webglObjects, _webglObjectsImmediate ) {\r\n\r\n\tvar _gl = _renderer.context;\r\n\r\n\tvar _depthMaterial, _depthMaterialMorph, _depthMaterialSkin, _depthMaterialMorphSkin,\r\n\r\n\t_frustum = new THREE.Frustum(),\r\n\t_projScreenMatrix = new THREE.Matrix4(),\r\n\r\n\t_min = new THREE.Vector3(),\r\n\t_max = new THREE.Vector3(),\r\n\r\n\t_matrixPosition = new THREE.Vector3(),\r\n\r\n\t_renderList = [];\r\n\r\n\t// init\r\n\r\n\tvar depthShader = THREE.ShaderLib[ \"depthRGBA\" ];\r\n\tvar depthUniforms = THREE.UniformsUtils.clone( depthShader.uniforms );\r\n\r\n\t_depthMaterial = new THREE.ShaderMaterial( {\r\n\t\tuniforms: depthUniforms,\r\n\t\tvertexShader: depthShader.vertexShader,\r\n\t\tfragmentShader: depthShader.fragmentShader\r\n\t } );\r\n\r\n\t_depthMaterialMorph = new THREE.ShaderMaterial( {\r\n\t\tuniforms: depthUniforms,\r\n\t\tvertexShader: depthShader.vertexShader,\r\n\t\tfragmentShader: depthShader.fragmentShader,\r\n\t\tmorphTargets: true\r\n\t} );\r\n\r\n\t_depthMaterialSkin = new THREE.ShaderMaterial( {\r\n\t\tuniforms: depthUniforms,\r\n\t\tvertexShader: depthShader.vertexShader,\r\n\t\tfragmentShader: depthShader.fragmentShader,\r\n\t\tskinning: true\r\n\t} );\r\n\r\n\t_depthMaterialMorphSkin = new THREE.ShaderMaterial( {\r\n\t\tuniforms: depthUniforms,\r\n\t\tvertexShader: depthShader.vertexShader,\r\n\t\tfragmentShader: depthShader.fragmentShader,\r\n\t\tmorphTargets: true,\r\n\t\tskinning: true\r\n\t} );\r\n\r\n\t_depthMaterial._shadowPass = true;\r\n\t_depthMaterialMorph._shadowPass = true;\r\n\t_depthMaterialSkin._shadowPass = true;\r\n\t_depthMaterialMorphSkin._shadowPass = true;\r\n\r\n\tthis.render = function ( scene, camera ) {\r\n\r\n\t\tif ( _renderer.shadowMapEnabled === false ) return;\r\n\r\n\t\tvar i, il, j, jl, n,\r\n\r\n\t\tshadowMap, shadowMatrix, shadowCamera,\r\n\t\tbuffer, material,\r\n\t\twebglObject, object, light,\r\n\r\n\t\tlights = [],\r\n\t\tk = 0,\r\n\r\n\t\tfog = null;\r\n\r\n\t\t// set GL state for depth map\r\n\r\n\t\t_gl.clearColor( 1, 1, 1, 1 );\r\n\t\t_gl.disable( _gl.BLEND );\r\n\r\n\t\t_gl.enable( _gl.CULL_FACE );\r\n\t\t_gl.frontFace( _gl.CCW );\r\n\r\n\t\tif ( _renderer.shadowMapCullFace === THREE.CullFaceFront ) {\r\n\r\n\t\t\t_gl.cullFace( _gl.FRONT );\r\n\r\n\t\t} else {\r\n\r\n\t\t\t_gl.cullFace( _gl.BACK );\r\n\r\n\t\t}\r\n\r\n\t\t_renderer.state.setDepthTest( true );\r\n\r\n\t\t// preprocess lights\r\n\t\t// \t- skip lights that are not casting shadows\r\n\t\t//\t- create virtual lights for cascaded shadow maps\r\n\r\n\t\tfor ( i = 0, il = _lights.length; i < il; i ++ ) {\r\n\r\n\t\t\tlight = _lights[ i ];\r\n\r\n\t\t\tif ( ! light.castShadow ) continue;\r\n\r\n\t\t\tif ( ( light instanceof THREE.DirectionalLight ) && light.shadowCascade ) {\r\n\r\n\t\t\t\tfor ( n = 0; n < light.shadowCascadeCount; n ++ ) {\r\n\r\n\t\t\t\t\tvar virtualLight;\r\n\r\n\t\t\t\t\tif ( ! light.shadowCascadeArray[ n ] ) {\r\n\r\n\t\t\t\t\t\tvirtualLight = createVirtualLight( light, n );\r\n\t\t\t\t\t\tvirtualLight.originalCamera = camera;\r\n\r\n\t\t\t\t\t\tvar gyro = new THREE.Gyroscope();\r\n\t\t\t\t\t\tgyro.position.copy( light.shadowCascadeOffset );\r\n\r\n\t\t\t\t\t\tgyro.add( virtualLight );\r\n\t\t\t\t\t\tgyro.add( virtualLight.target );\r\n\r\n\t\t\t\t\t\tcamera.add( gyro );\r\n\r\n\t\t\t\t\t\tlight.shadowCascadeArray[ n ] = virtualLight;\r\n\r\n\t\t\t\t\t\t//console.log( \"Created virtualLight\", virtualLight );\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tvirtualLight = light.shadowCascadeArray[ n ];\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tupdateVirtualLight( light, n );\r\n\r\n\t\t\t\t\tlights[ k ] = virtualLight;\r\n\t\t\t\t\tk ++;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tlights[ k ] = light;\r\n\t\t\t\tk ++;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// render depth map\r\n\r\n\t\tfor ( i = 0, il = lights.length; i < il; i ++ ) {\r\n\r\n\t\t\tlight = lights[ i ];\r\n\r\n\t\t\tif ( ! light.shadowMap ) {\r\n\r\n\t\t\t\tvar shadowFilter = THREE.LinearFilter;\r\n\r\n\t\t\t\tif ( _renderer.shadowMapType === THREE.PCFSoftShadowMap ) {\r\n\r\n\t\t\t\t\tshadowFilter = THREE.NearestFilter;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tvar pars = { minFilter: shadowFilter, magFilter: shadowFilter, format: THREE.RGBAFormat };\r\n\r\n\t\t\t\tlight.shadowMap = new THREE.WebGLRenderTarget( light.shadowMapWidth, light.shadowMapHeight, pars );\r\n\t\t\t\tlight.shadowMapSize = new THREE.Vector2( light.shadowMapWidth, light.shadowMapHeight );\r\n\r\n\t\t\t\tlight.shadowMatrix = new THREE.Matrix4();\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( ! light.shadowCamera ) {\r\n\r\n\t\t\t\tif ( light instanceof THREE.SpotLight ) {\r\n\r\n\t\t\t\t\tlight.shadowCamera = new THREE.PerspectiveCamera( light.shadowCameraFov, light.shadowMapWidth / light.shadowMapHeight, light.shadowCameraNear, light.shadowCameraFar );\r\n\r\n\t\t\t\t} else if ( light instanceof THREE.DirectionalLight ) {\r\n\r\n\t\t\t\t\tlight.shadowCamera = new THREE.OrthographicCamera( light.shadowCameraLeft, light.shadowCameraRight, light.shadowCameraTop, light.shadowCameraBottom, light.shadowCameraNear, light.shadowCameraFar );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tTHREE.error( \"THREE.ShadowMapPlugin: Unsupported light type for shadow\", light );\r\n\t\t\t\t\tcontinue;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tscene.add( light.shadowCamera );\r\n\r\n\t\t\t\tif ( scene.autoUpdate === true ) scene.updateMatrixWorld();\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( light.shadowCameraVisible && ! light.cameraHelper ) {\r\n\r\n\t\t\t\tlight.cameraHelper = new THREE.CameraHelper( light.shadowCamera );\r\n\t\t\t\tscene.add( light.cameraHelper );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( light.isVirtual && virtualLight.originalCamera == camera ) {\r\n\r\n\t\t\t\tupdateShadowCamera( camera, light );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tshadowMap = light.shadowMap;\r\n\t\t\tshadowMatrix = light.shadowMatrix;\r\n\t\t\tshadowCamera = light.shadowCamera;\r\n\r\n\t\t\t//\r\n\r\n\t\t\tshadowCamera.position.setFromMatrixPosition( light.matrixWorld );\r\n\t\t\t_matrixPosition.setFromMatrixPosition( light.target.matrixWorld );\r\n\t\t\tshadowCamera.lookAt( _matrixPosition );\r\n\t\t\tshadowCamera.updateMatrixWorld();\r\n\r\n\t\t\tshadowCamera.matrixWorldInverse.getInverse( shadowCamera.matrixWorld );\r\n\r\n\t\t\t//\r\n\r\n\t\t\tif ( light.cameraHelper ) light.cameraHelper.visible = light.shadowCameraVisible;\r\n\t\t\tif ( light.shadowCameraVisible ) light.cameraHelper.update();\r\n\r\n\t\t\t// compute shadow matrix\r\n\r\n\t\t\tshadowMatrix.set(\r\n\t\t\t\t0.5, 0.0, 0.0, 0.5,\r\n\t\t\t\t0.0, 0.5, 0.0, 0.5,\r\n\t\t\t\t0.0, 0.0, 0.5, 0.5,\r\n\t\t\t\t0.0, 0.0, 0.0, 1.0\r\n\t\t\t);\r\n\r\n\t\t\tshadowMatrix.multiply( shadowCamera.projectionMatrix );\r\n\t\t\tshadowMatrix.multiply( shadowCamera.matrixWorldInverse );\r\n\r\n\t\t\t// update camera matrices and frustum\r\n\r\n\t\t\t_projScreenMatrix.multiplyMatrices( shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse );\r\n\t\t\t_frustum.setFromMatrix( _projScreenMatrix );\r\n\r\n\t\t\t// render shadow map\r\n\r\n\t\t\t_renderer.setRenderTarget( shadowMap );\r\n\t\t\t_renderer.clear();\r\n\r\n\t\t\t// set object matrices & frustum culling\r\n\r\n\t\t\t_renderList.length = 0;\r\n\r\n\t\t\tprojectObject( scene, scene, shadowCamera );\r\n\r\n\r\n\t\t\t// render regular objects\r\n\r\n\t\t\tvar objectMaterial, useMorphing, useSkinning;\r\n\r\n\t\t\tfor ( j = 0, jl = _renderList.length; j < jl; j ++ ) {\r\n\r\n\t\t\t\twebglObject = _renderList[ j ];\r\n\r\n\t\t\t\tobject = webglObject.object;\r\n\t\t\t\tbuffer = webglObject.buffer;\r\n\r\n\t\t\t\t// culling is overriden globally for all objects\r\n\t\t\t\t// while rendering depth map\r\n\r\n\t\t\t\t// need to deal with MeshFaceMaterial somehow\r\n\t\t\t\t// in that case just use the first of material.materials for now\r\n\t\t\t\t// (proper solution would require to break objects by materials\r\n\t\t\t\t//  similarly to regular rendering and then set corresponding\r\n\t\t\t\t//  depth materials per each chunk instead of just once per object)\r\n\r\n\t\t\t\tobjectMaterial = getObjectMaterial( object );\r\n\r\n\t\t\t\tuseMorphing = object.geometry.morphTargets !== undefined && object.geometry.morphTargets.length > 0 && objectMaterial.morphTargets;\r\n\t\t\t\tuseSkinning = object instanceof THREE.SkinnedMesh && objectMaterial.skinning;\r\n\r\n\t\t\t\tif ( object.customDepthMaterial ) {\r\n\r\n\t\t\t\t\tmaterial = object.customDepthMaterial;\r\n\r\n\t\t\t\t} else if ( useSkinning ) {\r\n\r\n\t\t\t\t\tmaterial = useMorphing ? _depthMaterialMorphSkin : _depthMaterialSkin;\r\n\r\n\t\t\t\t} else if ( useMorphing ) {\r\n\r\n\t\t\t\t\tmaterial = _depthMaterialMorph;\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tmaterial = _depthMaterial;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t_renderer.setMaterialFaces( objectMaterial );\r\n\r\n\t\t\t\tif ( buffer instanceof THREE.BufferGeometry ) {\r\n\r\n\t\t\t\t\t_renderer.renderBufferDirect( shadowCamera, _lights, fog, material, buffer, object );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\t_renderer.renderBuffer( shadowCamera, _lights, fog, material, buffer, object );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// set matrices and render immediate objects\r\n\r\n\t\t\tfor ( j = 0, jl = _webglObjectsImmediate.length; j < jl; j ++ ) {\r\n\r\n\t\t\t\twebglObject = _webglObjectsImmediate[ j ];\r\n\t\t\t\tobject = webglObject.object;\r\n\r\n\t\t\t\tif ( object.visible && object.castShadow ) {\r\n\r\n\t\t\t\t\tobject._modelViewMatrix.multiplyMatrices( shadowCamera.matrixWorldInverse, object.matrixWorld );\r\n\r\n\t\t\t\t\t_renderer.renderImmediateObject( shadowCamera, _lights, fog, _depthMaterial, object );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// restore GL state\r\n\r\n\t\tvar clearColor = _renderer.getClearColor(),\r\n\t\tclearAlpha = _renderer.getClearAlpha();\r\n\r\n\t\t_gl.clearColor( clearColor.r, clearColor.g, clearColor.b, clearAlpha );\r\n\t\t_gl.enable( _gl.BLEND );\r\n\r\n\t\tif ( _renderer.shadowMapCullFace === THREE.CullFaceFront ) {\r\n\r\n\t\t\t_gl.cullFace( _gl.BACK );\r\n\r\n\t\t}\r\n\r\n\t\t_renderer.resetGLState();\r\n\r\n\t};\r\n\r\n\tfunction projectObject( scene, object, shadowCamera ) {\r\n\r\n\t\tif ( object.visible ) {\r\n\r\n\t\t\tvar webglObjects = _webglObjects[ object.id ];\r\n\r\n\t\t\tif ( webglObjects && object.castShadow && (object.frustumCulled === false || _frustum.intersectsObject( object ) === true) ) {\r\n\r\n\t\t\t\tfor ( var i = 0, l = webglObjects.length; i < l; i ++ ) {\r\n\r\n\t\t\t\t\tvar webglObject = webglObjects[ i ];\r\n\r\n\t\t\t\t\tobject._modelViewMatrix.multiplyMatrices( shadowCamera.matrixWorldInverse, object.matrixWorld );\r\n\t\t\t\t\t_renderList.push( webglObject );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfor ( var i = 0, l = object.children.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tprojectObject( scene, object.children[ i ], shadowCamera );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction createVirtualLight( light, cascade ) {\r\n\r\n\t\tvar virtualLight = new THREE.DirectionalLight();\r\n\r\n\t\tvirtualLight.isVirtual = true;\r\n\r\n\t\tvirtualLight.onlyShadow = true;\r\n\t\tvirtualLight.castShadow = true;\r\n\r\n\t\tvirtualLight.shadowCameraNear = light.shadowCameraNear;\r\n\t\tvirtualLight.shadowCameraFar = light.shadowCameraFar;\r\n\r\n\t\tvirtualLight.shadowCameraLeft = light.shadowCameraLeft;\r\n\t\tvirtualLight.shadowCameraRight = light.shadowCameraRight;\r\n\t\tvirtualLight.shadowCameraBottom = light.shadowCameraBottom;\r\n\t\tvirtualLight.shadowCameraTop = light.shadowCameraTop;\r\n\r\n\t\tvirtualLight.shadowCameraVisible = light.shadowCameraVisible;\r\n\r\n\t\tvirtualLight.shadowDarkness = light.shadowDarkness;\r\n\r\n\t\tvirtualLight.shadowBias = light.shadowCascadeBias[ cascade ];\r\n\t\tvirtualLight.shadowMapWidth = light.shadowCascadeWidth[ cascade ];\r\n\t\tvirtualLight.shadowMapHeight = light.shadowCascadeHeight[ cascade ];\r\n\r\n\t\tvirtualLight.pointsWorld = [];\r\n\t\tvirtualLight.pointsFrustum = [];\r\n\r\n\t\tvar pointsWorld = virtualLight.pointsWorld,\r\n\t\t\tpointsFrustum = virtualLight.pointsFrustum;\r\n\r\n\t\tfor ( var i = 0; i < 8; i ++ ) {\r\n\r\n\t\t\tpointsWorld[ i ] = new THREE.Vector3();\r\n\t\t\tpointsFrustum[ i ] = new THREE.Vector3();\r\n\r\n\t\t}\r\n\r\n\t\tvar nearZ = light.shadowCascadeNearZ[ cascade ];\r\n\t\tvar farZ = light.shadowCascadeFarZ[ cascade ];\r\n\r\n\t\tpointsFrustum[ 0 ].set( - 1, - 1, nearZ );\r\n\t\tpointsFrustum[ 1 ].set(  1, - 1, nearZ );\r\n\t\tpointsFrustum[ 2 ].set( - 1,  1, nearZ );\r\n\t\tpointsFrustum[ 3 ].set(  1,  1, nearZ );\r\n\r\n\t\tpointsFrustum[ 4 ].set( - 1, - 1, farZ );\r\n\t\tpointsFrustum[ 5 ].set(  1, - 1, farZ );\r\n\t\tpointsFrustum[ 6 ].set( - 1,  1, farZ );\r\n\t\tpointsFrustum[ 7 ].set(  1,  1, farZ );\r\n\r\n\t\treturn virtualLight;\r\n\r\n\t}\r\n\r\n\t// Synchronize virtual light with the original light\r\n\r\n\tfunction updateVirtualLight( light, cascade ) {\r\n\r\n\t\tvar virtualLight = light.shadowCascadeArray[ cascade ];\r\n\r\n\t\tvirtualLight.position.copy( light.position );\r\n\t\tvirtualLight.target.position.copy( light.target.position );\r\n\t\tvirtualLight.lookAt( virtualLight.target );\r\n\r\n\t\tvirtualLight.shadowCameraVisible = light.shadowCameraVisible;\r\n\t\tvirtualLight.shadowDarkness = light.shadowDarkness;\r\n\r\n\t\tvirtualLight.shadowBias = light.shadowCascadeBias[ cascade ];\r\n\r\n\t\tvar nearZ = light.shadowCascadeNearZ[ cascade ];\r\n\t\tvar farZ = light.shadowCascadeFarZ[ cascade ];\r\n\r\n\t\tvar pointsFrustum = virtualLight.pointsFrustum;\r\n\r\n\t\tpointsFrustum[ 0 ].z = nearZ;\r\n\t\tpointsFrustum[ 1 ].z = nearZ;\r\n\t\tpointsFrustum[ 2 ].z = nearZ;\r\n\t\tpointsFrustum[ 3 ].z = nearZ;\r\n\r\n\t\tpointsFrustum[ 4 ].z = farZ;\r\n\t\tpointsFrustum[ 5 ].z = farZ;\r\n\t\tpointsFrustum[ 6 ].z = farZ;\r\n\t\tpointsFrustum[ 7 ].z = farZ;\r\n\r\n\t}\r\n\r\n\t// Fit shadow camera's ortho frustum to camera frustum\r\n\r\n\tfunction updateShadowCamera( camera, light ) {\r\n\r\n\t\tvar shadowCamera = light.shadowCamera,\r\n\t\t\tpointsFrustum = light.pointsFrustum,\r\n\t\t\tpointsWorld = light.pointsWorld;\r\n\r\n\t\t_min.set( Infinity, Infinity, Infinity );\r\n\t\t_max.set( - Infinity, - Infinity, - Infinity );\r\n\r\n\t\tfor ( var i = 0; i < 8; i ++ ) {\r\n\r\n\t\t\tvar p = pointsWorld[ i ];\r\n\r\n\t\t\tp.copy( pointsFrustum[ i ] );\r\n\t\t\tp.unproject( camera );\r\n\r\n\t\t\tp.applyMatrix4( shadowCamera.matrixWorldInverse );\r\n\r\n\t\t\tif ( p.x < _min.x ) _min.x = p.x;\r\n\t\t\tif ( p.x > _max.x ) _max.x = p.x;\r\n\r\n\t\t\tif ( p.y < _min.y ) _min.y = p.y;\r\n\t\t\tif ( p.y > _max.y ) _max.y = p.y;\r\n\r\n\t\t\tif ( p.z < _min.z ) _min.z = p.z;\r\n\t\t\tif ( p.z > _max.z ) _max.z = p.z;\r\n\r\n\t\t}\r\n\r\n\t\tshadowCamera.left = _min.x;\r\n\t\tshadowCamera.right = _max.x;\r\n\t\tshadowCamera.top = _max.y;\r\n\t\tshadowCamera.bottom = _min.y;\r\n\r\n\t\t// can't really fit near/far\r\n\t\t//shadowCamera.near = _min.z;\r\n\t\t//shadowCamera.far = _max.z;\r\n\r\n\t\tshadowCamera.updateProjectionMatrix();\r\n\r\n\t}\r\n\r\n\t// For the moment just ignore objects that have multiple materials with different animation methods\r\n\t// Only the first material will be taken into account for deciding which depth material to use for shadow maps\r\n\r\n\tfunction getObjectMaterial( object ) {\r\n\r\n\t\treturn object.material instanceof THREE.MeshFaceMaterial\r\n\t\t\t? object.material.materials[ 0 ]\r\n\t\t\t: object.material;\r\n\r\n\t};\r\n\r\n};\r\n\r\n// File:src/renderers/webgl/plugins/SpritePlugin.js\r\n\r\n/**\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.SpritePlugin = function ( renderer, sprites ) {\r\n\r\n\tvar gl = renderer.context;\r\n\r\n\tvar vertexBuffer, elementBuffer;\r\n\tvar program, attributes, uniforms;\r\n\r\n\tvar texture;\r\n\r\n\t// decompose matrixWorld\r\n\r\n\tvar spritePosition = new THREE.Vector3();\r\n\tvar spriteRotation = new THREE.Quaternion();\r\n\tvar spriteScale = new THREE.Vector3();\r\n\r\n\tvar init = function () {\r\n\r\n\t\tvar vertices = new Float32Array( [\r\n\t\t\t- 0.5, - 0.5,  0, 0,\r\n\t\t\t  0.5, - 0.5,  1, 0,\r\n\t\t\t  0.5,   0.5,  1, 1,\r\n\t\t\t- 0.5,   0.5,  0, 1\r\n\t\t] );\r\n\r\n\t\tvar faces = new Uint16Array( [\r\n\t\t\t0, 1, 2,\r\n\t\t\t0, 2, 3\r\n\t\t] );\r\n\r\n\t\tvertexBuffer  = gl.createBuffer();\r\n\t\telementBuffer = gl.createBuffer();\r\n\r\n\t\tgl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );\r\n\t\tgl.bufferData( gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW );\r\n\r\n\t\tgl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );\r\n\t\tgl.bufferData( gl.ELEMENT_ARRAY_BUFFER, faces, gl.STATIC_DRAW );\r\n\r\n\t\tprogram = createProgram();\r\n\r\n\t\tattributes = {\r\n\t\t\tposition:\t\t\tgl.getAttribLocation ( program, 'position' ),\r\n\t\t\tuv:\t\t\t\t\tgl.getAttribLocation ( program, 'uv' )\r\n\t\t};\r\n\r\n\t\tuniforms = {\r\n\t\t\tuvOffset:\t\t\tgl.getUniformLocation( program, 'uvOffset' ),\r\n\t\t\tuvScale:\t\t\tgl.getUniformLocation( program, 'uvScale' ),\r\n\r\n\t\t\trotation:\t\t\tgl.getUniformLocation( program, 'rotation' ),\r\n\t\t\tscale:\t\t\t\tgl.getUniformLocation( program, 'scale' ),\r\n\r\n\t\t\tcolor:\t\t\t\tgl.getUniformLocation( program, 'color' ),\r\n\t\t\tmap:\t\t\t\tgl.getUniformLocation( program, 'map' ),\r\n\t\t\topacity:\t\t\tgl.getUniformLocation( program, 'opacity' ),\r\n\r\n\t\t\tmodelViewMatrix: \tgl.getUniformLocation( program, 'modelViewMatrix' ),\r\n\t\t\tprojectionMatrix:\tgl.getUniformLocation( program, 'projectionMatrix' ),\r\n\r\n\t\t\tfogType:\t\t\tgl.getUniformLocation( program, 'fogType' ),\r\n\t\t\tfogDensity:\t\t\tgl.getUniformLocation( program, 'fogDensity' ),\r\n\t\t\tfogNear:\t\t\tgl.getUniformLocation( program, 'fogNear' ),\r\n\t\t\tfogFar:\t\t\t\tgl.getUniformLocation( program, 'fogFar' ),\r\n\t\t\tfogColor:\t\t\tgl.getUniformLocation( program, 'fogColor' ),\r\n\r\n\t\t\talphaTest:\t\t\tgl.getUniformLocation( program, 'alphaTest' )\r\n\t\t};\r\n\r\n\t\tvar canvas = document.createElement( 'canvas' );\r\n\t\tcanvas.width = 8;\r\n\t\tcanvas.height = 8;\r\n\r\n\t\tvar context = canvas.getContext( '2d' );\r\n\t\tcontext.fillStyle = 'white';\r\n\t\tcontext.fillRect( 0, 0, 8, 8 );\r\n\r\n\t\ttexture = new THREE.Texture( canvas );\r\n\t\ttexture.needsUpdate = true;\r\n\r\n\t};\r\n\r\n\tthis.render = function ( scene, camera ) {\r\n\r\n\t\tif ( sprites.length === 0 ) return;\r\n\r\n\t\t// setup gl\r\n\r\n\t\tif ( program === undefined ) {\r\n\r\n\t\t\tinit();\r\n\r\n\t\t}\r\n\r\n\t\tgl.useProgram( program );\r\n\r\n\t\tgl.enableVertexAttribArray( attributes.position );\r\n\t\tgl.enableVertexAttribArray( attributes.uv );\r\n\r\n\t\tgl.disable( gl.CULL_FACE );\r\n\t\tgl.enable( gl.BLEND );\r\n\r\n\t\tgl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );\r\n\t\tgl.vertexAttribPointer( attributes.position, 2, gl.FLOAT, false, 2 * 8, 0 );\r\n\t\tgl.vertexAttribPointer( attributes.uv, 2, gl.FLOAT, false, 2 * 8, 8 );\r\n\r\n\t\tgl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );\r\n\r\n\t\tgl.uniformMatrix4fv( uniforms.projectionMatrix, false, camera.projectionMatrix.elements );\r\n\r\n\t\tgl.activeTexture( gl.TEXTURE0 );\r\n\t\tgl.uniform1i( uniforms.map, 0 );\r\n\r\n\t\tvar oldFogType = 0;\r\n\t\tvar sceneFogType = 0;\r\n\t\tvar fog = scene.fog;\r\n\r\n\t\tif ( fog ) {\r\n\r\n\t\t\tgl.uniform3f( uniforms.fogColor, fog.color.r, fog.color.g, fog.color.b );\r\n\r\n\t\t\tif ( fog instanceof THREE.Fog ) {\r\n\r\n\t\t\t\tgl.uniform1f( uniforms.fogNear, fog.near );\r\n\t\t\t\tgl.uniform1f( uniforms.fogFar, fog.far );\r\n\r\n\t\t\t\tgl.uniform1i( uniforms.fogType, 1 );\r\n\t\t\t\toldFogType = 1;\r\n\t\t\t\tsceneFogType = 1;\r\n\r\n\t\t\t} else if ( fog instanceof THREE.FogExp2 ) {\r\n\r\n\t\t\t\tgl.uniform1f( uniforms.fogDensity, fog.density );\r\n\r\n\t\t\t\tgl.uniform1i( uniforms.fogType, 2 );\r\n\t\t\t\toldFogType = 2;\r\n\t\t\t\tsceneFogType = 2;\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\tgl.uniform1i( uniforms.fogType, 0 );\r\n\t\t\toldFogType = 0;\r\n\t\t\tsceneFogType = 0;\r\n\r\n\t\t}\r\n\r\n\r\n\t\t// update positions and sort\r\n\r\n\t\tfor ( var i = 0, l = sprites.length; i < l; i ++ ) {\r\n\r\n\t\t\tvar sprite = sprites[ i ];\r\n\r\n\t\t\tsprite._modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, sprite.matrixWorld );\r\n\t\t\tsprite.z = - sprite._modelViewMatrix.elements[ 14 ];\r\n\r\n\t\t}\r\n\r\n\t\tsprites.sort( painterSortStable );\r\n\r\n\t\t// render all sprites\r\n\r\n\t\tvar scale = [];\r\n\r\n\t\tfor ( var i = 0, l = sprites.length; i < l; i ++ ) {\r\n\r\n\t\t\tvar sprite = sprites[ i ];\r\n\t\t\tvar material = sprite.material;\r\n\r\n\t\t\tgl.uniform1f( uniforms.alphaTest, material.alphaTest );\r\n\t\t\tgl.uniformMatrix4fv( uniforms.modelViewMatrix, false, sprite._modelViewMatrix.elements );\r\n\r\n\t\t\tsprite.matrixWorld.decompose( spritePosition, spriteRotation, spriteScale );\r\n\r\n\t\t\tscale[ 0 ] = spriteScale.x;\r\n\t\t\tscale[ 1 ] = spriteScale.y;\r\n\r\n\t\t\tvar fogType = 0;\r\n\r\n\t\t\tif ( scene.fog && material.fog ) {\r\n\r\n\t\t\t\tfogType = sceneFogType;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( oldFogType !== fogType ) {\r\n\r\n\t\t\t\tgl.uniform1i( uniforms.fogType, fogType );\r\n\t\t\t\toldFogType = fogType;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( material.map !== null ) {\r\n\r\n\t\t\t\tgl.uniform2f( uniforms.uvOffset, material.map.offset.x, material.map.offset.y );\r\n\t\t\t\tgl.uniform2f( uniforms.uvScale, material.map.repeat.x, material.map.repeat.y );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tgl.uniform2f( uniforms.uvOffset, 0, 0 );\r\n\t\t\t\tgl.uniform2f( uniforms.uvScale, 1, 1 );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tgl.uniform1f( uniforms.opacity, material.opacity );\r\n\t\t\tgl.uniform3f( uniforms.color, material.color.r, material.color.g, material.color.b );\r\n\r\n\t\t\tgl.uniform1f( uniforms.rotation, material.rotation );\r\n\t\t\tgl.uniform2fv( uniforms.scale, scale );\r\n\r\n\t\t\trenderer.state.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst );\r\n\t\t\trenderer.state.setDepthTest( material.depthTest );\r\n\t\t\trenderer.state.setDepthWrite( material.depthWrite );\r\n\r\n\t\t\tif ( material.map && material.map.image && material.map.image.width ) {\r\n\r\n\t\t\t\trenderer.setTexture( material.map, 0 );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\trenderer.setTexture( texture, 0 );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tgl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );\r\n\r\n\t\t}\r\n\r\n\t\t// restore gl\r\n\r\n\t\tgl.enable( gl.CULL_FACE );\r\n\r\n\t\trenderer.resetGLState();\r\n\r\n\t};\r\n\r\n\tfunction createProgram () {\r\n\r\n\t\tvar program = gl.createProgram();\r\n\r\n\t\tvar vertexShader = gl.createShader( gl.VERTEX_SHADER );\r\n\t\tvar fragmentShader = gl.createShader( gl.FRAGMENT_SHADER );\r\n\r\n\t\tgl.shaderSource( vertexShader, [\r\n\r\n\t\t\t'precision ' + renderer.getPrecision() + ' float;',\r\n\r\n\t\t\t'uniform mat4 modelViewMatrix;',\r\n\t\t\t'uniform mat4 projectionMatrix;',\r\n\t\t\t'uniform float rotation;',\r\n\t\t\t'uniform vec2 scale;',\r\n\t\t\t'uniform vec2 uvOffset;',\r\n\t\t\t'uniform vec2 uvScale;',\r\n\r\n\t\t\t'attribute vec2 position;',\r\n\t\t\t'attribute vec2 uv;',\r\n\r\n\t\t\t'varying vec2 vUV;',\r\n\r\n\t\t\t'void main() {',\r\n\r\n\t\t\t\t'vUV = uvOffset + uv * uvScale;',\r\n\r\n\t\t\t\t'vec2 alignedPosition = position * scale;',\r\n\r\n\t\t\t\t'vec2 rotatedPosition;',\r\n\t\t\t\t'rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;',\r\n\t\t\t\t'rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;',\r\n\r\n\t\t\t\t'vec4 finalPosition;',\r\n\r\n\t\t\t\t'finalPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );',\r\n\t\t\t\t'finalPosition.xy += rotatedPosition;',\r\n\t\t\t\t'finalPosition = projectionMatrix * finalPosition;',\r\n\r\n\t\t\t\t'gl_Position = finalPosition;',\r\n\r\n\t\t\t'}'\r\n\r\n\t\t].join( '\\n' ) );\r\n\r\n\t\tgl.shaderSource( fragmentShader, [\r\n\r\n\t\t\t'precision ' + renderer.getPrecision() + ' float;',\r\n\r\n\t\t\t'uniform vec3 color;',\r\n\t\t\t'uniform sampler2D map;',\r\n\t\t\t'uniform float opacity;',\r\n\r\n\t\t\t'uniform int fogType;',\r\n\t\t\t'uniform vec3 fogColor;',\r\n\t\t\t'uniform float fogDensity;',\r\n\t\t\t'uniform float fogNear;',\r\n\t\t\t'uniform float fogFar;',\r\n\t\t\t'uniform float alphaTest;',\r\n\r\n\t\t\t'varying vec2 vUV;',\r\n\r\n\t\t\t'void main() {',\r\n\r\n\t\t\t\t'vec4 texture = texture2D( map, vUV );',\r\n\r\n\t\t\t\t'if ( texture.a < alphaTest ) discard;',\r\n\r\n\t\t\t\t'gl_FragColor = vec4( color * texture.xyz, texture.a * opacity );',\r\n\r\n\t\t\t\t'if ( fogType > 0 ) {',\r\n\r\n\t\t\t\t\t'float depth = gl_FragCoord.z / gl_FragCoord.w;',\r\n\t\t\t\t\t'float fogFactor = 0.0;',\r\n\r\n\t\t\t\t\t'if ( fogType == 1 ) {',\r\n\r\n\t\t\t\t\t\t'fogFactor = smoothstep( fogNear, fogFar, depth );',\r\n\r\n\t\t\t\t\t'} else {',\r\n\r\n\t\t\t\t\t\t'const float LOG2 = 1.442695;',\r\n\t\t\t\t\t\t'float fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );',\r\n\t\t\t\t\t\t'fogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );',\r\n\r\n\t\t\t\t\t'}',\r\n\r\n\t\t\t\t\t'gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );',\r\n\r\n\t\t\t\t'}',\r\n\r\n\t\t\t'}'\r\n\r\n\t\t].join( '\\n' ) );\r\n\r\n\t\tgl.compileShader( vertexShader );\r\n\t\tgl.compileShader( fragmentShader );\r\n\r\n\t\tgl.attachShader( program, vertexShader );\r\n\t\tgl.attachShader( program, fragmentShader );\r\n\r\n\t\tgl.linkProgram( program );\r\n\r\n\t\treturn program;\r\n\r\n\t};\r\n\r\n\tfunction painterSortStable ( a, b ) {\r\n\r\n\t\tif ( a.z !== b.z ) {\r\n\r\n\t\t\treturn b.z - a.z;\r\n\r\n\t\t} else {\r\n\r\n\t\t\treturn b.id - a.id;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n};\r\n\r\n// File:src/extras/GeometryUtils.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.GeometryUtils = {\r\n\r\n\tmerge: function ( geometry1, geometry2, materialIndexOffset ) {\r\n\r\n\t\tTHREE.warn( 'THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead.' );\r\n\r\n\t\tvar matrix;\r\n\r\n\t\tif ( geometry2 instanceof THREE.Mesh ) {\r\n\r\n\t\t\tgeometry2.matrixAutoUpdate && geometry2.updateMatrix();\r\n\r\n\t\t\tmatrix = geometry2.matrix;\r\n\t\t\tgeometry2 = geometry2.geometry;\r\n\r\n\t\t}\r\n\r\n\t\tgeometry1.merge( geometry2, matrix, materialIndexOffset );\r\n\r\n\t},\r\n\r\n\tcenter: function ( geometry ) {\r\n\r\n\t\tTHREE.warn( 'THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead.' );\r\n\t\treturn geometry.center();\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/extras/ImageUtils.js\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author Daosheng Mu / https://github.com/DaoshengMu/\r\n */\r\n\r\nTHREE.ImageUtils = {\r\n\r\n\tcrossOrigin: undefined,\r\n\r\n\tloadTexture: function ( url, mapping, onLoad, onError ) {\r\n\r\n\t\tvar loader = new THREE.ImageLoader();\r\n\t\tloader.crossOrigin = this.crossOrigin;\r\n\r\n\t\tvar texture = new THREE.Texture( undefined, mapping );\r\n\r\n\t\tloader.load( url, function ( image ) {\r\n\r\n\t\t\ttexture.image = image;\r\n\t\t\ttexture.needsUpdate = true;\r\n\r\n\t\t\tif ( onLoad ) onLoad( texture );\r\n\r\n\t\t}, undefined, function ( event ) {\r\n\r\n\t\t\tif ( onError ) onError( event );\r\n\r\n\t\t} );\r\n\r\n\t\ttexture.sourceFile = url;\r\n\r\n\t\treturn texture;\r\n\r\n\t},\r\n\r\n\tloadTextureCube: function ( array, mapping, onLoad, onError ) {\r\n\r\n\t\tvar images = [];\r\n\r\n\t\tvar loader = new THREE.ImageLoader();\r\n\t\tloader.crossOrigin = this.crossOrigin;\r\n\r\n\t\tvar texture = new THREE.CubeTexture( images, mapping );\r\n\r\n\t\t// no flipping needed for cube textures\r\n\r\n\t\ttexture.flipY = false;\r\n\r\n\t\tvar loaded = 0;\r\n\r\n\t\tvar loadTexture = function ( i ) {\r\n\r\n\t\t\tloader.load( array[ i ], function ( image ) {\r\n\r\n\t\t\t\ttexture.images[ i ] = image;\r\n\r\n\t\t\t\tloaded += 1;\r\n\r\n\t\t\t\tif ( loaded === 6 ) {\r\n\r\n\t\t\t\t\ttexture.needsUpdate = true;\r\n\r\n\t\t\t\t\tif ( onLoad ) onLoad( texture );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}, undefined, onError );\r\n\r\n\t\t}\r\n\r\n\t\tfor ( var i = 0, il = array.length; i < il; ++ i ) {\r\n\r\n\t\t\tloadTexture( i );\r\n\r\n\t\t}\r\n\r\n\t\treturn texture;\r\n\r\n\t},\r\n\r\n\tloadCompressedTexture: function () {\r\n\r\n\t\tTHREE.error( 'THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.' )\r\n\r\n\t},\r\n\r\n\tloadCompressedTextureCube: function () {\r\n\r\n\t\tTHREE.error( 'THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.' )\r\n\r\n\t},\r\n\r\n\tgetNormalMap: function ( image, depth ) {\r\n\r\n\t\t// Adapted from http://www.paulbrunt.co.uk/lab/heightnormal/\r\n\r\n\t\tvar cross = function ( a, b ) {\r\n\r\n\t\t\treturn [ a[ 1 ] * b[ 2 ] - a[ 2 ] * b[ 1 ], a[ 2 ] * b[ 0 ] - a[ 0 ] * b[ 2 ], a[ 0 ] * b[ 1 ] - a[ 1 ] * b[ 0 ] ];\r\n\r\n\t\t}\r\n\r\n\t\tvar subtract = function ( a, b ) {\r\n\r\n\t\t\treturn [ a[ 0 ] - b[ 0 ], a[ 1 ] - b[ 1 ], a[ 2 ] - b[ 2 ] ];\r\n\r\n\t\t}\r\n\r\n\t\tvar normalize = function ( a ) {\r\n\r\n\t\t\tvar l = Math.sqrt( a[ 0 ] * a[ 0 ] + a[ 1 ] * a[ 1 ] + a[ 2 ] * a[ 2 ] );\r\n\t\t\treturn [ a[ 0 ] / l, a[ 1 ] / l, a[ 2 ] / l ];\r\n\r\n\t\t}\r\n\r\n\t\tdepth = depth | 1;\r\n\r\n\t\tvar width = image.width;\r\n\t\tvar height = image.height;\r\n\r\n\t\tvar canvas = document.createElement( 'canvas' );\r\n\t\tcanvas.width = width;\r\n\t\tcanvas.height = height;\r\n\r\n\t\tvar context = canvas.getContext( '2d' );\r\n\t\tcontext.drawImage( image, 0, 0 );\r\n\r\n\t\tvar data = context.getImageData( 0, 0, width, height ).data;\r\n\t\tvar imageData = context.createImageData( width, height );\r\n\t\tvar output = imageData.data;\r\n\r\n\t\tfor ( var x = 0; x < width; x ++ ) {\r\n\r\n\t\t\tfor ( var y = 0; y < height; y ++ ) {\r\n\r\n\t\t\t\tvar ly = y - 1 < 0 ? 0 : y - 1;\r\n\t\t\t\tvar uy = y + 1 > height - 1 ? height - 1 : y + 1;\r\n\t\t\t\tvar lx = x - 1 < 0 ? 0 : x - 1;\r\n\t\t\t\tvar ux = x + 1 > width - 1 ? width - 1 : x + 1;\r\n\r\n\t\t\t\tvar points = [];\r\n\t\t\t\tvar origin = [ 0, 0, data[ ( y * width + x ) * 4 ] / 255 * depth ];\r\n\t\t\t\tpoints.push( [ - 1, 0, data[ ( y * width + lx ) * 4 ] / 255 * depth ] );\r\n\t\t\t\tpoints.push( [ - 1, - 1, data[ ( ly * width + lx ) * 4 ] / 255 * depth ] );\r\n\t\t\t\tpoints.push( [ 0, - 1, data[ ( ly * width + x ) * 4 ] / 255 * depth ] );\r\n\t\t\t\tpoints.push( [ 1, - 1, data[ ( ly * width + ux ) * 4 ] / 255 * depth ] );\r\n\t\t\t\tpoints.push( [ 1, 0, data[ ( y * width + ux ) * 4 ] / 255 * depth ] );\r\n\t\t\t\tpoints.push( [ 1, 1, data[ ( uy * width + ux ) * 4 ] / 255 * depth ] );\r\n\t\t\t\tpoints.push( [ 0, 1, data[ ( uy * width + x ) * 4 ] / 255 * depth ] );\r\n\t\t\t\tpoints.push( [ - 1, 1, data[ ( uy * width + lx ) * 4 ] / 255 * depth ] );\r\n\r\n\t\t\t\tvar normals = [];\r\n\t\t\t\tvar num_points = points.length;\r\n\r\n\t\t\t\tfor ( var i = 0; i < num_points; i ++ ) {\r\n\r\n\t\t\t\t\tvar v1 = points[ i ];\r\n\t\t\t\t\tvar v2 = points[ ( i + 1 ) % num_points ];\r\n\t\t\t\t\tv1 = subtract( v1, origin );\r\n\t\t\t\t\tv2 = subtract( v2, origin );\r\n\t\t\t\t\tnormals.push( normalize( cross( v1, v2 ) ) );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tvar normal = [ 0, 0, 0 ];\r\n\r\n\t\t\t\tfor ( var i = 0; i < normals.length; i ++ ) {\r\n\r\n\t\t\t\t\tnormal[ 0 ] += normals[ i ][ 0 ];\r\n\t\t\t\t\tnormal[ 1 ] += normals[ i ][ 1 ];\r\n\t\t\t\t\tnormal[ 2 ] += normals[ i ][ 2 ];\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tnormal[ 0 ] /= normals.length;\r\n\t\t\t\tnormal[ 1 ] /= normals.length;\r\n\t\t\t\tnormal[ 2 ] /= normals.length;\r\n\r\n\t\t\t\tvar idx = ( y * width + x ) * 4;\r\n\r\n\t\t\t\toutput[ idx ] = ( ( normal[ 0 ] + 1.0 ) / 2.0 * 255 ) | 0;\r\n\t\t\t\toutput[ idx + 1 ] = ( ( normal[ 1 ] + 1.0 ) / 2.0 * 255 ) | 0;\r\n\t\t\t\toutput[ idx + 2 ] = ( normal[ 2 ] * 255 ) | 0;\r\n\t\t\t\toutput[ idx + 3 ] = 255;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tcontext.putImageData( imageData, 0, 0 );\r\n\r\n\t\treturn canvas;\r\n\r\n\t},\r\n\r\n\tgenerateDataTexture: function ( width, height, color ) {\r\n\r\n\t\tvar size = width * height;\r\n\t\tvar data = new Uint8Array( 3 * size );\r\n\r\n\t\tvar r = Math.floor( color.r * 255 );\r\n\t\tvar g = Math.floor( color.g * 255 );\r\n\t\tvar b = Math.floor( color.b * 255 );\r\n\r\n\t\tfor ( var i = 0; i < size; i ++ ) {\r\n\r\n\t\t\tdata[ i * 3 ] \t   = r;\r\n\t\t\tdata[ i * 3 + 1 ] = g;\r\n\t\t\tdata[ i * 3 + 2 ] = b;\r\n\r\n\t\t}\r\n\r\n\t\tvar texture = new THREE.DataTexture( data, width, height, THREE.RGBFormat );\r\n\t\ttexture.needsUpdate = true;\r\n\r\n\t\treturn texture;\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/extras/SceneUtils.js\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.SceneUtils = {\r\n\r\n\tcreateMultiMaterialObject: function ( geometry, materials ) {\r\n\r\n\t\tvar group = new THREE.Object3D();\r\n\r\n\t\tfor ( var i = 0, l = materials.length; i < l; i ++ ) {\r\n\r\n\t\t\tgroup.add( new THREE.Mesh( geometry, materials[ i ] ) );\r\n\r\n\t\t}\r\n\r\n\t\treturn group;\r\n\r\n\t},\r\n\r\n\tdetach: function ( child, parent, scene ) {\r\n\r\n\t\tchild.applyMatrix( parent.matrixWorld );\r\n\t\tparent.remove( child );\r\n\t\tscene.add( child );\r\n\r\n\t},\r\n\r\n\tattach: function ( child, scene, parent ) {\r\n\r\n\t\tvar matrixWorldInverse = new THREE.Matrix4();\r\n\t\tmatrixWorldInverse.getInverse( parent.matrixWorld );\r\n\t\tchild.applyMatrix( matrixWorldInverse );\r\n\r\n\t\tscene.remove( child );\r\n\t\tparent.add( child );\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/extras/FontUtils.js\r\n\r\n/**\r\n * @author zz85 / http://www.lab4games.net/zz85/blog\r\n * @author alteredq / http://alteredqualia.com/\r\n *\r\n * For Text operations in three.js (See TextGeometry)\r\n *\r\n * It uses techniques used in:\r\n *\r\n * \ttypeface.js and canvastext\r\n * \t\tFor converting fonts and rendering with javascript\r\n *\t\thttp://typeface.neocracy.org\r\n *\r\n *\tTriangulation ported from AS3\r\n *\t\tSimple Polygon Triangulation\r\n *\t\thttp://actionsnippet.com/?p=1462\r\n *\r\n * \tA Method to triangulate shapes with holes\r\n *\t\thttp://www.sakri.net/blog/2009/06/12/an-approach-to-triangulating-polygons-with-holes/\r\n *\r\n */\r\n\r\nTHREE.FontUtils = {\r\n\r\n\tfaces: {},\r\n\r\n\t// Just for now. face[weight][style]\r\n\r\n\tface: 'helvetiker',\r\n\tweight: 'normal',\r\n\tstyle: 'normal',\r\n\tsize: 150,\r\n\tdivisions: 10,\r\n\r\n\tgetFace: function () {\r\n\r\n\t\ttry {\r\n\r\n\t\t\treturn this.faces[ this.face ][ this.weight ][ this.style ];\r\n\r\n\t\t} catch (e) {\r\n\r\n\t\t\tthrow \"The font \" + this.face + \" with \" + this.weight + \" weight and \" + this.style + \" style is missing.\"\r\n\r\n\t\t};\r\n\r\n\t},\r\n\r\n\tloadFace: function ( data ) {\r\n\r\n\t\tvar family = data.familyName.toLowerCase();\r\n\r\n\t\tvar ThreeFont = this;\r\n\r\n\t\tThreeFont.faces[ family ] = ThreeFont.faces[ family ] || {};\r\n\r\n\t\tThreeFont.faces[ family ][ data.cssFontWeight ] = ThreeFont.faces[ family ][ data.cssFontWeight ] || {};\r\n\t\tThreeFont.faces[ family ][ data.cssFontWeight ][ data.cssFontStyle ] = data;\r\n\r\n\t\tThreeFont.faces[ family ][ data.cssFontWeight ][ data.cssFontStyle ] = data;\r\n\r\n\t\treturn data;\r\n\r\n\t},\r\n\r\n\tdrawText: function ( text ) {\r\n\r\n\t\t// RenderText\r\n\r\n\t\tvar i,\r\n\t\t\tface = this.getFace(),\r\n\t\t\tscale = this.size / face.resolution,\r\n\t\t\toffset = 0,\r\n\t\t\tchars = String( text ).split( '' ),\r\n\t\t\tlength = chars.length;\r\n\r\n\t\tvar fontPaths = [];\r\n\r\n\t\tfor ( i = 0; i < length; i ++ ) {\r\n\r\n\t\t\tvar path = new THREE.Path();\r\n\r\n\t\t\tvar ret = this.extractGlyphPoints( chars[ i ], face, scale, offset, path );\r\n\t\t\toffset += ret.offset;\r\n\r\n\t\t\tfontPaths.push( ret.path );\r\n\r\n\t\t}\r\n\r\n\t\t// get the width\r\n\r\n\t\tvar width = offset / 2;\r\n\t\t//\r\n\t\t// for ( p = 0; p < allPts.length; p++ ) {\r\n\t\t//\r\n\t\t// \tallPts[ p ].x -= width;\r\n\t\t//\r\n\t\t// }\r\n\r\n\t\t//var extract = this.extractPoints( allPts, characterPts );\r\n\t\t//extract.contour = allPts;\r\n\r\n\t\t//extract.paths = fontPaths;\r\n\t\t//extract.offset = width;\r\n\r\n\t\treturn { paths: fontPaths, offset: width };\r\n\r\n\t},\r\n\r\n\r\n\r\n\r\n\textractGlyphPoints: function ( c, face, scale, offset, path ) {\r\n\r\n\t\tvar pts = [];\r\n\r\n\t\tvar i, i2, divisions,\r\n\t\t\toutline, action, length,\r\n\t\t\tscaleX, scaleY,\r\n\t\t\tx, y, cpx, cpy, cpx0, cpy0, cpx1, cpy1, cpx2, cpy2,\r\n\t\t\tlaste,\r\n\t\t\tglyph = face.glyphs[ c ] || face.glyphs[ '?' ];\r\n\r\n\t\tif ( ! glyph ) return;\r\n\r\n\t\tif ( glyph.o ) {\r\n\r\n\t\t\toutline = glyph._cachedOutline || ( glyph._cachedOutline = glyph.o.split( ' ' ) );\r\n\t\t\tlength = outline.length;\r\n\r\n\t\t\tscaleX = scale;\r\n\t\t\tscaleY = scale;\r\n\r\n\t\t\tfor ( i = 0; i < length; ) {\r\n\r\n\t\t\t\taction = outline[ i ++ ];\r\n\r\n\t\t\t\t//console.log( action );\r\n\r\n\t\t\t\tswitch ( action ) {\r\n\r\n\t\t\t\tcase 'm':\r\n\r\n\t\t\t\t\t// Move To\r\n\r\n\t\t\t\t\tx = outline[ i ++ ] * scaleX + offset;\r\n\t\t\t\t\ty = outline[ i ++ ] * scaleY;\r\n\r\n\t\t\t\t\tpath.moveTo( x, y );\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'l':\r\n\r\n\t\t\t\t\t// Line To\r\n\r\n\t\t\t\t\tx = outline[ i ++ ] * scaleX + offset;\r\n\t\t\t\t\ty = outline[ i ++ ] * scaleY;\r\n\t\t\t\t\tpath.lineTo( x, y );\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'q':\r\n\r\n\t\t\t\t\t// QuadraticCurveTo\r\n\r\n\t\t\t\t\tcpx  = outline[ i ++ ] * scaleX + offset;\r\n\t\t\t\t\tcpy  = outline[ i ++ ] * scaleY;\r\n\t\t\t\t\tcpx1 = outline[ i ++ ] * scaleX + offset;\r\n\t\t\t\t\tcpy1 = outline[ i ++ ] * scaleY;\r\n\r\n\t\t\t\t\tpath.quadraticCurveTo( cpx1, cpy1, cpx, cpy );\r\n\r\n\t\t\t\t\tlaste = pts[ pts.length - 1 ];\r\n\r\n\t\t\t\t\tif ( laste ) {\r\n\r\n\t\t\t\t\t\tcpx0 = laste.x;\r\n\t\t\t\t\t\tcpy0 = laste.y;\r\n\r\n\t\t\t\t\t\tfor ( i2 = 1, divisions = this.divisions; i2 <= divisions; i2 ++ ) {\r\n\r\n\t\t\t\t\t\t\tvar t = i2 / divisions;\r\n\t\t\t\t\t\t\tTHREE.Shape.Utils.b2( t, cpx0, cpx1, cpx );\r\n\t\t\t\t\t\t\tTHREE.Shape.Utils.b2( t, cpy0, cpy1, cpy );\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'b':\r\n\r\n\t\t\t\t\t// Cubic Bezier Curve\r\n\r\n\t\t\t\t\tcpx  = outline[ i ++ ] *  scaleX + offset;\r\n\t\t\t\t\tcpy  = outline[ i ++ ] *  scaleY;\r\n\t\t\t\t\tcpx1 = outline[ i ++ ] *  scaleX + offset;\r\n\t\t\t\t\tcpy1 = outline[ i ++ ] *  scaleY;\r\n\t\t\t\t\tcpx2 = outline[ i ++ ] *  scaleX + offset;\r\n\t\t\t\t\tcpy2 = outline[ i ++ ] *  scaleY;\r\n\r\n\t\t\t\t\tpath.bezierCurveTo( cpx1, cpy1, cpx2, cpy2, cpx, cpy );\r\n\r\n\t\t\t\t\tlaste = pts[ pts.length - 1 ];\r\n\r\n\t\t\t\t\tif ( laste ) {\r\n\r\n\t\t\t\t\t\tcpx0 = laste.x;\r\n\t\t\t\t\t\tcpy0 = laste.y;\r\n\r\n\t\t\t\t\t\tfor ( i2 = 1, divisions = this.divisions; i2 <= divisions; i2 ++ ) {\r\n\r\n\t\t\t\t\t\t\tvar t = i2 / divisions;\r\n\t\t\t\t\t\t\tTHREE.Shape.Utils.b3( t, cpx0, cpx1, cpx2, cpx );\r\n\t\t\t\t\t\t\tTHREE.Shape.Utils.b3( t, cpy0, cpy1, cpy2, cpy );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\t\t}\r\n\r\n\r\n\r\n\t\treturn { offset: glyph.ha * scale, path:path };\r\n\t}\r\n\r\n};\r\n\r\n\r\nTHREE.FontUtils.generateShapes = function ( text, parameters ) {\r\n\r\n\t// Parameters \r\n\r\n\tparameters = parameters || {};\r\n\r\n\tvar size = parameters.size !== undefined ? parameters.size : 100;\r\n\tvar curveSegments = parameters.curveSegments !== undefined ? parameters.curveSegments : 4;\r\n\r\n\tvar font = parameters.font !== undefined ? parameters.font : 'helvetiker';\r\n\tvar weight = parameters.weight !== undefined ? parameters.weight : 'normal';\r\n\tvar style = parameters.style !== undefined ? parameters.style : 'normal';\r\n\r\n\tTHREE.FontUtils.size = size;\r\n\tTHREE.FontUtils.divisions = curveSegments;\r\n\r\n\tTHREE.FontUtils.face = font;\r\n\tTHREE.FontUtils.weight = weight;\r\n\tTHREE.FontUtils.style = style;\r\n\r\n\t// Get a Font data json object\r\n\r\n\tvar data = THREE.FontUtils.drawText( text );\r\n\r\n\tvar paths = data.paths;\r\n\tvar shapes = [];\r\n\r\n\tfor ( var p = 0, pl = paths.length; p < pl; p ++ ) {\r\n\r\n\t\tArray.prototype.push.apply( shapes, paths[ p ].toShapes() );\r\n\r\n\t}\r\n\r\n\treturn shapes;\r\n\r\n};\r\n\r\n\r\n/**\r\n * This code is a quick port of code written in C++ which was submitted to\r\n * flipcode.com by John W. Ratcliff  // July 22, 2000\r\n * See original code and more information here:\r\n * http://www.flipcode.com/archives/Efficient_Polygon_Triangulation.shtml\r\n *\r\n * ported to actionscript by Zevan Rosser\r\n * www.actionsnippet.com\r\n *\r\n * ported to javascript by Joshua Koo\r\n * http://www.lab4games.net/zz85/blog\r\n *\r\n */\r\n\r\n\r\n( function ( namespace ) {\r\n\r\n\tvar EPSILON = 0.0000000001;\r\n\r\n\t// takes in an contour array and returns\r\n\r\n\tvar process = function ( contour, indices ) {\r\n\r\n\t\tvar n = contour.length;\r\n\r\n\t\tif ( n < 3 ) return null;\r\n\r\n\t\tvar result = [],\r\n\t\t\tverts = [],\r\n\t\t\tvertIndices = [];\r\n\r\n\t\t/* we want a counter-clockwise polygon in verts */\r\n\r\n\t\tvar u, v, w;\r\n\r\n\t\tif ( area( contour ) > 0.0 ) {\r\n\r\n\t\t\tfor ( v = 0; v < n; v ++ ) verts[ v ] = v;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tfor ( v = 0; v < n; v ++ ) verts[ v ] = ( n - 1 ) - v;\r\n\r\n\t\t}\r\n\r\n\t\tvar nv = n;\r\n\r\n\t\t/*  remove nv - 2 vertices, creating 1 triangle every time */\r\n\r\n\t\tvar count = 2 * nv;   /* error detection */\r\n\r\n\t\tfor ( v = nv - 1; nv > 2; ) {\r\n\r\n\t\t\t/* if we loop, it is probably a non-simple polygon */\r\n\r\n\t\t\tif ( ( count -- ) <= 0 ) {\r\n\r\n\t\t\t\t//** Triangulate: ERROR - probable bad polygon!\r\n\r\n\t\t\t\t//throw ( \"Warning, unable to triangulate polygon!\" );\r\n\t\t\t\t//return null;\r\n\t\t\t\t// Sometimes warning is fine, especially polygons are triangulated in reverse.\r\n\t\t\t\tTHREE.warn( 'THREE.FontUtils: Warning, unable to triangulate polygon! in Triangulate.process()' );\r\n\r\n\t\t\t\tif ( indices ) return vertIndices;\r\n\t\t\t\treturn result;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t/* three consecutive vertices in current polygon, <u,v,w> */\r\n\r\n\t\t\tu = v; \t \tif ( nv <= u ) u = 0;     /* previous */\r\n\t\t\tv = u + 1;  if ( nv <= v ) v = 0;     /* new v    */\r\n\t\t\tw = v + 1;  if ( nv <= w ) w = 0;     /* next     */\r\n\r\n\t\t\tif ( snip( contour, u, v, w, nv, verts ) ) {\r\n\r\n\t\t\t\tvar a, b, c, s, t;\r\n\r\n\t\t\t\t/* true names of the vertices */\r\n\r\n\t\t\t\ta = verts[ u ];\r\n\t\t\t\tb = verts[ v ];\r\n\t\t\t\tc = verts[ w ];\r\n\r\n\t\t\t\t/* output Triangle */\r\n\r\n\t\t\t\tresult.push( [ contour[ a ],\r\n\t\t\t\t\tcontour[ b ],\r\n\t\t\t\t\tcontour[ c ] ] );\r\n\r\n\r\n\t\t\t\tvertIndices.push( [ verts[ u ], verts[ v ], verts[ w ] ] );\r\n\r\n\t\t\t\t/* remove v from the remaining polygon */\r\n\r\n\t\t\t\tfor ( s = v, t = v + 1; t < nv; s ++, t ++ ) {\r\n\r\n\t\t\t\t\tverts[ s ] = verts[ t ];\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tnv --;\r\n\r\n\t\t\t\t/* reset error detection counter */\r\n\r\n\t\t\t\tcount = 2 * nv;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( indices ) return vertIndices;\r\n\t\treturn result;\r\n\r\n\t};\r\n\r\n\t// calculate area of the contour polygon\r\n\r\n\tvar area = function ( contour ) {\r\n\r\n\t\tvar n = contour.length;\r\n\t\tvar a = 0.0;\r\n\r\n\t\tfor ( var p = n - 1, q = 0; q < n; p = q ++ ) {\r\n\r\n\t\t\ta += contour[ p ].x * contour[ q ].y - contour[ q ].x * contour[ p ].y;\r\n\r\n\t\t}\r\n\r\n\t\treturn a * 0.5;\r\n\r\n\t};\r\n\r\n\tvar snip = function ( contour, u, v, w, n, verts ) {\r\n\r\n\t\tvar p;\r\n\t\tvar ax, ay, bx, by;\r\n\t\tvar cx, cy, px, py;\r\n\r\n\t\tax = contour[ verts[ u ] ].x;\r\n\t\tay = contour[ verts[ u ] ].y;\r\n\r\n\t\tbx = contour[ verts[ v ] ].x;\r\n\t\tby = contour[ verts[ v ] ].y;\r\n\r\n\t\tcx = contour[ verts[ w ] ].x;\r\n\t\tcy = contour[ verts[ w ] ].y;\r\n\r\n\t\tif ( EPSILON > ( ( ( bx - ax ) * ( cy - ay ) ) - ( ( by - ay ) * ( cx - ax ) ) ) ) return false;\r\n\r\n\t\tvar aX, aY, bX, bY, cX, cY;\r\n\t\tvar apx, apy, bpx, bpy, cpx, cpy;\r\n\t\tvar cCROSSap, bCROSScp, aCROSSbp;\r\n\r\n\t\taX = cx - bx;  aY = cy - by;\r\n\t\tbX = ax - cx;  bY = ay - cy;\r\n\t\tcX = bx - ax;  cY = by - ay;\r\n\r\n\t\tfor ( p = 0; p < n; p ++ ) {\r\n\r\n\t\t\tpx = contour[ verts[ p ] ].x\r\n\t\t\tpy = contour[ verts[ p ] ].y\r\n\r\n\t\t\tif ( ( ( px === ax ) && ( py === ay ) ) ||\r\n\t\t\t\t ( ( px === bx ) && ( py === by ) ) ||\r\n\t\t\t\t ( ( px === cx ) && ( py === cy ) ) )\tcontinue;\r\n\r\n\t\t\tapx = px - ax;  apy = py - ay;\r\n\t\t\tbpx = px - bx;  bpy = py - by;\r\n\t\t\tcpx = px - cx;  cpy = py - cy;\r\n\r\n\t\t\t// see if p is inside triangle abc\r\n\r\n\t\t\taCROSSbp = aX * bpy - aY * bpx;\r\n\t\t\tcCROSSap = cX * apy - cY * apx;\r\n\t\t\tbCROSScp = bX * cpy - bY * cpx;\r\n\r\n\t\t\tif ( ( aCROSSbp >= - EPSILON ) && ( bCROSScp >= - EPSILON ) && ( cCROSSap >= - EPSILON ) ) return false;\r\n\r\n\t\t}\r\n\r\n\t\treturn true;\r\n\r\n\t};\r\n\r\n\r\n\tnamespace.Triangulate = process;\r\n\tnamespace.Triangulate.area = area;\r\n\r\n\treturn namespace;\r\n\r\n} )( THREE.FontUtils );\r\n\r\n// To use the typeface.js face files, hook up the API\r\nself._typeface_js = { faces: THREE.FontUtils.faces, loadFace: THREE.FontUtils.loadFace };\r\nTHREE.typeface_js = self._typeface_js;\r\n\r\n// File:src/extras/audio/Audio.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.Audio = function ( listener ) {\r\n\r\n\tTHREE.Object3D.call( this );\r\n\r\n\tthis.type = 'Audio';\r\n\r\n\tthis.context = listener.context;\r\n\tthis.source = this.context.createBufferSource();\r\n\tthis.source.onended = this.onEnded.bind(this);\r\n\r\n\tthis.gain = this.context.createGain();\r\n\tthis.gain.connect( this.context.destination );\r\n\r\n\tthis.panner = this.context.createPanner();\r\n\tthis.panner.connect( this.gain );\r\n\r\n\tthis.autoplay = false;\r\n\r\n\tthis.startTime = 0;\r\n\tthis.isPlaying = false;\r\n\r\n};\r\n\r\nTHREE.Audio.prototype = Object.create( THREE.Object3D.prototype );\r\nTHREE.Audio.prototype.constructor = THREE.Audio;\r\n\r\nTHREE.Audio.prototype.load = function ( file ) {\r\n\r\n\tvar scope = this;\r\n\r\n\tvar request = new XMLHttpRequest();\r\n\trequest.open( 'GET', file, true );\r\n\trequest.responseType = 'arraybuffer';\r\n\trequest.onload = function ( e ) {\r\n\r\n\t\tscope.context.decodeAudioData( this.response, function ( buffer ) {\r\n\r\n\t\t\tscope.source.buffer = buffer;\r\n\r\n\t\t\tif( scope.autoplay ) scope.play();\r\n\r\n\t\t} );\r\n\r\n\t};\r\n\trequest.send();\r\n\r\n\treturn this;\r\n\r\n};\r\n\r\nTHREE.Audio.prototype.play = function () {\r\n\r\n\tif ( this.isPlaying === true ) {\r\n\r\n\t\tTHREE.warn( 'THREE.Audio: Audio is already playing.' );\r\n\t\treturn;\r\n\r\n\t}\r\n\r\n\tvar source = this.context.createBufferSource();\r\n\r\n\tsource.buffer = this.source.buffer;\r\n\tsource.loop = this.source.loop;\r\n\tsource.onended = this.source.onended;\r\n\tsource.connect( this.panner );\r\n\tsource.start( 0, this.startTime );\r\n\r\n\tthis.isPlaying = true;\r\n\r\n\tthis.source = source;\r\n\r\n};\r\n\r\nTHREE.Audio.prototype.pause = function () {\r\n\r\n\tthis.source.stop();\r\n\tthis.startTime = this.context.currentTime;\r\n\r\n};\r\n\r\nTHREE.Audio.prototype.stop = function () {\r\n\r\n\tthis.source.stop();\r\n\tthis.startTime = 0;\r\n\r\n};\r\n\r\nTHREE.Audio.prototype.onEnded = function() {\r\n\r\n\tthis.isPlaying = false;\r\n\r\n};\r\n\r\nTHREE.Audio.prototype.setLoop = function ( value ) {\r\n\r\n\tthis.source.loop = value;\r\n\r\n};\r\n\r\nTHREE.Audio.prototype.setRefDistance = function ( value ) {\r\n\r\n\tthis.panner.refDistance = value;\r\n\r\n};\r\n\r\nTHREE.Audio.prototype.setRolloffFactor = function ( value ) {\r\n\r\n\tthis.panner.rolloffFactor = value;\r\n\r\n};\r\n\r\nTHREE.Audio.prototype.setVolume = function ( value ) {\r\n\r\n\tthis.gain.gain.value = value;\r\n\r\n};\r\n\r\nTHREE.Audio.prototype.updateMatrixWorld = ( function () {\r\n\r\n\tvar position = new THREE.Vector3();\r\n\r\n\treturn function ( force ) {\r\n\r\n\t\tTHREE.Object3D.prototype.updateMatrixWorld.call( this, force );\r\n\r\n\t\tposition.setFromMatrixPosition( this.matrixWorld );\r\n\r\n\t\tthis.panner.setPosition( position.x, position.y, position.z );\r\n\r\n\t};\r\n\r\n} )();\r\n\r\n// File:src/extras/audio/AudioListener.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.AudioListener = function () {\r\n\r\n\tTHREE.Object3D.call( this );\r\n\r\n\tthis.type = 'AudioListener';\r\n\r\n\tthis.context = new ( window.AudioContext || window.webkitAudioContext )();\r\n\r\n};\r\n\r\nTHREE.AudioListener.prototype = Object.create( THREE.Object3D.prototype );\r\nTHREE.AudioListener.prototype.constructor = THREE.AudioListener;\r\n\r\nTHREE.AudioListener.prototype.updateMatrixWorld = ( function () {\r\n\r\n\tvar position = new THREE.Vector3();\r\n\tvar quaternion = new THREE.Quaternion();\r\n\tvar scale = new THREE.Vector3();\r\n\r\n\tvar orientation = new THREE.Vector3();\r\n\tvar velocity = new THREE.Vector3();\r\n\r\n\tvar positionPrev = new THREE.Vector3();\r\n\r\n\treturn function ( force ) {\r\n\r\n\t\tTHREE.Object3D.prototype.updateMatrixWorld.call( this, force );\r\n\r\n\t\tvar listener = this.context.listener;\r\n\t\tvar up = this.up;\r\n\r\n\t\tthis.matrixWorld.decompose( position, quaternion, scale );\r\n\r\n\t\torientation.set( 0, 0, -1 ).applyQuaternion( quaternion );\r\n\t\tvelocity.subVectors( position, positionPrev );\r\n\r\n\t\tlistener.setPosition( position.x, position.y, position.z );\r\n\t\tlistener.setOrientation( orientation.x, orientation.y, orientation.z, up.x, up.y, up.z );\r\n\t\tlistener.setVelocity( velocity.x, velocity.y, velocity.z );\r\n\r\n\t\tpositionPrev.copy( position );\r\n\r\n\t};\r\n\r\n} )();\r\n\r\n// File:src/extras/core/Curve.js\r\n\r\n/**\r\n * @author zz85 / http://www.lab4games.net/zz85/blog\r\n * Extensible curve object\r\n *\r\n * Some common of Curve methods\r\n * .getPoint(t), getTangent(t)\r\n * .getPointAt(u), getTagentAt(u)\r\n * .getPoints(), .getSpacedPoints()\r\n * .getLength()\r\n * .updateArcLengths()\r\n *\r\n * This following classes subclasses THREE.Curve:\r\n *\r\n * -- 2d classes --\r\n * THREE.LineCurve\r\n * THREE.QuadraticBezierCurve\r\n * THREE.CubicBezierCurve\r\n * THREE.SplineCurve\r\n * THREE.ArcCurve\r\n * THREE.EllipseCurve\r\n *\r\n * -- 3d classes --\r\n * THREE.LineCurve3\r\n * THREE.QuadraticBezierCurve3\r\n * THREE.CubicBezierCurve3\r\n * THREE.SplineCurve3\r\n * THREE.ClosedSplineCurve3\r\n *\r\n * A series of curves can be represented as a THREE.CurvePath\r\n *\r\n **/\r\n\r\n/**************************************************************\r\n *\tAbstract Curve base class\r\n **************************************************************/\r\n\r\nTHREE.Curve = function () {\r\n\r\n};\r\n\r\n// Virtual base class method to overwrite and implement in subclasses\r\n//\t- t [0 .. 1]\r\n\r\nTHREE.Curve.prototype.getPoint = function ( t ) {\r\n\r\n\tTHREE.warn( \"THREE.Curve: Warning, getPoint() not implemented!\" );\r\n\treturn null;\r\n\r\n};\r\n\r\n// Get point at relative position in curve according to arc length\r\n// - u [0 .. 1]\r\n\r\nTHREE.Curve.prototype.getPointAt = function ( u ) {\r\n\r\n\tvar t = this.getUtoTmapping( u );\r\n\treturn this.getPoint( t );\r\n\r\n};\r\n\r\n// Get sequence of points using getPoint( t )\r\n\r\nTHREE.Curve.prototype.getPoints = function ( divisions ) {\r\n\r\n\tif ( ! divisions ) divisions = 5;\r\n\r\n\tvar d, pts = [];\r\n\r\n\tfor ( d = 0; d <= divisions; d ++ ) {\r\n\r\n\t\tpts.push( this.getPoint( d / divisions ) );\r\n\r\n\t}\r\n\r\n\treturn pts;\r\n\r\n};\r\n\r\n// Get sequence of points using getPointAt( u )\r\n\r\nTHREE.Curve.prototype.getSpacedPoints = function ( divisions ) {\r\n\r\n\tif ( ! divisions ) divisions = 5;\r\n\r\n\tvar d, pts = [];\r\n\r\n\tfor ( d = 0; d <= divisions; d ++ ) {\r\n\r\n\t\tpts.push( this.getPointAt( d / divisions ) );\r\n\r\n\t}\r\n\r\n\treturn pts;\r\n\r\n};\r\n\r\n// Get total curve arc length\r\n\r\nTHREE.Curve.prototype.getLength = function () {\r\n\r\n\tvar lengths = this.getLengths();\r\n\treturn lengths[ lengths.length - 1 ];\r\n\r\n};\r\n\r\n// Get list of cumulative segment lengths\r\n\r\nTHREE.Curve.prototype.getLengths = function ( divisions ) {\r\n\r\n\tif ( ! divisions ) divisions = (this.__arcLengthDivisions) ? (this.__arcLengthDivisions) : 200;\r\n\r\n\tif ( this.cacheArcLengths\r\n\t\t&& ( this.cacheArcLengths.length == divisions + 1 )\r\n\t\t&& ! this.needsUpdate) {\r\n\r\n\t\t//console.log( \"cached\", this.cacheArcLengths );\r\n\t\treturn this.cacheArcLengths;\r\n\r\n\t}\r\n\r\n\tthis.needsUpdate = false;\r\n\r\n\tvar cache = [];\r\n\tvar current, last = this.getPoint( 0 );\r\n\tvar p, sum = 0;\r\n\r\n\tcache.push( 0 );\r\n\r\n\tfor ( p = 1; p <= divisions; p ++ ) {\r\n\r\n\t\tcurrent = this.getPoint ( p / divisions );\r\n\t\tsum += current.distanceTo( last );\r\n\t\tcache.push( sum );\r\n\t\tlast = current;\r\n\r\n\t}\r\n\r\n\tthis.cacheArcLengths = cache;\r\n\r\n\treturn cache; // { sums: cache, sum:sum }; Sum is in the last element.\r\n\r\n};\r\n\r\n\r\nTHREE.Curve.prototype.updateArcLengths = function() {\r\n\tthis.needsUpdate = true;\r\n\tthis.getLengths();\r\n};\r\n\r\n// Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equi distance\r\n\r\nTHREE.Curve.prototype.getUtoTmapping = function ( u, distance ) {\r\n\r\n\tvar arcLengths = this.getLengths();\r\n\r\n\tvar i = 0, il = arcLengths.length;\r\n\r\n\tvar targetArcLength; // The targeted u distance value to get\r\n\r\n\tif ( distance ) {\r\n\r\n\t\ttargetArcLength = distance;\r\n\r\n\t} else {\r\n\r\n\t\ttargetArcLength = u * arcLengths[ il - 1 ];\r\n\r\n\t}\r\n\r\n\t//var time = Date.now();\r\n\r\n\t// binary search for the index with largest value smaller than target u distance\r\n\r\n\tvar low = 0, high = il - 1, comparison;\r\n\r\n\twhile ( low <= high ) {\r\n\r\n\t\ti = Math.floor( low + ( high - low ) / 2 ); // less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats\r\n\r\n\t\tcomparison = arcLengths[ i ] - targetArcLength;\r\n\r\n\t\tif ( comparison < 0 ) {\r\n\r\n\t\t\tlow = i + 1;\r\n\r\n\t\t} else if ( comparison > 0 ) {\r\n\r\n\t\t\thigh = i - 1;\r\n\r\n\t\t} else {\r\n\r\n\t\t\thigh = i;\r\n\t\t\tbreak;\r\n\r\n\t\t\t// DONE\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\ti = high;\r\n\r\n\t//console.log('b' , i, low, high, Date.now()- time);\r\n\r\n\tif ( arcLengths[ i ] == targetArcLength ) {\r\n\r\n\t\tvar t = i / ( il - 1 );\r\n\t\treturn t;\r\n\r\n\t}\r\n\r\n\t// we could get finer grain at lengths, or use simple interpolatation between two points\r\n\r\n\tvar lengthBefore = arcLengths[ i ];\r\n\tvar lengthAfter = arcLengths[ i + 1 ];\r\n\r\n\tvar segmentLength = lengthAfter - lengthBefore;\r\n\r\n    // determine where we are between the 'before' and 'after' points\r\n\r\n\tvar segmentFraction = ( targetArcLength - lengthBefore ) / segmentLength;\r\n\r\n    // add that fractional amount to t\r\n\r\n\tvar t = ( i + segmentFraction ) / ( il - 1 );\r\n\r\n\treturn t;\r\n\r\n};\r\n\r\n// Returns a unit vector tangent at t\r\n// In case any sub curve does not implement its tangent derivation,\r\n// 2 points a small delta apart will be used to find its gradient\r\n// which seems to give a reasonable approximation\r\n\r\nTHREE.Curve.prototype.getTangent = function( t ) {\r\n\r\n\tvar delta = 0.0001;\r\n\tvar t1 = t - delta;\r\n\tvar t2 = t + delta;\r\n\r\n\t// Capping in case of danger\r\n\r\n\tif ( t1 < 0 ) t1 = 0;\r\n\tif ( t2 > 1 ) t2 = 1;\r\n\r\n\tvar pt1 = this.getPoint( t1 );\r\n\tvar pt2 = this.getPoint( t2 );\r\n\r\n\tvar vec = pt2.clone().sub(pt1);\r\n\treturn vec.normalize();\r\n\r\n};\r\n\r\n\r\nTHREE.Curve.prototype.getTangentAt = function ( u ) {\r\n\r\n\tvar t = this.getUtoTmapping( u );\r\n\treturn this.getTangent( t );\r\n\r\n};\r\n\r\n\r\n\r\n\r\n\r\n/**************************************************************\r\n *\tUtils\r\n **************************************************************/\r\n\r\nTHREE.Curve.Utils = {\r\n\r\n\ttangentQuadraticBezier: function ( t, p0, p1, p2 ) {\r\n\r\n\t\treturn 2 * ( 1 - t ) * ( p1 - p0 ) + 2 * t * ( p2 - p1 );\r\n\r\n\t},\r\n\r\n\t// Puay Bing, thanks for helping with this derivative!\r\n\r\n\ttangentCubicBezier: function (t, p0, p1, p2, p3 ) {\r\n\r\n\t\treturn - 3 * p0 * (1 - t) * (1 - t)  +\r\n\t\t\t3 * p1 * (1 - t) * (1 - t) - 6 * t * p1 * (1 - t) +\r\n\t\t\t6 * t *  p2 * (1 - t) - 3 * t * t * p2 +\r\n\t\t\t3 * t * t * p3;\r\n\r\n\t},\r\n\r\n\ttangentSpline: function ( t, p0, p1, p2, p3 ) {\r\n\r\n\t\t// To check if my formulas are correct\r\n\r\n\t\tvar h00 = 6 * t * t - 6 * t; \t// derived from 2t^3 − 3t^2 + 1\r\n\t\tvar h10 = 3 * t * t - 4 * t + 1; // t^3 − 2t^2 + t\r\n\t\tvar h01 = - 6 * t * t + 6 * t; \t// − 2t3 + 3t2\r\n\t\tvar h11 = 3 * t * t - 2 * t;\t// t3 − t2\r\n\r\n\t\treturn h00 + h10 + h01 + h11;\r\n\r\n\t},\r\n\r\n\t// Catmull-Rom\r\n\r\n\tinterpolate: function( p0, p1, p2, p3, t ) {\r\n\r\n\t\tvar v0 = ( p2 - p0 ) * 0.5;\r\n\t\tvar v1 = ( p3 - p1 ) * 0.5;\r\n\t\tvar t2 = t * t;\r\n\t\tvar t3 = t * t2;\r\n\t\treturn ( 2 * p1 - 2 * p2 + v0 + v1 ) * t3 + ( - 3 * p1 + 3 * p2 - 2 * v0 - v1 ) * t2 + v0 * t + p1;\r\n\r\n\t}\r\n\r\n};\r\n\r\n\r\n// TODO: Transformation for Curves?\r\n\r\n/**************************************************************\r\n *\t3D Curves\r\n **************************************************************/\r\n\r\n// A Factory method for creating new curve subclasses\r\n\r\nTHREE.Curve.create = function ( constructor, getPointFunc ) {\r\n\r\n\tconstructor.prototype = Object.create( THREE.Curve.prototype );\r\n\tconstructor.prototype.constructor = constructor;\r\n\tconstructor.prototype.getPoint = getPointFunc;\r\n\r\n\treturn constructor;\r\n\r\n};\r\n\r\n// File:src/extras/core/CurvePath.js\r\n\r\n/**\r\n * @author zz85 / http://www.lab4games.net/zz85/blog\r\n *\r\n **/\r\n\r\n/**************************************************************\r\n *\tCurved Path - a curve path is simply a array of connected\r\n *  curves, but retains the api of a curve\r\n **************************************************************/\r\n\r\nTHREE.CurvePath = function () {\r\n\r\n\tthis.curves = [];\r\n\tthis.bends = [];\r\n\t\r\n\tthis.autoClose = false; // Automatically closes the path\r\n};\r\n\r\nTHREE.CurvePath.prototype = Object.create( THREE.Curve.prototype );\r\nTHREE.CurvePath.prototype.constructor = THREE.CurvePath;\r\n\r\nTHREE.CurvePath.prototype.add = function ( curve ) {\r\n\r\n\tthis.curves.push( curve );\r\n\r\n};\r\n\r\nTHREE.CurvePath.prototype.checkConnection = function() {\r\n\t// TODO\r\n\t// If the ending of curve is not connected to the starting\r\n\t// or the next curve, then, this is not a real path\r\n};\r\n\r\nTHREE.CurvePath.prototype.closePath = function() {\r\n\t// TODO Test\r\n\t// and verify for vector3 (needs to implement equals)\r\n\t// Add a line curve if start and end of lines are not connected\r\n\tvar startPoint = this.curves[0].getPoint(0);\r\n\tvar endPoint = this.curves[this.curves.length - 1].getPoint(1);\r\n\t\r\n\tif (! startPoint.equals(endPoint)) {\r\n\t\tthis.curves.push( new THREE.LineCurve(endPoint, startPoint) );\r\n\t}\r\n\t\r\n};\r\n\r\n// To get accurate point with reference to\r\n// entire path distance at time t,\r\n// following has to be done:\r\n\r\n// 1. Length of each sub path have to be known\r\n// 2. Locate and identify type of curve\r\n// 3. Get t for the curve\r\n// 4. Return curve.getPointAt(t')\r\n\r\nTHREE.CurvePath.prototype.getPoint = function( t ) {\r\n\r\n\tvar d = t * this.getLength();\r\n\tvar curveLengths = this.getCurveLengths();\r\n\tvar i = 0, diff, curve;\r\n\r\n\t// To think about boundaries points.\r\n\r\n\twhile ( i < curveLengths.length ) {\r\n\r\n\t\tif ( curveLengths[ i ] >= d ) {\r\n\r\n\t\t\tdiff = curveLengths[ i ] - d;\r\n\t\t\tcurve = this.curves[ i ];\r\n\r\n\t\t\tvar u = 1 - diff / curve.getLength();\r\n\r\n\t\t\treturn curve.getPointAt( u );\r\n\r\n\t\t}\r\n\r\n\t\ti ++;\r\n\r\n\t}\r\n\r\n\treturn null;\r\n\r\n\t// loop where sum != 0, sum > d , sum+1 <d\r\n\r\n};\r\n\r\n/*\r\nTHREE.CurvePath.prototype.getTangent = function( t ) {\r\n};*/\r\n\r\n\r\n// We cannot use the default THREE.Curve getPoint() with getLength() because in\r\n// THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath\r\n// getPoint() depends on getLength\r\n\r\nTHREE.CurvePath.prototype.getLength = function() {\r\n\r\n\tvar lens = this.getCurveLengths();\r\n\treturn lens[ lens.length - 1 ];\r\n\r\n};\r\n\r\n// Compute lengths and cache them\r\n// We cannot overwrite getLengths() because UtoT mapping uses it.\r\n\r\nTHREE.CurvePath.prototype.getCurveLengths = function() {\r\n\r\n\t// We use cache values if curves and cache array are same length\r\n\r\n\tif ( this.cacheLengths && this.cacheLengths.length == this.curves.length ) {\r\n\r\n\t\treturn this.cacheLengths;\r\n\r\n\t};\r\n\r\n\t// Get length of subsurve\r\n\t// Push sums into cached array\r\n\r\n\tvar lengths = [], sums = 0;\r\n\tvar i, il = this.curves.length;\r\n\r\n\tfor ( i = 0; i < il; i ++ ) {\r\n\r\n\t\tsums += this.curves[ i ].getLength();\r\n\t\tlengths.push( sums );\r\n\r\n\t}\r\n\r\n\tthis.cacheLengths = lengths;\r\n\r\n\treturn lengths;\r\n\r\n};\r\n\r\n\r\n\r\n// Returns min and max coordinates\r\n\r\nTHREE.CurvePath.prototype.getBoundingBox = function () {\r\n\r\n\tvar points = this.getPoints();\r\n\r\n\tvar maxX, maxY, maxZ;\r\n\tvar minX, minY, minZ;\r\n\r\n\tmaxX = maxY = Number.NEGATIVE_INFINITY;\r\n\tminX = minY = Number.POSITIVE_INFINITY;\r\n\r\n\tvar p, i, il, sum;\r\n\r\n\tvar v3 = points[0] instanceof THREE.Vector3;\r\n\r\n\tsum = v3 ? new THREE.Vector3() : new THREE.Vector2();\r\n\r\n\tfor ( i = 0, il = points.length; i < il; i ++ ) {\r\n\r\n\t\tp = points[ i ];\r\n\r\n\t\tif ( p.x > maxX ) maxX = p.x;\r\n\t\telse if ( p.x < minX ) minX = p.x;\r\n\r\n\t\tif ( p.y > maxY ) maxY = p.y;\r\n\t\telse if ( p.y < minY ) minY = p.y;\r\n\r\n\t\tif ( v3 ) {\r\n\r\n\t\t\tif ( p.z > maxZ ) maxZ = p.z;\r\n\t\t\telse if ( p.z < minZ ) minZ = p.z;\r\n\r\n\t\t}\r\n\r\n\t\tsum.add( p );\r\n\r\n\t}\r\n\r\n\tvar ret = {\r\n\r\n\t\tminX: minX,\r\n\t\tminY: minY,\r\n\t\tmaxX: maxX,\r\n\t\tmaxY: maxY\r\n\r\n\t};\r\n\r\n\tif ( v3 ) {\r\n\r\n\t\tret.maxZ = maxZ;\r\n\t\tret.minZ = minZ;\r\n\r\n\t}\r\n\r\n\treturn ret;\r\n\r\n};\r\n\r\n/**************************************************************\r\n *\tCreate Geometries Helpers\r\n **************************************************************/\r\n\r\n/// Generate geometry from path points (for Line or Points objects)\r\n\r\nTHREE.CurvePath.prototype.createPointsGeometry = function( divisions ) {\r\n\r\n\tvar pts = this.getPoints( divisions, true );\r\n\treturn this.createGeometry( pts );\r\n\r\n};\r\n\r\n// Generate geometry from equidistance sampling along the path\r\n\r\nTHREE.CurvePath.prototype.createSpacedPointsGeometry = function( divisions ) {\r\n\r\n\tvar pts = this.getSpacedPoints( divisions, true );\r\n\treturn this.createGeometry( pts );\r\n\r\n};\r\n\r\nTHREE.CurvePath.prototype.createGeometry = function( points ) {\r\n\r\n\tvar geometry = new THREE.Geometry();\r\n\r\n\tfor ( var i = 0; i < points.length; i ++ ) {\r\n\r\n\t\tgeometry.vertices.push( new THREE.Vector3( points[ i ].x, points[ i ].y, points[ i ].z || 0) );\r\n\r\n\t}\r\n\r\n\treturn geometry;\r\n\r\n};\r\n\r\n\r\n/**************************************************************\r\n *\tBend / Wrap Helper Methods\r\n **************************************************************/\r\n\r\n// Wrap path / Bend modifiers?\r\n\r\nTHREE.CurvePath.prototype.addWrapPath = function ( bendpath ) {\r\n\r\n\tthis.bends.push( bendpath );\r\n\r\n};\r\n\r\nTHREE.CurvePath.prototype.getTransformedPoints = function( segments, bends ) {\r\n\r\n\tvar oldPts = this.getPoints( segments ); // getPoints getSpacedPoints\r\n\tvar i, il;\r\n\r\n\tif ( ! bends ) {\r\n\r\n\t\tbends = this.bends;\r\n\r\n\t}\r\n\r\n\tfor ( i = 0, il = bends.length; i < il; i ++ ) {\r\n\r\n\t\toldPts = this.getWrapPoints( oldPts, bends[ i ] );\r\n\r\n\t}\r\n\r\n\treturn oldPts;\r\n\r\n};\r\n\r\nTHREE.CurvePath.prototype.getTransformedSpacedPoints = function( segments, bends ) {\r\n\r\n\tvar oldPts = this.getSpacedPoints( segments );\r\n\r\n\tvar i, il;\r\n\r\n\tif ( ! bends ) {\r\n\r\n\t\tbends = this.bends;\r\n\r\n\t}\r\n\r\n\tfor ( i = 0, il = bends.length; i < il; i ++ ) {\r\n\r\n\t\toldPts = this.getWrapPoints( oldPts, bends[ i ] );\r\n\r\n\t}\r\n\r\n\treturn oldPts;\r\n\r\n};\r\n\r\n// This returns getPoints() bend/wrapped around the contour of a path.\r\n// Read http://www.planetclegg.com/projects/WarpingTextToSplines.html\r\n\r\nTHREE.CurvePath.prototype.getWrapPoints = function ( oldPts, path ) {\r\n\r\n\tvar bounds = this.getBoundingBox();\r\n\r\n\tvar i, il, p, oldX, oldY, xNorm;\r\n\r\n\tfor ( i = 0, il = oldPts.length; i < il; i ++ ) {\r\n\r\n\t\tp = oldPts[ i ];\r\n\r\n\t\toldX = p.x;\r\n\t\toldY = p.y;\r\n\r\n\t\txNorm = oldX / bounds.maxX;\r\n\r\n\t\t// If using actual distance, for length > path, requires line extrusions\r\n\t\t//xNorm = path.getUtoTmapping(xNorm, oldX); // 3 styles. 1) wrap stretched. 2) wrap stretch by arc length 3) warp by actual distance\r\n\r\n\t\txNorm = path.getUtoTmapping( xNorm, oldX );\r\n\r\n\t\t// check for out of bounds?\r\n\r\n\t\tvar pathPt = path.getPoint( xNorm );\r\n\t\tvar normal = path.getTangent( xNorm );\r\n\t\tnormal.set( - normal.y, normal.x ).multiplyScalar( oldY );\r\n\r\n\t\tp.x = pathPt.x + normal.x;\r\n\t\tp.y = pathPt.y + normal.y;\r\n\r\n\t}\r\n\r\n\treturn oldPts;\r\n\r\n};\r\n\r\n\r\n// File:src/extras/core/Gyroscope.js\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.Gyroscope = function () {\r\n\r\n\tTHREE.Object3D.call( this );\r\n\r\n};\r\n\r\nTHREE.Gyroscope.prototype = Object.create( THREE.Object3D.prototype );\r\nTHREE.Gyroscope.prototype.constructor = THREE.Gyroscope;\r\n\r\nTHREE.Gyroscope.prototype.updateMatrixWorld = ( function () {\r\n\r\n\tvar translationObject = new THREE.Vector3();\r\n\tvar quaternionObject = new THREE.Quaternion();\r\n\tvar scaleObject = new THREE.Vector3();\r\n\r\n\tvar translationWorld = new THREE.Vector3();\r\n\tvar quaternionWorld = new THREE.Quaternion();\r\n\tvar scaleWorld = new THREE.Vector3();\r\n\r\n\treturn function ( force ) {\r\n\r\n\t\tthis.matrixAutoUpdate && this.updateMatrix();\r\n\r\n\t\t// update matrixWorld\r\n\r\n\t\tif ( this.matrixWorldNeedsUpdate || force ) {\r\n\r\n\t\t\tif ( this.parent ) {\r\n\r\n\t\t\t\tthis.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );\r\n\r\n\t\t\t\tthis.matrixWorld.decompose( translationWorld, quaternionWorld, scaleWorld );\r\n\t\t\t\tthis.matrix.decompose( translationObject, quaternionObject, scaleObject );\r\n\r\n\t\t\t\tthis.matrixWorld.compose( translationWorld, quaternionObject, scaleWorld );\r\n\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tthis.matrixWorld.copy( this.matrix );\r\n\r\n\t\t\t}\r\n\r\n\r\n\t\t\tthis.matrixWorldNeedsUpdate = false;\r\n\r\n\t\t\tforce = true;\r\n\r\n\t\t}\r\n\r\n\t\t// update children\r\n\r\n\t\tfor ( var i = 0, l = this.children.length; i < l; i ++ ) {\r\n\r\n\t\t\tthis.children[ i ].updateMatrixWorld( force );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\t\r\n}() );\r\n\r\n// File:src/extras/core/Path.js\r\n\r\n/**\r\n * @author zz85 / http://www.lab4games.net/zz85/blog\r\n * Creates free form 2d path using series of points, lines or curves.\r\n *\r\n **/\r\n\r\nTHREE.Path = function ( points ) {\r\n\r\n\tTHREE.CurvePath.call(this);\r\n\r\n\tthis.actions = [];\r\n\r\n\tif ( points ) {\r\n\r\n\t\tthis.fromPoints( points );\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.Path.prototype = Object.create( THREE.CurvePath.prototype );\r\nTHREE.Path.prototype.constructor = THREE.Path;\r\n\r\nTHREE.PathActions = {\r\n\r\n\tMOVE_TO: 'moveTo',\r\n\tLINE_TO: 'lineTo',\r\n\tQUADRATIC_CURVE_TO: 'quadraticCurveTo', // Bezier quadratic curve\r\n\tBEZIER_CURVE_TO: 'bezierCurveTo', \t\t// Bezier cubic curve\r\n\tCSPLINE_THRU: 'splineThru',\t\t\t\t// Catmull-rom spline\r\n\tARC: 'arc',\t\t\t\t\t\t\t\t// Circle\r\n\tELLIPSE: 'ellipse'\r\n};\r\n\r\n// TODO Clean up PATH API\r\n\r\n// Create path using straight lines to connect all points\r\n// - vectors: array of Vector2\r\n\r\nTHREE.Path.prototype.fromPoints = function ( vectors ) {\r\n\r\n\tthis.moveTo( vectors[ 0 ].x, vectors[ 0 ].y );\r\n\r\n\tfor ( var v = 1, vlen = vectors.length; v < vlen; v ++ ) {\r\n\r\n\t\tthis.lineTo( vectors[ v ].x, vectors[ v ].y );\r\n\r\n\t};\r\n\r\n};\r\n\r\n// startPath() endPath()?\r\n\r\nTHREE.Path.prototype.moveTo = function ( x, y ) {\r\n\r\n\tvar args = Array.prototype.slice.call( arguments );\r\n\tthis.actions.push( { action: THREE.PathActions.MOVE_TO, args: args } );\r\n\r\n};\r\n\r\nTHREE.Path.prototype.lineTo = function ( x, y ) {\r\n\r\n\tvar args = Array.prototype.slice.call( arguments );\r\n\r\n\tvar lastargs = this.actions[ this.actions.length - 1 ].args;\r\n\r\n\tvar x0 = lastargs[ lastargs.length - 2 ];\r\n\tvar y0 = lastargs[ lastargs.length - 1 ];\r\n\r\n\tvar curve = new THREE.LineCurve( new THREE.Vector2( x0, y0 ), new THREE.Vector2( x, y ) );\r\n\tthis.curves.push( curve );\r\n\r\n\tthis.actions.push( { action: THREE.PathActions.LINE_TO, args: args } );\r\n\r\n};\r\n\r\nTHREE.Path.prototype.quadraticCurveTo = function( aCPx, aCPy, aX, aY ) {\r\n\r\n\tvar args = Array.prototype.slice.call( arguments );\r\n\r\n\tvar lastargs = this.actions[ this.actions.length - 1 ].args;\r\n\r\n\tvar x0 = lastargs[ lastargs.length - 2 ];\r\n\tvar y0 = lastargs[ lastargs.length - 1 ];\r\n\r\n\tvar curve = new THREE.QuadraticBezierCurve( new THREE.Vector2( x0, y0 ),\r\n\t\t\t\t\t\t\t\t\t\t\t\tnew THREE.Vector2( aCPx, aCPy ),\r\n\t\t\t\t\t\t\t\t\t\t\t\tnew THREE.Vector2( aX, aY ) );\r\n\tthis.curves.push( curve );\r\n\r\n\tthis.actions.push( { action: THREE.PathActions.QUADRATIC_CURVE_TO, args: args } );\r\n\r\n};\r\n\r\nTHREE.Path.prototype.bezierCurveTo = function( aCP1x, aCP1y,\r\n\t\t\t\t\t\t\t\t\t\t\t   aCP2x, aCP2y,\r\n\t\t\t\t\t\t\t\t\t\t\t   aX, aY ) {\r\n\r\n\tvar args = Array.prototype.slice.call( arguments );\r\n\r\n\tvar lastargs = this.actions[ this.actions.length - 1 ].args;\r\n\r\n\tvar x0 = lastargs[ lastargs.length - 2 ];\r\n\tvar y0 = lastargs[ lastargs.length - 1 ];\r\n\r\n\tvar curve = new THREE.CubicBezierCurve( new THREE.Vector2( x0, y0 ),\r\n\t\t\t\t\t\t\t\t\t\t\tnew THREE.Vector2( aCP1x, aCP1y ),\r\n\t\t\t\t\t\t\t\t\t\t\tnew THREE.Vector2( aCP2x, aCP2y ),\r\n\t\t\t\t\t\t\t\t\t\t\tnew THREE.Vector2( aX, aY ) );\r\n\tthis.curves.push( curve );\r\n\r\n\tthis.actions.push( { action: THREE.PathActions.BEZIER_CURVE_TO, args: args } );\r\n\r\n};\r\n\r\nTHREE.Path.prototype.splineThru = function( pts /*Array of Vector*/ ) {\r\n\r\n\tvar args = Array.prototype.slice.call( arguments );\r\n\tvar lastargs = this.actions[ this.actions.length - 1 ].args;\r\n\r\n\tvar x0 = lastargs[ lastargs.length - 2 ];\r\n\tvar y0 = lastargs[ lastargs.length - 1 ];\r\n//---\r\n\tvar npts = [ new THREE.Vector2( x0, y0 ) ];\r\n\tArray.prototype.push.apply( npts, pts );\r\n\r\n\tvar curve = new THREE.SplineCurve( npts );\r\n\tthis.curves.push( curve );\r\n\r\n\tthis.actions.push( { action: THREE.PathActions.CSPLINE_THRU, args: args } );\r\n\r\n};\r\n\r\n// FUTURE: Change the API or follow canvas API?\r\n\r\nTHREE.Path.prototype.arc = function ( aX, aY, aRadius,\r\n\t\t\t\t\t\t\t\t\t  aStartAngle, aEndAngle, aClockwise ) {\r\n\r\n\tvar lastargs = this.actions[ this.actions.length - 1].args;\r\n\tvar x0 = lastargs[ lastargs.length - 2 ];\r\n\tvar y0 = lastargs[ lastargs.length - 1 ];\r\n\r\n\tthis.absarc(aX + x0, aY + y0, aRadius,\r\n\t\taStartAngle, aEndAngle, aClockwise );\r\n\r\n };\r\n\r\n THREE.Path.prototype.absarc = function ( aX, aY, aRadius,\r\n\t\t\t\t\t\t\t\t\t  aStartAngle, aEndAngle, aClockwise ) {\r\n\tthis.absellipse(aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);\r\n };\r\n\r\nTHREE.Path.prototype.ellipse = function ( aX, aY, xRadius, yRadius,\r\n\t\t\t\t\t\t\t\t\t  aStartAngle, aEndAngle, aClockwise ) {\r\n\r\n\tvar lastargs = this.actions[ this.actions.length - 1].args;\r\n\tvar x0 = lastargs[ lastargs.length - 2 ];\r\n\tvar y0 = lastargs[ lastargs.length - 1 ];\r\n\r\n\tthis.absellipse(aX + x0, aY + y0, xRadius, yRadius,\r\n\t\taStartAngle, aEndAngle, aClockwise );\r\n\r\n };\r\n\r\n\r\nTHREE.Path.prototype.absellipse = function ( aX, aY, xRadius, yRadius,\r\n\t\t\t\t\t\t\t\t\t  aStartAngle, aEndAngle, aClockwise ) {\r\n\r\n\tvar args = Array.prototype.slice.call( arguments );\r\n\tvar curve = new THREE.EllipseCurve( aX, aY, xRadius, yRadius,\r\n\t\t\t\t\t\t\t\t\taStartAngle, aEndAngle, aClockwise );\r\n\tthis.curves.push( curve );\r\n\r\n\tvar lastPoint = curve.getPoint(1);\r\n\targs.push(lastPoint.x);\r\n\targs.push(lastPoint.y);\r\n\r\n\tthis.actions.push( { action: THREE.PathActions.ELLIPSE, args: args } );\r\n\r\n };\r\n\r\nTHREE.Path.prototype.getSpacedPoints = function ( divisions, closedPath ) {\r\n\r\n\tif ( ! divisions ) divisions = 40;\r\n\r\n\tvar points = [];\r\n\r\n\tfor ( var i = 0; i < divisions; i ++ ) {\r\n\r\n\t\tpoints.push( this.getPoint( i / divisions ) );\r\n\r\n\t\t//if( !this.getPoint( i / divisions ) ) throw \"DIE\";\r\n\r\n\t}\r\n\r\n\t// if ( closedPath ) {\r\n\t//\r\n\t// \tpoints.push( points[ 0 ] );\r\n\t//\r\n\t// }\r\n\r\n\treturn points;\r\n\r\n};\r\n\r\n/* Return an array of vectors based on contour of the path */\r\n\r\nTHREE.Path.prototype.getPoints = function( divisions, closedPath ) {\r\n\r\n\tif (this.useSpacedPoints) {\r\n\t\tconsole.log('tata');\r\n\t\treturn this.getSpacedPoints( divisions, closedPath );\r\n\t}\r\n\r\n\tdivisions = divisions || 12;\r\n\r\n\tvar points = [];\r\n\r\n\tvar i, il, item, action, args;\r\n\tvar cpx, cpy, cpx2, cpy2, cpx1, cpy1, cpx0, cpy0,\r\n\t\tlaste, j,\r\n\t\tt, tx, ty;\r\n\r\n\tfor ( i = 0, il = this.actions.length; i < il; i ++ ) {\r\n\r\n\t\titem = this.actions[ i ];\r\n\r\n\t\taction = item.action;\r\n\t\targs = item.args;\r\n\r\n\t\tswitch ( action ) {\r\n\r\n\t\tcase THREE.PathActions.MOVE_TO:\r\n\r\n\t\t\tpoints.push( new THREE.Vector2( args[ 0 ], args[ 1 ] ) );\r\n\r\n\t\t\tbreak;\r\n\r\n\t\tcase THREE.PathActions.LINE_TO:\r\n\r\n\t\t\tpoints.push( new THREE.Vector2( args[ 0 ], args[ 1 ] ) );\r\n\r\n\t\t\tbreak;\r\n\r\n\t\tcase THREE.PathActions.QUADRATIC_CURVE_TO:\r\n\r\n\t\t\tcpx  = args[ 2 ];\r\n\t\t\tcpy  = args[ 3 ];\r\n\r\n\t\t\tcpx1 = args[ 0 ];\r\n\t\t\tcpy1 = args[ 1 ];\r\n\r\n\t\t\tif ( points.length > 0 ) {\r\n\r\n\t\t\t\tlaste = points[ points.length - 1 ];\r\n\r\n\t\t\t\tcpx0 = laste.x;\r\n\t\t\t\tcpy0 = laste.y;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tlaste = this.actions[ i - 1 ].args;\r\n\r\n\t\t\t\tcpx0 = laste[ laste.length - 2 ];\r\n\t\t\t\tcpy0 = laste[ laste.length - 1 ];\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfor ( j = 1; j <= divisions; j ++ ) {\r\n\r\n\t\t\t\tt = j / divisions;\r\n\r\n\t\t\t\ttx = THREE.Shape.Utils.b2( t, cpx0, cpx1, cpx );\r\n\t\t\t\tty = THREE.Shape.Utils.b2( t, cpy0, cpy1, cpy );\r\n\r\n\t\t\t\tpoints.push( new THREE.Vector2( tx, ty ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tbreak;\r\n\r\n\t\tcase THREE.PathActions.BEZIER_CURVE_TO:\r\n\r\n\t\t\tcpx  = args[ 4 ];\r\n\t\t\tcpy  = args[ 5 ];\r\n\r\n\t\t\tcpx1 = args[ 0 ];\r\n\t\t\tcpy1 = args[ 1 ];\r\n\r\n\t\t\tcpx2 = args[ 2 ];\r\n\t\t\tcpy2 = args[ 3 ];\r\n\r\n\t\t\tif ( points.length > 0 ) {\r\n\r\n\t\t\t\tlaste = points[ points.length - 1 ];\r\n\r\n\t\t\t\tcpx0 = laste.x;\r\n\t\t\t\tcpy0 = laste.y;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tlaste = this.actions[ i - 1 ].args;\r\n\r\n\t\t\t\tcpx0 = laste[ laste.length - 2 ];\r\n\t\t\t\tcpy0 = laste[ laste.length - 1 ];\r\n\r\n\t\t\t}\r\n\r\n\r\n\t\t\tfor ( j = 1; j <= divisions; j ++ ) {\r\n\r\n\t\t\t\tt = j / divisions;\r\n\r\n\t\t\t\ttx = THREE.Shape.Utils.b3( t, cpx0, cpx1, cpx2, cpx );\r\n\t\t\t\tty = THREE.Shape.Utils.b3( t, cpy0, cpy1, cpy2, cpy );\r\n\r\n\t\t\t\tpoints.push( new THREE.Vector2( tx, ty ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tbreak;\r\n\r\n\t\tcase THREE.PathActions.CSPLINE_THRU:\r\n\r\n\t\t\tlaste = this.actions[ i - 1 ].args;\r\n\r\n\t\t\tvar last = new THREE.Vector2( laste[ laste.length - 2 ], laste[ laste.length - 1 ] );\r\n\t\t\tvar spts = [ last ];\r\n\r\n\t\t\tvar n = divisions * args[ 0 ].length;\r\n\r\n\t\t\tspts = spts.concat( args[ 0 ] );\r\n\r\n\t\t\tvar spline = new THREE.SplineCurve( spts );\r\n\r\n\t\t\tfor ( j = 1; j <= n; j ++ ) {\r\n\r\n\t\t\t\tpoints.push( spline.getPointAt( j / n ) ) ;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tbreak;\r\n\r\n\t\tcase THREE.PathActions.ARC:\r\n\r\n\t\t\tvar aX = args[ 0 ], aY = args[ 1 ],\r\n\t\t\t\taRadius = args[ 2 ],\r\n\t\t\t\taStartAngle = args[ 3 ], aEndAngle = args[ 4 ],\r\n\t\t\t\taClockwise = !! args[ 5 ];\r\n\r\n\t\t\tvar deltaAngle = aEndAngle - aStartAngle;\r\n\t\t\tvar angle;\r\n\t\t\tvar tdivisions = divisions * 2;\r\n\r\n\t\t\tfor ( j = 1; j <= tdivisions; j ++ ) {\r\n\r\n\t\t\t\tt = j / tdivisions;\r\n\r\n\t\t\t\tif ( ! aClockwise ) {\r\n\r\n\t\t\t\t\tt = 1 - t;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tangle = aStartAngle + t * deltaAngle;\r\n\r\n\t\t\t\ttx = aX + aRadius * Math.cos( angle );\r\n\t\t\t\tty = aY + aRadius * Math.sin( angle );\r\n\r\n\t\t\t\t//console.log('t', t, 'angle', angle, 'tx', tx, 'ty', ty);\r\n\r\n\t\t\t\tpoints.push( new THREE.Vector2( tx, ty ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t//console.log(points);\r\n\r\n\t\t\tbreak;\r\n\t\t  \r\n\t\tcase THREE.PathActions.ELLIPSE:\r\n\r\n\t\t\tvar aX = args[ 0 ], aY = args[ 1 ],\r\n\t\t\t\txRadius = args[ 2 ],\r\n\t\t\t\tyRadius = args[ 3 ],\r\n\t\t\t\taStartAngle = args[ 4 ], aEndAngle = args[ 5 ],\r\n\t\t\t\taClockwise = !! args[ 6 ];\r\n\r\n\r\n\t\t\tvar deltaAngle = aEndAngle - aStartAngle;\r\n\t\t\tvar angle;\r\n\t\t\tvar tdivisions = divisions * 2;\r\n\r\n\t\t\tfor ( j = 1; j <= tdivisions; j ++ ) {\r\n\r\n\t\t\t\tt = j / tdivisions;\r\n\r\n\t\t\t\tif ( ! aClockwise ) {\r\n\r\n\t\t\t\t\tt = 1 - t;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tangle = aStartAngle + t * deltaAngle;\r\n\r\n\t\t\t\ttx = aX + xRadius * Math.cos( angle );\r\n\t\t\t\tty = aY + yRadius * Math.sin( angle );\r\n\r\n\t\t\t\t//console.log('t', t, 'angle', angle, 'tx', tx, 'ty', ty);\r\n\r\n\t\t\t\tpoints.push( new THREE.Vector2( tx, ty ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t//console.log(points);\r\n\r\n\t\t\tbreak;\r\n\r\n\t\t} // end switch\r\n\r\n\t}\r\n\r\n\r\n\r\n\t// Normalize to remove the closing point by default.\r\n\tvar lastPoint = points[ points.length - 1];\r\n\tvar EPSILON = 0.0000000001;\r\n\tif ( Math.abs(lastPoint.x - points[ 0 ].x) < EPSILON &&\r\n\t\t\t Math.abs(lastPoint.y - points[ 0 ].y) < EPSILON)\r\n\t\tpoints.splice( points.length - 1, 1);\r\n\tif ( closedPath ) {\r\n\r\n\t\tpoints.push( points[ 0 ] );\r\n\r\n\t}\r\n\r\n\treturn points;\r\n\r\n};\r\n\r\n//\r\n// Breaks path into shapes\r\n//\r\n//\tAssumptions (if parameter isCCW==true the opposite holds):\r\n//\t- solid shapes are defined clockwise (CW)\r\n//\t- holes are defined counterclockwise (CCW)\r\n//\r\n//\tIf parameter noHoles==true:\r\n//  - all subPaths are regarded as solid shapes\r\n//  - definition order CW/CCW has no relevance\r\n//\r\n\r\nTHREE.Path.prototype.toShapes = function( isCCW, noHoles ) {\r\n\r\n\tfunction extractSubpaths( inActions ) {\r\n\r\n\t\tvar i, il, item, action, args;\r\n\r\n\t\tvar subPaths = [], lastPath = new THREE.Path();\r\n\r\n\t\tfor ( i = 0, il = inActions.length; i < il; i ++ ) {\r\n\r\n\t\t\titem = inActions[ i ];\r\n\r\n\t\t\targs = item.args;\r\n\t\t\taction = item.action;\r\n\r\n\t\t\tif ( action == THREE.PathActions.MOVE_TO ) {\r\n\r\n\t\t\t\tif ( lastPath.actions.length != 0 ) {\r\n\r\n\t\t\t\t\tsubPaths.push( lastPath );\r\n\t\t\t\t\tlastPath = new THREE.Path();\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tlastPath[ action ].apply( lastPath, args );\r\n\r\n\t\t}\r\n\r\n\t\tif ( lastPath.actions.length != 0 ) {\r\n\r\n\t\t\tsubPaths.push( lastPath );\r\n\r\n\t\t}\r\n\r\n\t\t// console.log(subPaths);\r\n\r\n\t\treturn\tsubPaths;\r\n\t}\r\n\r\n\tfunction toShapesNoHoles( inSubpaths ) {\r\n\r\n\t\tvar shapes = [];\r\n\r\n\t\tfor ( var i = 0, il = inSubpaths.length; i < il; i ++ ) {\r\n\r\n\t\t\tvar tmpPath = inSubpaths[ i ];\r\n\r\n\t\t\tvar tmpShape = new THREE.Shape();\r\n\t\t\ttmpShape.actions = tmpPath.actions;\r\n\t\t\ttmpShape.curves = tmpPath.curves;\r\n\r\n\t\t\tshapes.push( tmpShape );\r\n\t\t}\r\n\r\n\t\t//console.log(\"shape\", shapes);\r\n\r\n\t\treturn shapes;\r\n\t};\r\n\r\n\tfunction isPointInsidePolygon( inPt, inPolygon ) {\r\n\t\tvar EPSILON = 0.0000000001;\r\n\r\n\t\tvar polyLen = inPolygon.length;\r\n\r\n\t\t// inPt on polygon contour => immediate success    or\r\n\t\t// toggling of inside/outside at every single! intersection point of an edge\r\n\t\t//  with the horizontal line through inPt, left of inPt\r\n\t\t//  not counting lowerY endpoints of edges and whole edges on that line\r\n\t\tvar inside = false;\r\n\t\tfor ( var p = polyLen - 1, q = 0; q < polyLen; p = q ++ ) {\r\n\t\t\tvar edgeLowPt  = inPolygon[ p ];\r\n\t\t\tvar edgeHighPt = inPolygon[ q ];\r\n\r\n\t\t\tvar edgeDx = edgeHighPt.x - edgeLowPt.x;\r\n\t\t\tvar edgeDy = edgeHighPt.y - edgeLowPt.y;\r\n\r\n\t\t\tif ( Math.abs(edgeDy) > EPSILON ) {\t\t\t// not parallel\r\n\t\t\t\tif ( edgeDy < 0 ) {\r\n\t\t\t\t\tedgeLowPt  = inPolygon[ q ]; edgeDx = - edgeDx;\r\n\t\t\t\t\tedgeHighPt = inPolygon[ p ]; edgeDy = - edgeDy;\r\n\t\t\t\t}\r\n\t\t\t\tif ( ( inPt.y < edgeLowPt.y ) || ( inPt.y > edgeHighPt.y ) ) \t\tcontinue;\r\n\r\n\t\t\t\tif ( inPt.y == edgeLowPt.y ) {\r\n\t\t\t\t\tif ( inPt.x == edgeLowPt.x )\t\treturn\ttrue;\t\t// inPt is on contour ?\r\n\t\t\t\t\t// continue;\t\t\t\t// no intersection or edgeLowPt => doesn't count !!!\r\n\t\t\t\t} else {\r\n\t\t\t\t\tvar perpEdge = edgeDy * (inPt.x - edgeLowPt.x) - edgeDx * (inPt.y - edgeLowPt.y);\r\n\t\t\t\t\tif ( perpEdge == 0 )\t\t\t\treturn\ttrue;\t\t// inPt is on contour ?\r\n\t\t\t\t\tif ( perpEdge < 0 ) \t\t\t\tcontinue;\r\n\t\t\t\t\tinside = ! inside;\t\t// true intersection left of inPt\r\n\t\t\t\t}\r\n\t\t\t} else {\t\t// parallel or colinear\r\n\t\t\t\tif ( inPt.y != edgeLowPt.y ) \t\tcontinue;\t\t\t// parallel\r\n\t\t\t\t// egde lies on the same horizontal line as inPt\r\n\t\t\t\tif ( ( ( edgeHighPt.x <= inPt.x ) && ( inPt.x <= edgeLowPt.x ) ) ||\r\n\t\t\t\t\t ( ( edgeLowPt.x <= inPt.x ) && ( inPt.x <= edgeHighPt.x ) ) )\t\treturn\ttrue;\t// inPt: Point on contour !\r\n\t\t\t\t// continue;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn\tinside;\r\n\t}\r\n\r\n\r\n\tvar subPaths = extractSubpaths( this.actions );\r\n\tif ( subPaths.length == 0 ) return [];\r\n\r\n\tif ( noHoles === true )\treturn\ttoShapesNoHoles( subPaths );\r\n\r\n\r\n\tvar solid, tmpPath, tmpShape, shapes = [];\r\n\r\n\tif ( subPaths.length == 1) {\r\n\r\n\t\ttmpPath = subPaths[0];\r\n\t\ttmpShape = new THREE.Shape();\r\n\t\ttmpShape.actions = tmpPath.actions;\r\n\t\ttmpShape.curves = tmpPath.curves;\r\n\t\tshapes.push( tmpShape );\r\n\t\treturn shapes;\r\n\r\n\t}\r\n\r\n\tvar holesFirst = ! THREE.Shape.Utils.isClockWise( subPaths[ 0 ].getPoints() );\r\n\tholesFirst = isCCW ? ! holesFirst : holesFirst;\r\n\r\n\t// console.log(\"Holes first\", holesFirst);\r\n\t\r\n\tvar betterShapeHoles = [];\r\n\tvar newShapes = [];\r\n\tvar newShapeHoles = [];\r\n\tvar mainIdx = 0;\r\n\tvar tmpPoints;\r\n\r\n\tnewShapes[mainIdx] = undefined;\r\n\tnewShapeHoles[mainIdx] = [];\r\n\r\n\tvar i, il;\r\n\r\n\tfor ( i = 0, il = subPaths.length; i < il; i ++ ) {\r\n\r\n\t\ttmpPath = subPaths[ i ];\r\n\t\ttmpPoints = tmpPath.getPoints();\r\n\t\tsolid = THREE.Shape.Utils.isClockWise( tmpPoints );\r\n\t\tsolid = isCCW ? ! solid : solid;\r\n\r\n\t\tif ( solid ) {\r\n\r\n\t\t\tif ( (! holesFirst ) && ( newShapes[mainIdx] ) )\tmainIdx ++;\r\n\r\n\t\t\tnewShapes[mainIdx] = { s: new THREE.Shape(), p: tmpPoints };\r\n\t\t\tnewShapes[mainIdx].s.actions = tmpPath.actions;\r\n\t\t\tnewShapes[mainIdx].s.curves = tmpPath.curves;\r\n\t\t\t\r\n\t\t\tif ( holesFirst )\tmainIdx ++;\r\n\t\t\tnewShapeHoles[mainIdx] = [];\r\n\r\n\t\t\t//console.log('cw', i);\r\n\r\n\t\t} else {\r\n\r\n\t\t\tnewShapeHoles[mainIdx].push( { h: tmpPath, p: tmpPoints[0] } );\r\n\r\n\t\t\t//console.log('ccw', i);\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// only Holes? -> probably all Shapes with wrong orientation\r\n\tif ( ! newShapes[0] )\treturn\ttoShapesNoHoles( subPaths );\r\n\r\n\r\n\tif ( newShapes.length > 1 ) {\r\n\t\tvar ambigious = false;\r\n\t\tvar toChange = [];\r\n\r\n\t\tfor (var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {\r\n\t\t\tbetterShapeHoles[sIdx] = [];\r\n\t\t}\r\n\t\tfor (var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {\r\n\t\t\tvar sho = newShapeHoles[sIdx];\r\n\t\t\tfor (var hIdx = 0; hIdx < sho.length; hIdx ++ ) {\r\n\t\t\t\tvar ho = sho[hIdx];\r\n\t\t\t\tvar hole_unassigned = true;\r\n\t\t\t\tfor (var s2Idx = 0; s2Idx < newShapes.length; s2Idx ++ ) {\r\n\t\t\t\t\tif ( isPointInsidePolygon( ho.p, newShapes[s2Idx].p ) ) {\r\n\t\t\t\t\t\tif ( sIdx != s2Idx )\t\ttoChange.push( { froms: sIdx, tos: s2Idx, hole: hIdx } );\r\n\t\t\t\t\t\tif ( hole_unassigned ) {\r\n\t\t\t\t\t\t\thole_unassigned = false;\r\n\t\t\t\t\t\t\tbetterShapeHoles[s2Idx].push( ho );\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tambigious = true;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif ( hole_unassigned ) { betterShapeHoles[sIdx].push( ho ); }\r\n\t\t\t}\r\n\t\t}\r\n\t\t// console.log(\"ambigious: \", ambigious);\r\n\t\tif ( toChange.length > 0 ) {\r\n\t\t\t// console.log(\"to change: \", toChange);\r\n\t\t\tif (! ambigious)\tnewShapeHoles = betterShapeHoles;\r\n\t\t}\r\n\t}\r\n\r\n\tvar tmpHoles, j, jl;\r\n\tfor ( i = 0, il = newShapes.length; i < il; i ++ ) {\r\n\t\ttmpShape = newShapes[i].s;\r\n\t\tshapes.push( tmpShape );\r\n\t\ttmpHoles = newShapeHoles[i];\r\n\t\tfor ( j = 0, jl = tmpHoles.length; j < jl; j ++ ) {\r\n\t\t\ttmpShape.holes.push( tmpHoles[j].h );\r\n\t\t}\r\n\t}\r\n\r\n\t//console.log(\"shape\", shapes);\r\n\r\n\treturn shapes;\r\n\r\n};\r\n\r\n// File:src/extras/core/Shape.js\r\n\r\n/**\r\n * @author zz85 / http://www.lab4games.net/zz85/blog\r\n * Defines a 2d shape plane using paths.\r\n **/\r\n\r\n// STEP 1 Create a path.\r\n// STEP 2 Turn path into shape.\r\n// STEP 3 ExtrudeGeometry takes in Shape/Shapes\r\n// STEP 3a - Extract points from each shape, turn to vertices\r\n// STEP 3b - Triangulate each shape, add faces.\r\n\r\nTHREE.Shape = function () {\r\n\r\n\tTHREE.Path.apply( this, arguments );\r\n\tthis.holes = [];\r\n\r\n};\r\n\r\nTHREE.Shape.prototype = Object.create( THREE.Path.prototype );\r\nTHREE.Shape.prototype.constructor = THREE.Shape;\r\n\r\n// Convenience method to return ExtrudeGeometry\r\n\r\nTHREE.Shape.prototype.extrude = function ( options ) {\r\n\r\n\tvar extruded = new THREE.ExtrudeGeometry( this, options );\r\n\treturn extruded;\r\n\r\n};\r\n\r\n// Convenience method to return ShapeGeometry\r\n\r\nTHREE.Shape.prototype.makeGeometry = function ( options ) {\r\n\r\n\tvar geometry = new THREE.ShapeGeometry( this, options );\r\n\treturn geometry;\r\n\r\n};\r\n\r\n// Get points of holes\r\n\r\nTHREE.Shape.prototype.getPointsHoles = function ( divisions ) {\r\n\r\n\tvar i, il = this.holes.length, holesPts = [];\r\n\r\n\tfor ( i = 0; i < il; i ++ ) {\r\n\r\n\t\tholesPts[ i ] = this.holes[ i ].getTransformedPoints( divisions, this.bends );\r\n\r\n\t}\r\n\r\n\treturn holesPts;\r\n\r\n};\r\n\r\n// Get points of holes (spaced by regular distance)\r\n\r\nTHREE.Shape.prototype.getSpacedPointsHoles = function ( divisions ) {\r\n\r\n\tvar i, il = this.holes.length, holesPts = [];\r\n\r\n\tfor ( i = 0; i < il; i ++ ) {\r\n\r\n\t\tholesPts[ i ] = this.holes[ i ].getTransformedSpacedPoints( divisions, this.bends );\r\n\r\n\t}\r\n\r\n\treturn holesPts;\r\n\r\n};\r\n\r\n\r\n// Get points of shape and holes (keypoints based on segments parameter)\r\n\r\nTHREE.Shape.prototype.extractAllPoints = function ( divisions ) {\r\n\r\n\treturn {\r\n\r\n\t\tshape: this.getTransformedPoints( divisions ),\r\n\t\tholes: this.getPointsHoles( divisions )\r\n\r\n\t};\r\n\r\n};\r\n\r\nTHREE.Shape.prototype.extractPoints = function ( divisions ) {\r\n\r\n\tif (this.useSpacedPoints) {\r\n\t\treturn this.extractAllSpacedPoints(divisions);\r\n\t}\r\n\r\n\treturn this.extractAllPoints(divisions);\r\n\r\n};\r\n\r\n//\r\n// THREE.Shape.prototype.extractAllPointsWithBend = function ( divisions, bend ) {\r\n//\r\n// \treturn {\r\n//\r\n// \t\tshape: this.transform( bend, divisions ),\r\n// \t\tholes: this.getPointsHoles( divisions, bend )\r\n//\r\n// \t};\r\n//\r\n// };\r\n\r\n// Get points of shape and holes (spaced by regular distance)\r\n\r\nTHREE.Shape.prototype.extractAllSpacedPoints = function ( divisions ) {\r\n\r\n\treturn {\r\n\r\n\t\tshape: this.getTransformedSpacedPoints( divisions ),\r\n\t\tholes: this.getSpacedPointsHoles( divisions )\r\n\r\n\t};\r\n\r\n};\r\n\r\n/**************************************************************\r\n *\tUtils\r\n **************************************************************/\r\n\r\nTHREE.Shape.Utils = {\r\n\r\n\ttriangulateShape: function ( contour, holes ) {\r\n\r\n\t\tfunction point_in_segment_2D_colin( inSegPt1, inSegPt2, inOtherPt ) {\r\n\t\t\t// inOtherPt needs to be colinear to the inSegment\r\n\t\t\tif ( inSegPt1.x != inSegPt2.x ) {\r\n\t\t\t\tif ( inSegPt1.x < inSegPt2.x ) {\r\n\t\t\t\t\treturn\t( ( inSegPt1.x <= inOtherPt.x ) && ( inOtherPt.x <= inSegPt2.x ) );\r\n\t\t\t\t} else {\r\n\t\t\t\t\treturn\t( ( inSegPt2.x <= inOtherPt.x ) && ( inOtherPt.x <= inSegPt1.x ) );\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tif ( inSegPt1.y < inSegPt2.y ) {\r\n\t\t\t\t\treturn\t( ( inSegPt1.y <= inOtherPt.y ) && ( inOtherPt.y <= inSegPt2.y ) );\r\n\t\t\t\t} else {\r\n\t\t\t\t\treturn\t( ( inSegPt2.y <= inOtherPt.y ) && ( inOtherPt.y <= inSegPt1.y ) );\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tfunction intersect_segments_2D( inSeg1Pt1, inSeg1Pt2, inSeg2Pt1, inSeg2Pt2, inExcludeAdjacentSegs ) {\r\n\t\t\tvar EPSILON = 0.0000000001;\r\n\r\n\t\t\tvar seg1dx = inSeg1Pt2.x - inSeg1Pt1.x,   seg1dy = inSeg1Pt2.y - inSeg1Pt1.y;\r\n\t\t\tvar seg2dx = inSeg2Pt2.x - inSeg2Pt1.x,   seg2dy = inSeg2Pt2.y - inSeg2Pt1.y;\r\n\r\n\t\t\tvar seg1seg2dx = inSeg1Pt1.x - inSeg2Pt1.x;\r\n\t\t\tvar seg1seg2dy = inSeg1Pt1.y - inSeg2Pt1.y;\r\n\r\n\t\t\tvar limit\t\t= seg1dy * seg2dx - seg1dx * seg2dy;\r\n\t\t\tvar perpSeg1\t= seg1dy * seg1seg2dx - seg1dx * seg1seg2dy;\r\n\r\n\t\t\tif ( Math.abs(limit) > EPSILON ) {\t\t\t// not parallel\r\n\r\n\t\t\t\tvar perpSeg2;\r\n\t\t\t\tif ( limit > 0 ) {\r\n\t\t\t\t\tif ( ( perpSeg1 < 0 ) || ( perpSeg1 > limit ) ) \t\treturn [];\r\n\t\t\t\t\tperpSeg2 = seg2dy * seg1seg2dx - seg2dx * seg1seg2dy;\r\n\t\t\t\t\tif ( ( perpSeg2 < 0 ) || ( perpSeg2 > limit ) ) \t\treturn [];\r\n\t\t\t\t} else {\r\n\t\t\t\t\tif ( ( perpSeg1 > 0 ) || ( perpSeg1 < limit ) ) \t\treturn [];\r\n\t\t\t\t\tperpSeg2 = seg2dy * seg1seg2dx - seg2dx * seg1seg2dy;\r\n\t\t\t\t\tif ( ( perpSeg2 > 0 ) || ( perpSeg2 < limit ) ) \t\treturn [];\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// i.e. to reduce rounding errors\r\n\t\t\t\t// intersection at endpoint of segment#1?\r\n\t\t\t\tif ( perpSeg2 == 0 ) {\r\n\t\t\t\t\tif ( ( inExcludeAdjacentSegs ) &&\r\n\t\t\t\t\t\t ( ( perpSeg1 == 0 ) || ( perpSeg1 == limit ) ) )\t\treturn [];\r\n\t\t\t\t\treturn [ inSeg1Pt1 ];\r\n\t\t\t\t}\r\n\t\t\t\tif ( perpSeg2 == limit ) {\r\n\t\t\t\t\tif ( ( inExcludeAdjacentSegs ) &&\r\n\t\t\t\t\t\t ( ( perpSeg1 == 0 ) || ( perpSeg1 == limit ) ) )\t\treturn [];\r\n\t\t\t\t\treturn [ inSeg1Pt2 ];\r\n\t\t\t\t}\r\n\t\t\t\t// intersection at endpoint of segment#2?\r\n\t\t\t\tif ( perpSeg1 == 0 )\t\treturn [ inSeg2Pt1 ];\r\n\t\t\t\tif ( perpSeg1 == limit )\treturn [ inSeg2Pt2 ];\r\n\r\n\t\t\t\t// return real intersection point\r\n\t\t\t\tvar factorSeg1 = perpSeg2 / limit;\r\n\t\t\t\treturn\t[ { x: inSeg1Pt1.x + factorSeg1 * seg1dx,\r\n\t\t\t\t\t\t\ty: inSeg1Pt1.y + factorSeg1 * seg1dy } ];\r\n\r\n\t\t\t} else {\t\t// parallel or colinear\r\n\t\t\t\tif ( ( perpSeg1 != 0 ) ||\r\n\t\t\t\t\t ( seg2dy * seg1seg2dx != seg2dx * seg1seg2dy ) ) \t\t\treturn [];\r\n\r\n\t\t\t\t// they are collinear or degenerate\r\n\t\t\t\tvar seg1Pt = ( (seg1dx == 0) && (seg1dy == 0) );\t// segment1 ist just a point?\r\n\t\t\t\tvar seg2Pt = ( (seg2dx == 0) && (seg2dy == 0) );\t// segment2 ist just a point?\r\n\t\t\t\t// both segments are points\r\n\t\t\t\tif ( seg1Pt && seg2Pt ) {\r\n\t\t\t\t\tif ( (inSeg1Pt1.x != inSeg2Pt1.x) ||\r\n\t\t\t\t\t\t (inSeg1Pt1.y != inSeg2Pt1.y) )\t\treturn [];   \t// they are distinct  points\r\n\t\t\t\t\treturn [ inSeg1Pt1 ];                 \t\t\t\t\t// they are the same point\r\n\t\t\t\t}\r\n\t\t\t\t// segment#1  is a single point\r\n\t\t\t\tif ( seg1Pt ) {\r\n\t\t\t\t\tif (! point_in_segment_2D_colin( inSeg2Pt1, inSeg2Pt2, inSeg1Pt1 ) )\t\treturn [];\t\t// but not in segment#2\r\n\t\t\t\t\treturn [ inSeg1Pt1 ];\r\n\t\t\t\t}\r\n\t\t\t\t// segment#2  is a single point\r\n\t\t\t\tif ( seg2Pt ) {\r\n\t\t\t\t\tif (! point_in_segment_2D_colin( inSeg1Pt1, inSeg1Pt2, inSeg2Pt1 ) )\t\treturn [];\t\t// but not in segment#1\r\n\t\t\t\t\treturn [ inSeg2Pt1 ];\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// they are collinear segments, which might overlap\r\n\t\t\t\tvar seg1min, seg1max, seg1minVal, seg1maxVal;\r\n\t\t\t\tvar seg2min, seg2max, seg2minVal, seg2maxVal;\r\n\t\t\t\tif (seg1dx != 0) {\t\t// the segments are NOT on a vertical line\r\n\t\t\t\t\tif ( inSeg1Pt1.x < inSeg1Pt2.x ) {\r\n\t\t\t\t\t\tseg1min = inSeg1Pt1; seg1minVal = inSeg1Pt1.x;\r\n\t\t\t\t\t\tseg1max = inSeg1Pt2; seg1maxVal = inSeg1Pt2.x;\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tseg1min = inSeg1Pt2; seg1minVal = inSeg1Pt2.x;\r\n\t\t\t\t\t\tseg1max = inSeg1Pt1; seg1maxVal = inSeg1Pt1.x;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif ( inSeg2Pt1.x < inSeg2Pt2.x ) {\r\n\t\t\t\t\t\tseg2min = inSeg2Pt1; seg2minVal = inSeg2Pt1.x;\r\n\t\t\t\t\t\tseg2max = inSeg2Pt2; seg2maxVal = inSeg2Pt2.x;\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tseg2min = inSeg2Pt2; seg2minVal = inSeg2Pt2.x;\r\n\t\t\t\t\t\tseg2max = inSeg2Pt1; seg2maxVal = inSeg2Pt1.x;\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\t\t\t\t// the segments are on a vertical line\r\n\t\t\t\t\tif ( inSeg1Pt1.y < inSeg1Pt2.y ) {\r\n\t\t\t\t\t\tseg1min = inSeg1Pt1; seg1minVal = inSeg1Pt1.y;\r\n\t\t\t\t\t\tseg1max = inSeg1Pt2; seg1maxVal = inSeg1Pt2.y;\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tseg1min = inSeg1Pt2; seg1minVal = inSeg1Pt2.y;\r\n\t\t\t\t\t\tseg1max = inSeg1Pt1; seg1maxVal = inSeg1Pt1.y;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif ( inSeg2Pt1.y < inSeg2Pt2.y ) {\r\n\t\t\t\t\t\tseg2min = inSeg2Pt1; seg2minVal = inSeg2Pt1.y;\r\n\t\t\t\t\t\tseg2max = inSeg2Pt2; seg2maxVal = inSeg2Pt2.y;\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tseg2min = inSeg2Pt2; seg2minVal = inSeg2Pt2.y;\r\n\t\t\t\t\t\tseg2max = inSeg2Pt1; seg2maxVal = inSeg2Pt1.y;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif ( seg1minVal <= seg2minVal ) {\r\n\t\t\t\t\tif ( seg1maxVal <  seg2minVal )\treturn [];\r\n\t\t\t\t\tif ( seg1maxVal == seg2minVal )\t{\r\n\t\t\t\t\t\tif ( inExcludeAdjacentSegs )\t\treturn [];\r\n\t\t\t\t\t\treturn [ seg2min ];\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif ( seg1maxVal <= seg2maxVal )\treturn [ seg2min, seg1max ];\r\n\t\t\t\t\treturn\t[ seg2min, seg2max ];\r\n\t\t\t\t} else {\r\n\t\t\t\t\tif ( seg1minVal >  seg2maxVal )\treturn [];\r\n\t\t\t\t\tif ( seg1minVal == seg2maxVal )\t{\r\n\t\t\t\t\t\tif ( inExcludeAdjacentSegs )\t\treturn [];\r\n\t\t\t\t\t\treturn [ seg1min ];\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif ( seg1maxVal <= seg2maxVal )\treturn [ seg1min, seg1max ];\r\n\t\t\t\t\treturn\t[ seg1min, seg2max ];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tfunction isPointInsideAngle( inVertex, inLegFromPt, inLegToPt, inOtherPt ) {\r\n\t\t\t// The order of legs is important\r\n\r\n\t\t\tvar EPSILON = 0.0000000001;\r\n\r\n\t\t\t// translation of all points, so that Vertex is at (0,0)\r\n\t\t\tvar legFromPtX\t= inLegFromPt.x - inVertex.x,  legFromPtY\t= inLegFromPt.y - inVertex.y;\r\n\t\t\tvar legToPtX\t= inLegToPt.x\t- inVertex.x,  legToPtY\t\t= inLegToPt.y\t- inVertex.y;\r\n\t\t\tvar otherPtX\t= inOtherPt.x\t- inVertex.x,  otherPtY\t\t= inOtherPt.y\t- inVertex.y;\r\n\r\n\t\t\t// main angle >0: < 180 deg.; 0: 180 deg.; <0: > 180 deg.\r\n\t\t\tvar from2toAngle\t= legFromPtX * legToPtY - legFromPtY * legToPtX;\r\n\t\t\tvar from2otherAngle\t= legFromPtX * otherPtY - legFromPtY * otherPtX;\r\n\r\n\t\t\tif ( Math.abs(from2toAngle) > EPSILON ) {\t\t\t// angle != 180 deg.\r\n\r\n\t\t\t\tvar other2toAngle\t\t= otherPtX * legToPtY - otherPtY * legToPtX;\r\n\t\t\t\t// console.log( \"from2to: \" + from2toAngle + \", from2other: \" + from2otherAngle + \", other2to: \" + other2toAngle );\r\n\r\n\t\t\t\tif ( from2toAngle > 0 ) {\t\t\t\t// main angle < 180 deg.\r\n\t\t\t\t\treturn\t( ( from2otherAngle >= 0 ) && ( other2toAngle >= 0 ) );\r\n\t\t\t\t} else {\t\t\t\t\t\t\t\t// main angle > 180 deg.\r\n\t\t\t\t\treturn\t( ( from2otherAngle >= 0 ) || ( other2toAngle >= 0 ) );\r\n\t\t\t\t}\r\n\t\t\t} else {\t\t\t\t\t\t\t\t\t\t// angle == 180 deg.\r\n\t\t\t\t// console.log( \"from2to: 180 deg., from2other: \" + from2otherAngle  );\r\n\t\t\t\treturn\t( from2otherAngle > 0 );\r\n\t\t\t}\r\n\t\t}\r\n\r\n\r\n\t\tfunction removeHoles( contour, holes ) {\r\n\r\n\t\t\tvar shape = contour.concat(); // work on this shape\r\n\t\t\tvar hole;\r\n\r\n\t\t\tfunction isCutLineInsideAngles( inShapeIdx, inHoleIdx ) {\r\n\t\t\t\t// Check if hole point lies within angle around shape point\r\n\t\t\t\tvar lastShapeIdx = shape.length - 1;\r\n\r\n\t\t\t\tvar prevShapeIdx = inShapeIdx - 1;\r\n\t\t\t\tif ( prevShapeIdx < 0 )\t\t\tprevShapeIdx = lastShapeIdx;\r\n\r\n\t\t\t\tvar nextShapeIdx = inShapeIdx + 1;\r\n\t\t\t\tif ( nextShapeIdx > lastShapeIdx )\tnextShapeIdx = 0;\r\n\r\n\t\t\t\tvar insideAngle = isPointInsideAngle( shape[inShapeIdx], shape[ prevShapeIdx ], shape[ nextShapeIdx ], hole[inHoleIdx] );\r\n\t\t\t\tif (! insideAngle ) {\r\n\t\t\t\t\t// console.log( \"Vertex (Shape): \" + inShapeIdx + \", Point: \" + hole[inHoleIdx].x + \"/\" + hole[inHoleIdx].y );\r\n\t\t\t\t\treturn\tfalse;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Check if shape point lies within angle around hole point\r\n\t\t\t\tvar lastHoleIdx = hole.length - 1;\r\n\r\n\t\t\t\tvar prevHoleIdx = inHoleIdx - 1;\r\n\t\t\t\tif ( prevHoleIdx < 0 )\t\t\tprevHoleIdx = lastHoleIdx;\r\n\r\n\t\t\t\tvar nextHoleIdx = inHoleIdx + 1;\r\n\t\t\t\tif ( nextHoleIdx > lastHoleIdx )\tnextHoleIdx = 0;\r\n\r\n\t\t\t\tinsideAngle = isPointInsideAngle( hole[inHoleIdx], hole[ prevHoleIdx ], hole[ nextHoleIdx ], shape[inShapeIdx] );\r\n\t\t\t\tif (! insideAngle ) {\r\n\t\t\t\t\t// console.log( \"Vertex (Hole): \" + inHoleIdx + \", Point: \" + shape[inShapeIdx].x + \"/\" + shape[inShapeIdx].y );\r\n\t\t\t\t\treturn\tfalse;\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn\ttrue;\r\n\t\t\t}\r\n\r\n\t\t\tfunction intersectsShapeEdge( inShapePt, inHolePt ) {\r\n\t\t\t\t// checks for intersections with shape edges\r\n\t\t\t\tvar sIdx, nextIdx, intersection;\r\n\t\t\t\tfor ( sIdx = 0; sIdx < shape.length; sIdx ++ ) {\r\n\t\t\t\t\tnextIdx = sIdx + 1; nextIdx %= shape.length;\r\n\t\t\t\t\tintersection = intersect_segments_2D( inShapePt, inHolePt, shape[sIdx], shape[nextIdx], true );\r\n\t\t\t\t\tif ( intersection.length > 0 )\t\treturn\ttrue;\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn\tfalse;\r\n\t\t\t}\r\n\r\n\t\t\tvar indepHoles = [];\r\n\r\n\t\t\tfunction intersectsHoleEdge( inShapePt, inHolePt ) {\r\n\t\t\t\t// checks for intersections with hole edges\r\n\t\t\t\tvar ihIdx, chkHole,\r\n\t\t\t\t\thIdx, nextIdx, intersection;\r\n\t\t\t\tfor ( ihIdx = 0; ihIdx < indepHoles.length; ihIdx ++ ) {\r\n\t\t\t\t\tchkHole = holes[indepHoles[ihIdx]];\r\n\t\t\t\t\tfor ( hIdx = 0; hIdx < chkHole.length; hIdx ++ ) {\r\n\t\t\t\t\t\tnextIdx = hIdx + 1; nextIdx %= chkHole.length;\r\n\t\t\t\t\t\tintersection = intersect_segments_2D( inShapePt, inHolePt, chkHole[hIdx], chkHole[nextIdx], true );\r\n\t\t\t\t\t\tif ( intersection.length > 0 )\t\treturn\ttrue;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\treturn\tfalse;\r\n\t\t\t}\r\n\r\n\t\t\tvar holeIndex, shapeIndex,\r\n\t\t\t\tshapePt, holePt,\r\n\t\t\t\tholeIdx, cutKey, failedCuts = [],\r\n\t\t\t\ttmpShape1, tmpShape2,\r\n\t\t\t\ttmpHole1, tmpHole2;\r\n\r\n\t\t\tfor ( var h = 0, hl = holes.length; h < hl; h ++ ) {\r\n\r\n\t\t\t\tindepHoles.push( h );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar minShapeIndex = 0;\r\n\t\t\tvar counter = indepHoles.length * 2;\r\n\t\t\twhile ( indepHoles.length > 0 ) {\r\n\t\t\t\tcounter --;\r\n\t\t\t\tif ( counter < 0 ) {\r\n\t\t\t\t\tconsole.log( \"Infinite Loop! Holes left:\" + indepHoles.length + \", Probably Hole outside Shape!\" );\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// search for shape-vertex and hole-vertex,\r\n\t\t\t\t// which can be connected without intersections\r\n\t\t\t\tfor ( shapeIndex = minShapeIndex; shapeIndex < shape.length; shapeIndex ++ ) {\r\n\r\n\t\t\t\t\tshapePt = shape[ shapeIndex ];\r\n\t\t\t\t\tholeIndex\t= - 1;\r\n\r\n\t\t\t\t\t// search for hole which can be reached without intersections\r\n\t\t\t\t\tfor ( var h = 0; h < indepHoles.length; h ++ ) {\r\n\t\t\t\t\t\tholeIdx = indepHoles[h];\r\n\r\n\t\t\t\t\t\t// prevent multiple checks\r\n\t\t\t\t\t\tcutKey = shapePt.x + \":\" + shapePt.y + \":\" + holeIdx;\r\n\t\t\t\t\t\tif ( failedCuts[cutKey] !== undefined )\t\t\tcontinue;\r\n\r\n\t\t\t\t\t\thole = holes[holeIdx];\r\n\t\t\t\t\t\tfor ( var h2 = 0; h2 < hole.length; h2 ++ ) {\r\n\t\t\t\t\t\t\tholePt = hole[ h2 ];\r\n\t\t\t\t\t\t\tif (! isCutLineInsideAngles( shapeIndex, h2 ) )\t\tcontinue;\r\n\t\t\t\t\t\t\tif ( intersectsShapeEdge( shapePt, holePt ) )\t\tcontinue;\r\n\t\t\t\t\t\t\tif ( intersectsHoleEdge( shapePt, holePt ) )\t\tcontinue;\r\n\r\n\t\t\t\t\t\t\tholeIndex = h2;\r\n\t\t\t\t\t\t\tindepHoles.splice(h, 1);\r\n\r\n\t\t\t\t\t\t\ttmpShape1 = shape.slice( 0, shapeIndex + 1 );\r\n\t\t\t\t\t\t\ttmpShape2 = shape.slice( shapeIndex );\r\n\t\t\t\t\t\t\ttmpHole1 = hole.slice( holeIndex );\r\n\t\t\t\t\t\t\ttmpHole2 = hole.slice( 0, holeIndex + 1 );\r\n\r\n\t\t\t\t\t\t\tshape = tmpShape1.concat( tmpHole1 ).concat( tmpHole2 ).concat( tmpShape2 );\r\n\r\n\t\t\t\t\t\t\tminShapeIndex = shapeIndex;\r\n\r\n\t\t\t\t\t\t\t// Debug only, to show the selected cuts\r\n\t\t\t\t\t\t\t// glob_CutLines.push( [ shapePt, holePt ] );\r\n\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif ( holeIndex >= 0 )\tbreak;\t\t// hole-vertex found\r\n\r\n\t\t\t\t\t\tfailedCuts[cutKey] = true;\t\t\t// remember failure\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif ( holeIndex >= 0 )\tbreak;\t\t// hole-vertex found\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\treturn shape; \t\t\t/* shape with no holes */\r\n\t\t}\r\n\r\n\r\n\t\tvar i, il, f, face,\r\n\t\t\tkey, index,\r\n\t\t\tallPointsMap = {};\r\n\r\n\t\t// To maintain reference to old shape, one must match coordinates, or offset the indices from original arrays. It's probably easier to do the first.\r\n\r\n\t\tvar allpoints = contour.concat();\r\n\r\n\t\tfor ( var h = 0, hl = holes.length; h < hl; h ++ ) {\r\n\r\n\t\t\tArray.prototype.push.apply( allpoints, holes[h] );\r\n\r\n\t\t}\r\n\r\n\t\t//console.log( \"allpoints\",allpoints, allpoints.length );\r\n\r\n\t\t// prepare all points map\r\n\r\n\t\tfor ( i = 0, il = allpoints.length; i < il; i ++ ) {\r\n\r\n\t\t\tkey = allpoints[ i ].x + \":\" + allpoints[ i ].y;\r\n\r\n\t\t\tif ( allPointsMap[ key ] !== undefined ) {\r\n\r\n\t\t\t\tTHREE.warn( \"THREE.Shape: Duplicate point\", key );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tallPointsMap[ key ] = i;\r\n\r\n\t\t}\r\n\r\n\t\t// remove holes by cutting paths to holes and adding them to the shape\r\n\t\tvar shapeWithoutHoles = removeHoles( contour, holes );\r\n\r\n\t\tvar triangles = THREE.FontUtils.Triangulate( shapeWithoutHoles, false ); // True returns indices for points of spooled shape\r\n\t\t//console.log( \"triangles\",triangles, triangles.length );\r\n\r\n\t\t// check all face vertices against all points map\r\n\r\n\t\tfor ( i = 0, il = triangles.length; i < il; i ++ ) {\r\n\r\n\t\t\tface = triangles[ i ];\r\n\r\n\t\t\tfor ( f = 0; f < 3; f ++ ) {\r\n\r\n\t\t\t\tkey = face[ f ].x + \":\" + face[ f ].y;\r\n\r\n\t\t\t\tindex = allPointsMap[ key ];\r\n\r\n\t\t\t\tif ( index !== undefined ) {\r\n\r\n\t\t\t\t\tface[ f ] = index;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn triangles.concat();\r\n\r\n\t},\r\n\r\n\tisClockWise: function ( pts ) {\r\n\r\n\t\treturn THREE.FontUtils.Triangulate.area( pts ) < 0;\r\n\r\n\t},\r\n\r\n\t// Bezier Curves formulas obtained from\r\n\t// http://en.wikipedia.org/wiki/B%C3%A9zier_curve\r\n\r\n\t// Quad Bezier Functions\r\n\r\n\tb2p0: function ( t, p ) {\r\n\r\n\t\tvar k = 1 - t;\r\n\t\treturn k * k * p;\r\n\r\n\t},\r\n\r\n\tb2p1: function ( t, p ) {\r\n\r\n\t\treturn 2 * ( 1 - t ) * t * p;\r\n\r\n\t},\r\n\r\n\tb2p2: function ( t, p ) {\r\n\r\n\t\treturn t * t * p;\r\n\r\n\t},\r\n\r\n\tb2: function ( t, p0, p1, p2 ) {\r\n\r\n\t\treturn this.b2p0( t, p0 ) + this.b2p1( t, p1 ) + this.b2p2( t, p2 );\r\n\r\n\t},\r\n\r\n\t// Cubic Bezier Functions\r\n\r\n\tb3p0: function ( t, p ) {\r\n\r\n\t\tvar k = 1 - t;\r\n\t\treturn k * k * k * p;\r\n\r\n\t},\r\n\r\n\tb3p1: function ( t, p ) {\r\n\r\n\t\tvar k = 1 - t;\r\n\t\treturn 3 * k * k * t * p;\r\n\r\n\t},\r\n\r\n\tb3p2: function ( t, p ) {\r\n\r\n\t\tvar k = 1 - t;\r\n\t\treturn 3 * k * t * t * p;\r\n\r\n\t},\r\n\r\n\tb3p3: function ( t, p ) {\r\n\r\n\t\treturn t * t * t * p;\r\n\r\n\t},\r\n\r\n\tb3: function ( t, p0, p1, p2, p3 ) {\r\n\r\n\t\treturn this.b3p0( t, p0 ) + this.b3p1( t, p1 ) + this.b3p2( t, p2 ) +  this.b3p3( t, p3 );\r\n\r\n\t}\r\n\r\n};\r\n\r\n\r\n// File:src/extras/curves/LineCurve.js\r\n\r\n/**************************************************************\r\n *\tLine\r\n **************************************************************/\r\n\r\nTHREE.LineCurve = function ( v1, v2 ) {\r\n\r\n\tthis.v1 = v1;\r\n\tthis.v2 = v2;\r\n\r\n};\r\n\r\nTHREE.LineCurve.prototype = Object.create( THREE.Curve.prototype );\r\nTHREE.LineCurve.prototype.constructor = THREE.LineCurve;\r\n\r\nTHREE.LineCurve.prototype.getPoint = function ( t ) {\r\n\r\n\tvar point = this.v2.clone().sub(this.v1);\r\n\tpoint.multiplyScalar( t ).add( this.v1 );\r\n\r\n\treturn point;\r\n\r\n};\r\n\r\n// Line curve is linear, so we can overwrite default getPointAt\r\n\r\nTHREE.LineCurve.prototype.getPointAt = function ( u ) {\r\n\r\n\treturn this.getPoint( u );\r\n\r\n};\r\n\r\nTHREE.LineCurve.prototype.getTangent = function( t ) {\r\n\r\n\tvar tangent = this.v2.clone().sub(this.v1);\r\n\r\n\treturn tangent.normalize();\r\n\r\n};\r\n\r\n// File:src/extras/curves/QuadraticBezierCurve.js\r\n\r\n/**************************************************************\r\n *\tQuadratic Bezier curve\r\n **************************************************************/\r\n\r\n\r\nTHREE.QuadraticBezierCurve = function ( v0, v1, v2 ) {\r\n\r\n\tthis.v0 = v0;\r\n\tthis.v1 = v1;\r\n\tthis.v2 = v2;\r\n\r\n};\r\n\r\nTHREE.QuadraticBezierCurve.prototype = Object.create( THREE.Curve.prototype );\r\nTHREE.QuadraticBezierCurve.prototype.constructor = THREE.QuadraticBezierCurve;\r\n\r\n\r\nTHREE.QuadraticBezierCurve.prototype.getPoint = function ( t ) {\r\n\r\n\tvar vector = new THREE.Vector2();\r\n\r\n\tvector.x = THREE.Shape.Utils.b2( t, this.v0.x, this.v1.x, this.v2.x );\r\n\tvector.y = THREE.Shape.Utils.b2( t, this.v0.y, this.v1.y, this.v2.y );\r\n\r\n\treturn vector;\r\n\r\n};\r\n\r\n\r\nTHREE.QuadraticBezierCurve.prototype.getTangent = function( t ) {\r\n\r\n\tvar vector = new THREE.Vector2();\r\n\r\n\tvector.x = THREE.Curve.Utils.tangentQuadraticBezier( t, this.v0.x, this.v1.x, this.v2.x );\r\n\tvector.y = THREE.Curve.Utils.tangentQuadraticBezier( t, this.v0.y, this.v1.y, this.v2.y );\r\n\r\n\t// returns unit vector\r\n\r\n\treturn vector.normalize();\r\n\r\n};\r\n\r\n// File:src/extras/curves/CubicBezierCurve.js\r\n\r\n/**************************************************************\r\n *\tCubic Bezier curve\r\n **************************************************************/\r\n\r\nTHREE.CubicBezierCurve = function ( v0, v1, v2, v3 ) {\r\n\r\n\tthis.v0 = v0;\r\n\tthis.v1 = v1;\r\n\tthis.v2 = v2;\r\n\tthis.v3 = v3;\r\n\r\n};\r\n\r\nTHREE.CubicBezierCurve.prototype = Object.create( THREE.Curve.prototype );\r\nTHREE.CubicBezierCurve.prototype.constructor = THREE.CubicBezierCurve;\r\n\r\nTHREE.CubicBezierCurve.prototype.getPoint = function ( t ) {\r\n\r\n\tvar tx, ty;\r\n\r\n\ttx = THREE.Shape.Utils.b3( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x );\r\n\tty = THREE.Shape.Utils.b3( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y );\r\n\r\n\treturn new THREE.Vector2( tx, ty );\r\n\r\n};\r\n\r\nTHREE.CubicBezierCurve.prototype.getTangent = function( t ) {\r\n\r\n\tvar tx, ty;\r\n\r\n\ttx = THREE.Curve.Utils.tangentCubicBezier( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x );\r\n\tty = THREE.Curve.Utils.tangentCubicBezier( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y );\r\n\r\n\tvar tangent = new THREE.Vector2( tx, ty );\r\n\ttangent.normalize();\r\n\r\n\treturn tangent;\r\n\r\n};\r\n\r\n// File:src/extras/curves/SplineCurve.js\r\n\r\n/**************************************************************\r\n *\tSpline curve\r\n **************************************************************/\r\n\r\nTHREE.SplineCurve = function ( points /* array of Vector2 */ ) {\r\n\r\n\tthis.points = ( points == undefined ) ? [] : points;\r\n\r\n};\r\n\r\nTHREE.SplineCurve.prototype = Object.create( THREE.Curve.prototype );\r\nTHREE.SplineCurve.prototype.constructor = THREE.SplineCurve;\r\n\r\nTHREE.SplineCurve.prototype.getPoint = function ( t ) {\r\n\r\n\tvar points = this.points;\r\n\tvar point = ( points.length - 1 ) * t;\r\n\r\n\tvar intPoint = Math.floor( point );\r\n\tvar weight = point - intPoint;\r\n\r\n\tvar point0 = points[ intPoint == 0 ? intPoint : intPoint - 1 ]\r\n\tvar point1 = points[ intPoint ]\r\n\tvar point2 = points[ intPoint > points.length - 2 ? points.length - 1 : intPoint + 1 ]\r\n\tvar point3 = points[ intPoint > points.length - 3 ? points.length - 1 : intPoint + 2 ]\r\n\r\n\tvar vector = new THREE.Vector2();\r\n\r\n\tvector.x = THREE.Curve.Utils.interpolate( point0.x, point1.x, point2.x, point3.x, weight );\r\n\tvector.y = THREE.Curve.Utils.interpolate( point0.y, point1.y, point2.y, point3.y, weight );\r\n\r\n\treturn vector;\r\n\r\n};\r\n\r\n// File:src/extras/curves/EllipseCurve.js\r\n\r\n/**************************************************************\r\n *\tEllipse curve\r\n **************************************************************/\r\n\r\nTHREE.EllipseCurve = function ( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise ) {\r\n\r\n\tthis.aX = aX;\r\n\tthis.aY = aY;\r\n\r\n\tthis.xRadius = xRadius;\r\n\tthis.yRadius = yRadius;\r\n\r\n\tthis.aStartAngle = aStartAngle;\r\n\tthis.aEndAngle = aEndAngle;\r\n\r\n\tthis.aClockwise = aClockwise;\r\n\r\n};\r\n\r\nTHREE.EllipseCurve.prototype = Object.create( THREE.Curve.prototype );\r\nTHREE.EllipseCurve.prototype.constructor = THREE.EllipseCurve;\r\n\r\nTHREE.EllipseCurve.prototype.getPoint = function ( t ) {\r\n\r\n\tvar deltaAngle = this.aEndAngle - this.aStartAngle;\r\n\r\n\tif ( deltaAngle < 0 ) deltaAngle += Math.PI * 2;\r\n\tif ( deltaAngle > Math.PI * 2 ) deltaAngle -= Math.PI * 2;\r\n\r\n\tvar angle;\r\n\r\n\tif ( this.aClockwise === true ) {\r\n\r\n\t\tangle = this.aEndAngle + ( 1 - t ) * ( Math.PI * 2 - deltaAngle );\r\n\r\n\t} else {\r\n\r\n\t\tangle = this.aStartAngle + t * deltaAngle;\r\n\r\n\t}\r\n\t\r\n\tvar vector = new THREE.Vector2();\r\n\r\n\tvector.x = this.aX + this.xRadius * Math.cos( angle );\r\n\tvector.y = this.aY + this.yRadius * Math.sin( angle );\r\n\r\n\treturn vector;\r\n\r\n};\r\n\r\n// File:src/extras/curves/ArcCurve.js\r\n\r\n/**************************************************************\r\n *\tArc curve\r\n **************************************************************/\r\n\r\nTHREE.ArcCurve = function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {\r\n\r\n\tTHREE.EllipseCurve.call( this, aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );\r\n};\r\n\r\nTHREE.ArcCurve.prototype = Object.create( THREE.EllipseCurve.prototype );\r\nTHREE.ArcCurve.prototype.constructor = THREE.ArcCurve;\r\n\r\n// File:src/extras/curves/LineCurve3.js\r\n\r\n/**************************************************************\r\n *\tLine3D\r\n **************************************************************/\r\n\r\nTHREE.LineCurve3 = THREE.Curve.create(\r\n\r\n\tfunction ( v1, v2 ) {\r\n\r\n\t\tthis.v1 = v1;\r\n\t\tthis.v2 = v2;\r\n\r\n\t},\r\n\r\n\tfunction ( t ) {\r\n\r\n\t\tvar vector = new THREE.Vector3();\r\n\r\n\t\tvector.subVectors( this.v2, this.v1 ); // diff\r\n\t\tvector.multiplyScalar( t );\r\n\t\tvector.add( this.v1 );\r\n\r\n\t\treturn vector;\r\n\r\n\t}\r\n\r\n);\r\n\r\n// File:src/extras/curves/QuadraticBezierCurve3.js\r\n\r\n/**************************************************************\r\n *\tQuadratic Bezier 3D curve\r\n **************************************************************/\r\n\r\nTHREE.QuadraticBezierCurve3 = THREE.Curve.create(\r\n\r\n\tfunction ( v0, v1, v2 ) {\r\n\r\n\t\tthis.v0 = v0;\r\n\t\tthis.v1 = v1;\r\n\t\tthis.v2 = v2;\r\n\r\n\t},\r\n\r\n\tfunction ( t ) {\r\n\r\n\t\tvar vector = new THREE.Vector3();\r\n\r\n\t\tvector.x = THREE.Shape.Utils.b2( t, this.v0.x, this.v1.x, this.v2.x );\r\n\t\tvector.y = THREE.Shape.Utils.b2( t, this.v0.y, this.v1.y, this.v2.y );\r\n\t\tvector.z = THREE.Shape.Utils.b2( t, this.v0.z, this.v1.z, this.v2.z );\r\n\r\n\t\treturn vector;\r\n\r\n\t}\r\n\r\n);\r\n\r\n// File:src/extras/curves/CubicBezierCurve3.js\r\n\r\n/**************************************************************\r\n *\tCubic Bezier 3D curve\r\n **************************************************************/\r\n\r\nTHREE.CubicBezierCurve3 = THREE.Curve.create(\r\n\r\n\tfunction ( v0, v1, v2, v3 ) {\r\n\r\n\t\tthis.v0 = v0;\r\n\t\tthis.v1 = v1;\r\n\t\tthis.v2 = v2;\r\n\t\tthis.v3 = v3;\r\n\r\n\t},\r\n\r\n\tfunction ( t ) {\r\n\r\n\t\tvar vector = new THREE.Vector3();\r\n\r\n\t\tvector.x = THREE.Shape.Utils.b3( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x );\r\n\t\tvector.y = THREE.Shape.Utils.b3( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y );\r\n\t\tvector.z = THREE.Shape.Utils.b3( t, this.v0.z, this.v1.z, this.v2.z, this.v3.z );\r\n\r\n\t\treturn vector;\r\n\r\n\t}\r\n\r\n);\r\n\r\n// File:src/extras/curves/SplineCurve3.js\r\n\r\n/**************************************************************\r\n *\tSpline 3D curve\r\n **************************************************************/\r\n\r\n\r\nTHREE.SplineCurve3 = THREE.Curve.create(\r\n\r\n\tfunction ( points /* array of Vector3 */) {\r\n\r\n\t\tthis.points = ( points == undefined ) ? [] : points;\r\n\r\n\t},\r\n\r\n\tfunction ( t ) {\r\n\r\n\t\tvar points = this.points;\r\n\t\tvar point = ( points.length - 1 ) * t;\r\n\r\n\t\tvar intPoint = Math.floor( point );\r\n\t\tvar weight = point - intPoint;\r\n\r\n\t\tvar point0 = points[ intPoint == 0 ? intPoint : intPoint - 1 ];\r\n\t\tvar point1 = points[ intPoint ];\r\n\t\tvar point2 = points[ intPoint > points.length - 2 ? points.length - 1 : intPoint + 1 ];\r\n\t\tvar point3 = points[ intPoint > points.length - 3 ? points.length - 1 : intPoint + 2 ];\r\n\r\n\t\tvar vector = new THREE.Vector3();\r\n\r\n\t\tvector.x = THREE.Curve.Utils.interpolate( point0.x, point1.x, point2.x, point3.x, weight );\r\n\t\tvector.y = THREE.Curve.Utils.interpolate( point0.y, point1.y, point2.y, point3.y, weight );\r\n\t\tvector.z = THREE.Curve.Utils.interpolate( point0.z, point1.z, point2.z, point3.z, weight );\r\n\r\n\t\treturn vector;\r\n\r\n\t}\r\n\r\n);\r\n\r\n// File:src/extras/curves/ClosedSplineCurve3.js\r\n\r\n/**************************************************************\r\n *\tClosed Spline 3D curve\r\n **************************************************************/\r\n\r\n\r\nTHREE.ClosedSplineCurve3 = THREE.Curve.create(\r\n\r\n\tfunction ( points /* array of Vector3 */) {\r\n\r\n\t\tthis.points = ( points == undefined ) ? [] : points;\r\n\r\n\t},\r\n\r\n\tfunction ( t ) {\r\n\r\n\t\tvar points = this.points;\r\n\t\tvar point = ( points.length - 0 ) * t; // This needs to be from 0-length +1\r\n\r\n\t\tvar intPoint = Math.floor( point );\r\n\t\tvar weight = point - intPoint;\r\n\r\n\t\tintPoint += intPoint > 0 ? 0 : ( Math.floor( Math.abs( intPoint ) / points.length ) + 1 ) * points.length;\r\n\r\n\t\tvar point0 = points[ ( intPoint - 1 ) % points.length ];\r\n\t\tvar point1 = points[ ( intPoint     ) % points.length ];\r\n\t\tvar point2 = points[ ( intPoint + 1 ) % points.length ];\r\n\t\tvar point3 = points[ ( intPoint + 2 ) % points.length ];\r\n\r\n\t\tvar vector = new THREE.Vector3();\r\n\r\n\t\tvector.x = THREE.Curve.Utils.interpolate( point0.x, point1.x, point2.x, point3.x, weight );\r\n\t\tvector.y = THREE.Curve.Utils.interpolate( point0.y, point1.y, point2.y, point3.y, weight );\r\n\t\tvector.z = THREE.Curve.Utils.interpolate( point0.z, point1.z, point2.z, point3.z, weight );\r\n\r\n\t\treturn vector;\r\n\r\n\t}\r\n\r\n);\r\n\r\n// File:src/extras/animation/AnimationHandler.js\r\n\r\n/**\r\n * @author mikael emtinger / http://gomo.se/\r\n */\r\n\r\nTHREE.AnimationHandler = {\r\n\r\n\tLINEAR: 0,\r\n\tCATMULLROM: 1,\r\n\tCATMULLROM_FORWARD: 2,\r\n\r\n\t//\r\n\r\n\tadd: function () { THREE.warn( 'THREE.AnimationHandler.add() has been deprecated.' ); },\r\n\tget: function () { THREE.warn( 'THREE.AnimationHandler.get() has been deprecated.' ); },\r\n\tremove: function () { THREE.warn( 'THREE.AnimationHandler.remove() has been deprecated.' ); },\r\n\r\n\t//\r\n\r\n\tanimations: [],\r\n\r\n\tinit: function ( data ) {\r\n\r\n\t\tif ( data.initialized === true ) return data;\r\n\r\n\t\t// loop through all keys\r\n\r\n\t\tfor ( var h = 0; h < data.hierarchy.length; h ++ ) {\r\n\r\n\t\t\tfor ( var k = 0; k < data.hierarchy[ h ].keys.length; k ++ ) {\r\n\r\n\t\t\t\t// remove minus times\r\n\r\n\t\t\t\tif ( data.hierarchy[ h ].keys[ k ].time < 0 ) {\r\n\r\n\t\t\t\t\t data.hierarchy[ h ].keys[ k ].time = 0;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// create quaternions\r\n\r\n\t\t\t\tif ( data.hierarchy[ h ].keys[ k ].rot !== undefined &&\r\n\t\t\t\t  ! ( data.hierarchy[ h ].keys[ k ].rot instanceof THREE.Quaternion ) ) {\r\n\r\n\t\t\t\t\tvar quat = data.hierarchy[ h ].keys[ k ].rot;\r\n\t\t\t\t\tdata.hierarchy[ h ].keys[ k ].rot = new THREE.Quaternion().fromArray( quat );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// prepare morph target keys\r\n\r\n\t\t\tif ( data.hierarchy[ h ].keys.length && data.hierarchy[ h ].keys[ 0 ].morphTargets !== undefined ) {\r\n\r\n\t\t\t\t// get all used\r\n\r\n\t\t\t\tvar usedMorphTargets = {};\r\n\r\n\t\t\t\tfor ( var k = 0; k < data.hierarchy[ h ].keys.length; k ++ ) {\r\n\r\n\t\t\t\t\tfor ( var m = 0; m < data.hierarchy[ h ].keys[ k ].morphTargets.length; m ++ ) {\r\n\r\n\t\t\t\t\t\tvar morphTargetName = data.hierarchy[ h ].keys[ k ].morphTargets[ m ];\r\n\t\t\t\t\t\tusedMorphTargets[ morphTargetName ] = - 1;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tdata.hierarchy[ h ].usedMorphTargets = usedMorphTargets;\r\n\r\n\r\n\t\t\t\t// set all used on all frames\r\n\r\n\t\t\t\tfor ( var k = 0; k < data.hierarchy[ h ].keys.length; k ++ ) {\r\n\r\n\t\t\t\t\tvar influences = {};\r\n\r\n\t\t\t\t\tfor ( var morphTargetName in usedMorphTargets ) {\r\n\r\n\t\t\t\t\t\tfor ( var m = 0; m < data.hierarchy[ h ].keys[ k ].morphTargets.length; m ++ ) {\r\n\r\n\t\t\t\t\t\t\tif ( data.hierarchy[ h ].keys[ k ].morphTargets[ m ] === morphTargetName ) {\r\n\r\n\t\t\t\t\t\t\t\tinfluences[ morphTargetName ] = data.hierarchy[ h ].keys[ k ].morphTargetsInfluences[ m ];\r\n\t\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tif ( m === data.hierarchy[ h ].keys[ k ].morphTargets.length ) {\r\n\r\n\t\t\t\t\t\t\tinfluences[ morphTargetName ] = 0;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tdata.hierarchy[ h ].keys[ k ].morphTargetsInfluences = influences;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\r\n\t\t\t// remove all keys that are on the same time\r\n\r\n\t\t\tfor ( var k = 1; k < data.hierarchy[ h ].keys.length; k ++ ) {\r\n\r\n\t\t\t\tif ( data.hierarchy[ h ].keys[ k ].time === data.hierarchy[ h ].keys[ k - 1 ].time ) {\r\n\r\n\t\t\t\t\tdata.hierarchy[ h ].keys.splice( k, 1 );\r\n\t\t\t\t\tk --;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\r\n\t\t\t// set index\r\n\r\n\t\t\tfor ( var k = 0; k < data.hierarchy[ h ].keys.length; k ++ ) {\r\n\r\n\t\t\t\tdata.hierarchy[ h ].keys[ k ].index = k;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tdata.initialized = true;\r\n\r\n\t\treturn data;\r\n\r\n\t},\r\n\r\n\tparse: function ( root ) {\r\n\r\n\t\tvar parseRecurseHierarchy = function ( root, hierarchy ) {\r\n\r\n\t\t\thierarchy.push( root );\r\n\r\n\t\t\tfor ( var c = 0; c < root.children.length; c ++ )\r\n\t\t\t\tparseRecurseHierarchy( root.children[ c ], hierarchy );\r\n\r\n\t\t};\r\n\r\n\t\t// setup hierarchy\r\n\r\n\t\tvar hierarchy = [];\r\n\r\n\t\tif ( root instanceof THREE.SkinnedMesh ) {\r\n\r\n\t\t\tfor ( var b = 0; b < root.skeleton.bones.length; b ++ ) {\r\n\r\n\t\t\t\thierarchy.push( root.skeleton.bones[ b ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\tparseRecurseHierarchy( root, hierarchy );\r\n\r\n\t\t}\r\n\r\n\t\treturn hierarchy;\r\n\r\n\t},\r\n\r\n\tplay: function ( animation ) {\r\n\r\n\t\tif ( this.animations.indexOf( animation ) === - 1 ) {\r\n\r\n\t\t\tthis.animations.push( animation );\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tstop: function ( animation ) {\r\n\r\n\t\tvar index = this.animations.indexOf( animation );\r\n\r\n\t\tif ( index !== - 1 ) {\r\n\r\n\t\t\tthis.animations.splice( index, 1 );\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tupdate: function ( deltaTimeMS ) {\r\n\r\n\t\tfor ( var i = 0; i < this.animations.length; i ++ ) {\r\n\r\n\t\t\tthis.animations[ i ].resetBlendWeights( );\r\n\r\n\t\t}\r\n\r\n\t\tfor ( var i = 0; i < this.animations.length; i ++ ) {\r\n\r\n\t\t\tthis.animations[ i ].update( deltaTimeMS );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/extras/animation/Animation.js\r\n\r\n/**\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.Animation = function ( root, data ) {\r\n\r\n\tthis.root = root;\r\n\tthis.data = THREE.AnimationHandler.init( data );\r\n\tthis.hierarchy = THREE.AnimationHandler.parse( root );\r\n\r\n\tthis.currentTime = 0;\r\n\tthis.timeScale = 1;\r\n\r\n\tthis.isPlaying = false;\r\n\tthis.loop = true;\r\n\tthis.weight = 0;\r\n\r\n\tthis.interpolationType = THREE.AnimationHandler.LINEAR;\r\n\r\n};\r\n\r\nTHREE.Animation.prototype = {\r\n\r\n\tconstructor: THREE.Animation,\r\n\r\n\tkeyTypes:  [ \"pos\", \"rot\", \"scl\" ],\r\n\r\n\tplay: function ( startTime, weight ) {\r\n\r\n\t\tthis.currentTime = startTime !== undefined ? startTime : 0;\r\n\t\tthis.weight = weight !== undefined ? weight : 1;\r\n\r\n\t\tthis.isPlaying = true;\r\n\r\n\t\tthis.reset();\r\n\r\n\t\tTHREE.AnimationHandler.play( this );\r\n\r\n\t},\r\n\r\n\tstop: function() {\r\n\r\n\t\tthis.isPlaying = false;\r\n\r\n\t\tTHREE.AnimationHandler.stop( this );\r\n\r\n\t},\r\n\r\n\treset: function () {\r\n\r\n\t\tfor ( var h = 0, hl = this.hierarchy.length; h < hl; h ++ ) {\r\n\r\n\t\t\tvar object = this.hierarchy[ h ];\r\n\r\n\t\t\tif ( object.animationCache === undefined ) {\r\n\r\n\t\t\t\tobject.animationCache = {\r\n\t\t\t\t\tanimations: {},\r\n\t\t\t\t\tblending: {\r\n\t\t\t\t\t\tpositionWeight: 0.0,\r\n\t\t\t\t\t\tquaternionWeight: 0.0,\r\n\t\t\t\t\t\tscaleWeight: 0.0\r\n\t\t\t\t\t}\r\n\t\t\t\t};\r\n\t\t\t}\r\n\r\n\t\t\tvar name = this.data.name;\r\n\t\t\tvar animations = object.animationCache.animations;\r\n\t\t\tvar animationCache = animations[ name ];\r\n\r\n\t\t\tif ( animationCache === undefined ) {\r\n\r\n\t\t\t\tanimationCache = {\r\n\t\t\t\t\tprevKey: { pos: 0, rot: 0, scl: 0 },\r\n\t\t\t\t\tnextKey: { pos: 0, rot: 0, scl: 0 },\r\n\t\t\t\t\toriginalMatrix: object.matrix\r\n\t\t\t\t};\r\n\r\n\t\t\t\tanimations[ name ] = animationCache;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// Get keys to match our current time\r\n\r\n\t\t\tfor ( var t = 0; t < 3; t ++ ) {\r\n\r\n\t\t\t\tvar type = this.keyTypes[ t ];\r\n\r\n\t\t\t\tvar prevKey = this.data.hierarchy[ h ].keys[ 0 ];\r\n\t\t\t\tvar nextKey = this.getNextKeyWith( type, h, 1 );\r\n\r\n\t\t\t\twhile ( nextKey.time < this.currentTime && nextKey.index > prevKey.index ) {\r\n\r\n\t\t\t\t\tprevKey = nextKey;\r\n\t\t\t\t\tnextKey = this.getNextKeyWith( type, h, nextKey.index + 1 );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tanimationCache.prevKey[ type ] = prevKey;\r\n\t\t\t\tanimationCache.nextKey[ type ] = nextKey;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tresetBlendWeights: function () {\r\n\r\n\t\tfor ( var h = 0, hl = this.hierarchy.length; h < hl; h ++ ) {\r\n\r\n\t\t\tvar object = this.hierarchy[ h ];\r\n\t\t\tvar animationCache = object.animationCache;\r\n\r\n\t\t\tif ( animationCache !== undefined ) {\r\n\r\n\t\t\t\tvar blending = animationCache.blending;\r\n\r\n\t\t\t\tblending.positionWeight = 0.0;\r\n\t\t\t\tblending.quaternionWeight = 0.0;\r\n\t\t\t\tblending.scaleWeight = 0.0;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tupdate: ( function() {\r\n\r\n\t\tvar points = [];\r\n\t\tvar target = new THREE.Vector3();\r\n\t\tvar newVector = new THREE.Vector3();\r\n\t\tvar newQuat = new THREE.Quaternion();\r\n\r\n\t\t// Catmull-Rom spline\r\n\r\n\t\tvar interpolateCatmullRom = function ( points, scale ) {\r\n\r\n\t\t\tvar c = [], v3 = [],\r\n\t\t\tpoint, intPoint, weight, w2, w3,\r\n\t\t\tpa, pb, pc, pd;\r\n\r\n\t\t\tpoint = ( points.length - 1 ) * scale;\r\n\t\t\tintPoint = Math.floor( point );\r\n\t\t\tweight = point - intPoint;\r\n\r\n\t\t\tc[ 0 ] = intPoint === 0 ? intPoint : intPoint - 1;\r\n\t\t\tc[ 1 ] = intPoint;\r\n\t\t\tc[ 2 ] = intPoint > points.length - 2 ? intPoint : intPoint + 1;\r\n\t\t\tc[ 3 ] = intPoint > points.length - 3 ? intPoint : intPoint + 2;\r\n\r\n\t\t\tpa = points[ c[ 0 ] ];\r\n\t\t\tpb = points[ c[ 1 ] ];\r\n\t\t\tpc = points[ c[ 2 ] ];\r\n\t\t\tpd = points[ c[ 3 ] ];\r\n\r\n\t\t\tw2 = weight * weight;\r\n\t\t\tw3 = weight * w2;\r\n\r\n\t\t\tv3[ 0 ] = interpolate( pa[ 0 ], pb[ 0 ], pc[ 0 ], pd[ 0 ], weight, w2, w3 );\r\n\t\t\tv3[ 1 ] = interpolate( pa[ 1 ], pb[ 1 ], pc[ 1 ], pd[ 1 ], weight, w2, w3 );\r\n\t\t\tv3[ 2 ] = interpolate( pa[ 2 ], pb[ 2 ], pc[ 2 ], pd[ 2 ], weight, w2, w3 );\r\n\r\n\t\t\treturn v3;\r\n\r\n\t\t};\r\n\r\n\t\tvar interpolate = function ( p0, p1, p2, p3, t, t2, t3 ) {\r\n\r\n\t\t\tvar v0 = ( p2 - p0 ) * 0.5,\r\n\t\t\t\tv1 = ( p3 - p1 ) * 0.5;\r\n\r\n\t\t\treturn ( 2 * ( p1 - p2 ) + v0 + v1 ) * t3 + ( - 3 * ( p1 - p2 ) - 2 * v0 - v1 ) * t2 + v0 * t + p1;\r\n\r\n\t\t};\r\n\r\n\t\treturn function ( delta ) {\r\n\r\n\t\t\tif ( this.isPlaying === false ) return;\r\n\r\n\t\t\tthis.currentTime += delta * this.timeScale;\r\n\r\n\t\t\tif ( this.weight === 0 )\r\n\t\t\t\treturn;\r\n\r\n\t\t\t//\r\n\r\n\t\t\tvar duration = this.data.length;\r\n\r\n\t\t\tif ( this.currentTime > duration || this.currentTime < 0 ) {\r\n\r\n\t\t\t\tif ( this.loop ) {\r\n\r\n\t\t\t\t\tthis.currentTime %= duration;\r\n\r\n\t\t\t\t\tif ( this.currentTime < 0 )\r\n\t\t\t\t\t\tthis.currentTime += duration;\r\n\r\n\t\t\t\t\tthis.reset();\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tthis.stop();\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfor ( var h = 0, hl = this.hierarchy.length; h < hl; h ++ ) {\r\n\r\n\t\t\t\tvar object = this.hierarchy[ h ];\r\n\t\t\t\tvar animationCache = object.animationCache.animations[this.data.name];\r\n\t\t\t\tvar blending = object.animationCache.blending;\r\n\r\n\t\t\t\t// loop through pos/rot/scl\r\n\r\n\t\t\t\tfor ( var t = 0; t < 3; t ++ ) {\r\n\r\n\t\t\t\t\t// get keys\r\n\r\n\t\t\t\t\tvar type    = this.keyTypes[ t ];\r\n\t\t\t\t\tvar prevKey = animationCache.prevKey[ type ];\r\n\t\t\t\t\tvar nextKey = animationCache.nextKey[ type ];\r\n\r\n\t\t\t\t\tif ( ( this.timeScale > 0 && nextKey.time <= this.currentTime ) ||\r\n\t\t\t\t\t\t( this.timeScale < 0 && prevKey.time >= this.currentTime ) ) {\r\n\r\n\t\t\t\t\t\tprevKey = this.data.hierarchy[ h ].keys[ 0 ];\r\n\t\t\t\t\t\tnextKey = this.getNextKeyWith( type, h, 1 );\r\n\r\n\t\t\t\t\t\twhile ( nextKey.time < this.currentTime && nextKey.index > prevKey.index ) {\r\n\r\n\t\t\t\t\t\t\tprevKey = nextKey;\r\n\t\t\t\t\t\t\tnextKey = this.getNextKeyWith( type, h, nextKey.index + 1 );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tanimationCache.prevKey[ type ] = prevKey;\r\n\t\t\t\t\t\tanimationCache.nextKey[ type ] = nextKey;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tvar scale = ( this.currentTime - prevKey.time ) / ( nextKey.time - prevKey.time );\r\n\r\n\t\t\t\t\tvar prevXYZ = prevKey[ type ];\r\n\t\t\t\t\tvar nextXYZ = nextKey[ type ];\r\n\r\n\t\t\t\t\tif ( scale < 0 ) scale = 0;\r\n\t\t\t\t\tif ( scale > 1 ) scale = 1;\r\n\r\n\t\t\t\t\t// interpolate\r\n\r\n\t\t\t\t\tif ( type === \"pos\" ) {\r\n\r\n\t\t\t\t\t\tif ( this.interpolationType === THREE.AnimationHandler.LINEAR ) {\r\n\r\n\t\t\t\t\t\t\tnewVector.x = prevXYZ[ 0 ] + ( nextXYZ[ 0 ] - prevXYZ[ 0 ] ) * scale;\r\n\t\t\t\t\t\t\tnewVector.y = prevXYZ[ 1 ] + ( nextXYZ[ 1 ] - prevXYZ[ 1 ] ) * scale;\r\n\t\t\t\t\t\t\tnewVector.z = prevXYZ[ 2 ] + ( nextXYZ[ 2 ] - prevXYZ[ 2 ] ) * scale;\r\n\r\n\t\t\t\t\t\t\t// blend\r\n\t\t\t\t\t\t\tvar proportionalWeight = this.weight / ( this.weight + blending.positionWeight );\r\n\t\t\t\t\t\t\tobject.position.lerp( newVector, proportionalWeight );\r\n\t\t\t\t\t\t\tblending.positionWeight += this.weight;\r\n\r\n\t\t\t\t\t\t} else if ( this.interpolationType === THREE.AnimationHandler.CATMULLROM ||\r\n\t\t\t\t\t\t\t\t\tthis.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD ) {\r\n\r\n\t\t\t\t\t\t\tpoints[ 0 ] = this.getPrevKeyWith( \"pos\", h, prevKey.index - 1 )[ \"pos\" ];\r\n\t\t\t\t\t\t\tpoints[ 1 ] = prevXYZ;\r\n\t\t\t\t\t\t\tpoints[ 2 ] = nextXYZ;\r\n\t\t\t\t\t\t\tpoints[ 3 ] = this.getNextKeyWith( \"pos\", h, nextKey.index + 1 )[ \"pos\" ];\r\n\r\n\t\t\t\t\t\t\tscale = scale * 0.33 + 0.33;\r\n\r\n\t\t\t\t\t\t\tvar currentPoint = interpolateCatmullRom( points, scale );\r\n\t\t\t\t\t\t\tvar proportionalWeight = this.weight / ( this.weight + blending.positionWeight );\r\n\t\t\t\t\t\t\tblending.positionWeight += this.weight;\r\n\r\n\t\t\t\t\t\t\t// blend\r\n\r\n\t\t\t\t\t\t\tvar vector = object.position;\r\n\r\n\t\t\t\t\t\t\tvector.x = vector.x + ( currentPoint[ 0 ] - vector.x ) * proportionalWeight;\r\n\t\t\t\t\t\t\tvector.y = vector.y + ( currentPoint[ 1 ] - vector.y ) * proportionalWeight;\r\n\t\t\t\t\t\t\tvector.z = vector.z + ( currentPoint[ 2 ] - vector.z ) * proportionalWeight;\r\n\r\n\t\t\t\t\t\t\tif ( this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD ) {\r\n\r\n\t\t\t\t\t\t\t\tvar forwardPoint = interpolateCatmullRom( points, scale * 1.01 );\r\n\r\n\t\t\t\t\t\t\t\ttarget.set( forwardPoint[ 0 ], forwardPoint[ 1 ], forwardPoint[ 2 ] );\r\n\t\t\t\t\t\t\t\ttarget.sub( vector );\r\n\t\t\t\t\t\t\t\ttarget.y = 0;\r\n\t\t\t\t\t\t\t\ttarget.normalize();\r\n\r\n\t\t\t\t\t\t\t\tvar angle = Math.atan2( target.x, target.z );\r\n\t\t\t\t\t\t\t\tobject.rotation.set( 0, angle, 0 );\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t} else if ( type === \"rot\" ) {\r\n\r\n\t\t\t\t\t\tTHREE.Quaternion.slerp( prevXYZ, nextXYZ, newQuat, scale );\r\n\r\n\t\t\t\t\t\t// Avoid paying the cost of an additional slerp if we don't have to\r\n\t\t\t\t\t\tif ( blending.quaternionWeight === 0 ) {\r\n\r\n\t\t\t\t\t\t\tobject.quaternion.copy(newQuat);\r\n\t\t\t\t\t\t\tblending.quaternionWeight = this.weight;\r\n\r\n\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\tvar proportionalWeight = this.weight / ( this.weight + blending.quaternionWeight );\r\n\t\t\t\t\t\t\tTHREE.Quaternion.slerp( object.quaternion, newQuat, object.quaternion, proportionalWeight );\r\n\t\t\t\t\t\t\tblending.quaternionWeight += this.weight;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t} else if ( type === \"scl\" ) {\r\n\r\n\t\t\t\t\t\tnewVector.x = prevXYZ[ 0 ] + ( nextXYZ[ 0 ] - prevXYZ[ 0 ] ) * scale;\r\n\t\t\t\t\t\tnewVector.y = prevXYZ[ 1 ] + ( nextXYZ[ 1 ] - prevXYZ[ 1 ] ) * scale;\r\n\t\t\t\t\t\tnewVector.z = prevXYZ[ 2 ] + ( nextXYZ[ 2 ] - prevXYZ[ 2 ] ) * scale;\r\n\r\n\t\t\t\t\t\tvar proportionalWeight = this.weight / ( this.weight + blending.scaleWeight );\r\n\t\t\t\t\t\tobject.scale.lerp( newVector, proportionalWeight );\r\n\t\t\t\t\t\tblending.scaleWeight += this.weight;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn true;\r\n\r\n\t\t};\r\n\r\n\t} )(),\r\n\r\n\tgetNextKeyWith: function ( type, h, key ) {\r\n\r\n\t\tvar keys = this.data.hierarchy[ h ].keys;\r\n\r\n\t\tif ( this.interpolationType === THREE.AnimationHandler.CATMULLROM ||\r\n\t\t\t this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD ) {\r\n\r\n\t\t\tkey = key < keys.length - 1 ? key : keys.length - 1;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tkey = key % keys.length;\r\n\r\n\t\t}\r\n\r\n\t\tfor ( ; key < keys.length; key ++ ) {\r\n\r\n\t\t\tif ( keys[ key ][ type ] !== undefined ) {\r\n\r\n\t\t\t\treturn keys[ key ];\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn this.data.hierarchy[ h ].keys[ 0 ];\r\n\r\n\t},\r\n\r\n\tgetPrevKeyWith: function ( type, h, key ) {\r\n\r\n\t\tvar keys = this.data.hierarchy[ h ].keys;\r\n\r\n\t\tif ( this.interpolationType === THREE.AnimationHandler.CATMULLROM ||\r\n\t\t\tthis.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD ) {\r\n\r\n\t\t\tkey = key > 0 ? key : 0;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tkey = key >= 0 ? key : key + keys.length;\r\n\r\n\t\t}\r\n\r\n\r\n\t\tfor ( ; key >= 0; key -- ) {\r\n\r\n\t\t\tif ( keys[ key ][ type ] !== undefined ) {\r\n\r\n\t\t\t\treturn keys[ key ];\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn this.data.hierarchy[ h ].keys[ keys.length - 1 ];\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/extras/animation/KeyFrameAnimation.js\r\n\r\n/**\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author khang duong\r\n * @author erik kitson\r\n */\r\n\r\nTHREE.KeyFrameAnimation = function ( data ) {\r\n\r\n\tthis.root = data.node;\r\n\tthis.data = THREE.AnimationHandler.init( data );\r\n\tthis.hierarchy = THREE.AnimationHandler.parse( this.root );\r\n\tthis.currentTime = 0;\r\n\tthis.timeScale = 0.001;\r\n\tthis.isPlaying = false;\r\n\tthis.isPaused = true;\r\n\tthis.loop = true;\r\n\r\n\t// initialize to first keyframes\r\n\r\n\tfor ( var h = 0, hl = this.hierarchy.length; h < hl; h ++ ) {\r\n\r\n\t\tvar keys = this.data.hierarchy[h].keys,\r\n\t\t\tsids = this.data.hierarchy[h].sids,\r\n\t\t\tobj = this.hierarchy[h];\r\n\r\n\t\tif ( keys.length && sids ) {\r\n\r\n\t\t\tfor ( var s = 0; s < sids.length; s ++ ) {\r\n\r\n\t\t\t\tvar sid = sids[ s ],\r\n\t\t\t\t\tnext = this.getNextKeyWith( sid, h, 0 );\r\n\r\n\t\t\t\tif ( next ) {\r\n\r\n\t\t\t\t\tnext.apply( sid );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tobj.matrixAutoUpdate = false;\r\n\t\t\tthis.data.hierarchy[h].node.updateMatrix();\r\n\t\t\tobj.matrixWorldNeedsUpdate = true;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.KeyFrameAnimation.prototype = {\r\n\r\n\tconstructor: THREE.KeyFrameAnimation,\r\n\r\n\tplay: function ( startTime ) {\r\n\r\n\t\tthis.currentTime = startTime !== undefined ? startTime : 0;\r\n\r\n\t\tif ( this.isPlaying === false ) {\r\n\r\n\t\t\tthis.isPlaying = true;\r\n\r\n\t\t\t// reset key cache\r\n\r\n\t\t\tvar h, hl = this.hierarchy.length,\r\n\t\t\t\tobject,\r\n\t\t\t\tnode;\r\n\r\n\t\t\tfor ( h = 0; h < hl; h ++ ) {\r\n\r\n\t\t\t\tobject = this.hierarchy[ h ];\r\n\t\t\t\tnode = this.data.hierarchy[ h ];\r\n\r\n\t\t\t\tif ( node.animationCache === undefined ) {\r\n\r\n\t\t\t\t\tnode.animationCache = {};\r\n\t\t\t\t\tnode.animationCache.prevKey = null;\r\n\t\t\t\t\tnode.animationCache.nextKey = null;\r\n\t\t\t\t\tnode.animationCache.originalMatrix = object.matrix;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tvar keys = this.data.hierarchy[h].keys;\r\n\r\n\t\t\t\tif (keys.length) {\r\n\r\n\t\t\t\t\tnode.animationCache.prevKey = keys[ 0 ];\r\n\t\t\t\t\tnode.animationCache.nextKey = keys[ 1 ];\r\n\r\n\t\t\t\t\tthis.startTime = Math.min( keys[0].time, this.startTime );\r\n\t\t\t\t\tthis.endTime = Math.max( keys[keys.length - 1].time, this.endTime );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis.update( 0 );\r\n\r\n\t\t}\r\n\r\n\t\tthis.isPaused = false;\r\n\r\n\t\tTHREE.AnimationHandler.play( this );\r\n\r\n\t},\r\n\r\n\tstop: function () {\r\n\r\n\t\tthis.isPlaying = false;\r\n\t\tthis.isPaused  = false;\r\n\r\n\t\tTHREE.AnimationHandler.stop( this );\r\n\r\n\t\t// reset JIT matrix and remove cache\r\n\r\n\t\tfor ( var h = 0; h < this.data.hierarchy.length; h ++ ) {\r\n\r\n\t\t\tvar obj = this.hierarchy[ h ];\r\n\t\t\tvar node = this.data.hierarchy[ h ];\r\n\r\n\t\t\tif ( node.animationCache !== undefined ) {\r\n\r\n\t\t\t\tvar original = node.animationCache.originalMatrix;\r\n\r\n\t\t\t\toriginal.copy( obj.matrix );\r\n\t\t\t\tobj.matrix = original;\r\n\r\n\t\t\t\tdelete node.animationCache;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tupdate: function ( delta ) {\r\n\r\n\t\tif ( this.isPlaying === false ) return;\r\n\r\n\t\tthis.currentTime += delta * this.timeScale;\r\n\r\n\t\t//\r\n\r\n\t\tvar duration = this.data.length;\r\n\r\n\t\tif ( this.loop === true && this.currentTime > duration ) {\r\n\r\n\t\t\tthis.currentTime %= duration;\r\n\r\n\t\t}\r\n\r\n\t\tthis.currentTime = Math.min( this.currentTime, duration );\r\n\r\n\t\tfor ( var h = 0, hl = this.hierarchy.length; h < hl; h ++ ) {\r\n\r\n\t\t\tvar object = this.hierarchy[ h ];\r\n\t\t\tvar node = this.data.hierarchy[ h ];\r\n\r\n\t\t\tvar keys = node.keys,\r\n\t\t\t\tanimationCache = node.animationCache;\r\n\r\n\r\n\t\t\tif ( keys.length ) {\r\n\r\n\t\t\t\tvar prevKey = animationCache.prevKey;\r\n\t\t\t\tvar nextKey = animationCache.nextKey;\r\n\r\n\t\t\t\tif ( nextKey.time <= this.currentTime ) {\r\n\r\n\t\t\t\t\twhile ( nextKey.time < this.currentTime && nextKey.index > prevKey.index ) {\r\n\r\n\t\t\t\t\t\tprevKey = nextKey;\r\n\t\t\t\t\t\tnextKey = keys[ prevKey.index + 1 ];\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tanimationCache.prevKey = prevKey;\r\n\t\t\t\t\tanimationCache.nextKey = nextKey;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( nextKey.time >= this.currentTime ) {\r\n\r\n\t\t\t\t\tprevKey.interpolate( nextKey, this.currentTime );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tprevKey.interpolate( nextKey, nextKey.time );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tthis.data.hierarchy[ h ].node.updateMatrix();\r\n\t\t\t\tobject.matrixWorldNeedsUpdate = true;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tgetNextKeyWith: function ( sid, h, key ) {\r\n\r\n\t\tvar keys = this.data.hierarchy[ h ].keys;\r\n\t\tkey = key % keys.length;\r\n\r\n\t\tfor ( ; key < keys.length; key ++ ) {\r\n\r\n\t\t\tif ( keys[ key ].hasTarget( sid ) ) {\r\n\r\n\t\t\t\treturn keys[ key ];\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn keys[ 0 ];\r\n\r\n\t},\r\n\r\n\tgetPrevKeyWith: function ( sid, h, key ) {\r\n\r\n\t\tvar keys = this.data.hierarchy[ h ].keys;\r\n\t\tkey = key >= 0 ? key : key + keys.length;\r\n\r\n\t\tfor ( ; key >= 0; key -- ) {\r\n\r\n\t\t\tif ( keys[ key ].hasTarget( sid ) ) {\r\n\r\n\t\t\t\treturn keys[ key ];\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn keys[ keys.length - 1 ];\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/extras/animation/MorphAnimation.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com\r\n * @author willy-vvu / http://willy-vvu.github.io\r\n */\r\n\r\nTHREE.MorphAnimation = function ( mesh ) {\r\n\r\n\tthis.mesh = mesh;\r\n\tthis.frames = mesh.morphTargetInfluences.length;\r\n\tthis.currentTime = 0;\r\n\tthis.duration = 1000;\r\n\tthis.loop = true;\r\n\tthis.lastFrame = 0;\r\n\tthis.currentFrame = 0;\r\n\r\n\tthis.isPlaying = false;\r\n\r\n};\r\n\r\nTHREE.MorphAnimation.prototype = {\r\n\r\n\tconstructor: THREE.MorphAnimation,\r\n\r\n\tplay: function () {\r\n\r\n\t\tthis.isPlaying = true;\r\n\r\n\t},\r\n\r\n\tpause: function () {\r\n\r\n\t\tthis.isPlaying = false;\r\n\r\n\t},\r\n\r\n\tupdate: function ( delta ) {\r\n\r\n\t\tif ( this.isPlaying === false ) return;\r\n\r\n\t\tthis.currentTime += delta;\r\n\r\n\t\tif ( this.loop === true && this.currentTime > this.duration ) {\r\n\r\n\t\t\tthis.currentTime %= this.duration;\r\n\r\n\t\t}\r\n\r\n\t\tthis.currentTime = Math.min( this.currentTime, this.duration );\r\n\r\n\t\tvar interpolation = this.duration / this.frames;\r\n\t\tvar frame = Math.floor( this.currentTime / interpolation );\r\n\r\n\t\tvar influences = this.mesh.morphTargetInfluences;\r\n\r\n\t\tif ( frame != this.currentFrame ) {\r\n\r\n\t\t\tinfluences[ this.lastFrame ] = 0;\r\n\t\t\tinfluences[ this.currentFrame ] = 1;\r\n\t\t\tinfluences[ frame ] = 0;\r\n\r\n\t\t\tthis.lastFrame = this.currentFrame;\r\n\t\t\tthis.currentFrame = frame;\r\n\r\n\t\t}\r\n\r\n\t\tinfluences[ frame ] = ( this.currentTime % interpolation ) / interpolation;\r\n\t\tinfluences[ this.lastFrame ] = 1 - influences[ frame ];\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/extras/geometries/BoxGeometry.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Cube.as\r\n */\r\n\r\nTHREE.BoxGeometry = function ( width, height, depth, widthSegments, heightSegments, depthSegments ) {\r\n\r\n\tTHREE.Geometry.call( this );\r\n\r\n\tthis.type = 'BoxGeometry';\r\n\r\n\tthis.parameters = {\r\n\t\twidth: width,\r\n\t\theight: height,\r\n\t\tdepth: depth,\r\n\t\twidthSegments: widthSegments,\r\n\t\theightSegments: heightSegments,\r\n\t\tdepthSegments: depthSegments\r\n\t};\r\n\r\n\tthis.widthSegments = widthSegments || 1;\r\n\tthis.heightSegments = heightSegments || 1;\r\n\tthis.depthSegments = depthSegments || 1;\r\n\r\n\tvar scope = this;\r\n\r\n\tvar width_half = width / 2;\r\n\tvar height_half = height / 2;\r\n\tvar depth_half = depth / 2;\r\n\r\n\tbuildPlane( 'z', 'y', - 1, - 1, depth, height, width_half, 0 ); // px\r\n\tbuildPlane( 'z', 'y',   1, - 1, depth, height, - width_half, 1 ); // nx\r\n\tbuildPlane( 'x', 'z',   1,   1, width, depth, height_half, 2 ); // py\r\n\tbuildPlane( 'x', 'z',   1, - 1, width, depth, - height_half, 3 ); // ny\r\n\tbuildPlane( 'x', 'y',   1, - 1, width, height, depth_half, 4 ); // pz\r\n\tbuildPlane( 'x', 'y', - 1, - 1, width, height, - depth_half, 5 ); // nz\r\n\r\n\tfunction buildPlane( u, v, udir, vdir, width, height, depth, materialIndex ) {\r\n\r\n\t\tvar w, ix, iy,\r\n\t\tgridX = scope.widthSegments,\r\n\t\tgridY = scope.heightSegments,\r\n\t\twidth_half = width / 2,\r\n\t\theight_half = height / 2,\r\n\t\toffset = scope.vertices.length;\r\n\r\n\t\tif ( ( u === 'x' && v === 'y' ) || ( u === 'y' && v === 'x' ) ) {\r\n\r\n\t\t\tw = 'z';\r\n\r\n\t\t} else if ( ( u === 'x' && v === 'z' ) || ( u === 'z' && v === 'x' ) ) {\r\n\r\n\t\t\tw = 'y';\r\n\t\t\tgridY = scope.depthSegments;\r\n\r\n\t\t} else if ( ( u === 'z' && v === 'y' ) || ( u === 'y' && v === 'z' ) ) {\r\n\r\n\t\t\tw = 'x';\r\n\t\t\tgridX = scope.depthSegments;\r\n\r\n\t\t}\r\n\r\n\t\tvar gridX1 = gridX + 1,\r\n\t\tgridY1 = gridY + 1,\r\n\t\tsegment_width = width / gridX,\r\n\t\tsegment_height = height / gridY,\r\n\t\tnormal = new THREE.Vector3();\r\n\r\n\t\tnormal[ w ] = depth > 0 ? 1 : - 1;\r\n\r\n\t\tfor ( iy = 0; iy < gridY1; iy ++ ) {\r\n\r\n\t\t\tfor ( ix = 0; ix < gridX1; ix ++ ) {\r\n\r\n\t\t\t\tvar vector = new THREE.Vector3();\r\n\t\t\t\tvector[ u ] = ( ix * segment_width - width_half ) * udir;\r\n\t\t\t\tvector[ v ] = ( iy * segment_height - height_half ) * vdir;\r\n\t\t\t\tvector[ w ] = depth;\r\n\r\n\t\t\t\tscope.vertices.push( vector );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tfor ( iy = 0; iy < gridY; iy ++ ) {\r\n\r\n\t\t\tfor ( ix = 0; ix < gridX; ix ++ ) {\r\n\r\n\t\t\t\tvar a = ix + gridX1 * iy;\r\n\t\t\t\tvar b = ix + gridX1 * ( iy + 1 );\r\n\t\t\t\tvar c = ( ix + 1 ) + gridX1 * ( iy + 1 );\r\n\t\t\t\tvar d = ( ix + 1 ) + gridX1 * iy;\r\n\r\n\t\t\t\tvar uva = new THREE.Vector2( ix / gridX, 1 - iy / gridY );\r\n\t\t\t\tvar uvb = new THREE.Vector2( ix / gridX, 1 - ( iy + 1 ) / gridY );\r\n\t\t\t\tvar uvc = new THREE.Vector2( ( ix + 1 ) / gridX, 1 - ( iy + 1 ) / gridY );\r\n\t\t\t\tvar uvd = new THREE.Vector2( ( ix + 1 ) / gridX, 1 - iy / gridY );\r\n\r\n\t\t\t\tvar face = new THREE.Face3( a + offset, b + offset, d + offset );\r\n\t\t\t\tface.normal.copy( normal );\r\n\t\t\t\tface.vertexNormals.push( normal.clone(), normal.clone(), normal.clone() );\r\n\t\t\t\tface.materialIndex = materialIndex;\r\n\r\n\t\t\t\tscope.faces.push( face );\r\n\t\t\t\tscope.faceVertexUvs[ 0 ].push( [ uva, uvb, uvd ] );\r\n\r\n\t\t\t\tface = new THREE.Face3( b + offset, c + offset, d + offset );\r\n\t\t\t\tface.normal.copy( normal );\r\n\t\t\t\tface.vertexNormals.push( normal.clone(), normal.clone(), normal.clone() );\r\n\t\t\t\tface.materialIndex = materialIndex;\r\n\r\n\t\t\t\tscope.faces.push( face );\r\n\t\t\t\tscope.faceVertexUvs[ 0 ].push( [ uvb.clone(), uvc, uvd.clone() ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tthis.mergeVertices();\r\n\r\n};\r\n\r\nTHREE.BoxGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\nTHREE.BoxGeometry.prototype.constructor = THREE.BoxGeometry;\r\n\r\n// File:src/extras/geometries/CircleGeometry.js\r\n\r\n/**\r\n * @author hughes\r\n */\r\n\r\nTHREE.CircleGeometry = function ( radius, segments, thetaStart, thetaLength ) {\r\n\r\n\tTHREE.Geometry.call( this );\r\n\r\n\tthis.type = 'CircleGeometry';\r\n\r\n\tthis.parameters = {\r\n\t\tradius: radius,\r\n\t\tsegments: segments,\r\n\t\tthetaStart: thetaStart,\r\n\t\tthetaLength: thetaLength\r\n\t};\r\n\r\n\tradius = radius || 50;\r\n\tsegments = segments !== undefined ? Math.max( 3, segments ) : 8;\r\n\r\n\tthetaStart = thetaStart !== undefined ? thetaStart : 0;\r\n\tthetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;\r\n\r\n\tvar i, uvs = [],\r\n\tcenter = new THREE.Vector3(), centerUV = new THREE.Vector2( 0.5, 0.5 );\r\n\r\n\tthis.vertices.push(center);\r\n\tuvs.push( centerUV );\r\n\r\n\tfor ( i = 0; i <= segments; i ++ ) {\r\n\r\n\t\tvar vertex = new THREE.Vector3();\r\n\t\tvar segment = thetaStart + i / segments * thetaLength;\r\n\r\n\t\tvertex.x = radius * Math.cos( segment );\r\n\t\tvertex.y = radius * Math.sin( segment );\r\n\r\n\t\tthis.vertices.push( vertex );\r\n\t\tuvs.push( new THREE.Vector2( ( vertex.x / radius + 1 ) / 2, ( vertex.y / radius + 1 ) / 2 ) );\r\n\r\n\t}\r\n\r\n\tvar n = new THREE.Vector3( 0, 0, 1 );\r\n\r\n\tfor ( i = 1; i <= segments; i ++ ) {\r\n\r\n\t\tthis.faces.push( new THREE.Face3( i, i + 1, 0, [ n.clone(), n.clone(), n.clone() ] ) );\r\n\t\tthis.faceVertexUvs[ 0 ].push( [ uvs[ i ].clone(), uvs[ i + 1 ].clone(), centerUV.clone() ] );\r\n\r\n\t}\r\n\r\n\tthis.computeFaceNormals();\r\n\r\n\tthis.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );\r\n\r\n};\r\n\r\nTHREE.CircleGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\nTHREE.CircleGeometry.prototype.constructor = THREE.CircleGeometry;\r\n\r\n// File:src/extras/geometries/CubeGeometry.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\n\r\nTHREE.CubeGeometry = function ( width, height, depth, widthSegments, heightSegments, depthSegments ) {\r\n\r\n\tTHREE.warn( 'THREE.CubeGeometry has been renamed to THREE.BoxGeometry.' );\r\n\treturn new THREE.BoxGeometry( width, height, depth, widthSegments, heightSegments, depthSegments );\r\n\r\n };\r\n\r\n// File:src/extras/geometries/CylinderGeometry.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.CylinderGeometry = function ( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {\r\n\r\n\tTHREE.Geometry.call( this );\r\n\r\n\tthis.type = 'CylinderGeometry';\r\n\r\n\tthis.parameters = {\r\n\t\tradiusTop: radiusTop,\r\n\t\tradiusBottom: radiusBottom,\r\n\t\theight: height,\r\n\t\tradialSegments: radialSegments,\r\n\t\theightSegments: heightSegments,\r\n\t\topenEnded: openEnded,\r\n\t\tthetaStart: thetaStart,\r\n\t\tthetaLength: thetaLength\r\n\t};\r\n\r\n\tradiusTop = radiusTop !== undefined ? radiusTop : 20;\r\n\tradiusBottom = radiusBottom !== undefined ? radiusBottom : 20;\r\n\theight = height !== undefined ? height : 100;\r\n\r\n\tradialSegments = radialSegments || 8;\r\n\theightSegments = heightSegments || 1;\r\n\r\n\topenEnded = openEnded !== undefined ? openEnded : false;\r\n\tthetaStart = thetaStart !== undefined ? thetaStart : 0;\r\n\tthetaLength = thetaLength !== undefined ? thetaLength : 2 * Math.PI;\r\n\r\n\tvar heightHalf = height / 2;\r\n\r\n\tvar x, y, vertices = [], uvs = [];\r\n\r\n\tfor ( y = 0; y <= heightSegments; y ++ ) {\r\n\r\n\t\tvar verticesRow = [];\r\n\t\tvar uvsRow = [];\r\n\r\n\t\tvar v = y / heightSegments;\r\n\t\tvar radius = v * ( radiusBottom - radiusTop ) + radiusTop;\r\n\r\n\t\tfor ( x = 0; x <= radialSegments; x ++ ) {\r\n\r\n\t\t\tvar u = x / radialSegments;\r\n\r\n\t\t\tvar vertex = new THREE.Vector3();\r\n\t\t\tvertex.x = radius * Math.sin( u * thetaLength + thetaStart );\r\n\t\t\tvertex.y = - v * height + heightHalf;\r\n\t\t\tvertex.z = radius * Math.cos( u * thetaLength + thetaStart );\r\n\r\n\t\t\tthis.vertices.push( vertex );\r\n\r\n\t\t\tverticesRow.push( this.vertices.length - 1 );\r\n\t\t\tuvsRow.push( new THREE.Vector2( u, 1 - v ) );\r\n\r\n\t\t}\r\n\r\n\t\tvertices.push( verticesRow );\r\n\t\tuvs.push( uvsRow );\r\n\r\n\t}\r\n\r\n\tvar tanTheta = ( radiusBottom - radiusTop ) / height;\r\n\tvar na, nb;\r\n\r\n\tfor ( x = 0; x < radialSegments; x ++ ) {\r\n\r\n\t\tif ( radiusTop !== 0 ) {\r\n\r\n\t\t\tna = this.vertices[ vertices[ 0 ][ x ] ].clone();\r\n\t\t\tnb = this.vertices[ vertices[ 0 ][ x + 1 ] ].clone();\r\n\r\n\t\t} else {\r\n\r\n\t\t\tna = this.vertices[ vertices[ 1 ][ x ] ].clone();\r\n\t\t\tnb = this.vertices[ vertices[ 1 ][ x + 1 ] ].clone();\r\n\r\n\t\t}\r\n\r\n\t\tna.setY( Math.sqrt( na.x * na.x + na.z * na.z ) * tanTheta ).normalize();\r\n\t\tnb.setY( Math.sqrt( nb.x * nb.x + nb.z * nb.z ) * tanTheta ).normalize();\r\n\r\n\t\tfor ( y = 0; y < heightSegments; y ++ ) {\r\n\r\n\t\t\tvar v1 = vertices[ y ][ x ];\r\n\t\t\tvar v2 = vertices[ y + 1 ][ x ];\r\n\t\t\tvar v3 = vertices[ y + 1 ][ x + 1 ];\r\n\t\t\tvar v4 = vertices[ y ][ x + 1 ];\r\n\r\n\t\t\tvar n1 = na.clone();\r\n\t\t\tvar n2 = na.clone();\r\n\t\t\tvar n3 = nb.clone();\r\n\t\t\tvar n4 = nb.clone();\r\n\r\n\t\t\tvar uv1 = uvs[ y ][ x ].clone();\r\n\t\t\tvar uv2 = uvs[ y + 1 ][ x ].clone();\r\n\t\t\tvar uv3 = uvs[ y + 1 ][ x + 1 ].clone();\r\n\t\t\tvar uv4 = uvs[ y ][ x + 1 ].clone();\r\n\r\n\t\t\tthis.faces.push( new THREE.Face3( v1, v2, v4, [ n1, n2, n4 ] ) );\r\n\t\t\tthis.faceVertexUvs[ 0 ].push( [ uv1, uv2, uv4 ] );\r\n\r\n\t\t\tthis.faces.push( new THREE.Face3( v2, v3, v4, [ n2.clone(), n3, n4.clone() ] ) );\r\n\t\t\tthis.faceVertexUvs[ 0 ].push( [ uv2.clone(), uv3, uv4.clone() ] );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// top cap\r\n\r\n\tif ( openEnded === false && radiusTop > 0 ) {\r\n\r\n\t\tthis.vertices.push( new THREE.Vector3( 0, heightHalf, 0 ) );\r\n\r\n\t\tfor ( x = 0; x < radialSegments; x ++ ) {\r\n\r\n\t\t\tvar v1 = vertices[ 0 ][ x ];\r\n\t\t\tvar v2 = vertices[ 0 ][ x + 1 ];\r\n\t\t\tvar v3 = this.vertices.length - 1;\r\n\r\n\t\t\tvar n1 = new THREE.Vector3( 0, 1, 0 );\r\n\t\t\tvar n2 = new THREE.Vector3( 0, 1, 0 );\r\n\t\t\tvar n3 = new THREE.Vector3( 0, 1, 0 );\r\n\r\n\t\t\tvar uv1 = uvs[ 0 ][ x ].clone();\r\n\t\t\tvar uv2 = uvs[ 0 ][ x + 1 ].clone();\r\n\t\t\tvar uv3 = new THREE.Vector2( uv2.x, 0 );\r\n\r\n\t\t\tthis.faces.push( new THREE.Face3( v1, v2, v3, [ n1, n2, n3 ] ) );\r\n\t\t\tthis.faceVertexUvs[ 0 ].push( [ uv1, uv2, uv3 ] );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// bottom cap\r\n\r\n\tif ( openEnded === false && radiusBottom > 0 ) {\r\n\r\n\t\tthis.vertices.push( new THREE.Vector3( 0, - heightHalf, 0 ) );\r\n\r\n\t\tfor ( x = 0; x < radialSegments; x ++ ) {\r\n\r\n\t\t\tvar v1 = vertices[ heightSegments ][ x + 1 ];\r\n\t\t\tvar v2 = vertices[ heightSegments ][ x ];\r\n\t\t\tvar v3 = this.vertices.length - 1;\r\n\r\n\t\t\tvar n1 = new THREE.Vector3( 0, - 1, 0 );\r\n\t\t\tvar n2 = new THREE.Vector3( 0, - 1, 0 );\r\n\t\t\tvar n3 = new THREE.Vector3( 0, - 1, 0 );\r\n\r\n\t\t\tvar uv1 = uvs[ heightSegments ][ x + 1 ].clone();\r\n\t\t\tvar uv2 = uvs[ heightSegments ][ x ].clone();\r\n\t\t\tvar uv3 = new THREE.Vector2( uv2.x, 1 );\r\n\r\n\t\t\tthis.faces.push( new THREE.Face3( v1, v2, v3, [ n1, n2, n3 ] ) );\r\n\t\t\tthis.faceVertexUvs[ 0 ].push( [ uv1, uv2, uv3 ] );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tthis.computeFaceNormals();\r\n\r\n};\r\n\r\nTHREE.CylinderGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\nTHREE.CylinderGeometry.prototype.constructor = THREE.CylinderGeometry;\r\n\r\n// File:src/extras/geometries/ExtrudeGeometry.js\r\n\r\n/**\r\n * @author zz85 / http://www.lab4games.net/zz85/blog\r\n *\r\n * Creates extruded geometry from a path shape.\r\n *\r\n * parameters = {\r\n *\r\n *  curveSegments: <int>, // number of points on the curves\r\n *  steps: <int>, // number of points for z-side extrusions / used for subdividing segements of extrude spline too\r\n *  amount: <int>, // Depth to extrude the shape\r\n *\r\n *  bevelEnabled: <bool>, // turn on bevel\r\n *  bevelThickness: <float>, // how deep into the original shape bevel goes\r\n *  bevelSize: <float>, // how far from shape outline is bevel\r\n *  bevelSegments: <int>, // number of bevel layers\r\n *\r\n *  extrudePath: <THREE.CurvePath> // 3d spline path to extrude shape along. (creates Frames if .frames aren't defined)\r\n *  frames: <THREE.TubeGeometry.FrenetFrames> // containing arrays of tangents, normals, binormals\r\n *\r\n *  material: <int> // material index for front and back faces\r\n *  extrudeMaterial: <int> // material index for extrusion and beveled faces\r\n *  uvGenerator: <Object> // object that provides UV generator functions\r\n *\r\n * }\r\n **/\r\n\r\nTHREE.ExtrudeGeometry = function ( shapes, options ) {\r\n\r\n\tif ( typeof( shapes ) === \"undefined\" ) {\r\n\t\tshapes = [];\r\n\t\treturn;\r\n\t}\r\n\r\n\tTHREE.Geometry.call( this );\r\n\r\n\tthis.type = 'ExtrudeGeometry';\r\n\r\n\tshapes = shapes instanceof Array ? shapes : [ shapes ];\r\n\r\n\tthis.addShapeList( shapes, options );\r\n\r\n\tthis.computeFaceNormals();\r\n\r\n\t// can't really use automatic vertex normals\r\n\t// as then front and back sides get smoothed too\r\n\t// should do separate smoothing just for sides\r\n\r\n\t//this.computeVertexNormals();\r\n\r\n\t//console.log( \"took\", ( Date.now() - startTime ) );\r\n\r\n};\r\n\r\nTHREE.ExtrudeGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\nTHREE.ExtrudeGeometry.prototype.constructor = THREE.ExtrudeGeometry;\r\n\r\nTHREE.ExtrudeGeometry.prototype.addShapeList = function ( shapes, options ) {\r\n\tvar sl = shapes.length;\r\n\r\n\tfor ( var s = 0; s < sl; s ++ ) {\r\n\t\tvar shape = shapes[ s ];\r\n\t\tthis.addShape( shape, options );\r\n\t}\r\n};\r\n\r\nTHREE.ExtrudeGeometry.prototype.addShape = function ( shape, options ) {\r\n\r\n\tvar amount = options.amount !== undefined ? options.amount : 100;\r\n\r\n\tvar bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 6; // 10\r\n\tvar bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 2; // 8\r\n\tvar bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;\r\n\r\n\tvar bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true; // false\r\n\r\n\tvar curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;\r\n\r\n\tvar steps = options.steps !== undefined ? options.steps : 1;\r\n\r\n\tvar extrudePath = options.extrudePath;\r\n\tvar extrudePts, extrudeByPath = false;\r\n\r\n\tvar material = options.material;\r\n\tvar extrudeMaterial = options.extrudeMaterial;\r\n\r\n\t// Use default WorldUVGenerator if no UV generators are specified.\r\n\tvar uvgen = options.UVGenerator !== undefined ? options.UVGenerator : THREE.ExtrudeGeometry.WorldUVGenerator;\r\n\r\n\tvar splineTube, binormal, normal, position2;\r\n\tif ( extrudePath ) {\r\n\r\n\t\textrudePts = extrudePath.getSpacedPoints( steps );\r\n\r\n\t\textrudeByPath = true;\r\n\t\tbevelEnabled = false; // bevels not supported for path extrusion\r\n\r\n\t\t// SETUP TNB variables\r\n\r\n\t\t// Reuse TNB from TubeGeomtry for now.\r\n\t\t// TODO1 - have a .isClosed in spline?\r\n\r\n\t\tsplineTube = options.frames !== undefined ? options.frames : new THREE.TubeGeometry.FrenetFrames(extrudePath, steps, false);\r\n\r\n\t\t// console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length);\r\n\r\n\t\tbinormal = new THREE.Vector3();\r\n\t\tnormal = new THREE.Vector3();\r\n\t\tposition2 = new THREE.Vector3();\r\n\r\n\t}\r\n\r\n\t// Safeguards if bevels are not enabled\r\n\r\n\tif ( ! bevelEnabled ) {\r\n\r\n\t\tbevelSegments = 0;\r\n\t\tbevelThickness = 0;\r\n\t\tbevelSize = 0;\r\n\r\n\t}\r\n\r\n\t// Variables initalization\r\n\r\n\tvar ahole, h, hl; // looping of holes\r\n\tvar scope = this;\r\n\r\n\tvar shapesOffset = this.vertices.length;\r\n\r\n\tvar shapePoints = shape.extractPoints( curveSegments );\r\n\r\n\tvar vertices = shapePoints.shape;\r\n\tvar holes = shapePoints.holes;\r\n\r\n\tvar reverse = ! THREE.Shape.Utils.isClockWise( vertices ) ;\r\n\r\n\tif ( reverse ) {\r\n\r\n\t\tvertices = vertices.reverse();\r\n\r\n\t\t// Maybe we should also check if holes are in the opposite direction, just to be safe ...\r\n\r\n\t\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\r\n\r\n\t\t\tahole = holes[ h ];\r\n\r\n\t\t\tif ( THREE.Shape.Utils.isClockWise( ahole ) ) {\r\n\r\n\t\t\t\tholes[ h ] = ahole.reverse();\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treverse = false; // If vertices are in order now, we shouldn't need to worry about them again (hopefully)!\r\n\r\n\t}\r\n\r\n\r\n\tvar faces = THREE.Shape.Utils.triangulateShape ( vertices, holes );\r\n\r\n\t/* Vertices */\r\n\r\n\tvar contour = vertices; // vertices has all points but contour has only points of circumference\r\n\r\n\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\r\n\r\n\t\tahole = holes[ h ];\r\n\r\n\t\tvertices = vertices.concat( ahole );\r\n\r\n\t}\r\n\r\n\r\n\tfunction scalePt2 ( pt, vec, size ) {\r\n\r\n\t\tif ( ! vec ) THREE.error( \"THREE.ExtrudeGeometry: vec does not exist\" );\r\n\r\n\t\treturn vec.clone().multiplyScalar( size ).add( pt );\r\n\r\n\t}\r\n\r\n\tvar b, bs, t, z,\r\n\t\tvert, vlen = vertices.length,\r\n\t\tface, flen = faces.length;\r\n\r\n\r\n\t// Find directions for point movement\r\n\r\n\r\n\tfunction getBevelVec( inPt, inPrev, inNext ) {\r\n\r\n\t\tvar EPSILON = 0.0000000001;\r\n\t\t\r\n\t\t// computes for inPt the corresponding point inPt' on a new contour\r\n\t\t//   shiftet by 1 unit (length of normalized vector) to the left\r\n\t\t// if we walk along contour clockwise, this new contour is outside the old one\r\n\t\t//\r\n\t\t// inPt' is the intersection of the two lines parallel to the two\r\n\t\t//  adjacent edges of inPt at a distance of 1 unit on the left side.\r\n\t\t\r\n\t\tvar v_trans_x, v_trans_y, shrink_by = 1;\t\t// resulting translation vector for inPt\r\n\r\n\t\t// good reading for geometry algorithms (here: line-line intersection)\r\n\t\t// http://geomalgorithms.com/a05-_intersect-1.html\r\n\r\n\t\tvar v_prev_x = inPt.x - inPrev.x, v_prev_y = inPt.y - inPrev.y;\r\n\t\tvar v_next_x = inNext.x - inPt.x, v_next_y = inNext.y - inPt.y;\r\n\t\t\r\n\t\tvar v_prev_lensq = ( v_prev_x * v_prev_x + v_prev_y * v_prev_y );\r\n\t\t\r\n\t\t// check for colinear edges\r\n\t\tvar colinear0 = ( v_prev_x * v_next_y - v_prev_y * v_next_x );\r\n\t\t\r\n\t\tif ( Math.abs( colinear0 ) > EPSILON ) {\t\t// not colinear\r\n\t\t\t\r\n\t\t\t// length of vectors for normalizing\r\n\t\r\n\t\t\tvar v_prev_len = Math.sqrt( v_prev_lensq );\r\n\t\t\tvar v_next_len = Math.sqrt( v_next_x * v_next_x + v_next_y * v_next_y );\r\n\t\t\t\r\n\t\t\t// shift adjacent points by unit vectors to the left\r\n\t\r\n\t\t\tvar ptPrevShift_x = ( inPrev.x - v_prev_y / v_prev_len );\r\n\t\t\tvar ptPrevShift_y = ( inPrev.y + v_prev_x / v_prev_len );\r\n\t\t\t\r\n\t\t\tvar ptNextShift_x = ( inNext.x - v_next_y / v_next_len );\r\n\t\t\tvar ptNextShift_y = ( inNext.y + v_next_x / v_next_len );\r\n\t\r\n\t\t\t// scaling factor for v_prev to intersection point\r\n\t\r\n\t\t\tvar sf = (  ( ptNextShift_x - ptPrevShift_x ) * v_next_y -\r\n\t\t\t\t\t\t( ptNextShift_y - ptPrevShift_y ) * v_next_x    ) /\r\n\t\t\t\t\t  ( v_prev_x * v_next_y - v_prev_y * v_next_x );\r\n\t\r\n\t\t\t// vector from inPt to intersection point\r\n\t\r\n\t\t\tv_trans_x = ( ptPrevShift_x + v_prev_x * sf - inPt.x );\r\n\t\t\tv_trans_y = ( ptPrevShift_y + v_prev_y * sf - inPt.y );\r\n\t\r\n\t\t\t// Don't normalize!, otherwise sharp corners become ugly\r\n\t\t\t//  but prevent crazy spikes\r\n\t\t\tvar v_trans_lensq = ( v_trans_x * v_trans_x + v_trans_y * v_trans_y )\r\n\t\t\tif ( v_trans_lensq <= 2 ) {\r\n\t\t\t\treturn\tnew THREE.Vector2( v_trans_x, v_trans_y );\r\n\t\t\t} else {\r\n\t\t\t\tshrink_by = Math.sqrt( v_trans_lensq / 2 );\r\n\t\t\t}\r\n\t\t\t\r\n\t\t} else {\t\t// handle special case of colinear edges\r\n\r\n\t\t\tvar direction_eq = false;\t\t// assumes: opposite\r\n\t\t\tif ( v_prev_x > EPSILON ) {\r\n\t\t\t\tif ( v_next_x > EPSILON ) { direction_eq = true; }\r\n\t\t\t} else {\r\n\t\t\t\tif ( v_prev_x < - EPSILON ) {\r\n\t\t\t\t\tif ( v_next_x < - EPSILON ) { direction_eq = true; }\r\n\t\t\t\t} else {\r\n\t\t\t\t\tif ( Math.sign(v_prev_y) == Math.sign(v_next_y) ) { direction_eq = true; }\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif ( direction_eq ) {\r\n\t\t\t\t// console.log(\"Warning: lines are a straight sequence\");\r\n\t\t\t\tv_trans_x = - v_prev_y;\r\n\t\t\t\tv_trans_y =  v_prev_x;\r\n\t\t\t\tshrink_by = Math.sqrt( v_prev_lensq );\r\n\t\t\t} else {\r\n\t\t\t\t// console.log(\"Warning: lines are a straight spike\");\r\n\t\t\t\tv_trans_x = v_prev_x;\r\n\t\t\t\tv_trans_y = v_prev_y;\r\n\t\t\t\tshrink_by = Math.sqrt( v_prev_lensq / 2 );\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn\tnew THREE.Vector2( v_trans_x / shrink_by, v_trans_y / shrink_by );\r\n\r\n\t}\r\n\r\n\r\n\tvar contourMovements = [];\r\n\r\n\tfor ( var i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {\r\n\r\n\t\tif ( j === il ) j = 0;\r\n\t\tif ( k === il ) k = 0;\r\n\r\n\t\t//  (j)---(i)---(k)\r\n\t\t// console.log('i,j,k', i, j , k)\r\n\r\n\t\tcontourMovements[ i ] = getBevelVec( contour[ i ], contour[ j ], contour[ k ] );\r\n\r\n\t}\r\n\r\n\tvar holesMovements = [], oneHoleMovements, verticesMovements = contourMovements.concat();\r\n\r\n\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\r\n\r\n\t\tahole = holes[ h ];\r\n\r\n\t\toneHoleMovements = [];\r\n\r\n\t\tfor ( i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {\r\n\r\n\t\t\tif ( j === il ) j = 0;\r\n\t\t\tif ( k === il ) k = 0;\r\n\r\n\t\t\t//  (j)---(i)---(k)\r\n\t\t\toneHoleMovements[ i ] = getBevelVec( ahole[ i ], ahole[ j ], ahole[ k ] );\r\n\r\n\t\t}\r\n\r\n\t\tholesMovements.push( oneHoleMovements );\r\n\t\tverticesMovements = verticesMovements.concat( oneHoleMovements );\r\n\r\n\t}\r\n\r\n\r\n\t// Loop bevelSegments, 1 for the front, 1 for the back\r\n\r\n\tfor ( b = 0; b < bevelSegments; b ++ ) {\r\n\t//for ( b = bevelSegments; b > 0; b -- ) {\r\n\r\n\t\tt = b / bevelSegments;\r\n\t\tz = bevelThickness * ( 1 - t );\r\n\r\n\t\t//z = bevelThickness * t;\r\n\t\tbs = bevelSize * ( Math.sin ( t * Math.PI / 2 ) ) ; // curved\r\n\t\t//bs = bevelSize * t ; // linear\r\n\r\n\t\t// contract shape\r\n\r\n\t\tfor ( i = 0, il = contour.length; i < il; i ++ ) {\r\n\r\n\t\t\tvert = scalePt2( contour[ i ], contourMovements[ i ], bs );\r\n\r\n\t\t\tv( vert.x, vert.y,  - z );\r\n\r\n\t\t}\r\n\r\n\t\t// expand holes\r\n\r\n\t\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\r\n\r\n\t\t\tahole = holes[ h ];\r\n\t\t\toneHoleMovements = holesMovements[ h ];\r\n\r\n\t\t\tfor ( i = 0, il = ahole.length; i < il; i ++ ) {\r\n\r\n\t\t\t\tvert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );\r\n\r\n\t\t\t\tv( vert.x, vert.y,  - z );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tbs = bevelSize;\r\n\r\n\t// Back facing vertices\r\n\r\n\tfor ( i = 0; i < vlen; i ++ ) {\r\n\r\n\t\tvert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];\r\n\r\n\t\tif ( ! extrudeByPath ) {\r\n\r\n\t\t\tv( vert.x, vert.y, 0 );\r\n\r\n\t\t} else {\r\n\r\n\t\t\t// v( vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x );\r\n\r\n\t\t\tnormal.copy( splineTube.normals[0] ).multiplyScalar(vert.x);\r\n\t\t\tbinormal.copy( splineTube.binormals[0] ).multiplyScalar(vert.y);\r\n\r\n\t\t\tposition2.copy( extrudePts[0] ).add(normal).add(binormal);\r\n\r\n\t\t\tv( position2.x, position2.y, position2.z );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// Add stepped vertices...\r\n\t// Including front facing vertices\r\n\r\n\tvar s;\r\n\r\n\tfor ( s = 1; s <= steps; s ++ ) {\r\n\r\n\t\tfor ( i = 0; i < vlen; i ++ ) {\r\n\r\n\t\t\tvert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];\r\n\r\n\t\t\tif ( ! extrudeByPath ) {\r\n\r\n\t\t\t\tv( vert.x, vert.y, amount / steps * s );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t// v( vert.x, vert.y + extrudePts[ s - 1 ].y, extrudePts[ s - 1 ].x );\r\n\r\n\t\t\t\tnormal.copy( splineTube.normals[s] ).multiplyScalar( vert.x );\r\n\t\t\t\tbinormal.copy( splineTube.binormals[s] ).multiplyScalar( vert.y );\r\n\r\n\t\t\t\tposition2.copy( extrudePts[s] ).add( normal ).add( binormal );\r\n\r\n\t\t\t\tv( position2.x, position2.y, position2.z );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\r\n\t// Add bevel segments planes\r\n\r\n\t//for ( b = 1; b <= bevelSegments; b ++ ) {\r\n\tfor ( b = bevelSegments - 1; b >= 0; b -- ) {\r\n\r\n\t\tt = b / bevelSegments;\r\n\t\tz = bevelThickness * ( 1 - t );\r\n\t\t//bs = bevelSize * ( 1-Math.sin ( ( 1 - t ) * Math.PI/2 ) );\r\n\t\tbs = bevelSize * Math.sin ( t * Math.PI / 2 ) ;\r\n\r\n\t\t// contract shape\r\n\r\n\t\tfor ( i = 0, il = contour.length; i < il; i ++ ) {\r\n\r\n\t\t\tvert = scalePt2( contour[ i ], contourMovements[ i ], bs );\r\n\t\t\tv( vert.x, vert.y,  amount + z );\r\n\r\n\t\t}\r\n\r\n\t\t// expand holes\r\n\r\n\t\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\r\n\r\n\t\t\tahole = holes[ h ];\r\n\t\t\toneHoleMovements = holesMovements[ h ];\r\n\r\n\t\t\tfor ( i = 0, il = ahole.length; i < il; i ++ ) {\r\n\r\n\t\t\t\tvert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );\r\n\r\n\t\t\t\tif ( ! extrudeByPath ) {\r\n\r\n\t\t\t\t\tv( vert.x, vert.y,  amount + z );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tv( vert.x, vert.y + extrudePts[ steps - 1 ].y, extrudePts[ steps - 1 ].x + z );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t/* Faces */\r\n\r\n\t// Top and bottom faces\r\n\r\n\tbuildLidFaces();\r\n\r\n\t// Sides faces\r\n\r\n\tbuildSideFaces();\r\n\r\n\r\n\t/////  Internal functions\r\n\r\n\tfunction buildLidFaces() {\r\n\r\n\t\tif ( bevelEnabled ) {\r\n\r\n\t\t\tvar layer = 0 ; // steps + 1\r\n\t\t\tvar offset = vlen * layer;\r\n\r\n\t\t\t// Bottom faces\r\n\r\n\t\t\tfor ( i = 0; i < flen; i ++ ) {\r\n\r\n\t\t\t\tface = faces[ i ];\r\n\t\t\t\tf3( face[ 2 ] + offset, face[ 1 ] + offset, face[ 0 ] + offset );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tlayer = steps + bevelSegments * 2;\r\n\t\t\toffset = vlen * layer;\r\n\r\n\t\t\t// Top faces\r\n\r\n\t\t\tfor ( i = 0; i < flen; i ++ ) {\r\n\r\n\t\t\t\tface = faces[ i ];\r\n\t\t\t\tf3( face[ 0 ] + offset, face[ 1 ] + offset, face[ 2 ] + offset );\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\t// Bottom faces\r\n\r\n\t\t\tfor ( i = 0; i < flen; i ++ ) {\r\n\r\n\t\t\t\tface = faces[ i ];\r\n\t\t\t\tf3( face[ 2 ], face[ 1 ], face[ 0 ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// Top faces\r\n\r\n\t\t\tfor ( i = 0; i < flen; i ++ ) {\r\n\r\n\t\t\t\tface = faces[ i ];\r\n\t\t\t\tf3( face[ 0 ] + vlen * steps, face[ 1 ] + vlen * steps, face[ 2 ] + vlen * steps );\r\n\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// Create faces for the z-sides of the shape\r\n\r\n\tfunction buildSideFaces() {\r\n\r\n\t\tvar layeroffset = 0;\r\n\t\tsidewalls( contour, layeroffset );\r\n\t\tlayeroffset += contour.length;\r\n\r\n\t\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\r\n\r\n\t\t\tahole = holes[ h ];\r\n\t\t\tsidewalls( ahole, layeroffset );\r\n\r\n\t\t\t//, true\r\n\t\t\tlayeroffset += ahole.length;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction sidewalls( contour, layeroffset ) {\r\n\r\n\t\tvar j, k;\r\n\t\ti = contour.length;\r\n\r\n\t\twhile ( -- i >= 0 ) {\r\n\r\n\t\t\tj = i;\r\n\t\t\tk = i - 1;\r\n\t\t\tif ( k < 0 ) k = contour.length - 1;\r\n\r\n\t\t\t//console.log('b', i,j, i-1, k,vertices.length);\r\n\r\n\t\t\tvar s = 0, sl = steps  + bevelSegments * 2;\r\n\r\n\t\t\tfor ( s = 0; s < sl; s ++ ) {\r\n\r\n\t\t\t\tvar slen1 = vlen * s;\r\n\t\t\t\tvar slen2 = vlen * ( s + 1 );\r\n\r\n\t\t\t\tvar a = layeroffset + j + slen1,\r\n\t\t\t\t\tb = layeroffset + k + slen1,\r\n\t\t\t\t\tc = layeroffset + k + slen2,\r\n\t\t\t\t\td = layeroffset + j + slen2;\r\n\r\n\t\t\t\tf4( a, b, c, d, contour, s, sl, j, k );\r\n\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t}\r\n\r\n\r\n\tfunction v( x, y, z ) {\r\n\r\n\t\tscope.vertices.push( new THREE.Vector3( x, y, z ) );\r\n\r\n\t}\r\n\r\n\tfunction f3( a, b, c ) {\r\n\r\n\t\ta += shapesOffset;\r\n\t\tb += shapesOffset;\r\n\t\tc += shapesOffset;\r\n\r\n\t\t// normal, color, material\r\n\t\tscope.faces.push( new THREE.Face3( a, b, c, null, null, material ) );\r\n\r\n\t\tvar uvs = uvgen.generateTopUV( scope, a, b, c );\r\n\r\n\t\tscope.faceVertexUvs[ 0 ].push( uvs );\r\n\r\n\t}\r\n\r\n\tfunction f4( a, b, c, d, wallContour, stepIndex, stepsLength, contourIndex1, contourIndex2 ) {\r\n\r\n\t\ta += shapesOffset;\r\n\t\tb += shapesOffset;\r\n\t\tc += shapesOffset;\r\n\t\td += shapesOffset;\r\n\r\n\t\tscope.faces.push( new THREE.Face3( a, b, d, null, null, extrudeMaterial ) );\r\n\t\tscope.faces.push( new THREE.Face3( b, c, d, null, null, extrudeMaterial ) );\r\n\r\n\t\tvar uvs = uvgen.generateSideWallUV( scope, a, b, c, d );\r\n\r\n\t\tscope.faceVertexUvs[ 0 ].push( [ uvs[ 0 ], uvs[ 1 ], uvs[ 3 ] ] );\r\n\t\tscope.faceVertexUvs[ 0 ].push( [ uvs[ 1 ], uvs[ 2 ], uvs[ 3 ] ] );\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.ExtrudeGeometry.WorldUVGenerator = {\r\n\r\n\tgenerateTopUV: function ( geometry, indexA, indexB, indexC ) {\r\n\r\n\t\tvar vertices = geometry.vertices;\r\n\r\n\t\tvar a = vertices[ indexA ];\r\n\t\tvar b = vertices[ indexB ];\r\n\t\tvar c = vertices[ indexC ];\r\n\r\n\t\treturn [\r\n\t\t\tnew THREE.Vector2( a.x, a.y ),\r\n\t\t\tnew THREE.Vector2( b.x, b.y ),\r\n\t\t\tnew THREE.Vector2( c.x, c.y )\r\n\t\t];\r\n\r\n\t},\r\n\r\n\tgenerateSideWallUV: function ( geometry, indexA, indexB, indexC, indexD ) {\r\n\r\n\t\tvar vertices = geometry.vertices;\r\n\r\n\t\tvar a = vertices[ indexA ];\r\n\t\tvar b = vertices[ indexB ];\r\n\t\tvar c = vertices[ indexC ];\r\n\t\tvar d = vertices[ indexD ];\r\n\r\n\t\tif ( Math.abs( a.y - b.y ) < 0.01 ) {\r\n\t\t\treturn [\r\n\t\t\t\tnew THREE.Vector2( a.x, 1 - a.z ),\r\n\t\t\t\tnew THREE.Vector2( b.x, 1 - b.z ),\r\n\t\t\t\tnew THREE.Vector2( c.x, 1 - c.z ),\r\n\t\t\t\tnew THREE.Vector2( d.x, 1 - d.z )\r\n\t\t\t];\r\n\t\t} else {\r\n\t\t\treturn [\r\n\t\t\t\tnew THREE.Vector2( a.y, 1 - a.z ),\r\n\t\t\t\tnew THREE.Vector2( b.y, 1 - b.z ),\r\n\t\t\t\tnew THREE.Vector2( c.y, 1 - c.z ),\r\n\t\t\t\tnew THREE.Vector2( d.y, 1 - d.z )\r\n\t\t\t];\r\n\t\t}\r\n\t}\r\n};\r\n\r\n// File:src/extras/geometries/ShapeGeometry.js\r\n\r\n/**\r\n * @author jonobr1 / http://jonobr1.com\r\n *\r\n * Creates a one-sided polygonal geometry from a path shape. Similar to\r\n * ExtrudeGeometry.\r\n *\r\n * parameters = {\r\n *\r\n *\tcurveSegments: <int>, // number of points on the curves. NOT USED AT THE MOMENT.\r\n *\r\n *\tmaterial: <int> // material index for front and back faces\r\n *\tuvGenerator: <Object> // object that provides UV generator functions\r\n *\r\n * }\r\n **/\r\n\r\nTHREE.ShapeGeometry = function ( shapes, options ) {\r\n\r\n\tTHREE.Geometry.call( this );\r\n\r\n\tthis.type = 'ShapeGeometry';\r\n\r\n\tif ( shapes instanceof Array === false ) shapes = [ shapes ];\r\n\r\n\tthis.addShapeList( shapes, options );\r\n\r\n\tthis.computeFaceNormals();\r\n\r\n};\r\n\r\nTHREE.ShapeGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\nTHREE.ShapeGeometry.prototype.constructor = THREE.ShapeGeometry;\r\n\r\n/**\r\n * Add an array of shapes to THREE.ShapeGeometry.\r\n */\r\nTHREE.ShapeGeometry.prototype.addShapeList = function ( shapes, options ) {\r\n\r\n\tfor ( var i = 0, l = shapes.length; i < l; i ++ ) {\r\n\r\n\t\tthis.addShape( shapes[ i ], options );\r\n\r\n\t}\r\n\r\n\treturn this;\r\n\r\n};\r\n\r\n/**\r\n * Adds a shape to THREE.ShapeGeometry, based on THREE.ExtrudeGeometry.\r\n */\r\nTHREE.ShapeGeometry.prototype.addShape = function ( shape, options ) {\r\n\r\n\tif ( options === undefined ) options = {};\r\n\tvar curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;\r\n\r\n\tvar material = options.material;\r\n\tvar uvgen = options.UVGenerator === undefined ? THREE.ExtrudeGeometry.WorldUVGenerator : options.UVGenerator;\r\n\r\n\t//\r\n\r\n\tvar i, l, hole;\r\n\r\n\tvar shapesOffset = this.vertices.length;\r\n\tvar shapePoints = shape.extractPoints( curveSegments );\r\n\r\n\tvar vertices = shapePoints.shape;\r\n\tvar holes = shapePoints.holes;\r\n\r\n\tvar reverse = ! THREE.Shape.Utils.isClockWise( vertices );\r\n\r\n\tif ( reverse ) {\r\n\r\n\t\tvertices = vertices.reverse();\r\n\r\n\t\t// Maybe we should also check if holes are in the opposite direction, just to be safe...\r\n\r\n\t\tfor ( i = 0, l = holes.length; i < l; i ++ ) {\r\n\r\n\t\t\thole = holes[ i ];\r\n\r\n\t\t\tif ( THREE.Shape.Utils.isClockWise( hole ) ) {\r\n\r\n\t\t\t\tholes[ i ] = hole.reverse();\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treverse = false;\r\n\r\n\t}\r\n\r\n\tvar faces = THREE.Shape.Utils.triangulateShape( vertices, holes );\r\n\r\n\t// Vertices\r\n\r\n\tvar contour = vertices;\r\n\r\n\tfor ( i = 0, l = holes.length; i < l; i ++ ) {\r\n\r\n\t\thole = holes[ i ];\r\n\t\tvertices = vertices.concat( hole );\r\n\r\n\t}\r\n\r\n\t//\r\n\r\n\tvar vert, vlen = vertices.length;\r\n\tvar face, flen = faces.length;\r\n\r\n\tfor ( i = 0; i < vlen; i ++ ) {\r\n\r\n\t\tvert = vertices[ i ];\r\n\r\n\t\tthis.vertices.push( new THREE.Vector3( vert.x, vert.y, 0 ) );\r\n\r\n\t}\r\n\r\n\tfor ( i = 0; i < flen; i ++ ) {\r\n\r\n\t\tface = faces[ i ];\r\n\r\n\t\tvar a = face[ 0 ] + shapesOffset;\r\n\t\tvar b = face[ 1 ] + shapesOffset;\r\n\t\tvar c = face[ 2 ] + shapesOffset;\r\n\r\n\t\tthis.faces.push( new THREE.Face3( a, b, c, null, null, material ) );\r\n\t\tthis.faceVertexUvs[ 0 ].push( uvgen.generateTopUV( this, a, b, c ) );\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/extras/geometries/LatheGeometry.js\r\n\r\n/**\r\n * @author astrodud / http://astrodud.isgreat.org/\r\n * @author zz85 / https://github.com/zz85\r\n * @author bhouston / http://exocortex.com\r\n */\r\n\r\n// points - to create a closed torus, one must use a set of points \r\n//    like so: [ a, b, c, d, a ], see first is the same as last.\r\n// segments - the number of circumference segments to create\r\n// phiStart - the starting radian\r\n// phiLength - the radian (0 to 2*PI) range of the lathed section\r\n//    2*pi is a closed lathe, less than 2PI is a portion.\r\n\r\nTHREE.LatheGeometry = function ( points, segments, phiStart, phiLength ) {\r\n\r\n\tTHREE.Geometry.call( this );\r\n\r\n\tthis.type = 'LatheGeometry';\r\n\r\n\tthis.parameters = {\r\n\t\tpoints: points,\r\n\t\tsegments: segments,\r\n\t\tphiStart: phiStart,\r\n\t\tphiLength: phiLength\r\n\t};\r\n\r\n\tsegments = segments || 12;\r\n\tphiStart = phiStart || 0;\r\n\tphiLength = phiLength || 2 * Math.PI;\r\n\r\n\tvar inversePointLength = 1.0 / ( points.length - 1 );\r\n\tvar inverseSegments = 1.0 / segments;\r\n\r\n\tfor ( var i = 0, il = segments; i <= il; i ++ ) {\r\n\r\n\t\tvar phi = phiStart + i * inverseSegments * phiLength;\r\n\r\n\t\tvar c = Math.cos( phi ),\r\n\t\t\ts = Math.sin( phi );\r\n\r\n\t\tfor ( var j = 0, jl = points.length; j < jl; j ++ ) {\r\n\r\n\t\t\tvar pt = points[ j ];\r\n\r\n\t\t\tvar vertex = new THREE.Vector3();\r\n\r\n\t\t\tvertex.x = c * pt.x - s * pt.y;\r\n\t\t\tvertex.y = s * pt.x + c * pt.y;\r\n\t\t\tvertex.z = pt.z;\r\n\r\n\t\t\tthis.vertices.push( vertex );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tvar np = points.length;\r\n\r\n\tfor ( var i = 0, il = segments; i < il; i ++ ) {\r\n\r\n\t\tfor ( var j = 0, jl = points.length - 1; j < jl; j ++ ) {\r\n\r\n\t\t\tvar base = j + np * i;\r\n\t\t\tvar a = base;\r\n\t\t\tvar b = base + np;\r\n\t\t\tvar c = base + 1 + np;\r\n\t\t\tvar d = base + 1;\r\n\r\n\t\t\tvar u0 = i * inverseSegments;\r\n\t\t\tvar v0 = j * inversePointLength;\r\n\t\t\tvar u1 = u0 + inverseSegments;\r\n\t\t\tvar v1 = v0 + inversePointLength;\r\n\r\n\t\t\tthis.faces.push( new THREE.Face3( a, b, d ) );\r\n\r\n\t\t\tthis.faceVertexUvs[ 0 ].push( [\r\n\r\n\t\t\t\tnew THREE.Vector2( u0, v0 ),\r\n\t\t\t\tnew THREE.Vector2( u1, v0 ),\r\n\t\t\t\tnew THREE.Vector2( u0, v1 )\r\n\r\n\t\t\t] );\r\n\r\n\t\t\tthis.faces.push( new THREE.Face3( b, c, d ) );\r\n\r\n\t\t\tthis.faceVertexUvs[ 0 ].push( [\r\n\r\n\t\t\t\tnew THREE.Vector2( u1, v0 ),\r\n\t\t\t\tnew THREE.Vector2( u1, v1 ),\r\n\t\t\t\tnew THREE.Vector2( u0, v1 )\r\n\r\n\t\t\t] );\r\n\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tthis.mergeVertices();\r\n\tthis.computeFaceNormals();\r\n\tthis.computeVertexNormals();\r\n\r\n};\r\n\r\nTHREE.LatheGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\nTHREE.LatheGeometry.prototype.constructor = THREE.LatheGeometry;\r\n\r\n// File:src/extras/geometries/PlaneGeometry.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Plane.as\r\n */\r\n\r\nTHREE.PlaneGeometry = function ( width, height, widthSegments, heightSegments ) {\r\n\r\n\tconsole.info( 'THREE.PlaneGeometry: Consider using THREE.PlaneBufferGeometry for lower memory footprint.' );\r\n\r\n\tTHREE.Geometry.call( this );\r\n\r\n\tthis.type = 'PlaneGeometry';\r\n\r\n\tthis.parameters = {\r\n\t\twidth: width,\r\n\t\theight: height,\r\n\t\twidthSegments: widthSegments,\r\n\t\theightSegments: heightSegments\r\n\t};\r\n\r\n\tthis.fromBufferGeometry( new THREE.PlaneBufferGeometry( width, height, widthSegments, heightSegments ) );\r\n\r\n};\r\n\r\nTHREE.PlaneGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\nTHREE.PlaneGeometry.prototype.constructor = THREE.PlaneGeometry;\r\n\r\n// File:src/extras/geometries/PlaneBufferGeometry.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Plane.as\r\n */\r\n\r\nTHREE.PlaneBufferGeometry = function ( width, height, widthSegments, heightSegments ) {\r\n\r\n\tTHREE.BufferGeometry.call( this );\r\n\r\n\tthis.type = 'PlaneBufferGeometry';\r\n\r\n\tthis.parameters = {\r\n\t\twidth: width,\r\n\t\theight: height,\r\n\t\twidthSegments: widthSegments,\r\n\t\theightSegments: heightSegments\r\n\t};\r\n\r\n\tvar width_half = width / 2;\r\n\tvar height_half = height / 2;\r\n\r\n\tvar gridX = widthSegments || 1;\r\n\tvar gridY = heightSegments || 1;\r\n\r\n\tvar gridX1 = gridX + 1;\r\n\tvar gridY1 = gridY + 1;\r\n\r\n\tvar segment_width = width / gridX;\r\n\tvar segment_height = height / gridY;\r\n\r\n\tvar vertices = new Float32Array( gridX1 * gridY1 * 3 );\r\n\tvar normals = new Float32Array( gridX1 * gridY1 * 3 );\r\n\tvar uvs = new Float32Array( gridX1 * gridY1 * 2 );\r\n\r\n\tvar offset = 0;\r\n\tvar offset2 = 0;\r\n\r\n\tfor ( var iy = 0; iy < gridY1; iy ++ ) {\r\n\r\n\t\tvar y = iy * segment_height - height_half;\r\n\r\n\t\tfor ( var ix = 0; ix < gridX1; ix ++ ) {\r\n\r\n\t\t\tvar x = ix * segment_width - width_half;\r\n\r\n\t\t\tvertices[ offset     ] = x;\r\n\t\t\tvertices[ offset + 1 ] = - y;\r\n\r\n\t\t\tnormals[ offset + 2 ] = 1;\r\n\r\n\t\t\tuvs[ offset2     ] = ix / gridX;\r\n\t\t\tuvs[ offset2 + 1 ] = 1 - ( iy / gridY );\r\n\r\n\t\t\toffset += 3;\r\n\t\t\toffset2 += 2;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\toffset = 0;\r\n\r\n\tvar indices = new ( ( vertices.length / 3 ) > 65535 ? Uint32Array : Uint16Array )( gridX * gridY * 6 );\r\n\r\n\tfor ( var iy = 0; iy < gridY; iy ++ ) {\r\n\r\n\t\tfor ( var ix = 0; ix < gridX; ix ++ ) {\r\n\r\n\t\t\tvar a = ix + gridX1 * iy;\r\n\t\t\tvar b = ix + gridX1 * ( iy + 1 );\r\n\t\t\tvar c = ( ix + 1 ) + gridX1 * ( iy + 1 );\r\n\t\t\tvar d = ( ix + 1 ) + gridX1 * iy;\r\n\r\n\t\t\tindices[ offset     ] = a;\r\n\t\t\tindices[ offset + 1 ] = b;\r\n\t\t\tindices[ offset + 2 ] = d;\r\n\r\n\t\t\tindices[ offset + 3 ] = b;\r\n\t\t\tindices[ offset + 4 ] = c;\r\n\t\t\tindices[ offset + 5 ] = d;\r\n\r\n\t\t\toffset += 6;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tthis.addAttribute( 'index', new THREE.BufferAttribute( indices, 1 ) );\r\n\tthis.addAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );\r\n\tthis.addAttribute( 'normal', new THREE.BufferAttribute( normals, 3 ) );\r\n\tthis.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ) );\r\n\r\n};\r\n\r\nTHREE.PlaneBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );\r\nTHREE.PlaneBufferGeometry.prototype.constructor = THREE.PlaneBufferGeometry;\r\n\r\n// File:src/extras/geometries/RingGeometry.js\r\n\r\n/**\r\n * @author Kaleb Murphy\r\n */\r\n\r\nTHREE.RingGeometry = function ( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) {\r\n\r\n\tTHREE.Geometry.call( this );\r\n\r\n\tthis.type = 'RingGeometry';\r\n\r\n\tthis.parameters = {\r\n\t\tinnerRadius: innerRadius,\r\n\t\touterRadius: outerRadius,\r\n\t\tthetaSegments: thetaSegments,\r\n\t\tphiSegments: phiSegments,\r\n\t\tthetaStart: thetaStart,\r\n\t\tthetaLength: thetaLength\r\n\t};\r\n\r\n\tinnerRadius = innerRadius || 0;\r\n\touterRadius = outerRadius || 50;\r\n\r\n\tthetaStart = thetaStart !== undefined ? thetaStart : 0;\r\n\tthetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;\r\n\r\n\tthetaSegments = thetaSegments !== undefined ? Math.max( 3, thetaSegments ) : 8;\r\n\tphiSegments = phiSegments !== undefined ? Math.max( 1, phiSegments ) : 8;\r\n\r\n\tvar i, o, uvs = [], radius = innerRadius, radiusStep = ( ( outerRadius - innerRadius ) / phiSegments );\r\n\r\n\tfor ( i = 0; i < phiSegments + 1; i ++ ) { // concentric circles inside ring\r\n\r\n\t\tfor ( o = 0; o < thetaSegments + 1; o ++ ) { // number of segments per circle\r\n\r\n\t\t\tvar vertex = new THREE.Vector3();\r\n\t\t\tvar segment = thetaStart + o / thetaSegments * thetaLength;\r\n\t\t\tvertex.x = radius * Math.cos( segment );\r\n\t\t\tvertex.y = radius * Math.sin( segment );\r\n\r\n\t\t\tthis.vertices.push( vertex );\r\n\t\t\tuvs.push( new THREE.Vector2( ( vertex.x / outerRadius + 1 ) / 2, ( vertex.y / outerRadius + 1 ) / 2 ) );\r\n\t\t}\r\n\r\n\t\tradius += radiusStep;\r\n\r\n\t}\r\n\r\n\tvar n = new THREE.Vector3( 0, 0, 1 );\r\n\r\n\tfor ( i = 0; i < phiSegments; i ++ ) { // concentric circles inside ring\r\n\r\n\t\tvar thetaSegment = i * (thetaSegments + 1);\r\n\r\n\t\tfor ( o = 0; o < thetaSegments ; o ++ ) { // number of segments per circle\r\n\r\n\t\t\tvar segment = o + thetaSegment;\r\n\r\n\t\t\tvar v1 = segment;\r\n\t\t\tvar v2 = segment + thetaSegments + 1;\r\n\t\t\tvar v3 = segment + thetaSegments + 2;\r\n\r\n\t\t\tthis.faces.push( new THREE.Face3( v1, v2, v3, [ n.clone(), n.clone(), n.clone() ] ) );\r\n\t\t\tthis.faceVertexUvs[ 0 ].push( [ uvs[ v1 ].clone(), uvs[ v2 ].clone(), uvs[ v3 ].clone() ]);\r\n\r\n\t\t\tv1 = segment;\r\n\t\t\tv2 = segment + thetaSegments + 2;\r\n\t\t\tv3 = segment + 1;\r\n\r\n\t\t\tthis.faces.push( new THREE.Face3( v1, v2, v3, [ n.clone(), n.clone(), n.clone() ] ) );\r\n\t\t\tthis.faceVertexUvs[ 0 ].push( [ uvs[ v1 ].clone(), uvs[ v2 ].clone(), uvs[ v3 ].clone() ]);\r\n\r\n\t\t}\r\n\t}\r\n\r\n\tthis.computeFaceNormals();\r\n\r\n\tthis.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );\r\n\r\n};\r\n\r\nTHREE.RingGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\nTHREE.RingGeometry.prototype.constructor = THREE.RingGeometry;\r\n\r\n\r\n// File:src/extras/geometries/SphereGeometry.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.SphereGeometry = function ( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) {\r\n\r\n\tTHREE.Geometry.call( this );\r\n\r\n\tthis.type = 'SphereGeometry';\r\n\r\n\tthis.parameters = {\r\n\t\tradius: radius,\r\n\t\twidthSegments: widthSegments,\r\n\t\theightSegments: heightSegments,\r\n\t\tphiStart: phiStart,\r\n\t\tphiLength: phiLength,\r\n\t\tthetaStart: thetaStart,\r\n\t\tthetaLength: thetaLength \r\n\t};\r\n\r\n\tradius = radius || 50;\r\n\r\n\twidthSegments = Math.max( 3, Math.floor( widthSegments ) || 8 );\r\n\theightSegments = Math.max( 2, Math.floor( heightSegments ) || 6 );\r\n\r\n\tphiStart = phiStart !== undefined ? phiStart : 0;\r\n\tphiLength = phiLength !== undefined ? phiLength : Math.PI * 2;\r\n\r\n\tthetaStart = thetaStart !== undefined ? thetaStart : 0;\r\n\tthetaLength = thetaLength !== undefined ? thetaLength : Math.PI;\r\n\r\n\tvar x, y, vertices = [], uvs = [];\r\n\r\n\tfor ( y = 0; y <= heightSegments; y ++ ) {\r\n\r\n\t\tvar verticesRow = [];\r\n\t\tvar uvsRow = [];\r\n\r\n\t\tfor ( x = 0; x <= widthSegments; x ++ ) {\r\n\r\n\t\t\tvar u = x / widthSegments;\r\n\t\t\tvar v = y / heightSegments;\r\n\r\n\t\t\tvar vertex = new THREE.Vector3();\r\n\t\t\tvertex.x = - radius * Math.cos( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );\r\n\t\t\tvertex.y = radius * Math.cos( thetaStart + v * thetaLength );\r\n\t\t\tvertex.z = radius * Math.sin( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );\r\n\r\n\t\t\tthis.vertices.push( vertex );\r\n\r\n\t\t\tverticesRow.push( this.vertices.length - 1 );\r\n\t\t\tuvsRow.push( new THREE.Vector2( u, 1 - v ) );\r\n\r\n\t\t}\r\n\r\n\t\tvertices.push( verticesRow );\r\n\t\tuvs.push( uvsRow );\r\n\r\n\t}\r\n\r\n\tfor ( y = 0; y < heightSegments; y ++ ) {\r\n\r\n\t\tfor ( x = 0; x < widthSegments; x ++ ) {\r\n\r\n\t\t\tvar v1 = vertices[ y ][ x + 1 ];\r\n\t\t\tvar v2 = vertices[ y ][ x ];\r\n\t\t\tvar v3 = vertices[ y + 1 ][ x ];\r\n\t\t\tvar v4 = vertices[ y + 1 ][ x + 1 ];\r\n\r\n\t\t\tvar n1 = this.vertices[ v1 ].clone().normalize();\r\n\t\t\tvar n2 = this.vertices[ v2 ].clone().normalize();\r\n\t\t\tvar n3 = this.vertices[ v3 ].clone().normalize();\r\n\t\t\tvar n4 = this.vertices[ v4 ].clone().normalize();\r\n\r\n\t\t\tvar uv1 = uvs[ y ][ x + 1 ].clone();\r\n\t\t\tvar uv2 = uvs[ y ][ x ].clone();\r\n\t\t\tvar uv3 = uvs[ y + 1 ][ x ].clone();\r\n\t\t\tvar uv4 = uvs[ y + 1 ][ x + 1 ].clone();\r\n\r\n\t\t\tif ( Math.abs( this.vertices[ v1 ].y ) === radius ) {\r\n\r\n\t\t\t\tuv1.x = ( uv1.x + uv2.x ) / 2;\r\n\t\t\t\tthis.faces.push( new THREE.Face3( v1, v3, v4, [ n1, n3, n4 ] ) );\r\n\t\t\t\tthis.faceVertexUvs[ 0 ].push( [ uv1, uv3, uv4 ] );\r\n\r\n\t\t\t} else if ( Math.abs( this.vertices[ v3 ].y ) === radius ) {\r\n\r\n\t\t\t\tuv3.x = ( uv3.x + uv4.x ) / 2;\r\n\t\t\t\tthis.faces.push( new THREE.Face3( v1, v2, v3, [ n1, n2, n3 ] ) );\r\n\t\t\t\tthis.faceVertexUvs[ 0 ].push( [ uv1, uv2, uv3 ] );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tthis.faces.push( new THREE.Face3( v1, v2, v4, [ n1, n2, n4 ] ) );\r\n\t\t\t\tthis.faceVertexUvs[ 0 ].push( [ uv1, uv2, uv4 ] );\r\n\r\n\t\t\t\tthis.faces.push( new THREE.Face3( v2, v3, v4, [ n2.clone(), n3, n4.clone() ] ) );\r\n\t\t\t\tthis.faceVertexUvs[ 0 ].push( [ uv2.clone(), uv3, uv4.clone() ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tthis.computeFaceNormals();\r\n\r\n\tthis.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );\r\n\r\n};\r\n\r\nTHREE.SphereGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\nTHREE.SphereGeometry.prototype.constructor = THREE.SphereGeometry;\r\n\r\n// File:src/extras/geometries/TextGeometry.js\r\n\r\n/**\r\n * @author zz85 / http://www.lab4games.net/zz85/blog\r\n * @author alteredq / http://alteredqualia.com/\r\n *\r\n * For creating 3D text geometry in three.js\r\n *\r\n * Text = 3D Text\r\n *\r\n * parameters = {\r\n *  size: \t\t\t<float>, \t// size of the text\r\n *  height: \t\t<float>, \t// thickness to extrude text\r\n *  curveSegments: \t<int>,\t\t// number of points on the curves\r\n *\r\n *  font: \t\t\t<string>,\t\t// font name\r\n *  weight: \t\t<string>,\t\t// font weight (normal, bold)\r\n *  style: \t\t\t<string>,\t\t// font style  (normal, italics)\r\n *\r\n *  bevelEnabled:\t<bool>,\t\t\t// turn on bevel\r\n *  bevelThickness: <float>, \t\t// how deep into text bevel goes\r\n *  bevelSize:\t\t<float>, \t\t// how far from text outline is bevel\r\n *  }\r\n *\r\n */\r\n\r\n/*\tUsage Examples\r\n\r\n\t// TextGeometry wrapper\r\n\r\n\tvar text3d = new TextGeometry( text, options );\r\n\r\n\t// Complete manner\r\n\r\n\tvar textShapes = THREE.FontUtils.generateShapes( text, options );\r\n\tvar text3d = new ExtrudeGeometry( textShapes, options );\r\n\r\n*/\r\n\r\n\r\nTHREE.TextGeometry = function ( text, parameters ) {\r\n\r\n\tparameters = parameters || {};\r\n\r\n\tvar textShapes = THREE.FontUtils.generateShapes( text, parameters );\r\n\r\n\t// translate parameters to ExtrudeGeometry API\r\n\r\n\tparameters.amount = parameters.height !== undefined ? parameters.height : 50;\r\n\r\n\t// defaults\r\n\r\n\tif ( parameters.bevelThickness === undefined ) parameters.bevelThickness = 10;\r\n\tif ( parameters.bevelSize === undefined ) parameters.bevelSize = 8;\r\n\tif ( parameters.bevelEnabled === undefined ) parameters.bevelEnabled = false;\r\n\r\n\tTHREE.ExtrudeGeometry.call( this, textShapes, parameters );\r\n\r\n\tthis.type = 'TextGeometry';\r\n\r\n};\r\n\r\nTHREE.TextGeometry.prototype = Object.create( THREE.ExtrudeGeometry.prototype );\r\nTHREE.TextGeometry.prototype.constructor = THREE.TextGeometry;\r\n\r\n// File:src/extras/geometries/TorusGeometry.js\r\n\r\n/**\r\n * @author oosmoxiecode\r\n * @author mrdoob / http://mrdoob.com/\r\n * based on http://code.google.com/p/away3d/source/browse/trunk/fp10/Away3DLite/src/away3dlite/primitives/Torus.as?r=2888\r\n */\r\n\r\nTHREE.TorusGeometry = function ( radius, tube, radialSegments, tubularSegments, arc ) {\r\n\r\n\tTHREE.Geometry.call( this );\r\n\r\n\tthis.type = 'TorusGeometry';\r\n\r\n\tthis.parameters = {\r\n\t\tradius: radius,\r\n\t\ttube: tube,\r\n\t\tradialSegments: radialSegments,\r\n\t\ttubularSegments: tubularSegments,\r\n\t\tarc: arc\r\n\t};\r\n\r\n\tradius = radius || 100;\r\n\ttube = tube || 40;\r\n\tradialSegments = radialSegments || 8;\r\n\ttubularSegments = tubularSegments || 6;\r\n\tarc = arc || Math.PI * 2;\r\n\r\n\tvar center = new THREE.Vector3(), uvs = [], normals = [];\r\n\r\n\tfor ( var j = 0; j <= radialSegments; j ++ ) {\r\n\r\n\t\tfor ( var i = 0; i <= tubularSegments; i ++ ) {\r\n\r\n\t\t\tvar u = i / tubularSegments * arc;\r\n\t\t\tvar v = j / radialSegments * Math.PI * 2;\r\n\r\n\t\t\tcenter.x = radius * Math.cos( u );\r\n\t\t\tcenter.y = radius * Math.sin( u );\r\n\r\n\t\t\tvar vertex = new THREE.Vector3();\r\n\t\t\tvertex.x = ( radius + tube * Math.cos( v ) ) * Math.cos( u );\r\n\t\t\tvertex.y = ( radius + tube * Math.cos( v ) ) * Math.sin( u );\r\n\t\t\tvertex.z = tube * Math.sin( v );\r\n\r\n\t\t\tthis.vertices.push( vertex );\r\n\r\n\t\t\tuvs.push( new THREE.Vector2( i / tubularSegments, j / radialSegments ) );\r\n\t\t\tnormals.push( vertex.clone().sub( center ).normalize() );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfor ( var j = 1; j <= radialSegments; j ++ ) {\r\n\r\n\t\tfor ( var i = 1; i <= tubularSegments; i ++ ) {\r\n\r\n\t\t\tvar a = ( tubularSegments + 1 ) * j + i - 1;\r\n\t\t\tvar b = ( tubularSegments + 1 ) * ( j - 1 ) + i - 1;\r\n\t\t\tvar c = ( tubularSegments + 1 ) * ( j - 1 ) + i;\r\n\t\t\tvar d = ( tubularSegments + 1 ) * j + i;\r\n\r\n\t\t\tvar face = new THREE.Face3( a, b, d, [ normals[ a ].clone(), normals[ b ].clone(), normals[ d ].clone() ] );\r\n\t\t\tthis.faces.push( face );\r\n\t\t\tthis.faceVertexUvs[ 0 ].push( [ uvs[ a ].clone(), uvs[ b ].clone(), uvs[ d ].clone() ] );\r\n\r\n\t\t\tface = new THREE.Face3( b, c, d, [ normals[ b ].clone(), normals[ c ].clone(), normals[ d ].clone() ] );\r\n\t\t\tthis.faces.push( face );\r\n\t\t\tthis.faceVertexUvs[ 0 ].push( [ uvs[ b ].clone(), uvs[ c ].clone(), uvs[ d ].clone() ] );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tthis.computeFaceNormals();\r\n\r\n};\r\n\r\nTHREE.TorusGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\nTHREE.TorusGeometry.prototype.constructor = THREE.TorusGeometry;\r\n\r\n// File:src/extras/geometries/TorusKnotGeometry.js\r\n\r\n/**\r\n * @author oosmoxiecode\r\n * based on http://code.google.com/p/away3d/source/browse/trunk/fp10/Away3D/src/away3d/primitives/TorusKnot.as?spec=svn2473&r=2473\r\n */\r\n\r\nTHREE.TorusKnotGeometry = function ( radius, tube, radialSegments, tubularSegments, p, q, heightScale ) {\r\n\r\n\tTHREE.Geometry.call( this );\r\n\r\n\tthis.type = 'TorusKnotGeometry';\r\n\r\n\tthis.parameters = {\r\n\t\tradius: radius,\r\n\t\ttube: tube,\r\n\t\tradialSegments: radialSegments,\r\n\t\ttubularSegments: tubularSegments,\r\n\t\tp: p,\r\n\t\tq: q,\r\n\t\theightScale: heightScale\r\n\t};\r\n\r\n\tradius = radius || 100;\r\n\ttube = tube || 40;\r\n\tradialSegments = radialSegments || 64;\r\n\ttubularSegments = tubularSegments || 8;\r\n\tp = p || 2;\r\n\tq = q || 3;\r\n\theightScale = heightScale || 1;\r\n\t\r\n\tvar grid = new Array( radialSegments );\r\n\tvar tang = new THREE.Vector3();\r\n\tvar n = new THREE.Vector3();\r\n\tvar bitan = new THREE.Vector3();\r\n\r\n\tfor ( var i = 0; i < radialSegments; ++ i ) {\r\n\r\n\t\tgrid[ i ] = new Array( tubularSegments );\r\n\t\tvar u = i / radialSegments * 2 * p * Math.PI;\r\n\t\tvar p1 = getPos( u, q, p, radius, heightScale );\r\n\t\tvar p2 = getPos( u + 0.01, q, p, radius, heightScale );\r\n\t\ttang.subVectors( p2, p1 );\r\n\t\tn.addVectors( p2, p1 );\r\n\r\n\t\tbitan.crossVectors( tang, n );\r\n\t\tn.crossVectors( bitan, tang );\r\n\t\tbitan.normalize();\r\n\t\tn.normalize();\r\n\r\n\t\tfor ( var j = 0; j < tubularSegments; ++ j ) {\r\n\r\n\t\t\tvar v = j / tubularSegments * 2 * Math.PI;\r\n\t\t\tvar cx = - tube * Math.cos( v ); // TODO: Hack: Negating it so it faces outside.\r\n\t\t\tvar cy = tube * Math.sin( v );\r\n\r\n\t\t\tvar pos = new THREE.Vector3();\r\n\t\t\tpos.x = p1.x + cx * n.x + cy * bitan.x;\r\n\t\t\tpos.y = p1.y + cx * n.y + cy * bitan.y;\r\n\t\t\tpos.z = p1.z + cx * n.z + cy * bitan.z;\r\n\r\n\t\t\tgrid[ i ][ j ] = this.vertices.push( pos ) - 1;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfor ( var i = 0; i < radialSegments; ++ i ) {\r\n\r\n\t\tfor ( var j = 0; j < tubularSegments; ++ j ) {\r\n\r\n\t\t\tvar ip = ( i + 1 ) % radialSegments;\r\n\t\t\tvar jp = ( j + 1 ) % tubularSegments;\r\n\r\n\t\t\tvar a = grid[ i ][ j ];\r\n\t\t\tvar b = grid[ ip ][ j ];\r\n\t\t\tvar c = grid[ ip ][ jp ];\r\n\t\t\tvar d = grid[ i ][ jp ];\r\n\r\n\t\t\tvar uva = new THREE.Vector2( i / radialSegments, j / tubularSegments );\r\n\t\t\tvar uvb = new THREE.Vector2( ( i + 1 ) / radialSegments, j / tubularSegments );\r\n\t\t\tvar uvc = new THREE.Vector2( ( i + 1 ) / radialSegments, ( j + 1 ) / tubularSegments );\r\n\t\t\tvar uvd = new THREE.Vector2( i / radialSegments, ( j + 1 ) / tubularSegments );\r\n\r\n\t\t\tthis.faces.push( new THREE.Face3( a, b, d ) );\r\n\t\t\tthis.faceVertexUvs[ 0 ].push( [ uva, uvb, uvd ] );\r\n\r\n\t\t\tthis.faces.push( new THREE.Face3( b, c, d ) );\r\n\t\t\tthis.faceVertexUvs[ 0 ].push( [ uvb.clone(), uvc, uvd.clone() ] );\r\n\r\n\t\t}\r\n\t}\r\n\r\n\tthis.computeFaceNormals();\r\n\tthis.computeVertexNormals();\r\n\r\n\tfunction getPos( u, in_q, in_p, radius, heightScale ) {\r\n\r\n\t\tvar cu = Math.cos( u );\r\n\t\tvar su = Math.sin( u );\r\n\t\tvar quOverP = in_q / in_p * u;\r\n\t\tvar cs = Math.cos( quOverP );\r\n\r\n\t\tvar tx = radius * ( 2 + cs ) * 0.5 * cu;\r\n\t\tvar ty = radius * ( 2 + cs ) * su * 0.5;\r\n\t\tvar tz = heightScale * radius * Math.sin( quOverP ) * 0.5;\r\n\r\n\t\treturn new THREE.Vector3( tx, ty, tz );\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.TorusKnotGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\nTHREE.TorusKnotGeometry.prototype.constructor = THREE.TorusKnotGeometry;\r\n\r\n// File:src/extras/geometries/TubeGeometry.js\r\n\r\n/**\r\n * @author WestLangley / https://github.com/WestLangley\r\n * @author zz85 / https://github.com/zz85\r\n * @author miningold / https://github.com/miningold\r\n * @author jonobr1 / https://github.com/jonobr1\r\n *\r\n * Modified from the TorusKnotGeometry by @oosmoxiecode\r\n *\r\n * Creates a tube which extrudes along a 3d spline\r\n *\r\n * Uses parallel transport frames as described in\r\n * http://www.cs.indiana.edu/pub/techreports/TR425.pdf\r\n */\r\n\r\nTHREE.TubeGeometry = function ( path, segments, radius, radialSegments, closed, taper ) {\r\n\r\n\tTHREE.Geometry.call( this );\r\n\r\n\tthis.type = 'TubeGeometry';\r\n\r\n\tthis.parameters = {\r\n\t\tpath: path,\r\n\t\tsegments: segments,\r\n\t\tradius: radius,\r\n\t\tradialSegments: radialSegments,\r\n\t\tclosed: closed\r\n\t};\r\n\r\n\tsegments = segments || 64;\r\n\tradius = radius || 1;\r\n\tradialSegments = radialSegments || 8;\r\n\tclosed = closed || false;\r\n\ttaper = taper || THREE.TubeGeometry.NoTaper;\r\n\r\n\tvar grid = [];\r\n\r\n\tvar scope = this,\r\n\r\n\t\ttangent,\r\n\t\tnormal,\r\n\t\tbinormal,\r\n\r\n\t\tnumpoints = segments + 1,\r\n\r\n\t\tu, v, r,\r\n\r\n\t\tcx, cy,\r\n\t\tpos, pos2 = new THREE.Vector3(),\r\n\t\ti, j,\r\n\t\tip, jp,\r\n\t\ta, b, c, d,\r\n\t\tuva, uvb, uvc, uvd;\r\n\r\n\tvar frames = new THREE.TubeGeometry.FrenetFrames( path, segments, closed ),\r\n\t\ttangents = frames.tangents,\r\n\t\tnormals = frames.normals,\r\n\t\tbinormals = frames.binormals;\r\n\r\n\t// proxy internals\r\n\tthis.tangents = tangents;\r\n\tthis.normals = normals;\r\n\tthis.binormals = binormals;\r\n\r\n\tfunction vert( x, y, z ) {\r\n\r\n\t\treturn scope.vertices.push( new THREE.Vector3( x, y, z ) ) - 1;\r\n\r\n\t}\r\n\r\n\t// consruct the grid\r\n\r\n\tfor ( i = 0; i < numpoints; i ++ ) {\r\n\r\n\t\tgrid[ i ] = [];\r\n\r\n\t\tu = i / ( numpoints - 1 );\r\n\r\n\t\tpos = path.getPointAt( u );\r\n\r\n\t\ttangent = tangents[ i ];\r\n\t\tnormal = normals[ i ];\r\n\t\tbinormal = binormals[ i ];\r\n\r\n\t\tr = radius * taper( u );\r\n\r\n\t\tfor ( j = 0; j < radialSegments; j ++ ) {\r\n\r\n\t\t\tv = j / radialSegments * 2 * Math.PI;\r\n\r\n\t\t\tcx = - r * Math.cos( v ); // TODO: Hack: Negating it so it faces outside.\r\n\t\t\tcy = r * Math.sin( v );\r\n\r\n\t\t\tpos2.copy( pos );\r\n\t\t\tpos2.x += cx * normal.x + cy * binormal.x;\r\n\t\t\tpos2.y += cx * normal.y + cy * binormal.y;\r\n\t\t\tpos2.z += cx * normal.z + cy * binormal.z;\r\n\r\n\t\t\tgrid[ i ][ j ] = vert( pos2.x, pos2.y, pos2.z );\r\n\r\n\t\t}\r\n\t}\r\n\r\n\r\n\t// construct the mesh\r\n\r\n\tfor ( i = 0; i < segments; i ++ ) {\r\n\r\n\t\tfor ( j = 0; j < radialSegments; j ++ ) {\r\n\r\n\t\t\tip = ( closed ) ? (i + 1) % segments : i + 1;\r\n\t\t\tjp = (j + 1) % radialSegments;\r\n\r\n\t\t\ta = grid[ i ][ j ];\t\t// *** NOT NECESSARILY PLANAR ! ***\r\n\t\t\tb = grid[ ip ][ j ];\r\n\t\t\tc = grid[ ip ][ jp ];\r\n\t\t\td = grid[ i ][ jp ];\r\n\r\n\t\t\tuva = new THREE.Vector2( i / segments, j / radialSegments );\r\n\t\t\tuvb = new THREE.Vector2( ( i + 1 ) / segments, j / radialSegments );\r\n\t\t\tuvc = new THREE.Vector2( ( i + 1 ) / segments, ( j + 1 ) / radialSegments );\r\n\t\t\tuvd = new THREE.Vector2( i / segments, ( j + 1 ) / radialSegments );\r\n\r\n\t\t\tthis.faces.push( new THREE.Face3( a, b, d ) );\r\n\t\t\tthis.faceVertexUvs[ 0 ].push( [ uva, uvb, uvd ] );\r\n\r\n\t\t\tthis.faces.push( new THREE.Face3( b, c, d ) );\r\n\t\t\tthis.faceVertexUvs[ 0 ].push( [ uvb.clone(), uvc, uvd.clone() ] );\r\n\r\n\t\t}\r\n\t}\r\n\r\n\tthis.computeFaceNormals();\r\n\tthis.computeVertexNormals();\r\n\r\n};\r\n\r\nTHREE.TubeGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\nTHREE.TubeGeometry.prototype.constructor = THREE.TubeGeometry;\r\n\r\nTHREE.TubeGeometry.NoTaper = function ( u ) {\r\n\r\n\treturn 1;\r\n\r\n};\r\n\r\nTHREE.TubeGeometry.SinusoidalTaper = function ( u ) {\r\n\r\n\treturn Math.sin( Math.PI * u );\r\n\r\n};\r\n\r\n// For computing of Frenet frames, exposing the tangents, normals and binormals the spline\r\nTHREE.TubeGeometry.FrenetFrames = function ( path, segments, closed ) {\r\n\r\n\tvar\tnormal = new THREE.Vector3(),\r\n\r\n\t\ttangents = [],\r\n\t\tnormals = [],\r\n\t\tbinormals = [],\r\n\r\n\t\tvec = new THREE.Vector3(),\r\n\t\tmat = new THREE.Matrix4(),\r\n\r\n\t\tnumpoints = segments + 1,\r\n\t\ttheta,\r\n\t\tepsilon = 0.0001,\r\n\t\tsmallest,\r\n\r\n\t\ttx, ty, tz,\r\n\t\ti, u;\r\n\r\n\r\n\t// expose internals\r\n\tthis.tangents = tangents;\r\n\tthis.normals = normals;\r\n\tthis.binormals = binormals;\r\n\r\n\t// compute the tangent vectors for each segment on the path\r\n\r\n\tfor ( i = 0; i < numpoints; i ++ ) {\r\n\r\n\t\tu = i / ( numpoints - 1 );\r\n\r\n\t\ttangents[ i ] = path.getTangentAt( u );\r\n\t\ttangents[ i ].normalize();\r\n\r\n\t}\r\n\r\n\tinitialNormal3();\r\n\r\n\t/*\r\n\tfunction initialNormal1(lastBinormal) {\r\n\t\t// fixed start binormal. Has dangers of 0 vectors\r\n\t\tnormals[ 0 ] = new THREE.Vector3();\r\n\t\tbinormals[ 0 ] = new THREE.Vector3();\r\n\t\tif (lastBinormal===undefined) lastBinormal = new THREE.Vector3( 0, 0, 1 );\r\n\t\tnormals[ 0 ].crossVectors( lastBinormal, tangents[ 0 ] ).normalize();\r\n\t\tbinormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] ).normalize();\r\n\t}\r\n\r\n\tfunction initialNormal2() {\r\n\r\n\t\t// This uses the Frenet-Serret formula for deriving binormal\r\n\t\tvar t2 = path.getTangentAt( epsilon );\r\n\r\n\t\tnormals[ 0 ] = new THREE.Vector3().subVectors( t2, tangents[ 0 ] ).normalize();\r\n\t\tbinormals[ 0 ] = new THREE.Vector3().crossVectors( tangents[ 0 ], normals[ 0 ] );\r\n\r\n\t\tnormals[ 0 ].crossVectors( binormals[ 0 ], tangents[ 0 ] ).normalize(); // last binormal x tangent\r\n\t\tbinormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] ).normalize();\r\n\r\n\t}\r\n\t*/\r\n\r\n\tfunction initialNormal3() {\r\n\t\t// select an initial normal vector perpenicular to the first tangent vector,\r\n\t\t// and in the direction of the smallest tangent xyz component\r\n\r\n\t\tnormals[ 0 ] = new THREE.Vector3();\r\n\t\tbinormals[ 0 ] = new THREE.Vector3();\r\n\t\tsmallest = Number.MAX_VALUE;\r\n\t\ttx = Math.abs( tangents[ 0 ].x );\r\n\t\tty = Math.abs( tangents[ 0 ].y );\r\n\t\ttz = Math.abs( tangents[ 0 ].z );\r\n\r\n\t\tif ( tx <= smallest ) {\r\n\t\t\tsmallest = tx;\r\n\t\t\tnormal.set( 1, 0, 0 );\r\n\t\t}\r\n\r\n\t\tif ( ty <= smallest ) {\r\n\t\t\tsmallest = ty;\r\n\t\t\tnormal.set( 0, 1, 0 );\r\n\t\t}\r\n\r\n\t\tif ( tz <= smallest ) {\r\n\t\t\tnormal.set( 0, 0, 1 );\r\n\t\t}\r\n\r\n\t\tvec.crossVectors( tangents[ 0 ], normal ).normalize();\r\n\r\n\t\tnormals[ 0 ].crossVectors( tangents[ 0 ], vec );\r\n\t\tbinormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] );\r\n\t}\r\n\r\n\r\n\t// compute the slowly-varying normal and binormal vectors for each segment on the path\r\n\r\n\tfor ( i = 1; i < numpoints; i ++ ) {\r\n\r\n\t\tnormals[ i ] = normals[ i - 1 ].clone();\r\n\r\n\t\tbinormals[ i ] = binormals[ i - 1 ].clone();\r\n\r\n\t\tvec.crossVectors( tangents[ i - 1 ], tangents[ i ] );\r\n\r\n\t\tif ( vec.length() > epsilon ) {\r\n\r\n\t\t\tvec.normalize();\r\n\r\n\t\t\ttheta = Math.acos( THREE.Math.clamp( tangents[ i - 1 ].dot( tangents[ i ] ), - 1, 1 ) ); // clamp for floating pt errors\r\n\r\n\t\t\tnormals[ i ].applyMatrix4( mat.makeRotationAxis( vec, theta ) );\r\n\r\n\t\t}\r\n\r\n\t\tbinormals[ i ].crossVectors( tangents[ i ], normals[ i ] );\r\n\r\n\t}\r\n\r\n\r\n\t// if the curve is closed, postprocess the vectors so the first and last normal vectors are the same\r\n\r\n\tif ( closed ) {\r\n\r\n\t\ttheta = Math.acos( THREE.Math.clamp( normals[ 0 ].dot( normals[ numpoints - 1 ] ), - 1, 1 ) );\r\n\t\ttheta /= ( numpoints - 1 );\r\n\r\n\t\tif ( tangents[ 0 ].dot( vec.crossVectors( normals[ 0 ], normals[ numpoints - 1 ] ) ) > 0 ) {\r\n\r\n\t\t\ttheta = - theta;\r\n\r\n\t\t}\r\n\r\n\t\tfor ( i = 1; i < numpoints; i ++ ) {\r\n\r\n\t\t\t// twist a little...\r\n\t\t\tnormals[ i ].applyMatrix4( mat.makeRotationAxis( tangents[ i ], theta * i ) );\r\n\t\t\tbinormals[ i ].crossVectors( tangents[ i ], normals[ i ] );\r\n\r\n\t\t}\r\n\r\n\t}\r\n};\r\n\r\n// File:src/extras/geometries/PolyhedronGeometry.js\r\n\r\n/**\r\n * @author clockworkgeek / https://github.com/clockworkgeek\r\n * @author timothypratley / https://github.com/timothypratley\r\n * @author WestLangley / http://github.com/WestLangley\r\n*/\r\n\r\nTHREE.PolyhedronGeometry = function ( vertices, indices, radius, detail ) {\r\n\r\n\tTHREE.Geometry.call( this );\r\n\r\n\tthis.type = 'PolyhedronGeometry';\r\n\r\n\tthis.parameters = {\r\n\t\tvertices: vertices,\r\n\t\tindices: indices,\r\n\t\tradius: radius,\r\n\t\tdetail: detail\r\n\t};\r\n\r\n\tradius = radius || 1;\r\n\tdetail = detail || 0;\r\n\r\n\tvar that = this;\r\n\r\n\tfor ( var i = 0, l = vertices.length; i < l; i += 3 ) {\r\n\r\n\t\tprepare( new THREE.Vector3( vertices[ i ], vertices[ i + 1 ], vertices[ i + 2 ] ) );\r\n\r\n\t}\r\n\r\n\tvar p = this.vertices;\r\n\r\n\tvar faces = [];\r\n\r\n\tfor ( var i = 0, j = 0, l = indices.length; i < l; i += 3, j ++ ) {\r\n\r\n\t\tvar v1 = p[ indices[ i     ] ];\r\n\t\tvar v2 = p[ indices[ i + 1 ] ];\r\n\t\tvar v3 = p[ indices[ i + 2 ] ];\r\n\r\n\t\tfaces[ j ] = new THREE.Face3( v1.index, v2.index, v3.index, [ v1.clone(), v2.clone(), v3.clone() ] );\r\n\r\n\t}\r\n\r\n\tvar centroid = new THREE.Vector3();\r\n\r\n\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\r\n\r\n\t\tsubdivide( faces[ i ], detail );\r\n\r\n\t}\r\n\r\n\r\n\t// Handle case when face straddles the seam\r\n\r\n\tfor ( var i = 0, l = this.faceVertexUvs[ 0 ].length; i < l; i ++ ) {\r\n\r\n\t\tvar uvs = this.faceVertexUvs[ 0 ][ i ];\r\n\r\n\t\tvar x0 = uvs[ 0 ].x;\r\n\t\tvar x1 = uvs[ 1 ].x;\r\n\t\tvar x2 = uvs[ 2 ].x;\r\n\r\n\t\tvar max = Math.max( x0, Math.max( x1, x2 ) );\r\n\t\tvar min = Math.min( x0, Math.min( x1, x2 ) );\r\n\r\n\t\tif ( max > 0.9 && min < 0.1 ) { // 0.9 is somewhat arbitrary\r\n\r\n\t\t\tif ( x0 < 0.2 ) uvs[ 0 ].x += 1;\r\n\t\t\tif ( x1 < 0.2 ) uvs[ 1 ].x += 1;\r\n\t\t\tif ( x2 < 0.2 ) uvs[ 2 ].x += 1;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\r\n\t// Apply radius\r\n\r\n\tfor ( var i = 0, l = this.vertices.length; i < l; i ++ ) {\r\n\r\n\t\tthis.vertices[ i ].multiplyScalar( radius );\r\n\r\n\t}\r\n\r\n\r\n\t// Merge vertices\r\n\r\n\tthis.mergeVertices();\r\n\r\n\tthis.computeFaceNormals();\r\n\r\n\tthis.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );\r\n\r\n\r\n\t// Project vector onto sphere's surface\r\n\r\n\tfunction prepare( vector ) {\r\n\r\n\t\tvar vertex = vector.normalize().clone();\r\n\t\tvertex.index = that.vertices.push( vertex ) - 1;\r\n\r\n\t\t// Texture coords are equivalent to map coords, calculate angle and convert to fraction of a circle.\r\n\r\n\t\tvar u = azimuth( vector ) / 2 / Math.PI + 0.5;\r\n\t\tvar v = inclination( vector ) / Math.PI + 0.5;\r\n\t\tvertex.uv = new THREE.Vector2( u, 1 - v );\r\n\r\n\t\treturn vertex;\r\n\r\n\t}\r\n\r\n\r\n\t// Approximate a curved face with recursively sub-divided triangles.\r\n\r\n\tfunction make( v1, v2, v3 ) {\r\n\r\n\t\tvar face = new THREE.Face3( v1.index, v2.index, v3.index, [ v1.clone(), v2.clone(), v3.clone() ] );\r\n\t\tthat.faces.push( face );\r\n\r\n\t\tcentroid.copy( v1 ).add( v2 ).add( v3 ).divideScalar( 3 );\r\n\r\n\t\tvar azi = azimuth( centroid );\r\n\r\n\t\tthat.faceVertexUvs[ 0 ].push( [\r\n\t\t\tcorrectUV( v1.uv, v1, azi ),\r\n\t\t\tcorrectUV( v2.uv, v2, azi ),\r\n\t\t\tcorrectUV( v3.uv, v3, azi )\r\n\t\t] );\r\n\r\n\t}\r\n\r\n\r\n\t// Analytically subdivide a face to the required detail level.\r\n\r\n\tfunction subdivide( face, detail ) {\r\n\r\n\t\tvar cols = Math.pow(2, detail);\r\n\t\tvar a = prepare( that.vertices[ face.a ] );\r\n\t\tvar b = prepare( that.vertices[ face.b ] );\r\n\t\tvar c = prepare( that.vertices[ face.c ] );\r\n\t\tvar v = [];\r\n\r\n\t\t// Construct all of the vertices for this subdivision.\r\n\r\n\t\tfor ( var i = 0 ; i <= cols; i ++ ) {\r\n\r\n\t\t\tv[ i ] = [];\r\n\r\n\t\t\tvar aj = prepare( a.clone().lerp( c, i / cols ) );\r\n\t\t\tvar bj = prepare( b.clone().lerp( c, i / cols ) );\r\n\t\t\tvar rows = cols - i;\r\n\r\n\t\t\tfor ( var j = 0; j <= rows; j ++) {\r\n\r\n\t\t\t\tif ( j == 0 && i == cols ) {\r\n\r\n\t\t\t\t\tv[ i ][ j ] = aj;\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tv[ i ][ j ] = prepare( aj.clone().lerp( bj, j / rows ) );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// Construct all of the faces.\r\n\r\n\t\tfor ( var i = 0; i < cols ; i ++ ) {\r\n\r\n\t\t\tfor ( var j = 0; j < 2 * (cols - i) - 1; j ++ ) {\r\n\r\n\t\t\t\tvar k = Math.floor( j / 2 );\r\n\r\n\t\t\t\tif ( j % 2 == 0 ) {\r\n\r\n\t\t\t\t\tmake(\r\n\t\t\t\t\t\tv[ i ][ k + 1],\r\n\t\t\t\t\t\tv[ i + 1 ][ k ],\r\n\t\t\t\t\t\tv[ i ][ k ]\r\n\t\t\t\t\t);\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tmake(\r\n\t\t\t\t\t\tv[ i ][ k + 1 ],\r\n\t\t\t\t\t\tv[ i + 1][ k + 1],\r\n\t\t\t\t\t\tv[ i + 1 ][ k ]\r\n\t\t\t\t\t);\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\r\n\t// Angle around the Y axis, counter-clockwise when looking from above.\r\n\r\n\tfunction azimuth( vector ) {\r\n\r\n\t\treturn Math.atan2( vector.z, - vector.x );\r\n\r\n\t}\r\n\r\n\r\n\t// Angle above the XZ plane.\r\n\r\n\tfunction inclination( vector ) {\r\n\r\n\t\treturn Math.atan2( - vector.y, Math.sqrt( ( vector.x * vector.x ) + ( vector.z * vector.z ) ) );\r\n\r\n\t}\r\n\r\n\r\n\t// Texture fixing helper. Spheres have some odd behaviours.\r\n\r\n\tfunction correctUV( uv, vector, azimuth ) {\r\n\r\n\t\tif ( ( azimuth < 0 ) && ( uv.x === 1 ) ) uv = new THREE.Vector2( uv.x - 1, uv.y );\r\n\t\tif ( ( vector.x === 0 ) && ( vector.z === 0 ) ) uv = new THREE.Vector2( azimuth / 2 / Math.PI + 0.5, uv.y );\r\n\t\treturn uv.clone();\r\n\r\n\t}\r\n\r\n\r\n};\r\n\r\nTHREE.PolyhedronGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\nTHREE.PolyhedronGeometry.prototype.constructor = THREE.PolyhedronGeometry;\r\n\r\n// File:src/extras/geometries/DodecahedronGeometry.js\r\n\r\n/**\r\n * @author Abe Pazos / https://hamoid.com\r\n */\r\n\r\nTHREE.DodecahedronGeometry = function ( radius, detail ) {\r\n\r\n\tthis.parameters = {\r\n\t\tradius: radius,\r\n\t\tdetail: detail\r\n\t};\r\n\r\n\tvar t = ( 1 + Math.sqrt( 5 ) ) / 2;\r\n\tvar r = 1 / t;\r\n\r\n\tvar vertices = [\r\n\r\n\t\t// (±1, ±1, ±1)\r\n\t\t-1, -1, -1,    -1, -1,  1,\r\n\t\t-1,  1, -1,    -1,  1,  1,\r\n\t\t 1, -1, -1,     1, -1,  1,\r\n\t\t 1,  1, -1,     1,  1,  1,\r\n\r\n\t\t// (0, ±1/φ, ±φ)\r\n\t\t 0, -r, -t,     0, -r,  t,\r\n\t\t 0,  r, -t,     0,  r,  t,\r\n\r\n\t\t// (±1/φ, ±φ, 0)\r\n\t\t-r, -t,  0,    -r,  t,  0,\r\n\t\t r, -t,  0,     r,  t,  0,\r\n\r\n\t\t// (±φ, 0, ±1/φ)\r\n\t\t-t,  0, -r,     t,  0, -r,\r\n\t\t-t,  0,  r,     t,  0,  r\r\n\t];\r\n\r\n\tvar indices = [\r\n\t\t 3, 11,  7,      3,  7, 15,      3, 15, 13,\r\n\t\t 7, 19, 17,      7, 17,  6,      7,  6, 15,\r\n\t\t17,  4,  8,     17,  8, 10,     17, 10,  6,\r\n\t\t 8,  0, 16,      8, 16,  2,      8,  2, 10,\r\n\t\t 0, 12,  1,      0,  1, 18,      0, 18, 16,\r\n\t\t 6, 10,  2,      6,  2, 13,      6, 13, 15,\r\n\t\t 2, 16, 18,      2, 18,  3,      2,  3, 13,\r\n\t\t18,  1,  9,     18,  9, 11,     18, 11,  3,\r\n\t\t 4, 14, 12,      4, 12,  0,      4,  0,  8,\r\n\t\t11,  9,  5,     11,  5, 19,     11, 19,  7,\r\n\t\t19,  5, 14,     19, 14,  4,     19,  4, 17,\r\n\t\t 1, 12, 14,      1, 14,  5,      1,  5,  9\r\n\t];\r\n\r\n\tTHREE.PolyhedronGeometry.call( this, vertices, indices, radius, detail );\r\n\r\n};\r\n\r\nTHREE.DodecahedronGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\nTHREE.DodecahedronGeometry.prototype.constructor = THREE.DodecahedronGeometry;\r\n\r\n// File:src/extras/geometries/IcosahedronGeometry.js\r\n\r\n/**\r\n * @author timothypratley / https://github.com/timothypratley\r\n */\r\n\r\nTHREE.IcosahedronGeometry = function ( radius, detail ) {\r\n\r\n\tvar t = ( 1 + Math.sqrt( 5 ) ) / 2;\r\n\r\n\tvar vertices = [\r\n\t\t- 1,  t,  0,    1,  t,  0,   - 1, - t,  0,    1, - t,  0,\r\n\t\t 0, - 1,  t,    0,  1,  t,    0, - 1, - t,    0,  1, - t,\r\n\t\t t,  0, - 1,    t,  0,  1,   - t,  0, - 1,   - t,  0,  1\r\n\t];\r\n\r\n\tvar indices = [\r\n\t\t 0, 11,  5,    0,  5,  1,    0,  1,  7,    0,  7, 10,    0, 10, 11,\r\n\t\t 1,  5,  9,    5, 11,  4,   11, 10,  2,   10,  7,  6,    7,  1,  8,\r\n\t\t 3,  9,  4,    3,  4,  2,    3,  2,  6,    3,  6,  8,    3,  8,  9,\r\n\t\t 4,  9,  5,    2,  4, 11,    6,  2, 10,    8,  6,  7,    9,  8,  1\r\n\t];\r\n\r\n\tTHREE.PolyhedronGeometry.call( this, vertices, indices, radius, detail );\r\n\r\n\tthis.type = 'IcosahedronGeometry';\r\n\r\n\tthis.parameters = {\r\n\t\tradius: radius,\r\n\t\tdetail: detail\r\n\t};\r\n};\r\n\r\nTHREE.IcosahedronGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\nTHREE.IcosahedronGeometry.prototype.constructor = THREE.IcosahedronGeometry;\r\n\r\n// File:src/extras/geometries/OctahedronGeometry.js\r\n\r\n/**\r\n * @author timothypratley / https://github.com/timothypratley\r\n */\r\n\r\nTHREE.OctahedronGeometry = function ( radius, detail ) {\r\n\r\n\tthis.parameters = {\r\n\t\tradius: radius,\r\n\t\tdetail: detail\r\n\t};\r\n\r\n\tvar vertices = [\r\n\t\t1, 0, 0,   - 1, 0, 0,    0, 1, 0,    0,- 1, 0,    0, 0, 1,    0, 0,- 1\r\n\t];\r\n\r\n\tvar indices = [\r\n\t\t0, 2, 4,    0, 4, 3,    0, 3, 5,    0, 5, 2,    1, 2, 5,    1, 5, 3,    1, 3, 4,    1, 4, 2\r\n\t];\r\n\r\n\tTHREE.PolyhedronGeometry.call( this, vertices, indices, radius, detail );\r\n\r\n\tthis.type = 'OctahedronGeometry';\r\n\r\n\tthis.parameters = {\r\n\t\tradius: radius,\r\n\t\tdetail: detail\r\n\t};\r\n};\r\n\r\nTHREE.OctahedronGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\nTHREE.OctahedronGeometry.prototype.constructor = THREE.OctahedronGeometry;\r\n\r\n// File:src/extras/geometries/TetrahedronGeometry.js\r\n\r\n/**\r\n * @author timothypratley / https://github.com/timothypratley\r\n */\r\n\r\nTHREE.TetrahedronGeometry = function ( radius, detail ) {\r\n\r\n\tvar vertices = [\r\n\t\t 1,  1,  1,   - 1, - 1,  1,   - 1,  1, - 1,    1, - 1, - 1\r\n\t];\r\n\r\n\tvar indices = [\r\n\t\t 2,  1,  0,    0,  3,  2,    1,  3,  0,    2,  3,  1\r\n\t];\r\n\r\n\tTHREE.PolyhedronGeometry.call( this, vertices, indices, radius, detail );\r\n\r\n\tthis.type = 'TetrahedronGeometry';\r\n\r\n\tthis.parameters = {\r\n\t\tradius: radius,\r\n\t\tdetail: detail\r\n\t};\r\n\r\n};\r\n\r\nTHREE.TetrahedronGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\nTHREE.TetrahedronGeometry.prototype.constructor = THREE.TetrahedronGeometry;\r\n\r\n// File:src/extras/geometries/ParametricGeometry.js\r\n\r\n/**\r\n * @author zz85 / https://github.com/zz85\r\n * Parametric Surfaces Geometry\r\n * based on the brilliant article by @prideout http://prideout.net/blog/?p=44\r\n *\r\n * new THREE.ParametricGeometry( parametricFunction, uSegments, ySegements );\r\n *\r\n */\r\n\r\nTHREE.ParametricGeometry = function ( func, slices, stacks ) {\r\n\r\n\tTHREE.Geometry.call( this );\r\n\r\n\tthis.type = 'ParametricGeometry';\r\n\r\n\tthis.parameters = {\r\n\t\tfunc: func,\r\n\t\tslices: slices,\r\n\t\tstacks: stacks\r\n\t};\r\n\r\n\tvar verts = this.vertices;\r\n\tvar faces = this.faces;\r\n\tvar uvs = this.faceVertexUvs[ 0 ];\r\n\r\n\tvar i, j, p;\r\n\tvar u, v;\r\n\r\n\tvar sliceCount = slices + 1;\r\n\r\n\tfor ( i = 0; i <= stacks; i ++ ) {\r\n\r\n\t\tv = i / stacks;\r\n\r\n\t\tfor ( j = 0; j <= slices; j ++ ) {\r\n\r\n\t\t\tu = j / slices;\r\n\r\n\t\t\tp = func( u, v );\r\n\t\t\tverts.push( p );\r\n\r\n\t\t}\r\n\t}\r\n\r\n\tvar a, b, c, d;\r\n\tvar uva, uvb, uvc, uvd;\r\n\r\n\tfor ( i = 0; i < stacks; i ++ ) {\r\n\r\n\t\tfor ( j = 0; j < slices; j ++ ) {\r\n\r\n\t\t\ta = i * sliceCount + j;\r\n\t\t\tb = i * sliceCount + j + 1;\r\n\t\t\tc = (i + 1) * sliceCount + j + 1;\r\n\t\t\td = (i + 1) * sliceCount + j;\r\n\r\n\t\t\tuva = new THREE.Vector2( j / slices, i / stacks );\r\n\t\t\tuvb = new THREE.Vector2( ( j + 1 ) / slices, i / stacks );\r\n\t\t\tuvc = new THREE.Vector2( ( j + 1 ) / slices, ( i + 1 ) / stacks );\r\n\t\t\tuvd = new THREE.Vector2( j / slices, ( i + 1 ) / stacks );\r\n\r\n\t\t\tfaces.push( new THREE.Face3( a, b, d ) );\r\n\t\t\tuvs.push( [ uva, uvb, uvd ] );\r\n\r\n\t\t\tfaces.push( new THREE.Face3( b, c, d ) );\r\n\t\t\tuvs.push( [ uvb.clone(), uvc, uvd.clone() ] );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// console.log(this);\r\n\r\n\t// magic bullet\r\n\t// var diff = this.mergeVertices();\r\n\t// console.log('removed ', diff, ' vertices by merging');\r\n\r\n\tthis.computeFaceNormals();\r\n\tthis.computeVertexNormals();\r\n\r\n};\r\n\r\nTHREE.ParametricGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\nTHREE.ParametricGeometry.prototype.constructor = THREE.ParametricGeometry;\r\n\r\n// File:src/extras/helpers/AxisHelper.js\r\n\r\n/**\r\n * @author sroucheray / http://sroucheray.org/\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.AxisHelper = function ( size ) {\r\n\r\n\tsize = size || 1;\r\n\r\n\tvar vertices = new Float32Array( [\r\n\t\t0, 0, 0,  size, 0, 0,\r\n\t\t0, 0, 0,  0, size, 0,\r\n\t\t0, 0, 0,  0, 0, size\r\n\t] );\r\n\r\n\tvar colors = new Float32Array( [\r\n\t\t1, 0, 0,  1, 0.6, 0,\r\n\t\t0, 1, 0,  0.6, 1, 0,\r\n\t\t0, 0, 1,  0, 0.6, 1\r\n\t] );\r\n\r\n\tvar geometry = new THREE.BufferGeometry();\r\n\tgeometry.addAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );\r\n\tgeometry.addAttribute( 'color', new THREE.BufferAttribute( colors, 3 ) );\r\n\r\n\tvar material = new THREE.LineBasicMaterial( { vertexColors: THREE.VertexColors } );\r\n\r\n\tTHREE.Line.call( this, geometry, material, THREE.LinePieces );\r\n\r\n};\r\n\r\nTHREE.AxisHelper.prototype = Object.create( THREE.Line.prototype );\r\nTHREE.AxisHelper.prototype.constructor = THREE.AxisHelper;\r\n\r\n// File:src/extras/helpers/ArrowHelper.js\r\n\r\n/**\r\n * @author WestLangley / http://github.com/WestLangley\r\n * @author zz85 / http://github.com/zz85\r\n * @author bhouston / http://exocortex.com\r\n *\r\n * Creates an arrow for visualizing directions\r\n *\r\n * Parameters:\r\n *  dir - Vector3\r\n *  origin - Vector3\r\n *  length - Number\r\n *  color - color in hex value\r\n *  headLength - Number\r\n *  headWidth - Number\r\n */\r\n\r\nTHREE.ArrowHelper = ( function () {\r\n\r\n\tvar lineGeometry = new THREE.Geometry();\r\n\tlineGeometry.vertices.push( new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( 0, 1, 0 ) );\r\n\r\n\tvar coneGeometry = new THREE.CylinderGeometry( 0, 0.5, 1, 5, 1 );\r\n\tconeGeometry.applyMatrix( new THREE.Matrix4().makeTranslation( 0, - 0.5, 0 ) );\r\n\r\n\treturn function ( dir, origin, length, color, headLength, headWidth ) {\r\n\r\n\t\t// dir is assumed to be normalized\r\n\r\n\t\tTHREE.Object3D.call( this );\r\n\r\n\t\tif ( color === undefined ) color = 0xffff00;\r\n\t\tif ( length === undefined ) length = 1;\r\n\t\tif ( headLength === undefined ) headLength = 0.2 * length;\r\n\t\tif ( headWidth === undefined ) headWidth = 0.2 * headLength;\r\n\r\n\t\tthis.position.copy( origin );\r\n\r\n\t\tthis.line = new THREE.Line( lineGeometry, new THREE.LineBasicMaterial( { color: color } ) );\r\n\t\tthis.line.matrixAutoUpdate = false;\r\n\t\tthis.add( this.line );\r\n\r\n\t\tthis.cone = new THREE.Mesh( coneGeometry, new THREE.MeshBasicMaterial( { color: color } ) );\r\n\t\tthis.cone.matrixAutoUpdate = false;\r\n\t\tthis.add( this.cone );\r\n\r\n\t\tthis.setDirection( dir );\r\n\t\tthis.setLength( length, headLength, headWidth );\r\n\r\n\t}\r\n\r\n}() );\r\n\r\nTHREE.ArrowHelper.prototype = Object.create( THREE.Object3D.prototype );\r\nTHREE.ArrowHelper.prototype.constructor = THREE.ArrowHelper;\r\n\r\nTHREE.ArrowHelper.prototype.setDirection = ( function () {\r\n\r\n\tvar axis = new THREE.Vector3();\r\n\tvar radians;\r\n\r\n\treturn function ( dir ) {\r\n\r\n\t\t// dir is assumed to be normalized\r\n\r\n\t\tif ( dir.y > 0.99999 ) {\r\n\r\n\t\t\tthis.quaternion.set( 0, 0, 0, 1 );\r\n\r\n\t\t} else if ( dir.y < - 0.99999 ) {\r\n\r\n\t\t\tthis.quaternion.set( 1, 0, 0, 0 );\r\n\r\n\t\t} else {\r\n\r\n\t\t\taxis.set( dir.z, 0, - dir.x ).normalize();\r\n\r\n\t\t\tradians = Math.acos( dir.y );\r\n\r\n\t\t\tthis.quaternion.setFromAxisAngle( axis, radians );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n}() );\r\n\r\nTHREE.ArrowHelper.prototype.setLength = function ( length, headLength, headWidth ) {\r\n\r\n\tif ( headLength === undefined ) headLength = 0.2 * length;\r\n\tif ( headWidth === undefined ) headWidth = 0.2 * headLength;\r\n\r\n\tthis.line.scale.set( 1, length - headLength, 1 );\r\n\tthis.line.updateMatrix();\r\n\r\n\tthis.cone.scale.set( headWidth, headLength, headWidth );\r\n\tthis.cone.position.y = length;\r\n\tthis.cone.updateMatrix();\r\n\r\n};\r\n\r\nTHREE.ArrowHelper.prototype.setColor = function ( color ) {\r\n\r\n\tthis.line.material.color.set( color );\r\n\tthis.cone.material.color.set( color );\r\n\r\n};\r\n\r\n// File:src/extras/helpers/BoxHelper.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.BoxHelper = function ( object ) {\r\n\r\n\tvar geometry = new THREE.BufferGeometry();\r\n\tgeometry.addAttribute( 'position', new THREE.BufferAttribute( new Float32Array( 72 ), 3 ) );\r\n\r\n\tTHREE.Line.call( this, geometry, new THREE.LineBasicMaterial( { color: 0xffff00 } ), THREE.LinePieces );\r\n\r\n\tif ( object !== undefined ) {\r\n\r\n\t\tthis.update( object );\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.BoxHelper.prototype = Object.create( THREE.Line.prototype );\r\nTHREE.BoxHelper.prototype.constructor = THREE.BoxHelper;\r\n\r\nTHREE.BoxHelper.prototype.update = function ( object ) {\r\n\r\n\tvar geometry = object.geometry;\r\n\r\n\tif ( geometry.boundingBox === null ) {\r\n\r\n\t\tgeometry.computeBoundingBox();\r\n\r\n\t}\r\n\r\n\tvar min = geometry.boundingBox.min;\r\n\tvar max = geometry.boundingBox.max;\r\n\r\n\t/*\r\n\t  5____4\r\n\t1/___0/|\r\n\t| 6__|_7\r\n\t2/___3/\r\n\r\n\t0: max.x, max.y, max.z\r\n\t1: min.x, max.y, max.z\r\n\t2: min.x, min.y, max.z\r\n\t3: max.x, min.y, max.z\r\n\t4: max.x, max.y, min.z\r\n\t5: min.x, max.y, min.z\r\n\t6: min.x, min.y, min.z\r\n\t7: max.x, min.y, min.z\r\n\t*/\r\n\r\n\tvar vertices = this.geometry.attributes.position.array;\r\n\r\n\tvertices[  0 ] = max.x; vertices[  1 ] = max.y; vertices[  2 ] = max.z;\r\n\tvertices[  3 ] = min.x; vertices[  4 ] = max.y; vertices[  5 ] = max.z;\r\n\r\n\tvertices[  6 ] = min.x; vertices[  7 ] = max.y; vertices[  8 ] = max.z;\r\n\tvertices[  9 ] = min.x; vertices[ 10 ] = min.y; vertices[ 11 ] = max.z;\r\n\r\n\tvertices[ 12 ] = min.x; vertices[ 13 ] = min.y; vertices[ 14 ] = max.z;\r\n\tvertices[ 15 ] = max.x; vertices[ 16 ] = min.y; vertices[ 17 ] = max.z;\r\n\r\n\tvertices[ 18 ] = max.x; vertices[ 19 ] = min.y; vertices[ 20 ] = max.z;\r\n\tvertices[ 21 ] = max.x; vertices[ 22 ] = max.y; vertices[ 23 ] = max.z;\r\n\r\n\t//\r\n\r\n\tvertices[ 24 ] = max.x; vertices[ 25 ] = max.y; vertices[ 26 ] = min.z;\r\n\tvertices[ 27 ] = min.x; vertices[ 28 ] = max.y; vertices[ 29 ] = min.z;\r\n\r\n\tvertices[ 30 ] = min.x; vertices[ 31 ] = max.y; vertices[ 32 ] = min.z;\r\n\tvertices[ 33 ] = min.x; vertices[ 34 ] = min.y; vertices[ 35 ] = min.z;\r\n\r\n\tvertices[ 36 ] = min.x; vertices[ 37 ] = min.y; vertices[ 38 ] = min.z;\r\n\tvertices[ 39 ] = max.x; vertices[ 40 ] = min.y; vertices[ 41 ] = min.z;\r\n\r\n\tvertices[ 42 ] = max.x; vertices[ 43 ] = min.y; vertices[ 44 ] = min.z;\r\n\tvertices[ 45 ] = max.x; vertices[ 46 ] = max.y; vertices[ 47 ] = min.z;\r\n\r\n\t//\r\n\r\n\tvertices[ 48 ] = max.x; vertices[ 49 ] = max.y; vertices[ 50 ] = max.z;\r\n\tvertices[ 51 ] = max.x; vertices[ 52 ] = max.y; vertices[ 53 ] = min.z;\r\n\r\n\tvertices[ 54 ] = min.x; vertices[ 55 ] = max.y; vertices[ 56 ] = max.z;\r\n\tvertices[ 57 ] = min.x; vertices[ 58 ] = max.y; vertices[ 59 ] = min.z;\r\n\r\n\tvertices[ 60 ] = min.x; vertices[ 61 ] = min.y; vertices[ 62 ] = max.z;\r\n\tvertices[ 63 ] = min.x; vertices[ 64 ] = min.y; vertices[ 65 ] = min.z;\r\n\r\n\tvertices[ 66 ] = max.x; vertices[ 67 ] = min.y; vertices[ 68 ] = max.z;\r\n\tvertices[ 69 ] = max.x; vertices[ 70 ] = min.y; vertices[ 71 ] = min.z;\r\n\r\n\tthis.geometry.attributes.position.needsUpdate = true;\r\n\r\n\tthis.geometry.computeBoundingSphere();\r\n\r\n\tthis.matrix = object.matrixWorld;\r\n\tthis.matrixAutoUpdate = false;\r\n\r\n};\r\n\r\n// File:src/extras/helpers/BoundingBoxHelper.js\r\n\r\n/**\r\n * @author WestLangley / http://github.com/WestLangley\r\n */\r\n\r\n// a helper to show the world-axis-aligned bounding box for an object\r\n\r\nTHREE.BoundingBoxHelper = function ( object, hex ) {\r\n\r\n\tvar color = ( hex !== undefined ) ? hex : 0x888888;\r\n\r\n\tthis.object = object;\r\n\r\n\tthis.box = new THREE.Box3();\r\n\r\n\tTHREE.Mesh.call( this, new THREE.BoxGeometry( 1, 1, 1 ), new THREE.MeshBasicMaterial( { color: color, wireframe: true } ) );\r\n\r\n};\r\n\r\nTHREE.BoundingBoxHelper.prototype = Object.create( THREE.Mesh.prototype );\r\nTHREE.BoundingBoxHelper.prototype.constructor = THREE.BoundingBoxHelper;\r\n\r\nTHREE.BoundingBoxHelper.prototype.update = function () {\r\n\r\n\tthis.box.setFromObject( this.object );\r\n\r\n\tthis.box.size( this.scale );\r\n\r\n\tthis.box.center( this.position );\r\n\r\n};\r\n\r\n// File:src/extras/helpers/CameraHelper.js\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n *\r\n *\t- shows frustum, line of sight and up of the camera\r\n *\t- suitable for fast updates\r\n * \t- based on frustum visualization in lightgl.js shadowmap example\r\n *\t\thttp://evanw.github.com/lightgl.js/tests/shadowmap.html\r\n */\r\n\r\nTHREE.CameraHelper = function ( camera ) {\r\n\r\n\tvar geometry = new THREE.Geometry();\r\n\tvar material = new THREE.LineBasicMaterial( { color: 0xffffff, vertexColors: THREE.FaceColors } );\r\n\r\n\tvar pointMap = {};\r\n\r\n\t// colors\r\n\r\n\tvar hexFrustum = 0xffaa00;\r\n\tvar hexCone = 0xff0000;\r\n\tvar hexUp = 0x00aaff;\r\n\tvar hexTarget = 0xffffff;\r\n\tvar hexCross = 0x333333;\r\n\r\n\t// near\r\n\r\n\taddLine( \"n1\", \"n2\", hexFrustum );\r\n\taddLine( \"n2\", \"n4\", hexFrustum );\r\n\taddLine( \"n4\", \"n3\", hexFrustum );\r\n\taddLine( \"n3\", \"n1\", hexFrustum );\r\n\r\n\t// far\r\n\r\n\taddLine( \"f1\", \"f2\", hexFrustum );\r\n\taddLine( \"f2\", \"f4\", hexFrustum );\r\n\taddLine( \"f4\", \"f3\", hexFrustum );\r\n\taddLine( \"f3\", \"f1\", hexFrustum );\r\n\r\n\t// sides\r\n\r\n\taddLine( \"n1\", \"f1\", hexFrustum );\r\n\taddLine( \"n2\", \"f2\", hexFrustum );\r\n\taddLine( \"n3\", \"f3\", hexFrustum );\r\n\taddLine( \"n4\", \"f4\", hexFrustum );\r\n\r\n\t// cone\r\n\r\n\taddLine( \"p\", \"n1\", hexCone );\r\n\taddLine( \"p\", \"n2\", hexCone );\r\n\taddLine( \"p\", \"n3\", hexCone );\r\n\taddLine( \"p\", \"n4\", hexCone );\r\n\r\n\t// up\r\n\r\n\taddLine( \"u1\", \"u2\", hexUp );\r\n\taddLine( \"u2\", \"u3\", hexUp );\r\n\taddLine( \"u3\", \"u1\", hexUp );\r\n\r\n\t// target\r\n\r\n\taddLine( \"c\", \"t\", hexTarget );\r\n\taddLine( \"p\", \"c\", hexCross );\r\n\r\n\t// cross\r\n\r\n\taddLine( \"cn1\", \"cn2\", hexCross );\r\n\taddLine( \"cn3\", \"cn4\", hexCross );\r\n\r\n\taddLine( \"cf1\", \"cf2\", hexCross );\r\n\taddLine( \"cf3\", \"cf4\", hexCross );\r\n\r\n\tfunction addLine( a, b, hex ) {\r\n\r\n\t\taddPoint( a, hex );\r\n\t\taddPoint( b, hex );\r\n\r\n\t}\r\n\r\n\tfunction addPoint( id, hex ) {\r\n\r\n\t\tgeometry.vertices.push( new THREE.Vector3() );\r\n\t\tgeometry.colors.push( new THREE.Color( hex ) );\r\n\r\n\t\tif ( pointMap[ id ] === undefined ) {\r\n\r\n\t\t\tpointMap[ id ] = [];\r\n\r\n\t\t}\r\n\r\n\t\tpointMap[ id ].push( geometry.vertices.length - 1 );\r\n\r\n\t}\r\n\r\n\tTHREE.Line.call( this, geometry, material, THREE.LinePieces );\r\n\r\n\tthis.camera = camera;\r\n\tthis.matrix = camera.matrixWorld;\r\n\tthis.matrixAutoUpdate = false;\r\n\r\n\tthis.pointMap = pointMap;\r\n\r\n\tthis.update();\r\n\r\n};\r\n\r\nTHREE.CameraHelper.prototype = Object.create( THREE.Line.prototype );\r\nTHREE.CameraHelper.prototype.constructor = THREE.CameraHelper;\r\n\r\nTHREE.CameraHelper.prototype.update = function () {\r\n\r\n\tvar geometry, pointMap;\r\n\t\r\n\tvar vector = new THREE.Vector3();\r\n\tvar camera = new THREE.Camera();\r\n\r\n\tvar setPoint = function ( point, x, y, z ) {\r\n\r\n\t\tvector.set( x, y, z ).unproject( camera );\r\n\r\n\t\tvar points = pointMap[ point ];\r\n\r\n\t\tif ( points !== undefined ) {\r\n\r\n\t\t\tfor ( var i = 0, il = points.length; i < il; i ++ ) {\r\n\r\n\t\t\t\tgeometry.vertices[ points[ i ] ].copy( vector );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\treturn function () {\r\n\r\n\t\tgeometry = this.geometry;\r\n\t\tpointMap = this.pointMap;\r\n\r\n\t\tvar w = 1, h = 1;\r\n\r\n\t\t// we need just camera projection matrix\r\n\t\t// world matrix must be identity\r\n\r\n\t\tcamera.projectionMatrix.copy( this.camera.projectionMatrix );\r\n\r\n\t\t// center / target\r\n\r\n\t\tsetPoint( \"c\", 0, 0, - 1 );\r\n\t\tsetPoint( \"t\", 0, 0,  1 );\r\n\r\n\t\t// near\r\n\r\n\t\tsetPoint( \"n1\", - w, - h, - 1 );\r\n\t\tsetPoint( \"n2\",   w, - h, - 1 );\r\n\t\tsetPoint( \"n3\", - w,   h, - 1 );\r\n\t\tsetPoint( \"n4\",   w,   h, - 1 );\r\n\r\n\t\t// far\r\n\r\n\t\tsetPoint( \"f1\", - w, - h, 1 );\r\n\t\tsetPoint( \"f2\",   w, - h, 1 );\r\n\t\tsetPoint( \"f3\", - w,   h, 1 );\r\n\t\tsetPoint( \"f4\",   w,   h, 1 );\r\n\r\n\t\t// up\r\n\r\n\t\tsetPoint( \"u1\",   w * 0.7, h * 1.1, - 1 );\r\n\t\tsetPoint( \"u2\", - w * 0.7, h * 1.1, - 1 );\r\n\t\tsetPoint( \"u3\",         0, h * 2,   - 1 );\r\n\r\n\t\t// cross\r\n\r\n\t\tsetPoint( \"cf1\", - w,   0, 1 );\r\n\t\tsetPoint( \"cf2\",   w,   0, 1 );\r\n\t\tsetPoint( \"cf3\",   0, - h, 1 );\r\n\t\tsetPoint( \"cf4\",   0,   h, 1 );\r\n\r\n\t\tsetPoint( \"cn1\", - w,   0, - 1 );\r\n\t\tsetPoint( \"cn2\",   w,   0, - 1 );\r\n\t\tsetPoint( \"cn3\",   0, - h, - 1 );\r\n\t\tsetPoint( \"cn4\",   0,   h, - 1 );\r\n\r\n\t\tgeometry.verticesNeedUpdate = true;\r\n\r\n\t};\r\n\r\n}();\r\n\r\n// File:src/extras/helpers/DirectionalLightHelper.js\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author WestLangley / http://github.com/WestLangley\r\n */\r\n\r\nTHREE.DirectionalLightHelper = function ( light, size ) {\r\n\r\n\tTHREE.Object3D.call( this );\r\n\r\n\tthis.light = light;\r\n\tthis.light.updateMatrixWorld();\r\n\r\n\tthis.matrix = light.matrixWorld;\r\n\tthis.matrixAutoUpdate = false;\r\n\r\n\tsize = size || 1;\r\n\r\n\tvar geometry = new THREE.Geometry();\r\n\tgeometry.vertices.push(\r\n\t\tnew THREE.Vector3( - size,   size, 0 ),\r\n\t\tnew THREE.Vector3(   size,   size, 0 ),\r\n\t\tnew THREE.Vector3(   size, - size, 0 ),\r\n\t\tnew THREE.Vector3( - size, - size, 0 ),\r\n\t\tnew THREE.Vector3( - size,   size, 0 )\r\n\t);\r\n\r\n\tvar material = new THREE.LineBasicMaterial( { fog: false } );\r\n\tmaterial.color.copy( this.light.color ).multiplyScalar( this.light.intensity );\r\n\r\n\tthis.lightPlane = new THREE.Line( geometry, material );\r\n\tthis.add( this.lightPlane );\r\n\r\n\tgeometry = new THREE.Geometry();\r\n\tgeometry.vertices.push(\r\n\t\tnew THREE.Vector3(),\r\n\t\tnew THREE.Vector3()\r\n\t);\r\n\r\n\tmaterial = new THREE.LineBasicMaterial( { fog: false } );\r\n\tmaterial.color.copy( this.light.color ).multiplyScalar( this.light.intensity );\r\n\r\n\tthis.targetLine = new THREE.Line( geometry, material );\r\n\tthis.add( this.targetLine );\r\n\r\n\tthis.update();\r\n\r\n};\r\n\r\nTHREE.DirectionalLightHelper.prototype = Object.create( THREE.Object3D.prototype );\r\nTHREE.DirectionalLightHelper.prototype.constructor = THREE.DirectionalLightHelper;\r\n\r\nTHREE.DirectionalLightHelper.prototype.dispose = function () {\r\n\r\n\tthis.lightPlane.geometry.dispose();\r\n\tthis.lightPlane.material.dispose();\r\n\tthis.targetLine.geometry.dispose();\r\n\tthis.targetLine.material.dispose();\r\n};\r\n\r\nTHREE.DirectionalLightHelper.prototype.update = function () {\r\n\r\n\tvar v1 = new THREE.Vector3();\r\n\tvar v2 = new THREE.Vector3();\r\n\tvar v3 = new THREE.Vector3();\r\n\r\n\treturn function () {\r\n\r\n\t\tv1.setFromMatrixPosition( this.light.matrixWorld );\r\n\t\tv2.setFromMatrixPosition( this.light.target.matrixWorld );\r\n\t\tv3.subVectors( v2, v1 );\r\n\r\n\t\tthis.lightPlane.lookAt( v3 );\r\n\t\tthis.lightPlane.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );\r\n\r\n\t\tthis.targetLine.geometry.vertices[ 1 ].copy( v3 );\r\n\t\tthis.targetLine.geometry.verticesNeedUpdate = true;\r\n\t\tthis.targetLine.material.color.copy( this.lightPlane.material.color );\r\n\r\n\t};\r\n\r\n}();\r\n\r\n// File:src/extras/helpers/EdgesHelper.js\r\n\r\n/**\r\n * @author WestLangley / http://github.com/WestLangley\r\n * @param object THREE.Mesh whose geometry will be used\r\n * @param hex line color\r\n * @param thresholdAngle the minimim angle (in degrees),\r\n * between the face normals of adjacent faces,\r\n * that is required to render an edge. A value of 10 means\r\n * an edge is only rendered if the angle is at least 10 degrees.\r\n */\r\n\r\nTHREE.EdgesHelper = function ( object, hex, thresholdAngle ) {\r\n\r\n\tvar color = ( hex !== undefined ) ? hex : 0xffffff;\r\n\tthresholdAngle = ( thresholdAngle !== undefined ) ? thresholdAngle : 1;\r\n\r\n\tvar thresholdDot = Math.cos( THREE.Math.degToRad( thresholdAngle ) );\r\n\r\n\tvar edge = [ 0, 0 ], hash = {};\r\n\tvar sortFunction = function ( a, b ) { return a - b };\r\n\r\n\tvar keys = [ 'a', 'b', 'c' ];\r\n\tvar geometry = new THREE.BufferGeometry();\r\n\r\n\tvar geometry2;\r\n\r\n\tif ( object.geometry instanceof THREE.BufferGeometry ) {\r\n\r\n\t\tgeometry2 = new THREE.Geometry();\r\n\t\tgeometry2.fromBufferGeometry( object.geometry );\r\n\r\n\t} else {\r\n\r\n\t\tgeometry2 = object.geometry.clone();\r\n\r\n\t}\r\n\r\n\tgeometry2.mergeVertices();\r\n\tgeometry2.computeFaceNormals();\r\n\r\n\tvar vertices = geometry2.vertices;\r\n\tvar faces = geometry2.faces;\r\n\tvar numEdges = 0;\r\n\r\n\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\r\n\r\n\t\tvar face = faces[ i ];\r\n\r\n\t\tfor ( var j = 0; j < 3; j ++ ) {\r\n\r\n\t\t\tedge[ 0 ] = face[ keys[ j ] ];\r\n\t\t\tedge[ 1 ] = face[ keys[ ( j + 1 ) % 3 ] ];\r\n\t\t\tedge.sort( sortFunction );\r\n\r\n\t\t\tvar key = edge.toString();\r\n\r\n\t\t\tif ( hash[ key ] === undefined ) {\r\n\r\n\t\t\t\thash[ key ] = { vert1: edge[ 0 ], vert2: edge[ 1 ], face1: i, face2: undefined };\r\n\t\t\t\tnumEdges ++;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\thash[ key ].face2 = i;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tvar coords = new Float32Array( numEdges * 2 * 3 );\r\n\r\n\tvar index = 0;\r\n\r\n\tfor ( var key in hash ) {\r\n\r\n\t\tvar h = hash[ key ];\r\n\r\n\t\tif ( h.face2 === undefined || faces[ h.face1 ].normal.dot( faces[ h.face2 ].normal ) <= thresholdDot ) {\r\n\r\n\t\t\tvar vertex = vertices[ h.vert1 ];\r\n\t\t\tcoords[ index ++ ] = vertex.x;\r\n\t\t\tcoords[ index ++ ] = vertex.y;\r\n\t\t\tcoords[ index ++ ] = vertex.z;\r\n\r\n\t\t\tvertex = vertices[ h.vert2 ];\r\n\t\t\tcoords[ index ++ ] = vertex.x;\r\n\t\t\tcoords[ index ++ ] = vertex.y;\r\n\t\t\tcoords[ index ++ ] = vertex.z;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tgeometry.addAttribute( 'position', new THREE.BufferAttribute( coords, 3 ) );\r\n\r\n\tTHREE.Line.call( this, geometry, new THREE.LineBasicMaterial( { color: color } ), THREE.LinePieces );\r\n\r\n\tthis.matrix = object.matrixWorld;\r\n\tthis.matrixAutoUpdate = false;\r\n\r\n};\r\n\r\nTHREE.EdgesHelper.prototype = Object.create( THREE.Line.prototype );\r\nTHREE.EdgesHelper.prototype.constructor = THREE.EdgesHelper;\r\n\r\n// File:src/extras/helpers/FaceNormalsHelper.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author WestLangley / http://github.com/WestLangley\r\n*/\r\n\r\nTHREE.FaceNormalsHelper = function ( object, size, hex, linewidth ) {\r\n\r\n\tthis.object = object;\r\n\r\n\tthis.size = ( size !== undefined ) ? size : 1;\r\n\r\n\tvar color = ( hex !== undefined ) ? hex : 0xffff00;\r\n\r\n\tvar width = ( linewidth !== undefined ) ? linewidth : 1;\r\n\r\n\tvar geometry = new THREE.Geometry();\r\n\r\n\tvar faces = this.object.geometry.faces;\r\n\r\n\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\r\n\r\n\t\tgeometry.vertices.push( new THREE.Vector3(), new THREE.Vector3() );\r\n\r\n\t}\r\n\r\n\tTHREE.Line.call( this, geometry, new THREE.LineBasicMaterial( { color: color, linewidth: width } ), THREE.LinePieces );\r\n\r\n\tthis.matrixAutoUpdate = false;\r\n\r\n\tthis.normalMatrix = new THREE.Matrix3();\r\n\r\n\tthis.update();\r\n\r\n};\r\n\r\nTHREE.FaceNormalsHelper.prototype = Object.create( THREE.Line.prototype );\r\nTHREE.FaceNormalsHelper.prototype.constructor = THREE.FaceNormalsHelper;\r\n\r\nTHREE.FaceNormalsHelper.prototype.update = function () {\r\n\r\n\tvar vertices = this.geometry.vertices;\r\n\r\n\tvar object = this.object;\r\n\tvar objectVertices = object.geometry.vertices;\r\n\tvar objectFaces = object.geometry.faces;\r\n\tvar objectWorldMatrix = object.matrixWorld;\r\n\r\n\tobject.updateMatrixWorld( true );\r\n\r\n\tthis.normalMatrix.getNormalMatrix( objectWorldMatrix );\r\n\r\n\tfor ( var i = 0, i2 = 0, l = objectFaces.length; i < l; i ++, i2 += 2 ) {\r\n\r\n\t\tvar face = objectFaces[ i ];\r\n\r\n\t\tvertices[ i2 ].copy( objectVertices[ face.a ] )\r\n\t\t\t.add( objectVertices[ face.b ] )\r\n\t\t\t.add( objectVertices[ face.c ] )\r\n\t\t\t.divideScalar( 3 )\r\n\t\t\t.applyMatrix4( objectWorldMatrix );\r\n\r\n\t\tvertices[ i2 + 1 ].copy( face.normal )\r\n\t\t\t.applyMatrix3( this.normalMatrix )\r\n\t\t\t.normalize()\r\n\t\t\t.multiplyScalar( this.size )\r\n\t\t\t.add( vertices[ i2 ] );\r\n\r\n\t}\r\n\r\n\tthis.geometry.verticesNeedUpdate = true;\r\n\r\n\treturn this;\r\n\r\n};\r\n\r\n\r\n// File:src/extras/helpers/GridHelper.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.GridHelper = function ( size, step ) {\r\n\r\n\tvar geometry = new THREE.Geometry();\r\n\tvar material = new THREE.LineBasicMaterial( { vertexColors: THREE.VertexColors } );\r\n\r\n\tthis.color1 = new THREE.Color( 0x444444 );\r\n\tthis.color2 = new THREE.Color( 0x888888 );\r\n\r\n\tfor ( var i = - size; i <= size; i += step ) {\r\n\r\n\t\tgeometry.vertices.push(\r\n\t\t\tnew THREE.Vector3( - size, 0, i ), new THREE.Vector3( size, 0, i ),\r\n\t\t\tnew THREE.Vector3( i, 0, - size ), new THREE.Vector3( i, 0, size )\r\n\t\t);\r\n\r\n\t\tvar color = i === 0 ? this.color1 : this.color2;\r\n\r\n\t\tgeometry.colors.push( color, color, color, color );\r\n\r\n\t}\r\n\r\n\tTHREE.Line.call( this, geometry, material, THREE.LinePieces );\r\n\r\n};\r\n\r\nTHREE.GridHelper.prototype = Object.create( THREE.Line.prototype );\r\nTHREE.GridHelper.prototype.constructor = THREE.GridHelper;\r\n\r\nTHREE.GridHelper.prototype.setColors = function( colorCenterLine, colorGrid ) {\r\n\r\n\tthis.color1.set( colorCenterLine );\r\n\tthis.color2.set( colorGrid );\r\n\r\n\tthis.geometry.colorsNeedUpdate = true;\r\n\r\n}\r\n\r\n// File:src/extras/helpers/HemisphereLightHelper.js\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.HemisphereLightHelper = function ( light, sphereSize ) {\r\n\r\n\tTHREE.Object3D.call( this );\r\n\r\n\tthis.light = light;\r\n\tthis.light.updateMatrixWorld();\r\n\r\n\tthis.matrix = light.matrixWorld;\r\n\tthis.matrixAutoUpdate = false;\r\n\r\n\tthis.colors = [ new THREE.Color(), new THREE.Color() ];\r\n\r\n\tvar geometry = new THREE.SphereGeometry( sphereSize, 4, 2 );\r\n\tgeometry.applyMatrix( new THREE.Matrix4().makeRotationX( - Math.PI / 2 ) );\r\n\r\n\tfor ( var i = 0, il = 8; i < il; i ++ ) {\r\n\r\n\t\tgeometry.faces[ i ].color = this.colors[ i < 4 ? 0 : 1 ];\r\n\r\n\t}\r\n\r\n\tvar material = new THREE.MeshBasicMaterial( { vertexColors: THREE.FaceColors, wireframe: true } );\r\n\r\n\tthis.lightSphere = new THREE.Mesh( geometry, material );\r\n\tthis.add( this.lightSphere );\r\n\r\n\tthis.update();\r\n\r\n};\r\n\r\nTHREE.HemisphereLightHelper.prototype = Object.create( THREE.Object3D.prototype );\r\nTHREE.HemisphereLightHelper.prototype.constructor = THREE.HemisphereLightHelper;\r\n\r\nTHREE.HemisphereLightHelper.prototype.dispose = function () {\r\n\tthis.lightSphere.geometry.dispose();\r\n\tthis.lightSphere.material.dispose();\r\n};\r\n\r\nTHREE.HemisphereLightHelper.prototype.update = function () {\r\n\r\n\tvar vector = new THREE.Vector3();\r\n\r\n\treturn function () {\r\n\r\n\t\tthis.colors[ 0 ].copy( this.light.color ).multiplyScalar( this.light.intensity );\r\n\t\tthis.colors[ 1 ].copy( this.light.groundColor ).multiplyScalar( this.light.intensity );\r\n\r\n\t\tthis.lightSphere.lookAt( vector.setFromMatrixPosition( this.light.matrixWorld ).negate() );\r\n\t\tthis.lightSphere.geometry.colorsNeedUpdate = true;\r\n\r\n\t}\r\n\r\n}();\r\n\r\n// File:src/extras/helpers/PointLightHelper.js\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.PointLightHelper = function ( light, sphereSize ) {\r\n\r\n\tthis.light = light;\r\n\tthis.light.updateMatrixWorld();\r\n\r\n\tvar geometry = new THREE.SphereGeometry( sphereSize, 4, 2 );\r\n\tvar material = new THREE.MeshBasicMaterial( { wireframe: true, fog: false } );\r\n\tmaterial.color.copy( this.light.color ).multiplyScalar( this.light.intensity );\r\n\r\n\tTHREE.Mesh.call( this, geometry, material );\r\n\r\n\tthis.matrix = this.light.matrixWorld;\r\n\tthis.matrixAutoUpdate = false;\r\n\r\n\t/*\r\n\tvar distanceGeometry = new THREE.IcosahedronGeometry( 1, 2 );\r\n\tvar distanceMaterial = new THREE.MeshBasicMaterial( { color: hexColor, fog: false, wireframe: true, opacity: 0.1, transparent: true } );\r\n\r\n\tthis.lightSphere = new THREE.Mesh( bulbGeometry, bulbMaterial );\r\n\tthis.lightDistance = new THREE.Mesh( distanceGeometry, distanceMaterial );\r\n\r\n\tvar d = light.distance;\r\n\r\n\tif ( d === 0.0 ) {\r\n\r\n\t\tthis.lightDistance.visible = false;\r\n\r\n\t} else {\r\n\r\n\t\tthis.lightDistance.scale.set( d, d, d );\r\n\r\n\t}\r\n\r\n\tthis.add( this.lightDistance );\r\n\t*/\r\n\r\n};\r\n\r\nTHREE.PointLightHelper.prototype = Object.create( THREE.Mesh.prototype );\r\nTHREE.PointLightHelper.prototype.constructor = THREE.PointLightHelper;\r\n\r\nTHREE.PointLightHelper.prototype.dispose = function () {\r\n\r\n\tthis.geometry.dispose();\r\n\tthis.material.dispose();\r\n};\r\n\r\nTHREE.PointLightHelper.prototype.update = function () {\r\n\r\n\tthis.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );\r\n\r\n\t/*\r\n\tvar d = this.light.distance;\r\n\r\n\tif ( d === 0.0 ) {\r\n\r\n\t\tthis.lightDistance.visible = false;\r\n\r\n\t} else {\r\n\r\n\t\tthis.lightDistance.visible = true;\r\n\t\tthis.lightDistance.scale.set( d, d, d );\r\n\r\n\t}\r\n\t*/\r\n\r\n};\r\n\r\n// File:src/extras/helpers/SkeletonHelper.js\r\n\r\n/**\r\n * @author Sean Griffin / http://twitter.com/sgrif\r\n * @author Michael Guerrero / http://realitymeltdown.com\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author ikerr / http://verold.com\r\n */\r\n\r\nTHREE.SkeletonHelper = function ( object ) {\r\n\r\n\tthis.bones = this.getBoneList( object );\r\n\r\n\tvar geometry = new THREE.Geometry();\r\n\r\n\tfor ( var i = 0; i < this.bones.length; i ++ ) {\r\n\r\n\t\tvar bone = this.bones[ i ];\r\n\r\n\t\tif ( bone.parent instanceof THREE.Bone ) {\r\n\r\n\t\t\tgeometry.vertices.push( new THREE.Vector3() );\r\n\t\t\tgeometry.vertices.push( new THREE.Vector3() );\r\n\t\t\tgeometry.colors.push( new THREE.Color( 0, 0, 1 ) );\r\n\t\t\tgeometry.colors.push( new THREE.Color( 0, 1, 0 ) );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tvar material = new THREE.LineBasicMaterial( { vertexColors: THREE.VertexColors, depthTest: false, depthWrite: false, transparent: true } );\r\n\r\n\tTHREE.Line.call( this, geometry, material, THREE.LinePieces );\r\n\r\n\tthis.root = object;\r\n\r\n\tthis.matrix = object.matrixWorld;\r\n\tthis.matrixAutoUpdate = false;\r\n\r\n\tthis.update();\r\n\r\n};\r\n\r\n\r\nTHREE.SkeletonHelper.prototype = Object.create( THREE.Line.prototype );\r\nTHREE.SkeletonHelper.prototype.constructor = THREE.SkeletonHelper;\r\n\r\nTHREE.SkeletonHelper.prototype.getBoneList = function( object ) {\r\n\r\n\tvar boneList = [];\r\n\r\n\tif ( object instanceof THREE.Bone ) {\r\n\r\n\t\tboneList.push( object );\r\n\r\n\t}\r\n\r\n\tfor ( var i = 0; i < object.children.length; i ++ ) {\r\n\r\n\t\tboneList.push.apply( boneList, this.getBoneList( object.children[ i ] ) );\r\n\r\n\t}\r\n\r\n\treturn boneList;\r\n\r\n};\r\n\r\nTHREE.SkeletonHelper.prototype.update = function () {\r\n\r\n\tvar geometry = this.geometry;\r\n\r\n\tvar matrixWorldInv = new THREE.Matrix4().getInverse( this.root.matrixWorld );\r\n\r\n\tvar boneMatrix = new THREE.Matrix4();\r\n\r\n\tvar j = 0;\r\n\r\n\tfor ( var i = 0; i < this.bones.length; i ++ ) {\r\n\r\n\t\tvar bone = this.bones[ i ];\r\n\r\n\t\tif ( bone.parent instanceof THREE.Bone ) {\r\n\r\n\t\t\tboneMatrix.multiplyMatrices( matrixWorldInv, bone.matrixWorld );\r\n\t\t\tgeometry.vertices[ j ].setFromMatrixPosition( boneMatrix );\r\n\r\n\t\t\tboneMatrix.multiplyMatrices( matrixWorldInv, bone.parent.matrixWorld );\r\n\t\t\tgeometry.vertices[ j + 1 ].setFromMatrixPosition( boneMatrix );\r\n\r\n\t\t\tj += 2;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tgeometry.verticesNeedUpdate = true;\r\n\r\n\tgeometry.computeBoundingSphere();\r\n\r\n};\r\n\r\n// File:src/extras/helpers/SpotLightHelper.js\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author WestLangley / http://github.com/WestLangley\r\n*/\r\n\r\nTHREE.SpotLightHelper = function ( light ) {\r\n\r\n\tTHREE.Object3D.call( this );\r\n\r\n\tthis.light = light;\r\n\tthis.light.updateMatrixWorld();\r\n\r\n\tthis.matrix = light.matrixWorld;\r\n\tthis.matrixAutoUpdate = false;\r\n\r\n\tvar geometry = new THREE.CylinderGeometry( 0, 1, 1, 8, 1, true );\r\n\r\n\tgeometry.applyMatrix( new THREE.Matrix4().makeTranslation( 0, - 0.5, 0 ) );\r\n\tgeometry.applyMatrix( new THREE.Matrix4().makeRotationX( - Math.PI / 2 ) );\r\n\r\n\tvar material = new THREE.MeshBasicMaterial( { wireframe: true, fog: false } );\r\n\r\n\tthis.cone = new THREE.Mesh( geometry, material );\r\n\tthis.add( this.cone );\r\n\r\n\tthis.update();\r\n\r\n};\r\n\r\nTHREE.SpotLightHelper.prototype = Object.create( THREE.Object3D.prototype );\r\nTHREE.SpotLightHelper.prototype.constructor = THREE.SpotLightHelper;\r\n\r\nTHREE.SpotLightHelper.prototype.dispose = function () {\r\n\tthis.cone.geometry.dispose();\r\n\tthis.cone.material.dispose();\r\n};\r\n\r\nTHREE.SpotLightHelper.prototype.update = function () {\r\n\r\n\tvar vector = new THREE.Vector3();\r\n\tvar vector2 = new THREE.Vector3();\r\n\r\n\treturn function () {\r\n\r\n\t\tvar coneLength = this.light.distance ? this.light.distance : 10000;\r\n\t\tvar coneWidth = coneLength * Math.tan( this.light.angle );\r\n\r\n\t\tthis.cone.scale.set( coneWidth, coneWidth, coneLength );\r\n\r\n\t\tvector.setFromMatrixPosition( this.light.matrixWorld );\r\n\t\tvector2.setFromMatrixPosition( this.light.target.matrixWorld );\r\n\r\n\t\tthis.cone.lookAt( vector2.sub( vector ) );\r\n\r\n\t\tthis.cone.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );\r\n\r\n\t};\r\n\r\n}();\r\n\r\n// File:src/extras/helpers/VertexNormalsHelper.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author WestLangley / http://github.com/WestLangley\r\n*/\r\n\r\nTHREE.VertexNormalsHelper = function ( object, size, hex, linewidth ) {\r\n\r\n\tthis.object = object;\r\n\r\n\tthis.size = ( size !== undefined ) ? size : 1;\r\n\r\n\tvar color = ( hex !== undefined ) ? hex : 0xff0000;\r\n\r\n\tvar width = ( linewidth !== undefined ) ? linewidth : 1;\r\n\r\n\tvar geometry = new THREE.Geometry();\r\n\r\n\tvar faces = object.geometry.faces;\r\n\r\n\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\r\n\r\n\t\tvar face = faces[ i ];\r\n\r\n\t\tfor ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {\r\n\r\n\t\t\tgeometry.vertices.push( new THREE.Vector3(), new THREE.Vector3() );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tTHREE.Line.call( this, geometry, new THREE.LineBasicMaterial( { color: color, linewidth: width } ), THREE.LinePieces );\r\n\r\n\tthis.matrixAutoUpdate = false;\r\n\r\n\tthis.normalMatrix = new THREE.Matrix3();\r\n\r\n\tthis.update();\r\n\r\n};\r\n\r\nTHREE.VertexNormalsHelper.prototype = Object.create( THREE.Line.prototype );\r\nTHREE.VertexNormalsHelper.prototype.constructor = THREE.VertexNormalsHelper;\r\n\r\nTHREE.VertexNormalsHelper.prototype.update = ( function ( object ) {\r\n\r\n\tvar v1 = new THREE.Vector3();\r\n\r\n\treturn function( object ) {\r\n\r\n\t\tvar keys = [ 'a', 'b', 'c', 'd' ];\r\n\r\n\t\tthis.object.updateMatrixWorld( true );\r\n\r\n\t\tthis.normalMatrix.getNormalMatrix( this.object.matrixWorld );\r\n\r\n\t\tvar vertices = this.geometry.vertices;\r\n\r\n\t\tvar verts = this.object.geometry.vertices;\r\n\r\n\t\tvar faces = this.object.geometry.faces;\r\n\r\n\t\tvar worldMatrix = this.object.matrixWorld;\r\n\r\n\t\tvar idx = 0;\r\n\r\n\t\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\r\n\r\n\t\t\tvar face = faces[ i ];\r\n\r\n\t\t\tfor ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {\r\n\r\n\t\t\t\tvar vertexId = face[ keys[ j ] ];\r\n\t\t\t\tvar vertex = verts[ vertexId ];\r\n\r\n\t\t\t\tvar normal = face.vertexNormals[ j ];\r\n\r\n\t\t\t\tvertices[ idx ].copy( vertex ).applyMatrix4( worldMatrix );\r\n\r\n\t\t\t\tv1.copy( normal ).applyMatrix3( this.normalMatrix ).normalize().multiplyScalar( this.size );\r\n\r\n\t\t\t\tv1.add( vertices[ idx ] );\r\n\t\t\t\tidx = idx + 1;\r\n\r\n\t\t\t\tvertices[ idx ].copy( v1 );\r\n\t\t\t\tidx = idx + 1;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tthis.geometry.verticesNeedUpdate = true;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n}());\r\n\r\n// File:src/extras/helpers/VertexTangentsHelper.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author WestLangley / http://github.com/WestLangley\r\n*/\r\n\r\nTHREE.VertexTangentsHelper = function ( object, size, hex, linewidth ) {\r\n\r\n\tthis.object = object;\r\n\r\n\tthis.size = ( size !== undefined ) ? size : 1;\r\n\r\n\tvar color = ( hex !== undefined ) ? hex : 0x0000ff;\r\n\r\n\tvar width = ( linewidth !== undefined ) ? linewidth : 1;\r\n\r\n\tvar geometry = new THREE.Geometry();\r\n\r\n\tvar faces = object.geometry.faces;\r\n\r\n\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\r\n\r\n\t\tvar face = faces[ i ];\r\n\r\n\t\tfor ( var j = 0, jl = face.vertexTangents.length; j < jl; j ++ ) {\r\n\r\n\t\t\tgeometry.vertices.push( new THREE.Vector3() );\r\n\t\t\tgeometry.vertices.push( new THREE.Vector3() );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tTHREE.Line.call( this, geometry, new THREE.LineBasicMaterial( { color: color, linewidth: width } ), THREE.LinePieces );\r\n\r\n\tthis.matrixAutoUpdate = false;\r\n\r\n\tthis.update();\r\n\r\n};\r\n\r\nTHREE.VertexTangentsHelper.prototype = Object.create( THREE.Line.prototype );\r\nTHREE.VertexTangentsHelper.prototype.constructor = THREE.VertexTangentsHelper;\r\n\r\nTHREE.VertexTangentsHelper.prototype.update = ( function ( object ) {\r\n\r\n\tvar v1 = new THREE.Vector3();\r\n\r\n\treturn function( object ) {\r\n\r\n\t\tvar keys = [ 'a', 'b', 'c', 'd' ];\r\n\r\n\t\tthis.object.updateMatrixWorld( true );\r\n\r\n\t\tvar vertices = this.geometry.vertices;\r\n\r\n\t\tvar verts = this.object.geometry.vertices;\r\n\r\n\t\tvar faces = this.object.geometry.faces;\r\n\r\n\t\tvar worldMatrix = this.object.matrixWorld;\r\n\r\n\t\tvar idx = 0;\r\n\r\n\t\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\r\n\r\n\t\t\tvar face = faces[ i ];\r\n\r\n\t\t\tfor ( var j = 0, jl = face.vertexTangents.length; j < jl; j ++ ) {\r\n\r\n\t\t\t\tvar vertexId = face[ keys[ j ] ];\r\n\t\t\t\tvar vertex = verts[ vertexId ];\r\n\r\n\t\t\t\tvar tangent = face.vertexTangents[ j ];\r\n\r\n\t\t\t\tvertices[ idx ].copy( vertex ).applyMatrix4( worldMatrix );\r\n\r\n\t\t\t\tv1.copy( tangent ).transformDirection( worldMatrix ).multiplyScalar( this.size );\r\n\r\n\t\t\t\tv1.add( vertices[ idx ] );\r\n\t\t\t\tidx = idx + 1;\r\n\r\n\t\t\t\tvertices[ idx ].copy( v1 );\r\n\t\t\t\tidx = idx + 1;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tthis.geometry.verticesNeedUpdate = true;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n}());\r\n\r\n// File:src/extras/helpers/WireframeHelper.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.WireframeHelper = function ( object, hex ) {\r\n\r\n\tvar color = ( hex !== undefined ) ? hex : 0xffffff;\r\n\r\n\tvar edge = [ 0, 0 ], hash = {};\r\n\tvar sortFunction = function ( a, b ) { return a - b };\r\n\r\n\tvar keys = [ 'a', 'b', 'c' ];\r\n\tvar geometry = new THREE.BufferGeometry();\r\n\r\n\tif ( object.geometry instanceof THREE.Geometry ) {\r\n\r\n\t\tvar vertices = object.geometry.vertices;\r\n\t\tvar faces = object.geometry.faces;\r\n\t\tvar numEdges = 0;\r\n\r\n\t\t// allocate maximal size\r\n\t\tvar edges = new Uint32Array( 6 * faces.length );\r\n\r\n\t\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\r\n\r\n\t\t\tvar face = faces[ i ];\r\n\r\n\t\t\tfor ( var j = 0; j < 3; j ++ ) {\r\n\r\n\t\t\t\tedge[ 0 ] = face[ keys[ j ] ];\r\n\t\t\t\tedge[ 1 ] = face[ keys[ ( j + 1 ) % 3 ] ];\r\n\t\t\t\tedge.sort( sortFunction );\r\n\r\n\t\t\t\tvar key = edge.toString();\r\n\r\n\t\t\t\tif ( hash[ key ] === undefined ) {\r\n\r\n\t\t\t\t\tedges[ 2 * numEdges ] = edge[ 0 ];\r\n\t\t\t\t\tedges[ 2 * numEdges + 1 ] = edge[ 1 ];\r\n\t\t\t\t\thash[ key ] = true;\r\n\t\t\t\t\tnumEdges ++;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tvar coords = new Float32Array( numEdges * 2 * 3 );\r\n\r\n\t\tfor ( var i = 0, l = numEdges; i < l; i ++ ) {\r\n\r\n\t\t\tfor ( var j = 0; j < 2; j ++ ) {\r\n\r\n\t\t\t\tvar vertex = vertices[ edges [ 2 * i + j] ];\r\n\r\n\t\t\t\tvar index = 6 * i + 3 * j;\r\n\t\t\t\tcoords[ index + 0 ] = vertex.x;\r\n\t\t\t\tcoords[ index + 1 ] = vertex.y;\r\n\t\t\t\tcoords[ index + 2 ] = vertex.z;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tgeometry.addAttribute( 'position', new THREE.BufferAttribute( coords, 3 ) );\r\n\r\n\t} else if ( object.geometry instanceof THREE.BufferGeometry ) {\r\n\r\n\t\tif ( object.geometry.attributes.index !== undefined ) { // Indexed BufferGeometry\r\n\r\n\t\t\tvar vertices = object.geometry.attributes.position.array;\r\n\t\t\tvar indices = object.geometry.attributes.index.array;\r\n\t\t\tvar drawcalls = object.geometry.drawcalls;\r\n\t\t\tvar numEdges = 0;\r\n\r\n\t\t\tif ( drawcalls.length === 0 ) {\r\n\r\n\t\t\t\tdrawcalls = [ { count : indices.length, index : 0, start : 0 } ];\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// allocate maximal size\r\n\t\t\tvar edges = new Uint32Array( 2 * indices.length );\r\n\r\n\t\t\tfor ( var o = 0, ol = drawcalls.length; o < ol; ++ o ) {\r\n\r\n\t\t\t\tvar start = drawcalls[ o ].start;\r\n\t\t\t\tvar count = drawcalls[ o ].count;\r\n\t\t\t\tvar index = drawcalls[ o ].index;\r\n\r\n\t\t\t\tfor ( var i = start, il = start + count; i < il; i += 3 ) {\r\n\r\n\t\t\t\t\tfor ( var j = 0; j < 3; j ++ ) {\r\n\r\n\t\t\t\t\t\tedge[ 0 ] = index + indices[ i + j ];\r\n\t\t\t\t\t\tedge[ 1 ] = index + indices[ i + ( j + 1 ) % 3 ];\r\n\t\t\t\t\t\tedge.sort( sortFunction );\r\n\r\n\t\t\t\t\t\tvar key = edge.toString();\r\n\r\n\t\t\t\t\t\tif ( hash[ key ] === undefined ) {\r\n\r\n\t\t\t\t\t\t\tedges[ 2 * numEdges ] = edge[ 0 ];\r\n\t\t\t\t\t\t\tedges[ 2 * numEdges + 1 ] = edge[ 1 ];\r\n\t\t\t\t\t\t\thash[ key ] = true;\r\n\t\t\t\t\t\t\tnumEdges ++;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar coords = new Float32Array( numEdges * 2 * 3 );\r\n\r\n\t\t\tfor ( var i = 0, l = numEdges; i < l; i ++ ) {\r\n\r\n\t\t\t\tfor ( var j = 0; j < 2; j ++ ) {\r\n\r\n\t\t\t\t\tvar index = 6 * i + 3 * j;\r\n\t\t\t\t\tvar index2 = 3 * edges[ 2 * i + j];\r\n\t\t\t\t\tcoords[ index + 0 ] = vertices[ index2 ];\r\n\t\t\t\t\tcoords[ index + 1 ] = vertices[ index2 + 1 ];\r\n\t\t\t\t\tcoords[ index + 2 ] = vertices[ index2 + 2 ];\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tgeometry.addAttribute( 'position', new THREE.BufferAttribute( coords, 3 ) );\r\n\r\n\t\t} else { // non-indexed BufferGeometry\r\n\r\n\t\t\tvar vertices = object.geometry.attributes.position.array;\r\n\t\t\tvar numEdges = vertices.length / 3;\r\n\t\t\tvar numTris = numEdges / 3;\r\n\r\n\t\t\tvar coords = new Float32Array( numEdges * 2 * 3 );\r\n\r\n\t\t\tfor ( var i = 0, l = numTris; i < l; i ++ ) {\r\n\r\n\t\t\t\tfor ( var j = 0; j < 3; j ++ ) {\r\n\r\n\t\t\t\t\tvar index = 18 * i + 6 * j;\r\n\r\n\t\t\t\t\tvar index1 = 9 * i + 3 * j;\r\n\t\t\t\t\tcoords[ index + 0 ] = vertices[ index1 ];\r\n\t\t\t\t\tcoords[ index + 1 ] = vertices[ index1 + 1 ];\r\n\t\t\t\t\tcoords[ index + 2 ] = vertices[ index1 + 2 ];\r\n\r\n\t\t\t\t\tvar index2 = 9 * i + 3 * ( ( j + 1 ) % 3 );\r\n\t\t\t\t\tcoords[ index + 3 ] = vertices[ index2 ];\r\n\t\t\t\t\tcoords[ index + 4 ] = vertices[ index2 + 1 ];\r\n\t\t\t\t\tcoords[ index + 5 ] = vertices[ index2 + 2 ];\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tgeometry.addAttribute( 'position', new THREE.BufferAttribute( coords, 3 ) );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tTHREE.Line.call( this, geometry, new THREE.LineBasicMaterial( { color: color } ), THREE.LinePieces );\r\n\r\n\tthis.matrix = object.matrixWorld;\r\n\tthis.matrixAutoUpdate = false;\r\n\r\n};\r\n\r\nTHREE.WireframeHelper.prototype = Object.create( THREE.Line.prototype );\r\nTHREE.WireframeHelper.prototype.constructor = THREE.WireframeHelper;\r\n\r\n// File:src/extras/objects/ImmediateRenderObject.js\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.ImmediateRenderObject = function () {\r\n\r\n\tTHREE.Object3D.call( this );\r\n\r\n\tthis.render = function ( renderCallback ) {};\r\n\r\n};\r\n\r\nTHREE.ImmediateRenderObject.prototype = Object.create( THREE.Object3D.prototype );\r\nTHREE.ImmediateRenderObject.prototype.constructor = THREE.ImmediateRenderObject;\r\n\r\n// File:src/extras/objects/MorphBlendMesh.js\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.MorphBlendMesh = function( geometry, material ) {\r\n\r\n\tTHREE.Mesh.call( this, geometry, material );\r\n\r\n\tthis.animationsMap = {};\r\n\tthis.animationsList = [];\r\n\r\n\t// prepare default animation\r\n\t// (all frames played together in 1 second)\r\n\r\n\tvar numFrames = this.geometry.morphTargets.length;\r\n\r\n\tvar name = \"__default\";\r\n\r\n\tvar startFrame = 0;\r\n\tvar endFrame = numFrames - 1;\r\n\r\n\tvar fps = numFrames / 1;\r\n\r\n\tthis.createAnimation( name, startFrame, endFrame, fps );\r\n\tthis.setAnimationWeight( name, 1 );\r\n\r\n};\r\n\r\nTHREE.MorphBlendMesh.prototype = Object.create( THREE.Mesh.prototype );\r\nTHREE.MorphBlendMesh.prototype.constructor = THREE.MorphBlendMesh;\r\n\r\nTHREE.MorphBlendMesh.prototype.createAnimation = function ( name, start, end, fps ) {\r\n\r\n\tvar animation = {\r\n\r\n\t\tstartFrame: start,\r\n\t\tendFrame: end,\r\n\r\n\t\tlength: end - start + 1,\r\n\r\n\t\tfps: fps,\r\n\t\tduration: ( end - start ) / fps,\r\n\r\n\t\tlastFrame: 0,\r\n\t\tcurrentFrame: 0,\r\n\r\n\t\tactive: false,\r\n\r\n\t\ttime: 0,\r\n\t\tdirection: 1,\r\n\t\tweight: 1,\r\n\r\n\t\tdirectionBackwards: false,\r\n\t\tmirroredLoop: false\r\n\r\n\t};\r\n\r\n\tthis.animationsMap[ name ] = animation;\r\n\tthis.animationsList.push( animation );\r\n\r\n};\r\n\r\nTHREE.MorphBlendMesh.prototype.autoCreateAnimations = function ( fps ) {\r\n\r\n\tvar pattern = /([a-z]+)_?(\\d+)/;\r\n\r\n\tvar firstAnimation, frameRanges = {};\r\n\r\n\tvar geometry = this.geometry;\r\n\r\n\tfor ( var i = 0, il = geometry.morphTargets.length; i < il; i ++ ) {\r\n\r\n\t\tvar morph = geometry.morphTargets[ i ];\r\n\t\tvar chunks = morph.name.match( pattern );\r\n\r\n\t\tif ( chunks && chunks.length > 1 ) {\r\n\r\n\t\t\tvar name = chunks[ 1 ];\r\n\r\n\t\t\tif ( ! frameRanges[ name ] ) frameRanges[ name ] = { start: Infinity, end: - Infinity };\r\n\r\n\t\t\tvar range = frameRanges[ name ];\r\n\r\n\t\t\tif ( i < range.start ) range.start = i;\r\n\t\t\tif ( i > range.end ) range.end = i;\r\n\r\n\t\t\tif ( ! firstAnimation ) firstAnimation = name;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfor ( var name in frameRanges ) {\r\n\r\n\t\tvar range = frameRanges[ name ];\r\n\t\tthis.createAnimation( name, range.start, range.end, fps );\r\n\r\n\t}\r\n\r\n\tthis.firstAnimation = firstAnimation;\r\n\r\n};\r\n\r\nTHREE.MorphBlendMesh.prototype.setAnimationDirectionForward = function ( name ) {\r\n\r\n\tvar animation = this.animationsMap[ name ];\r\n\r\n\tif ( animation ) {\r\n\r\n\t\tanimation.direction = 1;\r\n\t\tanimation.directionBackwards = false;\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.MorphBlendMesh.prototype.setAnimationDirectionBackward = function ( name ) {\r\n\r\n\tvar animation = this.animationsMap[ name ];\r\n\r\n\tif ( animation ) {\r\n\r\n\t\tanimation.direction = - 1;\r\n\t\tanimation.directionBackwards = true;\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.MorphBlendMesh.prototype.setAnimationFPS = function ( name, fps ) {\r\n\r\n\tvar animation = this.animationsMap[ name ];\r\n\r\n\tif ( animation ) {\r\n\r\n\t\tanimation.fps = fps;\r\n\t\tanimation.duration = ( animation.end - animation.start ) / animation.fps;\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.MorphBlendMesh.prototype.setAnimationDuration = function ( name, duration ) {\r\n\r\n\tvar animation = this.animationsMap[ name ];\r\n\r\n\tif ( animation ) {\r\n\r\n\t\tanimation.duration = duration;\r\n\t\tanimation.fps = ( animation.end - animation.start ) / animation.duration;\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.MorphBlendMesh.prototype.setAnimationWeight = function ( name, weight ) {\r\n\r\n\tvar animation = this.animationsMap[ name ];\r\n\r\n\tif ( animation ) {\r\n\r\n\t\tanimation.weight = weight;\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.MorphBlendMesh.prototype.setAnimationTime = function ( name, time ) {\r\n\r\n\tvar animation = this.animationsMap[ name ];\r\n\r\n\tif ( animation ) {\r\n\r\n\t\tanimation.time = time;\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.MorphBlendMesh.prototype.getAnimationTime = function ( name ) {\r\n\r\n\tvar time = 0;\r\n\r\n\tvar animation = this.animationsMap[ name ];\r\n\r\n\tif ( animation ) {\r\n\r\n\t\ttime = animation.time;\r\n\r\n\t}\r\n\r\n\treturn time;\r\n\r\n};\r\n\r\nTHREE.MorphBlendMesh.prototype.getAnimationDuration = function ( name ) {\r\n\r\n\tvar duration = - 1;\r\n\r\n\tvar animation = this.animationsMap[ name ];\r\n\r\n\tif ( animation ) {\r\n\r\n\t\tduration = animation.duration;\r\n\r\n\t}\r\n\r\n\treturn duration;\r\n\r\n};\r\n\r\nTHREE.MorphBlendMesh.prototype.playAnimation = function ( name ) {\r\n\r\n\tvar animation = this.animationsMap[ name ];\r\n\r\n\tif ( animation ) {\r\n\r\n\t\tanimation.time = 0;\r\n\t\tanimation.active = true;\r\n\r\n\t} else {\r\n\r\n\t\tTHREE.warn( \"THREE.MorphBlendMesh: animation[\" + name + \"] undefined in .playAnimation()\" );\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.MorphBlendMesh.prototype.stopAnimation = function ( name ) {\r\n\r\n\tvar animation = this.animationsMap[ name ];\r\n\r\n\tif ( animation ) {\r\n\r\n\t\tanimation.active = false;\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.MorphBlendMesh.prototype.update = function ( delta ) {\r\n\r\n\tfor ( var i = 0, il = this.animationsList.length; i < il; i ++ ) {\r\n\r\n\t\tvar animation = this.animationsList[ i ];\r\n\r\n\t\tif ( ! animation.active ) continue;\r\n\r\n\t\tvar frameTime = animation.duration / animation.length;\r\n\r\n\t\tanimation.time += animation.direction * delta;\r\n\r\n\t\tif ( animation.mirroredLoop ) {\r\n\r\n\t\t\tif ( animation.time > animation.duration || animation.time < 0 ) {\r\n\r\n\t\t\t\tanimation.direction *= - 1;\r\n\r\n\t\t\t\tif ( animation.time > animation.duration ) {\r\n\r\n\t\t\t\t\tanimation.time = animation.duration;\r\n\t\t\t\t\tanimation.directionBackwards = true;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( animation.time < 0 ) {\r\n\r\n\t\t\t\t\tanimation.time = 0;\r\n\t\t\t\t\tanimation.directionBackwards = false;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\tanimation.time = animation.time % animation.duration;\r\n\r\n\t\t\tif ( animation.time < 0 ) animation.time += animation.duration;\r\n\r\n\t\t}\r\n\r\n\t\tvar keyframe = animation.startFrame + THREE.Math.clamp( Math.floor( animation.time / frameTime ), 0, animation.length - 1 );\r\n\t\tvar weight = animation.weight;\r\n\r\n\t\tif ( keyframe !== animation.currentFrame ) {\r\n\r\n\t\t\tthis.morphTargetInfluences[ animation.lastFrame ] = 0;\r\n\t\t\tthis.morphTargetInfluences[ animation.currentFrame ] = 1 * weight;\r\n\r\n\t\t\tthis.morphTargetInfluences[ keyframe ] = 0;\r\n\r\n\t\t\tanimation.lastFrame = animation.currentFrame;\r\n\t\t\tanimation.currentFrame = keyframe;\r\n\r\n\t\t}\r\n\r\n\t\tvar mix = ( animation.time % frameTime ) / frameTime;\r\n\r\n\t\tif ( animation.directionBackwards ) mix = 1 - mix;\r\n\r\n\t\tthis.morphTargetInfluences[ animation.currentFrame ] = mix * weight;\r\n\t\tthis.morphTargetInfluences[ animation.lastFrame ] = ( 1 - mix ) * weight;\r\n\r\n\t}\r\n\r\n};\r\n\r\n\r\n// Export the THREE object for **Node.js**, with\r\n// backwards-compatibility for the old `require()` API. If we're in\r\n// the browser, add `_` as a global object via a string identifier,\r\n// for Closure Compiler \"advanced\" mode.\r\nif (typeof exports !== 'undefined') {\r\n  if (typeof module !== 'undefined' && module.exports) {\r\n    exports = module.exports = THREE;\r\n  }\r\n  exports.THREE = THREE;\r\n} else {\r\n  this['THREE'] = THREE;\r\n}\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** /home/amar/misc/Dropbox/projects/home/proto/~/three/three.js\n ** module id = 10\n ** module chunks = 0\n **/","require! { events: { EventEmitter } }\n\nexport class Entity extends EventEmitter\n  (@parent) ->\n    @children = []\n\n  add-child: ->\n    @children.push it\n    @emit \\childadded it\n    it\n\n  remove-child: ->\n    for child, index in @children\n      if child is it\n        @children.splice index, 1\n        @emit \\childremoved it\n        return it\n\n\n\n/** WEBPACK FOOTER **\n ** /home/amar/misc/Dropbox/projects/home/proto/src/core/entity.ls\n **/","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nfunction EventEmitter() {\n  this._events = this._events || {};\n  this._maxListeners = this._maxListeners || undefined;\n}\nmodule.exports = EventEmitter;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nEventEmitter.defaultMaxListeners = 10;\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function(n) {\n  if (!isNumber(n) || n < 0 || isNaN(n))\n    throw TypeError('n must be a positive number');\n  this._maxListeners = n;\n  return this;\n};\n\nEventEmitter.prototype.emit = function(type) {\n  var er, handler, len, args, i, listeners;\n\n  if (!this._events)\n    this._events = {};\n\n  // If there is no 'error' event listener then throw.\n  if (type === 'error') {\n    if (!this._events.error ||\n        (isObject(this._events.error) && !this._events.error.length)) {\n      er = arguments[1];\n      if (er instanceof Error) {\n        throw er; // Unhandled 'error' event\n      }\n      throw TypeError('Uncaught, unspecified \"error\" event.');\n    }\n  }\n\n  handler = this._events[type];\n\n  if (isUndefined(handler))\n    return false;\n\n  if (isFunction(handler)) {\n    switch (arguments.length) {\n      // fast cases\n      case 1:\n        handler.call(this);\n        break;\n      case 2:\n        handler.call(this, arguments[1]);\n        break;\n      case 3:\n        handler.call(this, arguments[1], arguments[2]);\n        break;\n      // slower\n      default:\n        len = arguments.length;\n        args = new Array(len - 1);\n        for (i = 1; i < len; i++)\n          args[i - 1] = arguments[i];\n        handler.apply(this, args);\n    }\n  } else if (isObject(handler)) {\n    len = arguments.length;\n    args = new Array(len - 1);\n    for (i = 1; i < len; i++)\n      args[i - 1] = arguments[i];\n\n    listeners = handler.slice();\n    len = listeners.length;\n    for (i = 0; i < len; i++)\n      listeners[i].apply(this, args);\n  }\n\n  return true;\n};\n\nEventEmitter.prototype.addListener = function(type, listener) {\n  var m;\n\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  if (!this._events)\n    this._events = {};\n\n  // To avoid recursion in the case that type === \"newListener\"! Before\n  // adding it to the listeners, first emit \"newListener\".\n  if (this._events.newListener)\n    this.emit('newListener', type,\n              isFunction(listener.listener) ?\n              listener.listener : listener);\n\n  if (!this._events[type])\n    // Optimize the case of one listener. Don't need the extra array object.\n    this._events[type] = listener;\n  else if (isObject(this._events[type]))\n    // If we've already got an array, just append.\n    this._events[type].push(listener);\n  else\n    // Adding the second element, need to change to array.\n    this._events[type] = [this._events[type], listener];\n\n  // Check for listener leak\n  if (isObject(this._events[type]) && !this._events[type].warned) {\n    var m;\n    if (!isUndefined(this._maxListeners)) {\n      m = this._maxListeners;\n    } else {\n      m = EventEmitter.defaultMaxListeners;\n    }\n\n    if (m && m > 0 && this._events[type].length > m) {\n      this._events[type].warned = true;\n      console.error('(node) warning: possible EventEmitter memory ' +\n                    'leak detected. %d listeners added. ' +\n                    'Use emitter.setMaxListeners() to increase limit.',\n                    this._events[type].length);\n      if (typeof console.trace === 'function') {\n        // not supported in IE 10\n        console.trace();\n      }\n    }\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.once = function(type, listener) {\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  var fired = false;\n\n  function g() {\n    this.removeListener(type, g);\n\n    if (!fired) {\n      fired = true;\n      listener.apply(this, arguments);\n    }\n  }\n\n  g.listener = listener;\n  this.on(type, g);\n\n  return this;\n};\n\n// emits a 'removeListener' event iff the listener was removed\nEventEmitter.prototype.removeListener = function(type, listener) {\n  var list, position, length, i;\n\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  if (!this._events || !this._events[type])\n    return this;\n\n  list = this._events[type];\n  length = list.length;\n  position = -1;\n\n  if (list === listener ||\n      (isFunction(list.listener) && list.listener === listener)) {\n    delete this._events[type];\n    if (this._events.removeListener)\n      this.emit('removeListener', type, listener);\n\n  } else if (isObject(list)) {\n    for (i = length; i-- > 0;) {\n      if (list[i] === listener ||\n          (list[i].listener && list[i].listener === listener)) {\n        position = i;\n        break;\n      }\n    }\n\n    if (position < 0)\n      return this;\n\n    if (list.length === 1) {\n      list.length = 0;\n      delete this._events[type];\n    } else {\n      list.splice(position, 1);\n    }\n\n    if (this._events.removeListener)\n      this.emit('removeListener', type, listener);\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.removeAllListeners = function(type) {\n  var key, listeners;\n\n  if (!this._events)\n    return this;\n\n  // not listening for removeListener, no need to emit\n  if (!this._events.removeListener) {\n    if (arguments.length === 0)\n      this._events = {};\n    else if (this._events[type])\n      delete this._events[type];\n    return this;\n  }\n\n  // emit removeListener for all listeners on all events\n  if (arguments.length === 0) {\n    for (key in this._events) {\n      if (key === 'removeListener') continue;\n      this.removeAllListeners(key);\n    }\n    this.removeAllListeners('removeListener');\n    this._events = {};\n    return this;\n  }\n\n  listeners = this._events[type];\n\n  if (isFunction(listeners)) {\n    this.removeListener(type, listeners);\n  } else {\n    // LIFO order\n    while (listeners.length)\n      this.removeListener(type, listeners[listeners.length - 1]);\n  }\n  delete this._events[type];\n\n  return this;\n};\n\nEventEmitter.prototype.listeners = function(type) {\n  var ret;\n  if (!this._events || !this._events[type])\n    ret = [];\n  else if (isFunction(this._events[type]))\n    ret = [this._events[type]];\n  else\n    ret = this._events[type].slice();\n  return ret;\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  var ret;\n  if (!emitter._events || !emitter._events[type])\n    ret = 0;\n  else if (isFunction(emitter._events[type]))\n    ret = 1;\n  else\n    ret = emitter._events[type].length;\n  return ret;\n};\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** (webpack)/~/node-libs-browser/~/events/events.js\n ** module id = 12\n ** module chunks = 0\n **/"],"sourceRoot":""}